<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1605 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1605</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1605</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-266201971</p>
                <p><strong>Paper Title:</strong> Revisiting Classical Controller Design and Tuning with Genetic Programming</p>
                <p><strong>Paper Abstract:</strong> This paper introduces the application of a genetic programming (GP)-based method for the automated design and tuning of process controllers, representing a noteworthy advancement in artificial intelligence (AI) within the realm of control engineering. In contrast to already existing work, our GP-based approach operates exclusively in the time domain, incorporating differential operations such as derivatives and integrals without necessitating intermediate inverse Laplace transformations. This unique feature not only simplifies the design process but also ensures the practical implementability of the generated controllers within physical systems. Notably, the GP’s functional set extends beyond basic arithmetic operators to include a rich repertoire of mathematical operations, encompassing trigonometric, exponential, and logarithmic functions. This broad set of operations enhances the flexibility and adaptability of the GP-based approach in controller design. To rigorously assess the efficacy of our GP-based approach, we conducted an extensive series of tests to determine its limits and capabilities. In summary, our research establishes the GP-based approach as a promising solution for automating the controller design process, offering a transformative tool to address a spectrum of control problems across various engineering applications.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1605.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1605.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GP-controller-generator</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Programming-based automatic controller generator and tuner (time-domain, RPN)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A GP system that evolves tree-structured mathematical/controller expressions in the time domain (including integral and derivative operators) using DEAP and a custom RPN evaluator; fitness balances tracking (ITSE), control effort, robustness to perturbed plant parameters, and expression length/implementability.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Programming-based controller generator (time-domain, RPN)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Evolves GP trees whose interior nodes are functions (bi-variate: +, -, *, /; uni-variate: exp, log, log10, sin, cos, integral, derivative) and whose terminals are system signals (states x_i, output y, control u, reference r, error ε) and constants k. All operators (including integral and derivative) are evaluated in the time domain using a custom Reverse Polish Notation (RPN) calculator. Each candidate controller is simulated in closed-loop (state-space) twice: once on the nominal plant and once on a slightly perturbed plant (parameter _sstep) to compute robustness. Parameters (numeric constants) are tuned with Nelder–Mead after structure generation. Fitness J aggregates: CA (controller action score = ITSE weighted by Q + integral squared control weighted by R, with multiplicative penalties for late stabilization, excessive overshoot, or excessive output slope), RI (robustness index = CA_nominal − CA_perturbed), and EL (expression length measured as GP tree size). Evolution uses elitism, mutation, crossover, and injection of ~10% newly randomized individuals each generation. Mutation and crossover probabilities are time-varying between configured bounds (mut_lims, cross_lims) using a linear VarRate schedule. Implementation is in Python 3 using DEAP and a custom RPN library; infeasible simulations (values exceeding limits) get assigned infinite fitness and are discarded.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / mathematical expressions (GP trees representing controller equations)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Crossover is used as a genetic operator with a time-varying probability bounded by cross_lims and updated via the VarRate linear schedule; the paper does not specify the low-level crossover mechanism in text, only that crossover probability increases over generations (exploitation). Implementation uses DEAP (which typically offers subtree crossover), but the paper does not explicitly state which DEAP crossover primitive was selected.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Mutation is used with a time-varying probability bounded by mut_lims and updated via the VarRate linear schedule; mutation probability starts higher to favor exploration and decreases over generations. The paper does not give a line-by-line definition of the mutation operator (e.g., point mutation, subtree mutation) but indicates mutation perturbs individuals and promotes exploration; additionally ~10% of each new generation are freshly randomized individuals.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Simulation-based executability/feasibility checks: each candidate is executed in closed-loop time-domain simulation using the RPN evaluator; if state or signal exceeds predefined maximum limits the simulation is halted and the candidate is assigned infinite (discarded) fitness. Implementability is encouraged via the EL term (EL = |GP_tree|) which penalizes large/complex expressions. The combined fitness J(CA, RI, EL) is therefore used as a proxy for both functionality and implementability.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td>Quantitative fitness results reported for best individuals across tests (examples from paper): Group 1 (first-order stable) best J values: Test1 J = 2.03 × 10^6, Test2 J = 2.20 × 10^6, Test3 J = 1.12 × 10^6; other reported values include Test4 J = 6.44 × 10^5, Test5 J = 2.19 × 10^6, Test6 J = 5.50 × 10^7. Group 2 and Group 3 best-individual J values are reported in paper tables (e.g. Test7 J = 3.38 × 10^7, Test9 J = 2.92 × 10^5, Test14 J = 2.57 × 10^6). These J numbers are the paper's primary quantitative readout of solution functionality/quality.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>No explicit numerical diversity metric was defined. The authors implement population-diversity mechanisms: (i) time-varying mutation and crossover probabilities to favor exploration early (higher mutation) and exploitation later (higher crossover), (ii) injection of ~10% newly randomized individuals per generation to maintain genetic diversity, and (iii) elitism to preserve top solutions. But no genotypic/phenotypic diversity index (e.g., Shannon, pairwise distance) is reported.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td>Not formally analyzed as a tradeoff curve; however the fitness explicitly penalizes expression length (EL) and unimplementable simulations, which implicitly biases the search away from highly novel but impractically complex expressions. The paper states this as an intended design: favor implementable/time-domain expressions (including integrals/derivatives) over potentially exotic Laplace-domain structures that are impractical to realize.</td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Automatic controller design and tuning for SISO linear time-invariant plants (first-order and second-order transfer functions) in reference-tracking tasks; testing suite includes stable/unstable first-order plants with low/medium/high gains and second-order plants.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared qualitatively to classical control solutions (e.g., PID/integral controllers) and to prior GP/GA literature (Koza-style GP and variants). No direct quantitative baseline experiments (e.g., run a PID tuner side-by-side with statistics) are presented; instead the paper observes that GP often rediscovers integral-like controllers.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Crossover and mutation schedule and other algorithmic choices strongly affect exploration vs exploitation: authors start with higher mutation probability and lower crossover probability to promote exploration, then linearly decrease mutation and increase crossover (VarRate formula) so the population exploits promising structures later. Specific configuration used in the experiments: ind_number = 120, gen_number = 50, hof_lims = 1 (elitism = 1), cross_lims = (0.31, 0.69), mut_lims = (0.35, 0.64), and 10% of each generation are newly randomized individuals; these settings allowed the GP to find simple integral controllers early (often within a few generations) and then tune constants. For more complex plants (high gain or unstable dynamics), more generations were needed and the algorithm sometimes produced more complex expressions (including exp/trig) or failed to find fully satisfactory controllers within 50 generations. The paper concludes that the combination of mutation schedule, crossover exploitation, injected random individuals, elitism, and Nelder–Mead parameter tuning yields practical, executable controllers and tends to rediscover classical control structures (e.g., integral control) when those are optimal.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Revisiting Classical Controller Design and Tuning with Genetic Programming', 'publication_date_yy_mm': '2023-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1605.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1605.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>GA/GP (background)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Genetic Algorithms (GA) and Genetic Programming (GP) (background / literature mention)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Background mention: GAs operate on fixed-length parameter vectors (optimize parameters), GP operates on tree-structured programs/expressions (optimize both structure and parameters) and uses genetic operators such as selection, replication, crossover, and mutation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Genetic Algorithms and Genetic Programming (general)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Described in the paper as the evolutionary computation family: GAs encode candidate solutions as fixed-length genomes (parameter vectors) and primarily perform parameter search; GP encodes candidate solutions as tree-structured programs/expressions allowing both structure and parameter evolution. The paper notes the common genetic operations (elitism, replication, crossover, mutation) and the need to balance exploration (mutation, random individuals) versus exploitation (crossover, elitism).</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>parameters (GA) and programs/expressions (GP trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Mentioned as a standard GA/GP operator; the paper states that crossover is one of the usual genetic operations used to combine successful individuals, but does not specify precise crossover variants in the general-background discussion.</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Mentioned as a standard GA/GP operator to perturb individuals; paper discusses mutation probability scheduling as an important control knob but does not specify atomic mutation operators in the general description.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>Discussed conceptually: diversity encouraged by adding new random individuals and tuning mutation probabilities, but no formal metric provided in background section.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General optimization and program synthesis; historically applied to control problems (cited works), robotics, vehicle systems, and program generation.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Background contrast between GA (parameter optimization) and GP (structure + parameter optimization).</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Authors emphasize GP's advantage in producing human-understandable mathematical controller expressions (unlike ML black-box networks) and its ability to include domain-specific operators (e.g., integrals/derivatives) if supplied in the function set; paper highlights the importance of function/terminal set choice, fitness evaluation, and occurrence probability of genetic functions for obtaining practically implementable controllers.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Revisiting Classical Controller Design and Tuning with Genetic Programming', 'publication_date_yy_mm': '2023-12'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Genetic Programming: A Paradigm for Genetically Breeding Populations of Computer Programs to Solve Problems. <em>(Rating: 2)</em></li>
                <li>Genetic Programming, on the Programming of Computers by Means of Natural Selection. <em>(Rating: 2)</em></li>
                <li>Genetic breeding of non-linear optimal control strategies for broom balancing <em>(Rating: 2)</em></li>
                <li>Automatic Creation of Human-Competitive Programs and Controllers by Means of Genetic Programming <em>(Rating: 2)</em></li>
                <li>DEAP: Evolutionary algorithms made easy. <em>(Rating: 2)</em></li>
                <li>An Enhanced Genetic Programming Algorithm for Optimal Controller Design <em>(Rating: 1)</em></li>
                <li>The archived-based genetic programming for optimal design of linear/non-linear controllers <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1605",
    "paper_id": "paper-266201971",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "GP-controller-generator",
            "name_full": "Genetic Programming-based automatic controller generator and tuner (time-domain, RPN)",
            "brief_description": "A GP system that evolves tree-structured mathematical/controller expressions in the time domain (including integral and derivative operators) using DEAP and a custom RPN evaluator; fitness balances tracking (ITSE), control effort, robustness to perturbed plant parameters, and expression length/implementability.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Genetic Programming-based controller generator (time-domain, RPN)",
            "system_description": "Evolves GP trees whose interior nodes are functions (bi-variate: +, -, *, /; uni-variate: exp, log, log10, sin, cos, integral, derivative) and whose terminals are system signals (states x_i, output y, control u, reference r, error ε) and constants k. All operators (including integral and derivative) are evaluated in the time domain using a custom Reverse Polish Notation (RPN) calculator. Each candidate controller is simulated in closed-loop (state-space) twice: once on the nominal plant and once on a slightly perturbed plant (parameter _sstep) to compute robustness. Parameters (numeric constants) are tuned with Nelder–Mead after structure generation. Fitness J aggregates: CA (controller action score = ITSE weighted by Q + integral squared control weighted by R, with multiplicative penalties for late stabilization, excessive overshoot, or excessive output slope), RI (robustness index = CA_nominal − CA_perturbed), and EL (expression length measured as GP tree size). Evolution uses elitism, mutation, crossover, and injection of ~10% newly randomized individuals each generation. Mutation and crossover probabilities are time-varying between configured bounds (mut_lims, cross_lims) using a linear VarRate schedule. Implementation is in Python 3 using DEAP and a custom RPN library; infeasible simulations (values exceeding limits) get assigned infinite fitness and are discarded.",
            "input_type": "programs / mathematical expressions (GP trees representing controller equations)",
            "crossover_operation": "Crossover is used as a genetic operator with a time-varying probability bounded by cross_lims and updated via the VarRate linear schedule; the paper does not specify the low-level crossover mechanism in text, only that crossover probability increases over generations (exploitation). Implementation uses DEAP (which typically offers subtree crossover), but the paper does not explicitly state which DEAP crossover primitive was selected.",
            "mutation_operation": "Mutation is used with a time-varying probability bounded by mut_lims and updated via the VarRate linear schedule; mutation probability starts higher to favor exploration and decreases over generations. The paper does not give a line-by-line definition of the mutation operator (e.g., point mutation, subtree mutation) but indicates mutation perturbs individuals and promotes exploration; additionally ~10% of each new generation are freshly randomized individuals.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Simulation-based executability/feasibility checks: each candidate is executed in closed-loop time-domain simulation using the RPN evaluator; if state or signal exceeds predefined maximum limits the simulation is halted and the candidate is assigned infinite (discarded) fitness. Implementability is encouraged via the EL term (EL = |GP_tree|) which penalizes large/complex expressions. The combined fitness J(CA, RI, EL) is therefore used as a proxy for both functionality and implementability.",
            "executability_results": "Quantitative fitness results reported for best individuals across tests (examples from paper): Group 1 (first-order stable) best J values: Test1 J = 2.03 × 10^6, Test2 J = 2.20 × 10^6, Test3 J = 1.12 × 10^6; other reported values include Test4 J = 6.44 × 10^5, Test5 J = 2.19 × 10^6, Test6 J = 5.50 × 10^7. Group 2 and Group 3 best-individual J values are reported in paper tables (e.g. Test7 J = 3.38 × 10^7, Test9 J = 2.92 × 10^5, Test14 J = 2.57 × 10^6). These J numbers are the paper's primary quantitative readout of solution functionality/quality.",
            "diversity_metric": "No explicit numerical diversity metric was defined. The authors implement population-diversity mechanisms: (i) time-varying mutation and crossover probabilities to favor exploration early (higher mutation) and exploitation later (higher crossover), (ii) injection of ~10% newly randomized individuals per generation to maintain genetic diversity, and (iii) elitism to preserve top solutions. But no genotypic/phenotypic diversity index (e.g., Shannon, pairwise distance) is reported.",
            "diversity_results": null,
            "novelty_executability_tradeoff": "Not formally analyzed as a tradeoff curve; however the fitness explicitly penalizes expression length (EL) and unimplementable simulations, which implicitly biases the search away from highly novel but impractically complex expressions. The paper states this as an intended design: favor implementable/time-domain expressions (including integrals/derivatives) over potentially exotic Laplace-domain structures that are impractical to realize.",
            "frontier_characterization": null,
            "benchmark_or_domain": "Automatic controller design and tuning for SISO linear time-invariant plants (first-order and second-order transfer functions) in reference-tracking tasks; testing suite includes stable/unstable first-order plants with low/medium/high gains and second-order plants.",
            "comparison_baseline": "Compared qualitatively to classical control solutions (e.g., PID/integral controllers) and to prior GP/GA literature (Koza-style GP and variants). No direct quantitative baseline experiments (e.g., run a PID tuner side-by-side with statistics) are presented; instead the paper observes that GP often rediscovers integral-like controllers.",
            "key_findings": "Crossover and mutation schedule and other algorithmic choices strongly affect exploration vs exploitation: authors start with higher mutation probability and lower crossover probability to promote exploration, then linearly decrease mutation and increase crossover (VarRate formula) so the population exploits promising structures later. Specific configuration used in the experiments: ind_number = 120, gen_number = 50, hof_lims = 1 (elitism = 1), cross_lims = (0.31, 0.69), mut_lims = (0.35, 0.64), and 10% of each generation are newly randomized individuals; these settings allowed the GP to find simple integral controllers early (often within a few generations) and then tune constants. For more complex plants (high gain or unstable dynamics), more generations were needed and the algorithm sometimes produced more complex expressions (including exp/trig) or failed to find fully satisfactory controllers within 50 generations. The paper concludes that the combination of mutation schedule, crossover exploitation, injected random individuals, elitism, and Nelder–Mead parameter tuning yields practical, executable controllers and tends to rediscover classical control structures (e.g., integral control) when those are optimal.",
            "uuid": "e1605.0",
            "source_info": {
                "paper_title": "Revisiting Classical Controller Design and Tuning with Genetic Programming",
                "publication_date_yy_mm": "2023-12"
            }
        },
        {
            "name_short": "GA/GP (background)",
            "name_full": "Genetic Algorithms (GA) and Genetic Programming (GP) (background / literature mention)",
            "brief_description": "Background mention: GAs operate on fixed-length parameter vectors (optimize parameters), GP operates on tree-structured programs/expressions (optimize both structure and parameters) and uses genetic operators such as selection, replication, crossover, and mutation.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Genetic Algorithms and Genetic Programming (general)",
            "system_description": "Described in the paper as the evolutionary computation family: GAs encode candidate solutions as fixed-length genomes (parameter vectors) and primarily perform parameter search; GP encodes candidate solutions as tree-structured programs/expressions allowing both structure and parameter evolution. The paper notes the common genetic operations (elitism, replication, crossover, mutation) and the need to balance exploration (mutation, random individuals) versus exploitation (crossover, elitism).",
            "input_type": "parameters (GA) and programs/expressions (GP trees)",
            "crossover_operation": "Mentioned as a standard GA/GP operator; the paper states that crossover is one of the usual genetic operations used to combine successful individuals, but does not specify precise crossover variants in the general-background discussion.",
            "mutation_operation": "Mentioned as a standard GA/GP operator to perturb individuals; paper discusses mutation probability scheduling as an important control knob but does not specify atomic mutation operators in the general description.",
            "uses_literature": null,
            "uses_code": null,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": "Discussed conceptually: diversity encouraged by adding new random individuals and tuning mutation probabilities, but no formal metric provided in background section.",
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "General optimization and program synthesis; historically applied to control problems (cited works), robotics, vehicle systems, and program generation.",
            "comparison_baseline": "Background contrast between GA (parameter optimization) and GP (structure + parameter optimization).",
            "key_findings": "Authors emphasize GP's advantage in producing human-understandable mathematical controller expressions (unlike ML black-box networks) and its ability to include domain-specific operators (e.g., integrals/derivatives) if supplied in the function set; paper highlights the importance of function/terminal set choice, fitness evaluation, and occurrence probability of genetic functions for obtaining practically implementable controllers.",
            "uuid": "e1605.1",
            "source_info": {
                "paper_title": "Revisiting Classical Controller Design and Tuning with Genetic Programming",
                "publication_date_yy_mm": "2023-12"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Genetic Programming: A Paradigm for Genetically Breeding Populations of Computer Programs to Solve Problems.",
            "rating": 2,
            "sanitized_title": "genetic_programming_a_paradigm_for_genetically_breeding_populations_of_computer_programs_to_solve_problems"
        },
        {
            "paper_title": "Genetic Programming, on the Programming of Computers by Means of Natural Selection.",
            "rating": 2,
            "sanitized_title": "genetic_programming_on_the_programming_of_computers_by_means_of_natural_selection"
        },
        {
            "paper_title": "Genetic breeding of non-linear optimal control strategies for broom balancing",
            "rating": 2,
            "sanitized_title": "genetic_breeding_of_nonlinear_optimal_control_strategies_for_broom_balancing"
        },
        {
            "paper_title": "Automatic Creation of Human-Competitive Programs and Controllers by Means of Genetic Programming",
            "rating": 2,
            "sanitized_title": "automatic_creation_of_humancompetitive_programs_and_controllers_by_means_of_genetic_programming"
        },
        {
            "paper_title": "DEAP: Evolutionary algorithms made easy.",
            "rating": 2,
            "sanitized_title": "deap_evolutionary_algorithms_made_easy"
        },
        {
            "paper_title": "An Enhanced Genetic Programming Algorithm for Optimal Controller Design",
            "rating": 1,
            "sanitized_title": "an_enhanced_genetic_programming_algorithm_for_optimal_controller_design"
        },
        {
            "paper_title": "The archived-based genetic programming for optimal design of linear/non-linear controllers",
            "rating": 1,
            "sanitized_title": "the_archivedbased_genetic_programming_for_optimal_design_of_linearnonlinear_controllers"
        }
    ],
    "cost": 0.01484825,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Revisiting Classical Controller Design and Tuning with Genetic Programming
9 December 2023</p>
<p>Mengchu Zhou 
Bi Jing 
Mohammadhossein H Ghahramani 
Roberto Teti 
Carlos A García 0000-0002-5473-9308
Power and Control Electronics Systems
Universitat Politècnica de Catalunya
08800 Vilanova i la GeltrúSpain</p>
<p>Manel Velasco manel.velasco@upc.edu 0000-0002-0764-3063
Power and Control Electronics Systems
Universitat Politècnica de Catalunya
08800 Vilanova i la GeltrúSpain</p>
<p>Cecilio Angulo cecilio.angulo@upc.edu 0000-0001-9589-8199
Intelligent Data Science and Artificial Intelligence
Universitat Politècnica de Catalunya
08034BarcelonaSpain</p>
<p>Pau Marti pau.marti@upc.edu 0000-0002-5189-0782
Power and Control Electronics Systems
Universitat Politècnica de Catalunya
08800 Vilanova i la GeltrúSpain</p>
<p>Antonio Camacho antonio.camacho.santiago@upc.edu 0000-0002-0673-6452
Power and Control Electronics Systems
Universitat Politècnica de Catalunya
08800 Vilanova i la GeltrúSpain</p>
<p>Revisiting Classical Controller Design and Tuning with Genetic Programming
9 December 2023C57107E80C68D37B5F282609E4DFBD8010.3390/s23249731Received: 19 October 2023 Revised: 23 November 2023 Accepted: 1 December 2023genetic algorithmgenetic programmingcontrol designcontrol tuning
This paper introduces the application of a genetic programming (GP)-based method for the automated design and tuning of process controllers, representing a noteworthy advancement in artificial intelligence (AI) within the realm of control engineering.In contrast to already existing work, our GP-based approach operates exclusively in the time domain, incorporating differential operations such as derivatives and integrals without necessitating intermediate inverse Laplace transformations.This unique feature not only simplifies the design process but also ensures the practical implementability of the generated controllers within physical systems.Notably, the GP's functional set extends beyond basic arithmetic operators to include a rich repertoire of mathematical operations, encompassing trigonometric, exponential, and logarithmic functions.This broad set of operations enhances the flexibility and adaptability of the GP-based approach in controller design.To rigorously assess the efficacy of our GP-based approach, we conducted an extensive series of tests to determine its limits and capabilities.In summary, our research establishes the GP-based approach as a promising solution for automating the controller design process, offering a transformative tool to address a spectrum of control problems across various engineering applications.</p>
<p>Introduction</p>
<p>For nearly a century, control theory has played a significant role in enabling systems to operate in accordance with desired mathematical specifications [1,2].Several control methodologies have been developed over the years, including PID control, adaptive control, robust control, stochastic optimal control, and others [3,4].Each methodology features a unique regulator structure characterized by multiple parameters and components to be tuned.The variety of alternatives provided by classical control theory has enabled researchers to successfully control a diversity of systems and processes.However, the rapid technological advancements in society have given rise to increasingly complex systems and control challenges, necessitating even more advanced techniques to achieve effective control.</p>
<p>Artificial intelligence (AI) has emerged in the context of modern control as a critical discipline with a significant impact on both research and engineering applications.AI helps in the generation of "intelligent agents" capable of performing tasks or solving problems that are beyond the scope of conventional methods.Initially, AI applications were limited to advanced search engines, pattern recognition, speech recognition, data classification, data segmentation, and intelligent clustering [5,6].However, as time passed, numerous disciplines recognized the potential of this technology and embarked on exploring ways to integrate it into their respective domains of expertise [7].This trend has led to the emergence of application fields such as autonomous vehicles, motion biomimicry, self-learning for decision making, perception enhancement, object manipulation, social intelligence, and more recently, the fields of control and automation, to mention only a few [8][9][10][11].</p>
<p>The quick acceptance of AI in the control theory research domain in the form of intelligent control techniques [12] is mainly the result of machine learning (ML) progress, through strategies such as supervised learning (SL) and reinforcement learning (RL).In the early stages of investigation, AI technology was primarily integrated into control applications as a fault and anomaly detector or as an intelligent scheduler for module coordination [13][14][15][16].However, the integration of ML methodologies rapidly escalated due to their efficient operation and quick responsiveness.The initial steps in this direction took form in examples such as [17,18], where the coordinated operation of a group of traffic lights was the result of an RL structure.Later on, investigations such as [19,20] began to describe complex systems, such as robots being controlled using SL or RL.From the lower levels of control to higher management levels, ML alternatives presented a reliable performance and optimal decision-making capabilities.</p>
<p>ML-based control offers solution to problems that conventional methods would not be able to solve.However, it is characterized by not resulting in an explicit analytical mathematical expression that can be readily implemented or modified using specific guidelines according to the system.Instead, control structures resulting from ML-based design techniques consist of networked layers of perceptrons, which are simplified mathematical representations of neurons, whose outputs activate according to the value resulting from the addition of their weighted inputs.In such structures, the human involvement is limited to participating by determining how many elements there are and what types they are comprised of.The values of the structure's weights are automatically adjusted by the computer during the AI training process.Consequently, ML-based controllers can be perceived as functional "black boxes" that accomplish the specified goal, but their decision-making logic remains unknown to developers.For most of the cases, this limitation might be irrelevant, as the main goal is merely to solve the control problem.However, when the goal includes (i) understanding how to solve the problem through analyzing the controller equation and (ii) understanding the controller's limitations and stability properties prior to its deployment, ML algorithms may not be suitable for development.</p>
<p>Machine learning (ML) has an older alternative that can provide solutions to control problems while generating structures that researchers can understand, analyze, and further improve using their knowledge, if necessary.Evolutionary techniques have been part of the AI research community since the early 1980s [21,22], and over the years the techniques have been successfully implemented in a number of control research projects [23][24][25][26].The main evolutionary techniques in this AI branch correspond to genetic algorithms (GAs) [27] and genetic programming (GP) [28,29].In the domain of evolutionary techniques, GAs identify and optimize parameters of an input-output system without varying their lengths and compositions.Conversely, GP is a methodology used to optimize both the structure and parameters of the system.In this case, the size and shape of the controllers dynamically change during the evolution process until an optimal structure that fits the specified requirements is found.Consequently, if properly implemented, GP allows for the generation of mathematical equations that are able to solve control problems, even complex ones.</p>
<p>When performing automatic controller design and tuning using genetic programming (GP), many factors influence the algorithm's output, that is, the controller structure and its parameters.Certain aspects of this technique become more relevant to the control engineering side, while others seem to naturally align with the domain of optimization.Key control factors that strongly affect the outcome of the generation process are (i) the set of available functions and operators, (ii) the evaluation process, and (iii) the occurrence probability values assigned to the genetic functions.Therefore, within the context of GPbased automatic controller design and tuning, the contribution of this paper primarily focuses on the set of functions (also referred to as operators) and the fitness evaluation (function, process, and constraints) in order to show that GP is able to recreate classical controllers as an optimal solution for general processes.</p>
<p>In particular, for linear time-invariant plants, genetic programming suggests that, in the framework of the classical tracking problem, the most effective controller is a straightforward integral controller, which is exactly the controller that would be also suggested by classical control theory.The mere generation of an integral controller is not the primary contribution.The contribution lies in determining how to embed into a GP framework key aspects for proper controller synthesis, such as including time-domain operators like integrals and derivatives, or specifying objective functions accounting for the controller performance, robustness, and implementation feasibility.Such a GP-based approach becomes a promising technique for addressing intricate control problems, as far as it is able to mimic well-known solutions for simpler problems, and, unlike classical control, the procedure is general enough to be readily extended to more complex scenarios.</p>
<p>The remainder of this paper is structured as follows: Section 2 offers a concise introduction to evolutionary techniques; Section 3 provides an overview of the current state of utilizing genetic programming in the realm of automatic control; Section 4 details the proposed genetic programming approach; Section 5 and Section 6 shows implementation of selected test cases where the results are presented and discussed; and lastly, Section 7 offers concluding remarks and outlines directions for future research.</p>
<p>Evolutionary Techniques</p>
<p>Genetic algorithms (GAs) and genetic programming (GP) both operate on the principle of propagating generations of individuals by selection based on the "survival of the fitness" criterion.The individuals that are part of a generation are initially generated in a random way, and each one is evaluated and ranked using a fitness function related to the process goal.An individual in a GA corresponds to a set of values in a parameterized model to be optimized.In contrast, an individual in GP is a tree-based structure.As depicted in Figure 1, each tree is a combination of several nodes and branches.Usually, variables and numerical constants are located at the leaf nodes of the tree, known as terminals, while mathematical operators, which are located in the interior nodes, compute the values of nodes and leaves attached under it, commonly referred to as functions.Terminals are selected from a "terminals set", T ∈ T , and functions are selected from a "functions set", F ∈ F .After the initial generation is populated with individuals, their parameters, known as genomes, are evaluated, and a fitness is assigned to them based on their performance on a cost function metric.Individuals with a higher fitness and ranking are more likely to progress to the next generation.There exists a set of usual genetic operations, also known as rules, that determine how individuals can be considered successful and evolve to the next generation [30]: elitism, replication, crossover, and mutation.</p>
<p>Successful individuals from each generation evolve to the next generation by means of any of the former genetic operations.However, a good practice includes newly generated individuals from scratch to promote diversity [31].The evolution of generations continues until the performance of the cost function converges to a desired stopping criterion.As usual in machine learning algorithms, it is not guaranteed to converge to a global minimum.Nevertheless, these algorithms have achieved success in many applications, thanks to the alternative local minima that are returned at the end of evolution.Improvement of the evolution performance can be obtained by adjusting the number of individuals through generations and the occurrence probability of the genetic operations, guided by custom functions [32,33].</p>
<p>State of the Art</p>
<p>In this section, an overview is provided about existing work related to genetic programming (GP) for control theory, focusing on the challenge of automatic controller design and tuning.This is a research domain treated in the literature for more than 30 years, with favorable results.One of the pioneering works in this topic is [28], where an innovative method to solve problems in computer programs was firstly presented.Back in the 1990s, the authors introduced the genetic breeding of nonlinear optimal control strategies for the broom balancing problem in [34].They considered a function set of basic arithmetic operations, and the system's model's states' variables, such as terminals, and a fitness function based on a linear approximation that replaces the hyperbolic functions in terms of the Taylor series expansion.Operative controllers were generated that outperformed classical controllers at that time for the specified plant.</p>
<p>More recent pioneering investigations, such as those by [35,36], describe the automatic controller generation applied to the vehicle field.Having as plants (i) a combination of an electric motor and electronic drive and (ii) an active suspension system, it is described how it is possible to obtain valid control expressions using evolutionary algorithms.Moreover, out of these examinations, it is noted that, among the results, some were able to manage nonlinearities, despite their linear nature.For instance, in the case of active suspension systems, the results included asymptotically stable candidates, which become unstable if a large bump is encountered and are thus lacking robustness.Following this line of investigation, research in [37][38][39] integrated GP into the field of mobile robotics control.These studies demonstrate the ease with which custom operations can be integrated into the function set used to create the individuals.In these cases, instead of directly obtaining a mathematical equation as the regulation structure, the controller is an algorithm that combines arithmetic, trigonometric, and custom-made functions.Since the algorithm employs user-defined functions, the resulting controller can be understood by the researchers and, if necessary, transformed into a mathematical equation.</p>
<p>Two major trends can be discerned in the field of automatic controller generation using genetic programming.The first one involves the generation of control structures tailored to specific plants or systems.For instance, research developed in [40] aims to simultaneously generate four controllers for a helicopter to perform hovering maneuvers; studies in [41] describe the automated synthesis of optimal controllers using multi-objective genetic programming for a two-mass-spring system; in [42], the objective is about the control of a turbulent jet system; and work in [43] seeks a control structure for a twodimensional version of the Goddard rocket problem.In all these studies, despite dealing with complex plants or systems, their function sets only included basic arithmetic operators, like exponential and trigonometric operations.From classic control theory, it is hard to imagine a controller minimizing the tracking error as much as possible without the use of integral terms.Nevertheless, GP algorithms demonstrated an ability to find an appropriate relationship among the specified functions and terminals, which was able to fulfill the control objectives.</p>
<p>In line with this first trend, some works can be also identified that combine elementary mathematical operations and custom-made functions to generate control programs for specific systems.In [44], using an acrobot as a plant, the automatic control generation for its minimum time swing up and balance regulation is described.The work introduces a set of logical operations into the function set.Although the final control structure manages to accomplish the regulation objectives, the combination of logical and mathematical operations results in a long expression that can be treated as a control program instead of a control equation.Similarly, research detailed in [45] describes the generation of controllers for high-level applications on a service robot.In this case, the set of functions considered for the evolution process is fully composed of nine custom-made functions, which are unique for this system.The controllers obtained from the work are lists of actions, which can be treated as a program, too.As in many analogous cases, the generated controllers outperformed the baseline alternatives.</p>
<p>The second major trend being highlighted is the research on the generation of control structures for generic systems or groups of plants.In contrast to the previous research line, the function set is restricted to simple mathematical operators.The choice of basic elements for the function set is driven by the main objective of these algorithms, which is to find a suitable mathematical expression that can solve the problem and provide an idea on how to deal with similar scenarios.Research in [46] is a good example for this trend, where authors are looking for the generation of optimal controllers for linear and non-linear plants.In this case, a variant of GP, known as archived-based GP, is used as an evolutionary strategy.It is characterized by the use of additional evolutionary functions, such as piling, sorting, excerpting, production, and archiving.The function set described in this work consists of the four basic arithmetic operations.Corresponding to this trend, the work presented in [47] uses linear GP to generate controllers for nonlinear dynamics with frequency crosstalk.Unlike the previous article, trigonometric operations are also included in the function set.In [48], a technique named multiple basis function genetic programming (MBFGP) is proposed.The structures of program trees in MBFGP are composed of a random number of linear and/or nonlinear basis functions (terms), which are forced to be linear in parameters.The function set used for the evolutionary process is composed of arithmetic operations.</p>
<p>In the previously mentioned research works, controllers for generic structures are generated using GP techniques relying on simple mathematics operations, avoiding the use of differential operations such as integrals and derivatives to obtain operative structures.However, these GP techniques compensate the lack of differential operators by increasing the length of the control expression significantly, attempting to mimic pseudo integral and derivative components.Our starting hypothesis is that differential operators are a pivotal component in an optimized control structure.Their use is expected to greatly enhance the regulation performance while reducing the expression length.</p>
<p>This research approach aligns with the work presented in [49].There, secondand third-order generic systems are included into the function set of an evolutionary algorithm responsible for generating human-competitive controllers.Controllers designed with this algorithm in the Laplace domain are reported to outperform PID (proportional-derivative-integral) control structures.Another contemporary work worth mentioning is [50], where derivatives and integrals are also included in the function set.Once again, the control structures obtained from this research show a better performance than those designed using traditional methods, such as those guidelines in [51].In this case, the controller is also developed in the Laplace domain.</p>
<p>Previous research has also used differential operators in genetic programming (GP) in different forms.In [52], the evolutionary process is addressed towards the generation of control structures in the form of block diagrams operating in the Laplace domain.Similarly, research is described in [41] about the integration of differential operators into GP-generated control structures.Although only basic arithmetic operations are used in the function set, the authors included the Laplace operator into the terminal set.This methodology allows the generation of structures in the form of transfer functions.</p>
<p>As has been described, the integration of differential operations into GP-generated control structures in the available literature always involves designing in the Laplace domain.Working in the Laplacian domain ensures the creation of structures that, in one way or another, will have integral and derivative components.Moreover, the evolutionary paradigm allows for the avoidance of human preconceptions regarding control design that are not exploited in current approaches.However, current approaches restrict the range of possible solutions to PID-type controllers.Nevertheless, the most significant limitation of these methods is their ability to produce functional expressions that may seem viable in the Laplace domain but are impractical in the physical world due to their complexity, preventing their transformation into the time domain.</p>
<p>To overcome the previous limitations, this paper proposes a GP framework that operates within the second trend, that is, designing and tuning generalist controllers, and performs the controller generation, design, and tuning in the time domain while simultaneously using differential operators.Moreover, the designed controllers are obtained by minimizing a fitness function that gathers merits such as standard control performance specifications and includes additional requirements, such as robustness against unmodeled dynamics or external perturbations, as well as the implementability of the solutions.</p>
<p>With this approach in mind, our goal is to design a GP-based evolutionary strategy capable of creating control expressions that use differential operations from the function set rather than the terminal set, while at the same time all of the design and tuning process is completed in the time domain.Theoretically, as will be demonstrated, operating in this manner will fully expand the group of possible combinations that the computer can present as control solutions for complex plants, and, importantly, all of these solutions will be fully realizable.</p>
<p>Automatic Controller Generation, Design, and Tuning</p>
<p>We propose the design of a genetic programming (GP) procedure for the automatic generation, design, and tuning of controllers.The GP-based evolutionary strategy is capable of generating tuned control expressions that include differential operations within their structures, with the overall design process taking part in the time domain.To achieve this challenging result, the function set, F , and the terminal set, T , which constitute the controller structure, must be defined.Moreover, a fitness function, J(•), must be defined, enclosing both the desired behavior for the controlled process and the control action.These elements will serve to obtain an optimal controller using a general GP evolutionary algorithm.</p>
<p>In this research work, a control structure will be considered optimal when meeting the following five requirements: R1.Small-sized expression for the controller; R2.The control action is as smooth as possible; R3.The control action is robust and can withstand variations in the system's dynamics; R4.The process variable does not surpass a specified overshoot; R5.The steady state error is minimal after a specified time.</p>
<p>Regardless of the GP algorithm employed, the five specified requirements must be contained in a fitness function allowing the GP-based procedure to generate, design, and tune time-domain optimal control strategies in the time domain for general SISO (singleinput, single-output) systems.</p>
<p>GP-Based Controller Generator</p>
<p>In order to develop a GP evolutionary strategy satisfying the aforementioned five requirements (R1-R5), special attention is dedicated to the definition of the function set, the terminal set, and the fitness function.The function set should include time-domain differential operators, the terminal set should allow time-domain closed-loop simulations during the optimization phase, and the fitness function bears the ultimate responsibility of identifying controller equations fulfilling all five requirements.</p>
<p>Function Set</p>
<p>According to our approach, the function set, F , is divided into two groups of operators based on the number of inputs they accept.The first group contains bi-variate operators, including the following operations: addition, subtraction, multiplication, and division.The division operator is configured to handle division by 0 by performing a division by 0.001 when such a situation appears during the evaluation of the tree expression.The second group of functions corresponds to uni-variate operators.It includes the operations of exp, log, log 10 , sin, cos, integral, and derivative.Similar to the division operator, the logarithmic operators are modified functions that return 0 in the case of input of 0. It is worth noting that all the mathematics of these functions is carried out in the time domain, including the differential operators.</p>
<p>Terminal Set</p>
<p>In a similar form, the terminal set, T , must be defined.In this research, the terminal set consists of system signals: states {x 0 , . . ., x n }, output y, control action u, reference signal r, and error ε.Additionally, the constant k is included to allow for the integration of operations with constant parameters and weighted functions.Another issue to be taken into account for the set-up of the GP-based procedure is the determination of initial values for the probabilities associated with the evolutionary process and their bounds (see Table 1): mutation, crossover, and top individuals.The fitness scores of the individuals of a given population are calculated based on the minimization of the cost function defined in Equation (1):
J(CA, RI, EL)(1)
which is based on three parameters related to the five requirements indicating the optimality of the solution:</p>
<p>1.The score of the controller action, denoted as CA, related to requirements R2, R4, and R5, which has to deal with the shape of closed-loop dynamics.2. The robustness index of the controller, named RI, which is linked to requirement R3, which may include unmodeled dynamics or external perturbations.3. The control expression length, represented as EL, related to requirement R1, which concerns the feasibility of implementation.</p>
<p>To obtain the required data, each controller candidate is simulated based on the state matrices of the plant.These values can either be directly specified in the configuration file or obtained from a plant defined as a transfer function using Equation (2):
ẋ(t) = A(t)x(t) + B(t)u(t) y(t) = C(t)x(t) + D(t)u(t)(2)
Hence, the cost function in Equation ( 1) could be expressed in the form of Equation (3):
J(•) = J ẋ(t),y(t) (•)(3)
The score of the controller action, CA, is the result of the addition of two weighted components, inspired in standard optimal control theory, defined as follows:
CA = Q t • ε 2 (t)dt + R u(t) 2 dt(4)
The first component in Equation ( 4) describes the reference tracking speed using the ITSE (integral time squared error) criterion [53].It is defined as the integral of the error multiplied by its time component raised to the power of two.This part of the score is weighted by a constant Q.The second component describes the control action speed using the integral of the squared control action.This part is weighted by a constant R. The purpose of the constants Q and R is to assign weights to errors and control actions, typically according to their fabrication and energy costs.</p>
<p>As additional means to calculate the control action score, there are supplementary indicators that modify its final value to allow penalizing deviations from the specified control performance requirements:
if (|ε| &gt; 0) &amp; (t &gt; stab_time) then CA = 3 • CA if (max_overshoot &lt; y) then CA = 2.5 • CA if max d 2 dt 2 (y) &lt; signal_slope then CA = 2 • CA(5)
where limit values in the formulation (Equation ( 5)) are described in Table 2.</p>
<p>Table 2. Set-up of experimental conditions for the controller action.</p>
<p>Variable Name Description</p>
<p>stab_time max stabilization time in output for reference variation max_overshoot max overshoot in the output signal tracking (%) signal_slope max slope variation of the system's output</p>
<p>The variables of these indicators are related to the occurrence of three events:</p>
<p>1.The tracking error is not minimal after a time value specified by the variable stab_time after a reference change; 2. The system's output overshoot exceeds the value specified by the variable max_overshoot when tracking a reference change; 3. The maximum value of the second derivative of the system's output signal does not exceed the limit specified in the variable signal_slope.</p>
<p>The last component is integrated to control the slope of the plant's output and prevent abrupt signal variations that might affect the useful life of the system's actuator in a physical implementation.If any of these events occur, the value of the control action score will be multiplied by 3 in the case of tracking error, 2.5 in the case of a high overshoot, and 2 in the case of rough system output.</p>
<p>When using our genetic programming procedure, both structures and their parameters are optimized according to the fitness evaluation method.In this investigation, the equations generated during the evolutionary process determine the structures, while the constants that modify the weight of the mathematical operations in the equations are represented by the parameters.Within the proposed genetic strategy, the structures are optimized using the natural evolution process of the algorithm.The parameters are fine-tuned (optimized) using the standard Nelder-Mead optimization method [54].As expressed in the available literature, both components of a valid individual could be simultaneously processed in the evolutionary process; however, this approach would lead to a huge search space for the GP system.Additionally, in the context of automatic controller generation, joint optimization for design and tuning could potentially lead to controllers with a satisfactory performance and stability due to the tuned values of their constant parameters.However, it may result in a poorly designed structure that lacks robustness.This issue emerges because the generated controller is a unique solution for the dynamic equation used in the simulation process.As a result, minimal changes in one of the equation's coefficients might mean that the controller will no longer be a functional structure.</p>
<p>In the available literature, it is a common trend to simulate the combination of a controller plus the plant operation to obtain analytical data for fitness scoring.However, this is typically performed assuming that the plant's dynamics are ideal and remain constant all the time.Real-world plants are not ideal and change over time due to aging components and continued usage.Mathematically, these variations do not add or remove factors from the plant's dynamic equation, but they do alter the values of its coefficients.To simulate this dynamic variation in the plant, a parameter named _sstep is used to generate a second plant equation with a slight variation.This modified equation is used in a second simulation process of the fitness calculation.Consequently, two control action scores are obtained at the end of the simulation stage.These values are used in the calculation of the robustness index RI, as described in Equation ( 6):
RI = CA − CA _sstep(6)
Finally, the last fitness parameter of the cost function is the expression length, EL.It is calculated according to the number of levels that a genetic tree has:
EL = |GP_tree|(7)
where | • | represents the length of the genetic programming tree denoted as GP_tree.</p>
<p>GP Evolutionary Algorithm</p>
<p>A regular and straightforward evolutionary algorithm is considered in our genetic programming approach.The initial stage of the GP procedure involves the generation of the first population of individuals, referred to as generation 0, denoted as G 0 .During this step, elements from the function set, as well as elements from the terminal set, are randomly selected and assembled into GP tree structures.</p>
<p>Once all the individuals (controllers) from a population have been assigned their corresponding fitness scores, the next step in the evolutionary process is to sort them in descending order of fitness according to their cost function values.Then, the generation of a new offspring of controllers is processed using the described genetic operations: elitism, mutation and crossover.The elitism operation is controlled by the parameter hof_num, which specifies from fittest to least fit how many candidate controllers are directly copied in the next population of available slots.In the case of the mutation, and crossover, the vectors mut_lims and cross_lims contain the upper and lower bounds for the probabilities associated with the evolutionary algorithm components.</p>
<p>Balancing exploration (mutation) and exploitation (crossover) in an evolutionary process is often challenging.Most of the time, a set of probabilities that leads to good results in one scenario does not generate the same favorable results in different ones.The literature suggests that during the initial stages of an evolutionary process, it is usually more effective to prioritize exploration over the exploitation of existing individuals.As the process goes on, a group of candidates with good performances appears, which makes it better to exploit local individuals rather than to keep looking for new alternatives.Initially, the mutation probability exceeds the crossover probability.However, as generations progress, the mutation probability decreases, while the crossover probability increases, following linear relationships.These variations in rates are calculated using the expression in Equation ( 8):
VarRate = maxLimit − minLimit GenerationsNumber(8)
The evolutionary algorithm uses genetic operations to fill about 90% of the defined number of individuals for every population.The remaining 10% of individuals are generated using the controller generator defined for the initial population creation.This approach facilitates the continuous integration of new components into the evolutionary process, which might lead to an overall generation improvement.</p>
<p>Implementation</p>
<p>To implement the proposed GP-generator procedure, a Python-based GP program has been developed.This code can generate time-domain optimal control strategies for general single-input, single-output (SISO) systems.The programming is coded in Python 3 and uses the open-source package DEAP, which stands for Distributed Evolutionary Algorithms in Python [55].DEAP is an evolutionary framework that allows for the fast development, implementation, and testing of code related to evolutionary techniques.It includes a range of predefined structures, objects, and functions that encapsulate the basic components and operations inherent to an evolutionary process.Additionally, it offers easy integration of custom-made components, allowing compatibility with any kind of development.</p>
<p>The final source code for the proposal is composed of three main files:</p>
<p>1.The configuration file, which contains the values and definitions of variables used throughout the system's execution.2. The custom-made Reverse Polish Notation (RPN) calculator library.3. The main file, which encodes the evolutionary strategy and report generator.The system's operation is visually represented in Figure 2.</p>
<p>The Configuration File</p>
<p>The configuration file specifies the state-space matrices of the system to be controlled, either by directly specifying their values or by calculating them and specifying the system's transfer function H(s) instead of the matrices.The program is coded to automatically detect how the plant has been specified and determine whether it is necessary to calculate its state-space matrices.In addition to this information, the configuration file also contains the following: (i) the system's simulation variables, (ii) limit values and execution constants for the fitness calculation, and (iii) variables and probabilities for the evolution process.For those variables that have not been previously defined in earlier sections, a list is provided in Table 3.</p>
<p>The RPN Calculator</p>
<p>To date, both customized and generalist procedures for applying GP in control prevent the generation of controllers endowed with differential operators designed in the time domain due to complexity issues.</p>
<p>To overcome the coding complexity issue, our approach develops and implements a custom-built Reverse Polish Notation calculator implemented in Python 3. RPN is a method for conveying mathematical expressions without the use of separators such as brackets and parentheses.In RPN, operators follow their operands, hence removing the need for brackets to define evaluation priority.The operation is read from left to right, but execution is performed every time an operator is reached.The RPN procedure always uses the last one or two numbers as operands.This notation is suited for computers and calculators since there are fewer characters to track and fewer operations to execute.The main objective of this custom RPN calculator library is to perform mathematical computations required for system simulations included in the fitness evaluation.RPN notation was selected over Infix notation (commonly used in arithmetical and logical expressions) for simulation calculations because, when combined with a memory structure, RPN's stack-based evaluation provides efficient and organized access to the memory positions of the differential operators memory structure.Hence, the code complexity for these operators is reduced to the minimum.</p>
<p>The Main File</p>
<p>When the required set-up parameters are loaded, the main program proceeds with two processes.First, it generates a Python pickle structure, and, simultaneously, it initializes an empty PDF document for historical data storage and report generation.Next, the initial population of individuals is generated.The function in charge of this procedure randomly selects mathematical operations and terminals from predefined sets and combines them into GP tree structures.</p>
<p>To obtain values for the variables involved in the different calculus of the fitness function, each controller candidate is simulated twice using the RPN calculator library for mathematical operations.The system's simulation for the feedback control of the plant is performed using the state-space equations described in Equation ( 2).The combined use of the library and the equations allows for an iterative, step-by-step simulation of the system.As a result, the verification of overshoot and stabilization parameters can be completed on the fly during system operation.It also brings the advantage that if a value exceeds a predefined maximum limit during the simulation, the process is halted, and all scores are assigned an infinite value for the fitness parameters of a control candidate, leading to its immediate discard from the evolution process.In the case that either the simulation process runs to completion or the maximum number of generations, denoted as gen_number, is reached, historical data on error, control action, and the system's output are processed to calculate the value of the controller action score.</p>
<p>Tests and Results</p>
<p>Most of the plants commonly encountered in practical control applications can be adequately approximated by either a first-order or a second-order transfer function, simplifying the control design process.Therefore, it will be assumed in this research that restricting the considerations to these types of plants provides a valid testing scenario.</p>
<p>In the classic control approach, a notable case is reference tracking.When the control objective consists of making the system follow a constant reference signal, a common answer is to use a proportional controller based on the reference signal and the system's gain.As mentioned, if the reference remains unchanged over time, the tracking performance of this alternative is flawless.However, if this strategy is faced with varying references, the tracking performance deteriorates.To eliminate the possibility that the program's outcome generates controllers relying solely on this structure, all validation design tests use a reference signal with three variations over time.The values were selected to have a small, a medium, and a large variation, thereby preventing the generation of controllers that can only handle a specific range of reference signal variations.</p>
<p>The test suite is designed to demonstrate three fundamental aspects of the algorithm's features:</p>
<p>1.</p>
<p>It possesses the ability of generating functional control algorithms using the mathematical operations defined in the function set.2.</p>
<p>It can handle complex control systems.</p>
<p>3.</p>
<p>It can generate controllers for both first-order and second-order plant models.</p>
<p>Referring to the first aspect, a practical approach involves modifying the code and seeing if the program is capable of generating structures that replicate or are similar to the classical PID equation structure.For this work, the previously mentioned modifications are to limit the elements of the function set to the four basic math operations (+, −, * , /) and the differential functions ( , d dt ).In the case of a successful outcome, this scenario would validate the effectiveness of the evolutionary algorithm, confirming that the program is able to combine the elements of the function set to meet the objectives defined by the fitness function.</p>
<p>According to control theory, a system is considered unstable when any of its natural poles has a positive sign.Additionally, a plant may pose control challenges when it exhibits a very high natural gain, with minimal input values causing significant variation in the plant's outputs.These characteristics can be used as instruments to assess how the algorithm performs when dealing with complex systems.Therefore, the test suite requires the program to generate control equations for first-order plants with positive poles.Furthermore, the plants in the test scenarios will exhibit a range of gain values, including small, medium, and large gains.Finally, once the two initial statements are proven true, a final series of tests will be carried out to assess the algorithm's when facing second-order systems with negative poles.</p>
<p>As a result of the described planning, the following tests are proposed to validate the GP-based controller generator:</p>
<p>1.</p>
<p>First-order plant, negative pole, low gain, and using the reduced funtions set (RFS); 2.</p>
<p>First-order plant, negative pole, medium gain, and using the RFS; 3.</p>
<p>First-order plant, negative pole, high gain, and using the RFS; 4.</p>
<p>First-order plant, negative pole, and low gain; 5.</p>
<p>First-order plant, negative pole, and medium gain; 6.</p>
<p>First-order plant, negative pole, and high gain; 7.</p>
<p>First-order plant, positive pole, low gain, and using the RFS; 8.</p>
<p>First-order plant, positive pole, medium gain, and using the RFS; 9.</p>
<p>First-order plant, positive pole, high gain, and using the RFS; 10.First-order plant, positive pole, and low gain; 11.First-order plant, positive pole, and medium gain; 12. First-order plant, positive pole, and high gain; 13.Second-order plant and low gain; 14.Second-order plant and medium gain; 15.Second-order plant and high gain.</p>
<p>To ensure a consistent performance evaluation, all evolutionary processes use the same configuration parameters, as listed in detail in Table 4. Finally, the test set is categorized into groups based on the system's order and the nature of its poles, resulting in the following groups:</p>
<p>• Group 1: Tests 1-6.First-order stable systems.• Group 2: Tests 7-12.First-order unstable systems.• Group 3: Tests 13-15.Second-order systems.</p>
<p>First-Order Stable Systems</p>
<p>The plant functions used as targets for the genetic evolution are depicted in Equation ( 9).As can be seen, each test increases the plant's gain by a factor of 10.
H(s) = K 0.5s + 1 , K = {0.4, 4, 40}(9)
After completing all the tests in the group, the data corresponding to the best individuals for each case are shown in Table 5.It consists of 4 columns, and from left to right, it describes (i) the generation number when the expression was found, (ii) the raw expression of the controller, (iii) the equation expressed using mathematical symbols, and (iv) the final J cost value of the control candidate.The results for Tests 1-3 in Table 5 show that all the best controllers are expressed as weighted integrals of the error signal.It is worth mentioning that the evolutionary algorithm was efficient in generating these solutions.Based on the generation numbers where the controllers were found, it can be seen that it took only half of the available generations to find functional solutions.In fact, the integral structure for each of these three cases was identified as the best structure even in earlier generations: generation 3 in Test 1, generation 5 in Test 2, and generation 8 in Test 3. Following these points in the evolution process, the algorithm was mainly trying to optimize the equations' constants as much as possible.</p>
<p>When checking the graphical representations of the equations for Tests 1-3, shown in Figure 3a-c, it can be seen how the controllers for Test 1 and Test 2 exhibit fast stabilization, a minimal overshoot peak, and, after the initial peak, a flawless tracking performance for all reference variations.However, in the case of Test 3 the behavior depicted in the image displays three oscillations after reaching a stable tracking state, which is the result of controlling a plant with an excessively high gain.</p>
<p>Regarding the results of Tests 4 and 5, Table 5 illustrates that these equations no longer consist of pure integral operations.In the case of Test 4, the equation now shapes a proportional-integral (PI) structure.Its proportional part is based on the weighted error and reference.As a result, it can be observed in its graphical behavior shown in Figure 3d that this structure is more aggressive.The stabilization time is the fastest of this group, the overshoot is minimal, and the reference tracking is again flawless.For Test 5, the control equation includes a derivative term.However, it is the derivative of the time variable, which equals 1.Therefore, after simplifying the equation, we have a weighted integral structure again.The corresponding graph in Figure 3e reveals that this controller is the most accurate one.Its behavior has no overshoot, a fast stabilization time, and excellent reference tracking.The most challenging case within this group is Test 6, where the objective is to control a plant with an exaggerated gain.As described in Table 5, the best equation found by the program contains an exponential element and was discovered at generation 32.From its graphical behavior, depicted in Figure 3f, it can be observed that for a small reference variation the equation describes 10 oscillations before stabilizing.However, for medium and large signal variations these oscillations were drastically reduced.Given the program's ability to design controllers for plants with a large gain and RFS and the previous cases that used the full function set, it can be inferred that in this particular case 50 generations were insufficient evolution generations for the algorithm to discover and optimize the best individual.</p>
<p>To better understand the evolutionary path of Test 6, details are depicted in Table 6.As illustrated, throughout this process, the algorithm explored various mathematical operations, including exponential and trigonometric functions.Referring to Figure 4, it can be observed that after struggling to fully track the reference until generation 20, at generation 21 it successfully replicated the reference's pattern.Subsequently, the algorithm attempted to minimize the offset error by experimenting with oscillatory alternatives, ultimately reaching generation 32 and achieving precise signal tracking after a certain period.A summary of the best controllers in this group is described in Table 7.The columns, from left to right, contain (i) the plant's equation, (ii) the controller generated using the full function set, and (iii) the controller generated using the reduced function set (RFS).</p>
<p>A summary of the best controllers in this group is provided in Table 7.The columns, from left to right, include (i) the plant's equation, (ii) the controller generated using the full function set, and (iii) the controller generated using the reduced function set (RFS).</p>
<p>First-Order Unstable Systems</p>
<p>The plant functions used as targets for the genetic evolution are depicted in Equation (10).As can be seen, each test increases the plant's gain by a factor of 10.
H(s) = K 0.5s − 3 , K = {0.4, 4, 40}(10)
Similar to the previous group, the data corresponding to the best individuals are depicted in Table 8.This table follows the same structure as the previous group.When examining the results corresponding to Tests 7-11 in Table 8, it can be observed that all the individuals include an integral term.In the case of Test 7, the equation exhibits a PI structure, where the proportional term is based on the error, reference, and current state.As shown in Figure 5a, this combination results in fast tracking with a small overshoot peak relative to the reference variation.For Test 8, the table also describes a PI structure.However, this time, the proportional element is only based on the current state.Figure 5b illustrates that this equation generates the best tracking behavior among Group 2. It demonstrates a fast reaction time, minimal overshoot peak, and perfect reference tracking.Finally, for Test 9 the best controller takes the form of a weighted integral of the error.As depicted in Figure 5c, the program was able to find a constant that enables fast tracking with overshoot only for significant reference variations.Its is worth noting that, once again, when using the reduced function set (RFS), the algorithm identified the best individual's structure in early generations, leaving the rest of the evolution process to optimize the constants.When using all the operations from the function set, Test 10 shapes a PI structure.The most interesting part of this result is that, in this case, the algorithm includes the previous output value of the plant in the control equation.In Figure 5d it is shown that this structure presents fast action and overshoot peaks in response to large reference variations.The individual found for Test 11 also describes a PI structure, with a proportional part relying on the current state.By observing Figure 5e, it can be seen that the behavior of this equation closely resembles the previous test.However, once again, when dealing with the most challenging problem in this group, the program managed to discover an equation that replicates the reference's base outline but fails to eliminate the offset error, as seen in Figure 5f.In this case, the optimal controller includes derivative and exponential operations.To gain a deeper understanding of the evolutionary path of this test, refer to Table 9.</p>
<p>A deeper analysis of Test 12 reveals that throughout the evolutionary process the algorithm is not able to incorporate an integral operation.As seen in Figure 6, during its initial stages the algorithm experimented with equations involving trigonometric operations, with limited success.Once the evolution path got rid of them, it could be seen that the new equations have the ability to replicate the reference's outline.The last significant leap in this evolutionary path took place at generation 47, yet this structure still had the offset issue and a substantial overshoot prior to stabilization.Similar to the previous group, it can be inferred that once again the range of 50 generations was insufficient for the algorithm to discover a functional equation, given the complexity of the plant.The final equations of the second group of tests are summarized in Table 10 along with their respective plant equations.From the previous groups of tests, the results confirm that the proposed algorithm is capable of generating control equations for complex systems.Depending on the systems' complexity, an increased number of generations is needed to find a suitable solution.Furthermore, it is also proved that the program can address control problems related to first-order plants.</p>
<p>Second-Order Stable Systems</p>
<p>The plant functions used as targets for the genetic evolution are depicted in Equation (11).As observed, each subsequent test increases the plant's gain 10 times.
H(s) = K s 2 + 1.5s + 0.5 , K = {0.35, 3.5, 35}(11)
With the results obtained in the previous subsections, the only remaining statement that needs to be proven true is the one corresponding to "the algorithm can also handle second order equations".Therefore, in this case there is no need to increase the complexity of the second-order system to exaggerated levels.This group contains only plants with negative poles.However, systems with low, medium, and high gains are used to observe how the algorithm reacts.The results of the tests are described in Table 11.When checking the final equation of Test 13, it can be seen that the equation corresponds to a PI structure.It is worth noting that this equation was found in generation 30. Figure 7a depicts how the tracking action of the controller draws an overshoot peak during its operation.In the case of Test 14, the equation has the best performance of the group.It presents a PI structure where the proportional part is based on the current value of state 1. Figure 7b shows how the tracking action is fast but not aggressive, has no overshoot peak, and has minimal steady-state error.Finally, the equation of Test 15 describes a PI form.The proportional part is based on the error and both of the system's states, while its integral component is the result of a division of time by the weighted integral of the error with the addition of the system's state 1.In Figure 7c, it can be seen that this equation has the most aggressive behavior of the group.However, its overshoot peak is minimal.</p>
<p>After analyzing the results of this group, it is proven true that the proposed algorithm is capable of generating controllers for both first-order and second-order plants.This means that a GP-based controller designer has been successfully generated, and it has the ability to generate operational controllers even for complex plants.</p>
<p>Conclusions</p>
<p>This research work has successfully attained its primary objective of developing a genetic programming-based controller generator.The proposed system represents a noteworthy achievement, showcasing its ability to design effective control structures whose structures have tuned and optimized individual parameters, allowing for the regulation of first-order and second-order single-input single-output (SISO) plants.The comprehensive testing conducted throughout this study demonstrates that the genetic programming (GP)based approach holds promise in addressing complex control problems that often surpass the capabilities of traditional, human-driven methods.</p>
<p>One significant advantage of the proposed generator lies in its capacity to create control structures in the time domain.This design choice brings several benefits, including the direct incorporation of differential operators such as integrals and derivatives within the equation structure.Additionally, it eliminates the generation of control candidates that cannot be practically implemented in control devices due to challenges associated with inverse Laplace operations.The result is a streamlined process where every proposed controller can be seamlessly implemented in control devices without encountering coding complications.</p>
<p>The experiments conducted yielded compelling results, showcasing the algorithm's capability to produce optimal control structures.These structures not only meet key criteria, such as fast error reduction, rapid control action, minimal overshoot, null error tracking after a specified time, and a compact equation length, but also excel in fulfilling them.It is noteworthy that these successful outcomes extend across both first-and second-order plants, which are prevalent structures within industrial settings.</p>
<p>While specific examples, such as second-order oscillatory systems, integrating systems, and delayed systems, were not explicitly covered as test subjects, the results from our comprehensive testing reveal the controller designer's capability to handle a broader spectrum of complex and diverse plant types.The key point is that, given a sufficient number of generations to evolve, the controller designer exhibits adaptability and potential for dealing with various system complexities.</p>
<p>The conducted series of tests demonstrate that the controller generator possesses the inherent capability to fulfill its evolution objectives.This effectiveness is constrained only by the configuration of the genetic evolution process.A notable strength of employing GP for obtaining control equations is the inherent nature of the evolution methodology.Over successive generations, the GP approach naturally sifts through various function and variable combinations, allowing the most effective ones to prevail.This iterative process ensures that if the control problem's solution involves incorporating differential operations in the equation structure, the algorithm will eventually discover combinations that successfully address the problem.</p>
<p>In essence, the use of GP provides a dynamic and self-adapting framework.The evolutionary process enables the identification and selection of optimal functions and variables, making it a powerful tool for solving intricate control problems.When confronted with more complex plants, the challenge lies in determining the appropriate number of generations.This decision is crucial as it provides the designer with the necessary range to thoroughly explore and exploit potential solutions.In conclusion, the complexity in dealing with more intricate plants is tied to the right selection of the generation number, ensuring a robust exploration of the solution space.This approach allows the GP-based controller designer to navigate and conquer the challenges posed by diverse and complex plant dynamics.</p>
<p>It is important to recognize that the observed success in these initial behaviors serves as a foundation for future developments, particularly with higher-order plants.The scalability and adaptability of the proposed genetic programming-based controller generator open avenues for further exploration and application in more intricate control scenarios, such as nonlinear and multi-input multi-output (MIMO) systems and even distributed control.The potential for addressing higher-order plant complexities positions this research as a stepping stone toward advancements that could significantly impact the field of control systems.</p>
<p>Figure 1 .
1
Figure 1.Genetic tree structure in genetic programming.This is the tree representation of the equation (a + b) * (c − d).</p>
<p>Figure 2 .
2
Figure 2. Flow diagram of the final GP-based controller generator.</p>
<p>Figure 3 .
3
Figure 3. Graphical behavior of the best individuals resulting from the Group 1 test set.</p>
<p>1 4
1
8 inv(add(kexp(kcos(ksin(r0))), u0)) 1 9.18e 6.85 cos (7 sin (ref)) + u k−, kexp(inv(kexp(e0)))) 0.34 ε(t)dt e x(t) 5.50 × 10 5 (a) Generation 5 best individual (b) Generation 8 best individual (c) Generation 21 best individual (d) Generation 30 best individual (e) Generation 32 best individual</p>
<p>Figure 4 .
4
Figure 4. Test 3: Controller's evolution process for a first-order plant with a negative pole with a high gain, using all the available functions to generate equations.</p>
<p>Figure 5 .
5
Figure 5. Graphical behavior of the best individuals resulting from the Group 2 test set.</p>
<p>Figure 6 .
6
Figure 6.Test 9.Controller's evolution process for a first-order plant with a positive pole with a high gain, using all the available functions to generate equations.</p>
<p>Figure 7 .
7
Figure 7. Graphical behavior of the best individuals resulting from the Group 3 test set.</p>
<p>Table 1 .
1
Set-up of experimental conditions for the GP-based procedure.
Variable NameDescriptionmut_limsinitial, min, and max values for mutation probabilitycross_limsinitial, min, and max values for crossover probabilityhof_limsnumber of top individuals copied for the next generation4.1.3. Fitness Function</p>
<p>Table 3 .
3
Set-up for system's simulation, evolutionary procedure, and optimization.
Variable NameDescriptiondtstep size for system's simulationststop time for system's simulationrefssystem simulation's reference valuesmaxtolmax tolerance in optimization processmaxitermax number of iterations in optimization processind_numbernumber of individualsgen_numbermax number of generations</p>
<p>Table 4 .
4
Configuration parameters used in the test suite.
Variable NameValue_sstep0.3dt0.1st150refs[2, 5, 15]max_overshoot0.1stab_time10signal_slope10ind_number120gen_number50hof_lims1cross_lims(0.31, 0.69)mut_lims(0.35, 0.64)</p>
<p>Table 5 .
5
Group 1 list of best individuals of each test.
GenRaw ExpressionEquationJTest 113kinte(e0)2.78 ε(t)dt2.03 × 10 6Test 222kinte(e0)0.24 ε(t)dt2.20 × 10 6Test 327kinte(e0)0.06 ε(t)dt1.12 × 10 6Test 417add(</p>
<p>) + 2ref + 1.92 ε(t)dt 6.44 × 10 5
Test 549div(kinte(e0), add(x0, add(y0, kderi(t))))0.15 ε(t)dt dt (t) d2.19 × 10 6Test 632div(e0, kexp(inv(kexp(e0))))0.34 ε(t)dt5.50 × 10 7e x(t)</p>
<p>Table 6 .
6
Tests 6 evolution process.First-order plant, negative pole, high gain, and RFS.
Gen Raw ExpressionEquationJ5div(inv(kexp(div(r0, r0))), kexp(x0))0.18 e 1+x(t)2.03 × 10 8</p>
<p>Table 7 .
7
Summing-up of the best controller for a first-order plant with a negative pole using the total (middle column) or the reduced (right column) function set.
PlantControllerControllerH(s) =0.4 0.5s + 1ref + 3ε(t) + 1.92 ε(t)dt2.78 ε(t)dtH(s) =4 0.5s + 10.15 ε(t)dt0.24 ε(t)dtH(s) =40 0.5s + 10.34e −x(t) ε(t)dt0.06 ε(t)dt</p>
<p>Table 8 .
8
Group 2 list of best individuals of each test.
GenRaw ExpressionEquationJTest 713sub(div(sub(e0, kderi(x0)), kexp(x0)), x0)ref x(t)+ ε(t) + ref − x(t) + 2.22 ε(t)dt3.38 × 10 7Test 818sub(kinte(e0), x0)0.11 ε(t)dt − x(t)2.70 × 10 6Test 930sub(kinte(e0), add(x0, x0))0.47 ε(t)dt2.92 × 10 5Test 1050sub(sub(kinte(e0), x0), add(y0, div(x0, r0)))7.35 ε(t)dt − y k−1 − x(t) + x(t) ref6.20 × 10 5Test 1138sub(sub(kinte(e0), x0), x0)4.35 ε(t)dt − 2x(t)1.98 × 10 5Test 1247sub(div(sub(e0, kderi(x0)), kexp(x0)), x0)ε(t) − 0.91 d dt x(t) 3.67 • e x(t)− x(t)3.38 × 10 6</p>
<p>Table 9 .
9
Test 12 evolution process.First-order plant, positive pole, high gain, and full function set.
Gen Raw ExpressionEquationJ5sub(kcos(y0), x0)1.02 cos (y k−1 ) − x(t)4.26 × 10 913sub(kcos(kcos(x0)), x0)1.13 cos (1.59 cos (x(t))) − x(t)3.47 × 10 818 30 34 47sub(div(sub(r0, x0), kexp(x0)), x0) sub(div(sub(r0, sub(inv(t), e0)), kexp(x0)), x0) sub(div(sub(e0, x0), kexp(x0)), x0) sub(div(sub(e0, kderi(x0)), kexp(x0)), x0)ref − x(t) 14.54e x(t) − x(t) ref − 1/t − ε(t) − x(t) 15.72e x(t) ε(t) − x(t) 11.06e x(t) − x(t) ε(t) − 0.91 d dt x(t) 3.67 • e x(t) − x(t)9.01 × 10 7 2.29 × 10 7 5.01 × 10 6 3.38 × 10 6</p>
<p>Table 10 .
10
Summing-up of the best controller for a first-order plant with a positive pole using the total (middle column) or the reduced (right column) function set.
PlantControllerControllerH(s) =0.4 0.5s − 3longlongH(s) =4 0.5s − 34.35 ε(t)dt − 2x(t)0.11 ε(t)dt − x(t)H(s) =40 0.5s − 3long0.47 ε(t)dt</p>
<p>Table 11 .
11
Group 3 list of best individuals of each test.Test 14 37 sub(kinte(e0), x0) 16.58 ε(t)dt − x 1 (t) 2.57 × 10 6 Test 15 45 sub(add(add(e0, x1), div(t, add(kinte(x1), x0))), x0) ε(t) + x 2 (t) − x 1 (t) + t 1.25 ε(t)dt + x 1 (t) 8.28 × 10 5
GenRaw ExpressionEquationJTest 1330add(kinte(e0), e0)ε(t) + 0.75 ε(t)dt3.09 × 10 6
Acknowledgments:The authors would like to thank Davood Naderi and Jerrad Hampton from Siemens Energy for their support and assistance during the elaboration of this analysis.Conflicts of Interest:The funders had no role in the design of the study; in the collection, analyses, or interpretation of data; in the writing of the manuscript; or in the decision to publish the results.Data Availability Statement: Data are contained within the article.Funding: This research was funded by Siemens Energy under the project C-11193.Institutional Review Board Statement: Not applicable.Informed Consent Statement: Not applicable.AbbreviationsThe following abbreviations are used in this manuscript:AIArtificial Intelligence GP Genetic Programming GA Genetic Algorithm PN Petri Net ML Machine Learning SL Supervised Learning RL Reinforcement Learning
S Bennett, Number 47 in Control, Robotics and Sensors; IET: Stevenage. UK1930-1955. 1993</p>
<p>A brief history of automatic control. S Bennett, IEEE Control Syst. Mag. 161996</p>
<p>Control Systems Engineering. N S Nise, 2006John Wiley &amp; Sons, IncHoboken, NJ, USA</p>
<p>The Control Systems Handbook. W S Levine, Second Edition: Control System Advanced Methods. Boca Raton, FL, USACRC Press, Inc20092nd ed.</p>
<p>Applications of A.I. in control systems. G Nagaraja, 10.1109/ACE.1990.762649Proceedings of the ACE '90. Proceedings of [XVI Annual Convention and Exhibition of the IEEE In India. the ACE '90. [XVI Annual Convention and Exhibition of the IEEE In IndiaBangalore, IndiaJanuary 1991</p>
<p>AI in control Systems engineering. D A Linkens, 10.1017/S0269888900005403Knowl. Eng. Rev. 51990</p>
<p>AI for Closed-Loop Control Systems: New Opportunities for Modeling, Designing, and Tuning Control Systems. J Schöning, A Riechmann, H J Pfisterer, 10.1145/3529836.3529952Proceedings of the 2022 14th International Conference on Machine Learning and Computing, ICMLC' 22. the 2022 14th International Conference on Machine Learning and Computing, ICMLC' 22Guangzhou, ChinaFebruary 2022</p>
<p>AI-based modeling and data-driven evaluation for smart manufacturing processes. M Ghahramani, Y Qiao, M C Zhou, A O'hagan, J Sweeney, 10.1109/JAS.2020.1003114IEEE/CAA J. Autom. Sin. 72020</p>
<p>Evolution from AI, IoT and Big Data Analytics to Metaverse. M Zhou, 10.1109/JAS.2022.106100IEEE/CAA J. Autom. Sin. 92022</p>
<p>Informatics and artificial intelligence at MPEI: Pages of history. I Ladygin, A Poliakov, 10.1109/SORUCOM51654.2020.9464975Proceedings of the 2020 Fifth International Conference "History of Computing in the Russia, Former Soviet Union and Council for Mutual Economic Assistance Countries" (SORUCOM). the 2020 Fifth International Conference "History of Computing in the Russia, Former Soviet Union and Council for Mutual Economic Assistance Countries" (SORUCOM)Moscow, Russia6-7 October 2020</p>
<p>From Artificial Intelligence to Augmented Age An Overview. D Lukac, M Milic, J Nikolic, 10.1109/ZINC.2018.8448793Proceedings of the 2018 Zooming Innovation in Consumer Technologies Conference (ZINC). the 2018 Zooming Innovation in Consumer Technologies Conference (ZINC)Novi Sad, SerbiaMay 2018</p>
<p>. K J Åström, T Mcavoy, 10.1016/0959-1524(92)85001-DJ. Intelligent control. J. Process Control. 21992</p>
<p>Artificial intelligence and concept of step wise fault detection. V Prasad, 10.1109/MWSCAS.1990.140940Proceedings of the 33rd Midwest Symposium on Circuits and Systems. the 33rd Midwest Symposium on Circuits and SystemsCalgary, AB, CanadaAugust 19902</p>
<p>Application of artificial intelligence in fault detection of mechanical equipment. Q Tingting, 10.1109/ICMCCE51767.2020.00303Proceedings of the 2020 5th International Conference on Mechanical, Control and Computer Engineering (ICMCCE). the 2020 5th International Conference on Mechanical, Control and Computer Engineering (ICMCCE)Harbin, ChinaDecember 2020</p>
<p>Artificial intelligence and magnetic field based fault detection system for microgrid. A Kumar, P Kumar, P Gadekar, A Jain, S Jaiswal, C Khadse, 10.1109/MysuruCon52639.2021.9641536Proceedings of the 2021 IEEE Mysore Sub Section International Conference (MysuruCon). the 2021 IEEE Mysore Sub Section International Conference (MysuruCon)Hassan, IndiaOctober 2021</p>
<p>Asynchronous motors fault detection using ANN and fuzzy logic methods. N Lashkari, H F Azgomi, J Poshtan, M Poshtan, 10.1109/ECCE.2016.7854890Proceedings of the 2016 IEEE Energy Conversion Congress and Exposition (ECCE). the 2016 IEEE Energy Conversion Congress and Exposition (ECCE)Milwaukee, WI, USA18-22 September 2016</p>
<p>Genetic programming tuned fuzzy controlled traffic light system. T Padmasiri, D Ranasinghe, 10.1109/ICTER.2014.7083885Proceedings of the 2014 14th International Conference on Advances in ICT for Emerging Regions (ICTer). the 2014 14th International Conference on Advances in ICT for Emerging Regions (ICTer)Colombo, Sri Lanka10-13 December 2014</p>
<p>On-line Reinforcement Learning Control for Urban Traffic Signals. L Zhi-Yong, M Feng-Wei, 10.1109/CHICC.2006.4347023Proceedings of the 2007 Chinese Control Conference. the 2007 Chinese Control ConferenceZhangjiajie, ChinaJuly 2007</p>
<p>Continuous-Time Reinforcement Learning for Force Control. W Yu, A Perrusquia, 10.1002/9781119782773.ch7Human-Robot Interaction Control Using Reinforcement Learning. Hoboken, NJ, USAJohn Wiley &amp; Sons2022</p>
<p>A New Tracking Control Algorithm for a Wheeled Mobile Robot Based on Backstepping and Hierarchical Sliding Mode Techniques. P T H Sen, N Q Minh, D T T Anh, D T T Anh, P X Minh, Proceedings of the 2019 First International Symposium on Instrumentation, Control, Artificial Intelligence, and Robotics (ICA-SYMP). the 2019 First International Symposium on Instrumentation, Control, Artificial Intelligence, and Robotics (ICA-SYMP)Bangkok, Thailand18 January 2019</p>
<p>BEAGLE-A Darwinian approach to pattern recognition. R Forsyth, 10.1108/eb005587198110</p>
<p>Computing Machinery and Intelligence. A M Turing, Creat. Comput. 61980</p>
<p>Genetic algorithms for process control: A survey. J M Renders, J P Nordvik, H Bersini, Artificial Intelligence in Real-Time Control. 1992. 1993Elsevier</p>
<p>Genetic algorithms in control systems engineering. P J Fleming, C M Fonseca, 10.1016/S1474-6670(17)49015-XIFAC Proc. 1993</p>
<p>Genetic programming for prediction and control. D C Dracopoulos, S Kent, 10.1007/BF01501508Neural Comput. Appl. 61997</p>
<p>Genetic Algorithms and Genetic Programming. D C Dracopoulos, Evolutionary Algorithms in Engineering Applications. Germany2013329Springer Science &amp; Business Media: Berlin/Heidelberg</p>
<p>Adaptation in Natural and Artificial Systems. J H Holland, 1976MIT PressCambridge, MA, USA</p>
<p>Genetic Programming: A Paradigm for Genetically Breeding Populations of Computer Programs to Solve Problems. J R Koza, 199034Stanford, CA, USAStanford University, Department of Computer Science</p>
<p>Genetic Programming, on the Programming of Computers by Means of Natural Selection. A Bradford Book. J R Koza, 1992MIT PressCambridge, MA, USA</p>
<p>Towards Intelligent Control via Genetic Programming. F Marchetti, E Minisci, A Riccardi, 10.1109/IJCNN48605.2020.9207694Proceedings of the 2020 International Joint Conference on Neural Networks (IJCNN). the 2020 International Joint Conference on Neural Networks (IJCNN)Glasgow, UK19-24 July 2020</p>
<p>Hybrid genetic algorithm and application to PID controllers. L Xiao, C Han, X Xu, W Huang, 10.1109/CCDC.2010.5498979Proceedings of the 2010 Chinese Control and Decision Conference. the 2010 Chinese Control and Decision ConferenceXuzhou, ChinaMay 2010</p>
<p>Cooperative Robot Swarm Locomotion Using Genetic Algorithms. M D Byington, B E Bishop, Proceedings of the 2008 40th Southeastern Symposium on System Theory (SSST). the 2008 40th Southeastern Symposium on System Theory (SSST)New Orleans, LA, USAMarch 2008</p>
<p>Genetic Programming -based Controller Design. I Sekaj, J Perkacz, 10.1109/CEC.2007.4424626Proceedings of the 2007 IEEE Congress on Evolutionary Computation. the 2007 IEEE Congress on Evolutionary ComputationSingaporeSeptember 2007</p>
<p>Genetic breeding of non-linear optimal control strategies for broom balancing. J R Koza, M A Keane, Analysis and Optimization of Systes. J L , Bensoussan, A., Lions; Berlin/Heidelberg, GermanySpringer1990</p>
<p>Application of genetic programming to control of vehicle systems. K Marko, R Hampo, 10.1109/IVS.1992.252255Proceedings of the Intelligent Vehicles' 92 Symposium. the Intelligent Vehicles' 92 SymposiumDetroit, MI, USA29 June-1 July 1992</p>
<p>Genetic Programming A New Paradigm for Control And Analysis. R J Hampo, Proceedings of the 3rd ASME Symposium on Transportation Systems. the 3rd ASME Symposium on Transportation SystemsAnaheim, CA, USANovember 199244</p>
<p>The genetic planner: The automatic generation of plans for a mobile robot via genetic programming. S Handley, 10.1109/ISIC.1993.397715Proceedings of the 8th IEEE International Symposium on Intelligent Control. the 8th IEEE International Symposium on Intelligent ControlChicago, IL, USAAugust 1993</p>
<p>Genetic programming for articulated figure motion. L Gritz, J K Hahn, 10.1002/vis.4340060303J. Vis. Comput. Animat. 61995</p>
<p>Genetic Programming Controlling a Miniature Robot. P Nordin, W Banzhaf, Proceedings of the Working Notes of the AAAI-95 Fall Symposium Series. Symposium of Genetic Programming. the Working Notes of the AAAI-95 Fall Symposium Series. Symposium of Genetic ProgrammingCambridge, MA, USANovember 1995</p>
<p>Genetic Programming for Generalised Helicopter Hovering Control. D C Dracopoulos, D Effraimidis, Genetic Programming. </p>
<p>. D Hutchison, T Kanade, J Kittler, J M Kleinberg, F Mattern, J C Mitchell, M Naor, O Nierstrasz, C Pandu Rangan, B Steffen, 10.1007/978-3-642-29139-5_32012Springer7244Berlin/Heidelberg, Germany</p>
<p>Automated synthesis of optimal controller using multi-objective genetic programming for two-mass-spring system. I Gholaminezhad, A Jamali, H Assimi, 10.1109/ICRoM.2014.6990874Proceedings of the 2014 Second RSI/ISM International Conference on Robotics and Mechatronics (ICRoM). the 2014 Second RSI/ISM International Conference on Robotics and Mechatronics (ICRoM)Tehran, IranOctober 2014</p>
<p>Artificial intelligence control of a turbulent jet. Y Zhou, D Fan, B Zhang, R Li, B R Noack, 10.1017/jfm.2020.392J. Fluid Mech. 8972020A27. [CrossRef</p>
<p>Genetic Programming Guidance Control System for a Reentry Vehicle under. F Marchetti, E Minisci, 10.3390/math9161868Uncertainties. Mathematics. 92021. 1868</p>
<p>Genetic programming for the minimum time swing up and balance control acrobot problem. Expert Syst. D C Dracopoulos, B D Nichols, 10.1111/exsy.121152017. e1211534</p>
<p>Evolving controllers for high-level applications on a service robot: A case study with exhibition visitor flow control. A Fukunaga, H Hiruma, K Komiya, H Iba, 10.1007/s10710-011-9152-3Genet. Program. Evolvable Mach. 132012</p>
<p>The archived-based genetic programming for optimal design of linear/non-linear controllers. A Mohammadi, N Nariman-Zadeh, A Jamali, 10.1177/0142331219891551Trans. Inst. Meas. Control. 422020</p>
<p>Linear genetic programming control for strongly nonlinear dynamics with frequency crosstalk. R Li, B R Noack, L Cordier, J Borée, E Kaiser, F Harambat, arXiv:1705.003672017</p>
<p>An Enhanced Genetic Programming Algorithm for Optimal Controller Design. R A Maher, M J Mohamed, 10.4236/ica.2013.41013Intell. Control Autom. 42013</p>
<p>Automatic Creation of Human-Competitive Programs and Controllers by Means of Genetic Programming. J R Koza, M A Keane, J Yu, F H Bennett, W Mydlowec, 10.1023/A:1010076532029Genet. Program. Evolvable Mach. 12000</p>
<p>Automatic design of both topology and tuning of a common parameterized controller for two families of plants using genetic programming. Y Jessen, M Keane, J Koza, 10.1109/CACSD.2000.900217Proceedings of the CACSD. Conference Proceedings. IEEE International Symposium on Computer-Aided Control System Design. the CACSD. Conference Proceedings. IEEE International Symposium on Computer-Aided Control System DesignAnchorage, AK, USASeptember 2000Cat. No. 00TH8537</p>
<p>PID Controllers: Theory, Design, and Tuning; ISA-The Instrumentation, Systems and Automation Society. K Åström, T Hägglund, 1995Pittsburgh, PA, USA</p>
<p>Design of a Discrete Deadbeat Controller Based on Block Diagram Oriented Genetic Programming. R A Maher, M J Mohamed, 10.1109/MCSI.2015.27Proceedings of the 2015 Second International Conference on Mathematics and Computers in Sciences and in Industry (MCSI). the 2015 Second International Conference on Mathematics and Computers in Sciences and in Industry (MCSI)Sliema, Malta17 August 2015</p>
<p>R Vilanova, A Visioli, PID Control in the Third Millennium: Lessons Learned and New Approaches; Advances in Industrial Control. London, UKSpringer2012</p>
<p>Globalized Nelder-Mead method for engineering optimization. M A Luersen, R Le Riche, Comput. Struct. 822004</p>
<p>DEAP: Evolutionary algorithms made easy. F A Fortin, F M De Rainville, M A G Gardner, M Parizeau, C Gagné, J. Mach. Learn. Res. 132012</p>
<p>Disclaimer/Publisher's Note: The statements, opinions and data contained in all publications are solely those of the individual author(s) and contributor(s) and not of MDPI and/or the editor(s). MDPI and/or the editor(s) disclaim responsibility for any injury to people or property resulting from any ideas, methods. instructions or products referred to in the content</p>            </div>
        </div>

    </div>
</body>
</html>