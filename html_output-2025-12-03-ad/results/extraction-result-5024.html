<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-5024 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-5024</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-5024</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-106.html">extraction-schema-106</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models (LLMs or neural language models) being used to solve puzzle games that require spatial knowledge (such as Sudoku or other spatial reasoning tasks). Include details about the models, the puzzles, the mechanisms or strategies used, performance metrics, evidence of spatial reasoning, limitations, and comparisons.</div>
                <p><strong>Paper ID:</strong> paper-ee9aae0190c3ff177e7d1c9cdc977ce7d971bcc1</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/ee9aae0190c3ff177e7d1c9cdc977ce7d971bcc1" target="_blank">Input Convex Neural Networks</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Machine Learning</p>
                <p><strong>Paper TL;DR:</strong> This paper presents the input convex neural network architecture, which are scalar-valued (potentially deep) neural networks with constraints on the network parameters such that the output of the network is a convex function of (some of) the inputs.</p>
                <p><strong>Paper Abstract:</strong> This paper presents the input convex neural network architecture. These are scalar-valued (potentially deep) neural networks with constraints on the network parameters such that the output of the network is a convex function of (some of) the inputs. The networks allow for efficient inference via optimization over some inputs to the network given others, and can be applied to settings including structured prediction, data imputation, reinforcement learning, and others. In this paper we lay the basic groundwork for these models, proposing methods for inference, optimization and learning, and analyze their representational power. We show that many existing neural network architectures can be made input-convex with a minor modification, and develop specialized optimization algorithms tailored to this setting. Finally, we highlight the performance of the methods on multi-label prediction, image completion, and reinforcement learning problems, where we show improvement over the existing state of the art in many cases.</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-5024",
    "paper_id": "paper-ee9aae0190c3ff177e7d1c9cdc977ce7d971bcc1",
    "extraction_schema_id": "extraction-schema-106",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00523725,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Input Convex Neural Networks</h1>
<p>Brandon Amos ${ }^{1}$ Lei Xu ${ }^{2 *}$ J. Zico Kolter ${ }^{1}$</p>
<h4>Abstract</h4>
<p>This paper presents the input convex neural network architecture. These are scalar-valued (potentially deep) neural networks with constraints on the network parameters such that the output of the network is a convex function of (some of) the inputs. The networks allow for efficient inference via optimization over some inputs to the network given others, and can be applied to settings including structured prediction, data imputation, reinforcement learning, and others. In this paper we lay the basic groundwork for these models, proposing methods for inference, optimization and learning, and analyze their representational power. We show that many existing neural network architectures can be made inputconvex with a minor modification, and develop specialized optimization algorithms tailored to this setting. Finally, we highlight the performance of the methods on multi-label prediction, image completion, and reinforcement learning problems, where we show improvement over the existing state of the art in many cases.</p>
<h2>1. Introduction</h2>
<p>In this paper, we propose a new neural network architecture that we call the input convex neural network (ICNN).These are scalar-valued neural networks $f(x, y ; \theta)$ where $x$ and $y$ denotes inputs to the function and $\theta$ denotes the parameters, built in such a way that the network is convex in (a subset of) inputs $y .{ }^{3}$ The fundamental benefit to these ICNNs is that we can optimize over the convex inputs to the network given some fixed value for other inputs. That is, given some fixed $x$ (and possibly some fixed elements of</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>$y$ ) we can globally and efficiently (because the problem is convex) solve the optimization problem</p>
<p>$$
\underset{y}{\operatorname{argmin}} f(x, y ; \theta)
$$</p>
<p>Fundamentally, this formalism lets us perform inference in the network via optimization. That is, instead of making predictions in a neural network via a purely feedforward process, we can make predictions by optimizing a scalar function (which effectively plays the role of an energy function) over some inputs to the function given others. There are a number of potential use cases for these networks.</p>
<p>Structured prediction As is perhaps apparent from our notation above, a key application of this work is in structured prediction. Given (typically high-dimensional) structured input and output spaces $\mathcal{X} \times \mathcal{Y}$, we can build a network over $(x, y)$ pairs that encodes the energy function for this pair, following typical energy-based learning formalisms (LeCun et al., 2006). Prediction involves finding the $y \in \mathcal{Y}$ that minimizes the energy for a given $x$, which is exactly the argmin problem in (1). In our setting, assuming that $\mathcal{Y}$ is a convex space (a common assumption in structured prediction), this optimization problem is convex. This is similar in nature to the structured prediction energy networks (SPENs) (Belanger \&amp; McCallum, 2016), which also use deep networks over the input and output spaces, with the difference being that in our setting $f$ is convex in $y$, so the optimization can be performed globally.</p>
<p>Data imputation Similar to structured prediction but slightly more generic, if we are given some space $\mathcal{Y}$ we can learn a network $f(y ; \theta)$ (removing the additional $x$ inputs, though these can be added as well) that, given an example with some subset $\mathcal{I}$ missing, imputes the likely values of these variables by solving the optimization problem as above $\hat{y}<em y__mathcal_I="y_{\mathcal{I">{\mathcal{I}}=\operatorname{argmin}</em> ; \theta\right)$ This could be used}}} f\left(y_{\mathcal{I}}, y_{\mathcal{I}</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>e.g., in image inpainting where the goal is to fill in some arbitrary set of missing pixels given observed ones.</p>
<p>Continuous action reinforcement learning Given a reinforcement learning problem with potentially continuous state and action spaces $\mathcal{S} \times \mathcal{A}$, we can model the (negative) $Q$ function, $-Q(s, a ; \theta)$ as an input convex neural network. In this case the action selection procedure can be formulated as a convex optimization problem $a^{*}(s)=$ $\operatorname{argmin}_{a}-Q(s, a ; \theta)$.</p>
<p>This paper lays the foundation for optimization, inference, and learning in these input convex models, and explores their performance in the applications above. Our main contributions are: we propose the ICNN architecture and a partially convex variant; we develop efficient optimization and inference procedures that are well-suited to the complexity of these specific models; we propose techniques for training these models, based upon either max-margin structured prediction or direct differentiation of the argmin operation; and we evaluate the system on multi-label prediction, image completion, and reinforcement learning domains; in many of these settings we show performance that improves upon the state of the art.</p>
<h2>2. Background and related work</h2>
<p>Energy-based learning The interplay between inference, optimization, and structured prediction has a long history in neural networks. Several early incarnations of neural networks were explicitly trained to produce structured sequences (e.g. (Simard \&amp; LeCun, 1991)), and there was an early appreciation that structured models like hidden Markov models could be combined with the outputs of neural networks (Bengio et al., 1994). Much of this earlier work is surveyed and synthesized by (LeCun et al., 2006), who give a tutorial on these energy based learning methods. In recent years, there has been a strong push to further incorporate structured prediction methods like conditional random fields as the "last layer" of a deep network architecture (Peng et al., 2009; Zheng et al., 2015; Chen et al., 2015). Several methods have proposed to build general neural networks over joint input and output spaces, and perform inference over outputs using generic optimization techniques such as Generative Adversarial Networks (GANs) (Goodfellow et al., 2014) and Structured Prediction Energy Networks (SPENs) (Belanger \&amp; McCallum, 2016). SPENs provide a deep structure over input and output spaces that performs the inference in (1) as a nonconvex optimization problem.</p>
<p>The current work is highly related to these past approaches, but also differs in a very particular way. To the best of our knowledge, each of these structured prediction methods based upon energy-based models operates in one of two
ways, either: 1) the architecture is built in a very particular way such that optimization over the output is guaranteed to be "easy" (e.g. convex, or the result of running some inference procedure), usually by introducing a structured linear objective at the last layer of the network; or 2) no attempt is made to make the architecture "easy" to run inference over, and instead a general model is built over the output space. In contrast, our approach lies somewhere in between: by ensuring convexity of the resulting decision space, we are constraining the inference problem to be easy in some respect, but we specify very little about the architecture other than the constraints required to make it convex. In particular, as we will show, the network architecture over the variables to be optimized over can be deep and involve multiple non-linearities. The goal of the proposed work is to allow for complex functions over the output without needing to specify them manually (exactly analogous to how current deep neural networks treat their input space).</p>
<p>Structured prediction and MAP inference Our work also draws some connection to MAP-inference-based learning and approximate inference. There are two broad classes of learning approaches in structured prediction: method that use probabilistic inference techniques (typically exploiting the fact that the gradient of log likelihood is given by the actual feature expectations minus their expectation under the learned model (Koller \&amp; Friedman, 2009, Ch 20)), and methods that rely solely upon MAP inference (such as max-margin structured prediction (Taskar et al., 2005; Tsochantaridis et al., 2005)). MAP inference in particular also has close connections to optimization, as various convex relaxations of the general MAP inference problem often perform well in theory and practice. The proposed methods can be viewed as an extreme case of this second class of algorithm, where inference is based solely upon a convex optimization problem that may not have any probabilistic semantics at all. Finally, although it is more abstract, we feel there is a philosophical similarity between our proposed approach and sum-product networks (Poon \&amp; Domingos, 2011); both settings define networks where inference is accomplished "easily" either by a sum-product message passing algorithm (by construction) or via convex optimization.</p>
<p>Fitting convex functions Finally, the proposed work relates to a topic less considered in the machine learning literature, that of fitting convex functions to data (Boyd \&amp; Vandenberghe, 2004, pg. 338). Indeed our learning problem can be viewed as parameter estimation under a model that is guaranteed to be convex by its construction. The most similar work of which we are aware specifically fits sums of rectified half-planes to data (Magnani \&amp; Boyd, 2009), which is similar to one layer of our rectified linear units. However, the actual training scheme is much differ-</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1. A fully input convex neural network (FICNN).
ent, and our deep network architecture allows for a much richer class of representations, while still maintaining convexity.</p>
<h2>3. Convex neural network architectures</h2>
<p>Here we more formally present different ICNN architectures and prove their convexity properties given certain constraints on the parameter space. Our chief claim is that the class of (full and partial) input convex models is rich and lets us capture complex joint models over the input to a network.</p>
<h3>3.1. Fully input convex neural networks</h3>
<p>To begin, we consider a fully convex, $k$-layer, fully connected ICNN that we call a FICNN and is shown in Figure 1. This model defines a neural network over the input $y$ (i.e., omitting any $x$ term in this function) using the architecture for $i=0, \ldots, k-1$</p>
<p>$$
z_{i+1}=g_{i}\left(W_{i}^{(z)} z_{i}+W_{i}^{(y)} y+b_{i}\right), \quad f(y ; \theta)=z_{k}
$$</p>
<p>where $z_{i}$ denotes the layer activations (with $z_{0}, W_{0}^{(z)} \equiv 0$ ), $\theta=\left{W_{0: k-1}^{(y)}, W_{1: k-1}^{(z)}, b_{0: k-1}\right}$ are the parameters, and $g_{i}$ are non-linear activation functions. The central result on convexity of the network is the following:
Proposition 1. The function $f$ is convex in $y$ provided that all $W_{1: k-1}^{(z)}$ are non-negative, and all functions $g_{i}$ are convex and non-decreasing.</p>
<p>The proof is simple and follows from the fact that nonnegative sums of convex functions are also convex and that the composition of a convex and convex non-decreasing function is also convex (see e.g. Boyd \&amp; Vandenberghe (2004, 3.2.4)). The constraint that the $g_{i}$ be convex nondecreasing is not particularly restrictive, as current nonlinear activation units like the rectified linear unit or maxpooling unit already satisfy this constraint. The constraint that the $W^{(z)}$ terms be non-negative is somewhat restrictive, but because the bias terms and $W^{(y)}$ terms can be negative, the network still has substantial representation power, as we will shortly demonstrate empirically.</p>
<p>One notable addition in the ICNN are the "passthrough" layers that directly connect the input $y$ to hidden units in
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2. A partially input convex neural network (PICNN).
deeper layers. Such layers are unnecessary in traditional feedforward networks because previous hidden units can always be mapped to subsequent hidden units with the identity mapping; however, for ICNNs, the non-negativity constraint subsequent $W^{(z)}$ weights restricts the allowable use of hidden units that mirror the identity mapping, and so we explicitly include this additional passthrough. Some passthrough layers have been recently explored in the deep residual networks (He et al., 2015) and densely connected convolutional networks (Huang et al., 2016), though these differ from those of an ICNN as they pass through hidden layers deeper in the network, whereas to maintain convexity our passthrough layers can only apply to the input directly.</p>
<p>Other linear operators like convolutions can be included in ICNNs without changing the convexity properties. Indeed, modern feedforward architectures such as AlexNet (Krizhevsky et al., 2012), VGG (Simonyan \&amp; Zisserman, 2014), and GoogLeNet (Szegedy et al., 2015) with ReLUs (Nair \&amp; Hinton, 2010) can be made input convex with Proposition 1. In the experiment that follow, we will explore ICNNs with both fully connected and convolutional layers, and we provide more detail about these additional architectures in Section A of the supplement.</p>
<h3>3.2. Partially input convex architectures</h3>
<p>The FICNN provides joint convexity over the entire input to the function, which indeed may be a restriction on the allowable class of models. Furthermore, this full joint convexity is unnecessary in settings like structured prediction where the neural network is used to build a joint model over an input and output example space and only convexity over the outputs is necessary.</p>
<p>In this section we propose an extension to the pure FICNN, the partially input convex neural network (PICNN), that is convex over only some inputs to the network (in general ICNNs will refer to this new class). As we will show, these networks generalize both traditional feedforward networks and FICNNs, and thus provide substantial representational benefits. We define a PICNN to be a network over $(x, y)$ pairs $f(x, y ; \theta)$ where $f$ is convex in $y$ but not convex in $x$. Figure 2 illustrates one potential $k$-layer PICNN architec-</p>
<p>ture defined by the recurrences</p>
<p>$$
\begin{aligned}
u_{i+1} &amp; =\tilde{g}<em i="i">{i}\left(\tilde{W}</em>} u_{i}+\tilde{b<em i_1="i+1">{i}\right) \
z</em>\right]} &amp; =g_{i}\left(W_{i}^{(z)}\left(z_{i} \circ\left[W_{i}^{(z u)} u_{i}+b_{i}^{(z)<em i="i">{+}\right)+\right. \
&amp; \left.W</em>\right) \
f(x, y ; \theta) &amp; =z_{k}, u_{0}=x
\end{aligned}
$$}^{(y)}\left(y \circ\left(W_{i}^{(y u)} u_{i}+b_{i}^{(y)}\right)\right)+W_{i}^{(u)} u_{i}+b_{i</p>
<p>where $u_{i} \in \mathbb{R}^{n_{i}}$ and $z_{i} \in \mathbb{R}^{m_{i}}$ denote the hidden units for the " $x$-path" and " $y$-path", where $y \in \mathbb{R}^{p}$, and where o denotes the Hadamard product, the elementwise product between two vectors. The crucial element here is that unlike the FICNN, we only need the $W^{(z)}$ terms to be nonnegative, and we can introduce arbitrary products between the $u_{i}$ hidden units and the $z_{i}$ hidden units. The following proposition highlights the representational power of the PICNN.</p>
<p>Proposition 2. A PICNN network with $k$ layers can represent any FICNN with $k$ layers and any purely feedforward network with $k$ layers.</p>
<p>Proof. To recover a FICNN we simply set the weights over the entire $x$ path to be zero and set $b^{(z)}=b^{(y)}=1$. We can recover a feedforward network by noting that a traditional feedforward network $\tilde{f}(x ; \theta)$ where $f: \mathcal{X} \rightarrow \mathcal{Y}$, can be viewed as a network with an inner product $f(x ; \theta)^{T} y$ in its last layer (see e.g. (LeCun et al., 2006) for more details). Thus, a feedforward network can be represented as a PICNN by setting the $x$ path to be exactly the feedforward component, then having the $y$ path be all zero except $W_{k-1}^{(y u)}=I$ and $W_{k-1}^{(y)}=1^{T}$.</p>
<h2>4. Inference in ICNNs</h2>
<p>Prediction in ICNNs (which we also refer to as inference), requires solving the convex optimization problem</p>
<p>$$
\underset{y \in \mathcal{Y}}{\operatorname{minimize}} f(x, y ; \theta)
$$</p>
<p>While the resulting tasks are convex optimization problems (and thus "easy" to solve in some sense), in practice this still involves the solution of a potentially very complex optimization problem. We discuss here several approaches for approximately solving these optimization problems. We can usually obtain reasonably accurate solutions in many settings using a procedure that only involves a small number of forward and backward passes through the network, and which thus has a complexity that is at most a constant factor worse than that for feedforward networks. The same consideration will apply to training such networks, which we will discuss in Section 5.</p>
<p>Exact inference in ICNNs Although it is not a practical approach for solving the optimization tasks, the inference problem for the networks presented above (where the nonlinear are either ReLU or linear units) can be posed as as linear program. We show how to do this in Section B.</p>
<h3>4.1. Approximate inference in ICNNs</h3>
<p>Because of the impracticality of exact inference, we focus on approximate approaches to optimizing over the inputs to these networks, but ideally ones that still exploit the convexity of the resulting problem. We specifically focus on gradient-based approaches, which use the fact that we can easily compute the gradient of an ICNN with respect to its inputs, $\nabla_{y} f(x, y ; \theta)$, using backpropagation.</p>
<p>Gradient descent. The simplest gradient-based methods for solving (4) is just (projected sub-) gradient descent, or modifications such as those that use a momentum term (Polyak, 1964; Rumelhart et al., 1988), or spectral step size modifications (Barzilai \&amp; Borwein, 1988; Birgin et al., 2000). That is, we start with some initial $\hat{y}$ and repeat the update</p>
<p>$$
\hat{y} \leftarrow \mathcal{P}<em y="y">{\mathcal{Y}}\left(\hat{y}-\alpha \nabla</em> ; \theta)\right)
$$} f(x, \hat{y</p>
<p>This method is appealing in its simplicity, but suffers from the typical problems of gradient descent on non-smooth objectives: we need to pick a step size and possibly use a sequence of decreasing step sizes, and don't have an obvious method to assess how accurate of a current solution we have obtained (since an ICNN with ReLUs is piecewise linear, it will not have zero gradient at the solution). The method is also more challenging to integrate with some learning procedures, as we often need to differentiate through an entire chain of the gradient descent algorithm (Domke, 2012). Thus, while the method can sometimes work in practice, we have found that other approaches typically far outperform this method, and we will focus on alternative approximate approaches for the remainder of this section.</p>
<h3>4.2. Approximate inference via the bundle entropy method</h3>
<p>An alternative approach to gradient descent is the bundle method (Smola et al., 2008), also known as the epigraph cutting plane approach, which iteratively optimizes a piecewise lower bound on the function given by the maximum over a set of first-order approximations. However, as, the traditional bundle method is not well suited to our setting (we need to evaluate a number of gradients equal to the dimension of $x$, and solve a complex optimization problem at each step) we have developed a new optimization algorithm for this domain that we term the bundle entropy method. This algorithm specifically applies to the (common) case where $\mathcal{Y}$ is bounded, which we assume to be $\mathcal{Y}=[0,1]^{n}$</p>
<p>(other upper or lower bounds can be attained through scaling). The method is also easily extensible to the setting where elements of $\mathcal{Y}$ belong to a higher-dimensional probability simplex as well.</p>
<p>For this approach, we consider adding an additional "barrier" function to the optimization in the form of the negative entropy $-H(y)$, where</p>
<p>$$
H(y)=-\sum_{i=1}^{n}\left(y_{i} \log y_{i}+\left(1-y_{i}\right) \log \left(1-y_{i}\right)\right)
$$</p>
<p>In other words, we instead want to solve the optimization problem $\operatorname{argmin}<em 0="0" _rightarrow="\rightarrow" y="y">{y} f(x, y ; \theta)-H(y)$ (with a possible additional scaling term). The negative entropy is a convex function, with the limits of $\lim </em>$.} H(y)=\lim _{y \rightarrow 1} H(y)=0$, and negative values in the interior of this range. The function acts as a barrier because, although it does not approach infinity as it reaches the barrier of the feasible set, its gradient does approach infinity as it reaches the barrier, and thus the optimal solution will always lie in the interior of the unit hypercube $\mathcal{Y</p>
<p>An appealing feature of the entropy regularization comes from its close connection with sigmoid units in typical neural networks. It follows easily from first-order optimality conditions that the optimization problem</p>
<p>$$
\underset{y}{\operatorname{minimize}} c^{T} y-H(y)
$$</p>
<p>is given by $y^{\star}=1 /(1+\exp (c))$. Thus if we consider the "trivial" PICNN mentioned in Section 3.2, which simply consists of the function $f(x, y ; \theta)=y^{T} \tilde{f}(x ; \theta)$ for some purely feedforward network $\tilde{f}(x ; \theta)$, then the entropy-regularized minimization problem gives a solution that is equivalent to simply taking the sigmoid of the neural network outputs. Thus, the move to ICNNs can be interpreted as providing a more structured joint energy functional over the linear function implicitly used by sigmoid layers.</p>
<p>At each iteration of the bundle entropy method, we solve the optimization problem</p>
<p>$$
y^{k+1}, t^{k+1}:=\underset{y, t}{\operatorname{argmin}}{t-H(y) \mid G y+h \leq t 1}
$$</p>
<p>where $G \in \mathbb{R}^{k \times n}$ has rows equal to</p>
<p>$$
g_{i}^{T}=\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T}
$$</p>
<p>and $h \in \mathbb{R}^{k}$ has entries equal to</p>
<p>$$
h_{i}=f\left(x, y^{i} ; \theta\right)-\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T} y^{i}
$$</p>
<p>The Lagrangian of the optimization problem is</p>
<p>$$
\mathcal{L}(y, t, \lambda)=t-H(y)+\lambda^{T}(G y+h-t 1)
$$</p>
<p>and differentiating with respect to $y$ and $t$ gives the optimality conditions</p>
<p>$$
\begin{aligned}
&amp; \nabla_{y} \mathcal{L}(y, t, \lambda)=0 \Longrightarrow y=\frac{1}{1+\exp \left(G^{T} \lambda\right)} \
&amp; \nabla_{t} \mathcal{L}(y, t, \lambda)=0 \Longrightarrow 1^{T} \lambda=1
\end{aligned}
$$</p>
<p>which in turn leads to the dual problem</p>
<p>$$
\begin{aligned}
&amp; \underset{\lambda}{\operatorname{maximize}}(G 1+h)^{T} \lambda-1^{T} \log \left(1+\exp \left(G^{T} \lambda\right)\right) \
&amp; \text { subject to } \lambda \geq 0,1^{T} \lambda=1
\end{aligned}
$$</p>
<p>This is a smooth optimization problem over the unit simplex, and can be solved using a method like the Projected Newton method of (Bertsekas, 1982, pg. 241, eq. 97). A complete description of the bundle entropy method is given in Section D. For lower dimensional problems, the bundle entropy method often attains an exact solution after a relatively small number of iterations. And even for larger problems, we find that the approximate solutions generated by a very small number of iterations (we typically use 5 iterations), still substantially outperform gradient descent approaches. Further, because we maintain an explicit lower bound on the function, we can compute an optimality gap of our solution, though in practice just using a fixed number of iterations performs well.</p>
<h2>5. Learning ICNNs</h2>
<p>Generally speaking, ICNN learning shapes the objective's energy function to produce the desired values when optimizing over the relevant inputs. That is, for a given input output pair $\left(x, y^{\star}\right)$, our goal is to find ICNN parameters $\theta$ such that</p>
<p>$$
y^{\star} \approx \underset{y}{\operatorname{argmin}} \tilde{f}(x, y ; \theta)
$$</p>
<p>where for the entirely of this section, we use the notation $\tilde{f}$ to denote the combination of the neural network function plus the regularization term such as $-H(y)$, if it is included, i.e.</p>
<p>$$
\tilde{f}(x, y ; \theta)=f(x, y ; \theta)-H(y)
$$</p>
<p>Although we only discuss the entropy regularization in this work, we emphasize that other regularizers are also possible. Depending on the setting, there are several different approaches we can use to ensure that the ICNN achieves the desired targets, and we consider three approaches below: direct functional fitting, max-margin structured prediction, and argmin differentiation.</p>
<p>Direct functional fitting. We first note that in some domains, we do not need a specialized procedure for fitting ICNNs, but can use existing approaches that directly fit the ICNN. An example of this is the Q-learning setting. Given</p>
<p>some observed tuple $\left(s, a, r, s^{\prime}\right), \mathrm{Q}$ learning updates the parameters $\theta$ with the gradient</p>
<p>$$
\left(Q(s, a)-r-\gamma \max <em _theta="\theta">{a^{\prime}} Q\left(s^{\prime}, a^{\prime}\right)\right) \nabla</em> Q(s, a)
$$</p>
<p>where the maximization step is carried out with gradient descent or the bundle entropy method. These updates can be applied to ICNNs with the only additional requirement that we project the weights onto their feasible sets after this update (i.e., clip or project any $W$ terms that are required to be positive). Section E gives a complete description of deep Q-learning with ICNNs.</p>
<p>Max-margin structured prediction. Although maxmargin structured prediction is a simple and well-studied approach (Tsochantaridis et al., 2005; Taskar et al., 2005), in our experiences using these methods within an ICNN, we had substantial difficulty choosing the proper margin scaling term (especially for domains with continuousvalued outputs), or allowing for losses other than the hinge loss. For this reason, Section F discusses max-margin structured prediction in more detail, but the majority of our experiments here focus on the next approach, which more directly encodes the loss suffered by the full structuredprediction pipeline.</p>
<h3>5.1. Argmin differentiation</h3>
<p>In our final proposed approach, that of argmin differentiation, we propose to directly minimize a loss function between true outputs and the outputs predicted by our model, where these predictions themselves are the result of an optimization problem. We explicitly consider the case where the approximate solution to the inference problem is attained via the previously-described bundle entropy method, typically run for some fixed (usually small) number of iterations. To simplify notation, in the following we will let</p>
<p>$$
\begin{aligned}
\hat{y}(x ; \theta) &amp; =\underset{y}{\operatorname{argmin}} \min _{t}{t-H(y) \mid G y+h \leq t 1} \
&amp; \approx \underset{y}{\operatorname{argmin}} \tilde{f}(x, y ; \theta)
\end{aligned}
$$</p>
<p>refer to the approximate minimization over $y$ that results from running the bundle entropy method, specifically at the last iteration of the method.</p>
<p>Given some example $\left(x, y^{<em>}\right)$, our goal is to compute the gradient, with respect to the ICNN parameters, of the loss between $y^{</em>}$ and $\hat{y}(x ; \theta): \ell\left(\hat{y}(x ; \theta), y^{*}\right)$. This is in some sense the most direct analogue to traditional neural network learning, since we typically optimize networks by minimizing some loss between the network's (feedforward) predictions and the true desired labels. Doing this in the predictions-via-optimization setting requires that we differentiate "through" the argmin operator, which can be ac-
complished via implicit differentiation of the KKT optimality conditions. Although the derivation is somewhat involved, the final result is fairly compact, and is given by the following proposition (for simplicity, we will write $\hat{y}$ below instead of $\hat{y}(x ; \theta)$ when the notation should be clear):</p>
<p>Proposition 3. The gradient of the neural network loss for predictions generated through the minimization process is</p>
<p>$$
\begin{aligned}
&amp; \nabla_{\theta} \ell\left(\hat{y}(x ; \theta), y^{*}\right)=\sum_{i=1}^{k}\left(c_{i}^{\lambda} \nabla_{\theta} f\left(x, y^{i} ; \theta\right)+\right. \
&amp; \left.\nabla_{\theta}\left(\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T}\left(\lambda_{i} c^{y}+c_{i}^{\lambda}\left(\hat{y}(x ; \theta)-y^{i}\right)\right)\right)\right)
\end{aligned}
$$</p>
<p>where $y^{i}$ denotes the solution returned by the ith iteration of the entropy bundle method, $\lambda$ denotes the dual variable solution of the entropy bundle method, and where the $c$ variables are determined by the solution to the linear system</p>
<p>$$
\left[\begin{array}{ccc}
H &amp; G^{T} &amp; 0 \
G &amp; 0 &amp; -1 \
0 &amp; -1^{T} &amp; 0
\end{array}\right]\left[\begin{array}{l}
c^{y} \
c^{\lambda} \
c^{t}
\end{array}\right]=\left[\begin{array}{c}
-\nabla_{\hat{y}} \ell\left(\hat{y}, y^{*}\right) \
0 \
0
\end{array}\right]
$$</p>
<p>where $H=\operatorname{diag}\left(\frac{1}{\hat{y}}+\frac{1}{1-\hat{y}}\right)$.
The proof of this proposition is given in Section G, but we highlight a few key points here. The complexity of computing this gradient will be linear in $k$, which is the number of active constraints at the solution of the bundle entropy method. The inverse of this matrix can also be computed efficiently by just inverting the $k \times k$ matrix $G H^{-1} G^{T}$ via a variable elimination procedure, instead of by inverting the full matrix. The gradients $\nabla_{\theta} f\left(x, y_{i} ; \theta\right)$ are standard neural network gradients, and further, can be computed in the same forward/backward pass as we use to compute the gradients for the bundle entropy method. The main challenge of the method is to compute the terms of the form $\nabla_{\theta}\left(\nabla_{y} f\left(x, y_{i} ; \theta\right)^{T} v\right)$ for some vector $v$. This quantity can be computed by most autodifferentiation tools (the gradient inner product $\nabla_{y} f\left(x, y_{i} ; \theta\right)^{T} v$ itself just becomes a graph computation than can be differentiated itself), or it can be computed by a finite difference approximation. The complexity of computing this entire gradient is a small constant multiple of computing $k$ gradients with respect to $\theta$.</p>
<p>Given this ability to compute gradients with respect to an arbitrary loss function, we can fit the parameter using traditional stochastic gradient methods examples. Specifically, given an example (or a minibatch of examples) $x_{i}, y_{i}$, we compute gradients $\nabla_{\theta} \ell\left(\hat{y}\left(x_{i} ; \theta\right), y_{i}\right)$ and update the parameters using e.g. the ADAM optimizer (Kingma \&amp; Ba, 2014).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Test Macro-F1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Feedforward net</td>
<td>0.396</td>
</tr>
<tr>
<td>ICNN</td>
<td>0.415</td>
</tr>
<tr>
<td>SPEN <em>Belanger &amp; McCallum (2016)</em></td>
<td>0.422</td>
</tr>
</tbody>
</table>
<p>Table 1: Comparison of approaches on BibTeX multi-label classification task. (Higher is better.)</p>
<h2>6 Experiments</h2>
<p>Our experiments study the representational power of ICNNs to better understand the interplay between the model’s restrictiveness and accuracy. Specifically, we evaluate the method on multi-label classification on the BibTeX dataset <em>Katakis et al. (2008)</em>, image completion using the Olivetti face dataset <em>Samaria &amp; Harter (1994)</em>, and continuous action reinforcement learning in the OpenAI Gym <em>Brockman et al. (2016)</em>. We show that the methods compare favorably to the state of the art in many situations. The full source code for all experiments is available in the icml2017 branch at https://github.com/locuslab/icnn and our implementation is built using Python <em>Van Rossum &amp; Drake Jr (1995)</em> with the numpy <em>Oliphant (2006)</em> and TensorFlow <em>Abadi et al. (2016)</em> packages.</p>
<h3>6.1 Synthetic 2D example</h3>
<p>Though we do not discuss it here, Section I presents a simple synthetic classification experiment comparing FICNN and PICNN decision boundaries.</p>
<h3>6.2 Multi-Label Classification</h3>
<p>We first study how ICNNs perform on multi-label classification with the BibTeX dataset and benchmark presented in <em>Katakis et al. (2008)</em>. This benchmark maps text classification from an input space $\mathcal{X}$ of 1836 bag-of-works indicator (binary) features to an output space $\mathcal{Y}$ of 159 binary labels. We use the train/test split of 4880/2515 from <em>Katakis et al. (2008)</em> and evaluate with the macro-F1 score (higher is better). We use the ARFF version of this dataset from Mulan <em>Tsoumakas et al. (2011)</em>. Our PICNN architecture for multi-label classification uses fully-connected layers with ReLU activation functions and batch normalization <em>Ioffe &amp; Szegedy (2015)</em> along the input path. As a baseline, we use a fully-connected neural network with batch normalization and ReLU activation functions. Both architectures have the same structure (600 fully connected, 159 (#labels) fully connected). We optimize our PICNN with 30 iterations of gradient descent with a learning rate of 0.1 and a momentum of 0.3.</p>
<p>Table 1 compares several different methods for this problem. Our PICNN’s final macro-F1 score of 0.415 outperforms our baseline feedforward network’s score of 0.396, which indicates PICNNs have the power to learn a robust structure over the output space. SPENs obtain a macro-F1 score of 0.422 on this task <em>Belanger &amp; McCallum (2016)</em> and pose an interesting comparison point to ICNNs as they have a similar (but not identical) deep structure that is non-convex over the input space. The difference of 0.007 between ICNNs and SPENs could be due to differences in our experimental setups, architectures, and random experimental noise. More details are included in Section J.</p>
<h3>6.3 Image completion on the Olivetti faces</h3>
<p>As a test of the system on a structured prediction task over a much more complex output space $\mathcal{Y}$, we apply a convolutional PICNN to face completion on the sklearn version <em>Pedregosa et al. (2011)</em> of the Olivetti data set <em>Samaria &amp; Harter (1994)</em>, which contains 400 64x64 grayscale images. ICNNs for face completion should be invariant to translations and other transformations in the input space. To achieve this invariance, our PICNN is inspired by the DQN architecture in <em>Mnih et al. (2015)</em>, which preserves this invariance in the different context of reinforcement learning. Specifically, our network is over $\langle x, y\rangle$ pairs where $x$ (32x64) is the left half and $y$ (32x64) is the right half of the image. The input and output paths are: 32x8x8 conv (stride 4x2), 64x4x4 conv (stride 2x2), 64x3x3 conv, 512 fully connected.</p>
<p>This experiment uses the same training/test splits and minimizes the mean squared error (MSE) as in <em>Poon &amp; Domingos (2011)</em> so that our results can be directly compared to (a non-exhaustive list of) other techniques. We also explore the tradeoffs between the bundle entropy method and gradient descent and use a non-convex baseline to better understand the impacts of convexity. We use a learning rate of 0.01 and momentum of 0.9 with gradient descent for the inner optimization in the ICNN.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>MSE</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICNN - Bundle Entropy</td>
<td>$\mathbf{8 3 3 . 0}$</td>
</tr>
<tr>
<td>ICNN - Gradient Decent</td>
<td>872.0</td>
</tr>
<tr>
<td>ICNN - Nonconvex</td>
<td>850.9</td>
</tr>
<tr>
<td>Sum-product (Poon \&amp; Domingos, 2011)</td>
<td>942</td>
</tr>
</tbody>
</table>
<p>Table 2. Comparisons of reconstruction error on image completion.</p>
<p>Table 2 shows the test MSEs for the different approaches. Example image completions are shown in Figure 3. These results show that the bundle entropy method can leverage more information from these five iterations than gradient descent, even when the convexity constraint is relaxed. The PICNN trained with back-optimization with the relaxed convexity constraint slightly outperforms the network with the convexity constraint, but not the network trained with the bundle-entropy method. This shows that for image completion with PICNNs, convexity does not seem to inhibit the representational power. Furthermore, this experiment suggests that a small number of inner optimization iterations (five in this case) is sufficient for good performance.</p>
<h3>6.4. Continuous Action Reinforcement Learning</h3>
<p>Finally, we present standard benchmarks in continuous action reinforcement learning from the OpenAI Gym (Brockman et al., 2016) that use the MuJoCo physics simulator (Todorov et al., 2012). We model the (negative) $Q$ function, $-Q(s, a ; \theta)$ as an ICNN and select actions with the convex optimization problem $a^{\star}(s)=\operatorname{argmin}_{a}-Q(s, a ; \theta)$. We use Q-learning to optimize the ICNN as described in Section 5 and Section E. At test time, the policy is selected by optimizing $Q(s, a ; \theta)$. All of our experiments use a PICNN with two fully-connected layers that each have 200 hidden units. We compare to Deep Deterministic Policy Gradient (DDPG) (Lillicrap et al., 2015) and Normalized Advantage Functions (NAF) (Gu et al., 2016) as state-of-the-art offpolicy learning baselines. ${ }^{4}$
Table 3 shows the maximum test reward achieved by the different algorithms on these tasks. Although no method strictly dominates the others, the ICNN approach has some clear advantages on tasks like HalfCheetah, Reacher, and HumanoidStandup, and performs comparably on many other tasks, though with also a few notable poor performances in Hopper and Walker2D. Nonetheless, given the strong baseline, and the fact that the method is literally just a drop-in replacement for a function approximator in</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Table 3. Maximum test reward for ICNN algorithm versus alternatives on several OpenAI Gym tasks. (All tasks are v1.)</p>
<p>Q-learning, these results are overall positive. NAF poses a particularly interesting comparison point to ICNNs. In particular, NAF decomposes the $Q$ function in terms of the value function an an advantage function $Q(s, a)=$ $V(s)+A(s, a)$ where the advantage function is restricted to be concave quadratic in the actions, and thus always has a closed-form solution. In a sense, this closely mirrors the setup of the PICNN architecture: like NAF, we have a separate non-convex path for the $s$ variables, and an overall function that is convex in $a$; however, the distinction is that while NAF requires that the convex portion be quadratic, the ICNN architecture allows any convex functional form. As our experiments show, this representational power does allow for better performance of the resulting system, though the trade-off, of course, is that determining the optimal action in an ICNN is substantially more computationally complex than for a quadratic.</p>
<h2>7. Conclusion and future work</h2>
<p>This paper laid the groundwork for the input convex neural network model. By incorporating relatively simple constraints into existing network architectures, we can fit very general convex functions and the apply optimization as an inference procedure. Since many existing models already fit into this overall framework (e.g., CRF models perform an optimization over an output space where parameters are given by the output of a neural network), the proposed method presents an extension where the entire inference procedure is "learned" along with the network itself, without the need for explicitly building typical structured prediction architectures. This work explored only a small subset of the possible applications of these network, and the networks offer promising directions for many additional domains.</p>
<h2>Acknowledgments</h2>
<p>BA is supported by the National Science Foundation Graduate Research Fellowship Program under Grant No. DGE1252522. We also thank David Belanger for helpful discussions.</p>
<h2>References</h2>
<p>Abadi, Martın, Agarwal, Ashish, Barham, Paul, Brevdo, Eugene, Chen, Zhifeng, Citro, Craig, Corrado, Greg S, Davis, Andy, Dean, Jeffrey, Devin, Matthieu, et al. Tensorflow: Large-scale machine learning on heterogeneous distributed systems. arXiv preprint arXiv:1603.04467, 2016.</p>
<p>Barzilai, Jonathan and Borwein, Jonathan M. Two-point step size gradient methods. IMA Journal of Numerical Analysis, 8(1):141-148, 1988.</p>
<p>Belanger, David and McCallum, Andrew. Structured prediction energy networks. In Proceedings of the International Conference on Machine Learning, 2016.</p>
<p>Bengio, Yoshua, LeCun, Yann, and Henderson, Donnie. Globally trained handwritten word recognizer using spatial representation, convolutional neural networks, and hidden markov models. Advances in neural information processing systems, pp. 937-937, 1994.</p>
<p>Bertsekas, Dimitri P. Projected newton methods for optimization problems with simple constraints. SIAM Journal on control and Optimization, 20(2):221-246, 1982.</p>
<p>Birgin, Ernesto G, Martínez, José Mario, and Raydan, Marcos. Nonmonotone spectral projected gradient methods on convex sets. SIAM Journal on Optimization, 10(4): 1196-1211, 2000.</p>
<p>Boyd, Stephen and Vandenberghe, Lieven. Convex optimization. Cambridge university press, 2004.</p>
<p>Boyd, Stephen, Parikh, Neal, Chu, Eric, Peleato, Borja, and Eckstein, Jonathan. Distributed optimization and statistical learning via the alternating direction method of multipliers. Foundations and Trends ${ }^{\circledR}$ in Machine Learning, 3(1):1-122, 2011.</p>
<p>Brockman, Greg, Cheung, Vicki, Pettersson, Ludwig, Schneider, Jonas, Schulman, John, Tang, Jie, and Zaremba, Wojciech. Openai gym. arXiv preprint arXiv:1606.01540, 2016.</p>
<p>Chen, Liang-Chieh, Schwing, Alexander G, Yuille, Alan L, and Urtasun, Raquel. Learning deep structured models. In Proceedings of the International Conference on Machine Learning, 2015.</p>
<p>Domke, Justin. Generic methods for optimization-based modeling. In Proceedings of the Conference on AI and Statistics, pp. 318-326, 2012.</p>
<p>Duchi, John, Hazan, Elad, and Singer, Yoram. Adaptive subgradient methods for online learning and stochastic optimization. The Journal of Machine Learning Research, 12:2121-2159, 2011.</p>
<p>Goodfellow, Ian, Pouget-Abadie, Jean, Mirza, Mehdi, Xu, Bing, Warde-Farley, David, Ozair, Sherjil, Courville, Aaron, and Bengio, Yoshua. Generative adversarial nets. In Advances in Neural Information Processing Systems, pp. 2672-2680, 2014.</p>
<p>Gu, Shixiang, Lillicrap, Timothy, Sutskever, Ilya, and Levine, Sergey. Continuous deep q-learning with modelbased acceleration. In Proceedings of the International Conference on Machine Learning, 2016.</p>
<p>He, Kaiming, Zhang, Xiangyu, Ren, Shaoqing, and Sun, Jian. Deep residual learning for image recognition. arXiv preprint arXiv:1512.03385, 2015.</p>
<p>Huang, Gao, Liu, Zhuang, and Weinberger, Kilian Q. Densely connected convolutional networks. arXiv preprint arXiv:1608.06993, 2016.</p>
<p>Ioffe, Sergey and Szegedy, Christian. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In Proceedings of The 32nd International Conference on Machine Learning, pp. 448-456, 2015.</p>
<p>Katakis, Ioannis, Tsoumakas, Grigorios, and Vlahavas, Ioannis. Multilabel text classification for automated tag suggestion. ECML PKDD discovery challenge, 75, 2008.</p>
<p>Kingma, Diederik and Ba, Jimmy. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.</p>
<p>Koller, Daphne and Friedman, Nir. Probabilistic graphical models: principles and techniques. MIT press, 2009.</p>
<p>Krizhevsky, Alex, Sutskever, Ilya, and Hinton, Geoffrey E. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, pp. 1097-1105, 2012.</p>
<p>LeCun, Yann, Chopra, Sumit, Hadsell, Raia, Ranzato, M, and Huang, F. A tutorial on energy-based learning. Predicting structured data, 1:0, 2006.</p>
<p>Lillicrap, Timothy P, Hunt, Jonathan J, Pritzel, Alexander, Heess, Nicolas, Erez, Tom, Tassa, Yuval, Silver, David, and Wierstra, Daan. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015.</p>
<p>Magnani, Alessandro and Boyd, Stephen P. Convex piecewise-linear fitting. Optimization and Engineering, 10(1):1-17, 2009.</p>
<p>Mnih, Volodymyr, Kavukcuoglu, Koray, Silver, David, Rusu, Andrei A, Veness, Joel, Bellemare, Marc G, Graves, Alex, Riedmiller, Martin, Fidjeland, Andreas K, Ostrovski, Georg, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529533, 2015.</p>
<p>Nair, Vinod and Hinton, Geoffrey E. Rectified linear units improve restricted boltzmann machines. In Proceedings of the 27th International Conference on Machine Learning (ICML-10), pp. 807-814, 2010.</p>
<p>Oliphant, Travis E. A guide to NumPy, volume 1. Trelgol Publishing USA, 2006.</p>
<p>Pedregosa, Fabian, Varoquaux, Gaël, Gramfort, Alexandre, Michel, Vincent, Thirion, Bertrand, Grisel, Olivier, Blondel, Mathieu, Prettenhofer, Peter, Weiss, Ron, Dubourg, Vincent, et al. Scikit-learn: Machine learning in python. The Journal of Machine Learning Research, 12:2825-2830, 2011.</p>
<p>Peng, Jian, Bo, Liefeng, and Xu, Jinbo. Conditional neural fields. In Advances in neural information processing systems, pp. 1419-1427, 2009.</p>
<p>Polyak, Boris T. Some methods of speeding up the convergence of iteration methods. USSR Computational Mathematics and Mathematical Physics, 4(5):1-17, 1964.</p>
<p>Poon, Hoifung and Domingos, Pedro. Sum-product networks: A new deep architecture. In UAI 2011, Proceedings of the Twenty-Seventh Conference on Uncertainty in Artificial Intelligence, Barcelona, Spain, July 14-17, 2011, pp. 337-346, 2011.</p>
<p>Ratliff, Nathan D, Bagnell, J Andrew, and Zinkevich, Martin. (Approximate) subgradient methods for structured prediction. In International Conference on Artificial Intelligence and Statistics, pp. 380-387, 2007.</p>
<p>Rumelhart, David E, Hinton, Geoffrey E, and Williams, Ronald J. Learning representations by back-propagating errors. Cognitive modeling, 5(3):1, 1988.</p>
<p>Samaria, Ferdinando S and Harter, Andy C. Parameterisation of a stochastic model for human face identification. In Applications of Computer Vision, 1994., Proceedings of the Second IEEE Workshop on, pp. 138-142. IEEE, 1994.</p>
<p>Simard, Patrice and LeCun, Yann. Reverse tdnn: an architecture for trajectory generation. In Advances in Neural Information Processing Systems, pp. 579-588. Citeseer, 1991.</p>
<p>Simonyan, Karen and Zisserman, Andrew. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.</p>
<p>Smola, Alex J., Vishwanathan, S.v.n., and Le, Quoc V. Bundle methods for machine learning. In Platt, J. C., Koller, D., Singer, Y., and Roweis, S. T. (eds.), Advances in Neural Information Processing Systems 20, pp. 13771384. Curran Associates, Inc., 2008.</p>
<p>Szegedy, Christian, Liu, Wei, Jia, Yangqing, Sermanet, Pierre, Reed, Scott, Anguelov, Dragomir, Erhan, Dumitru, Vanhoucke, Vincent, and Rabinovich, Andrew. Going deeper with convolutions. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 1-9, 2015.</p>
<p>Taskar, Ben, Chatalbashev, Vassil, Koller, Daphne, and Guestrin, Carlos. Learning structured prediction models: A large margin approach. In Proceedings of the 22nd International Conference on Machine Learning, pp. 896903. ACM, 2005.</p>
<p>Todorov, Emanuel, Erez, Tom, and Tassa, Yuval. Mujoco: A physics engine for model-based control. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems, pp. 5026-5033. IEEE, 2012.</p>
<p>Tsochantaridis, Ioannis, Joachims, Thorsten, Hofmann, Thomas, and Altun, Yasemin. Large margin methods for structured and interdependent output variables. Journal of Machine Learning Research, 6:1453-1484, 2005.</p>
<p>Tsoumakas, Grigorios, Spyromitros-Xioufis, Eleftherios, Vilcek, Jozef, and Vlahavas, Ioannis. Mulan: A java library for multi-label learning. Journal of Machine Learning Research, 12(Jul):2411-2414, 2011.</p>
<p>Van Rossum, Guido and Drake Jr, Fred L. Python reference manual. Centrum voor Wiskunde en Informatica Amsterdam, 1995.</p>
<p>Wright, Stephen J. Primal-dual interior-point methods. Siam, 1997.</p>
<p>Zheng, Shuai, Jayasumana, Sadeep, Romera-Paredes, Bernardino, Vineet, Vibhav, Su, Zhizhong, Du, Dalong, Huang, Chang, and Torr, Philip HS. Conditional random fields as recurrent neural networks. In Proceedings of the IEEE International Conference on Computer Vision, pp. 1529-1537, 2015.</p>
<h1>Input Convex Neural Networks: Supplementary Material</h1>
<h2>Brandon Amos Lei Xu J. Zico Kolter</h2>
<h2>A. Additional architectures</h2>
<h2>A.1. Convolutional architectures</h2>
<p>Convolutions are important to many visual structured tasks. We have left convolutions out to keep the prior ICNN notation light by using matrix-vector operations. ICNNs can be similarly created with convolutions because the convolution is a linear operator.</p>
<p>The construction of convolutional layers in ICNNs depends on the type of input and output space. If the input and output space are similarly structured (e.g. both spatial), the $j$ th feature map of a convolutional PICNN layer $i$ can be defined by
$z_{i+1}^{j}=g_{i}\left(z_{i} * W_{i, j}^{(z)}+(S x) * W_{i, j}^{(x)}+(S y) * W_{i, j}^{(y)}+b_{i, j}\right)$
where the convolution kernels $W$ are the same size and $S$ scales the input and output to be the same size as the previous feature map, and were we omit some of the Hadamard product terms that can appear above for simplicity of presentation.</p>
<p>If the input space is spatial, but the output space has another structure (e.g. the simplex), the convolution over the output space can be replaced by a matrix-vector operation, such as</p>
<p>$$
z_{i+1}^{j}=g_{i}\left(z_{i} * W_{i, j}^{(z)}+(S x) * W_{i, j}^{(x)}+B_{i, j}^{(y)} y+b_{i, j}\right)
$$</p>
<p>where the product $B_{i, j}^{(y)} y$ is a scalar.</p>
<h2>B. Exact inference in ICNNs</h2>
<p>Although it is not a practical approach for solving the optimization tasks, we first highlight the fact that the inference problem for the networks presented above (where the nonlinear are either ReLU or linear units) can be posed as as linear program. Specifically, considering the FICNN net-
work in (2) can be written as the optimization problem</p>
<p>$$
\begin{array}{ll}
\underset{y, z_{1}, \ldots, z_{k}}{\operatorname{minimize}} &amp; z_{k} \
\text { subject to } &amp; z_{i+1} \geq W_{i}^{(z)} z_{i}+W_{i}^{(y)} y+b_{i}, \quad i=0, \ldots, k-1 \
&amp; z_{i} \geq 0, \quad i=1, \ldots, k-1
\end{array}
$$</p>
<p>This problem exactly replicates the equations of the FICNN, with the exception that we have replaced ReLU and the equality constraint between layers with a positivity constraint on the $z_{i}$ terms and an inequality. However, because we are minimizing the final $z_{k}$ term, and because each inequality constraint is convex, at the solution one of these constraints must be tight, i.e., $\left(z_{i}\right)<em i="i">{j}=$ $\left(W</em>\right)}^{(z)} z_{i}+W_{i}^{(y)} y+b_{i<em i="i">{j}$ or $\left(z</em>=0$, which recovers the ReLU non-linearity exactly. The exact same procedure can be used to write to create an exact inference procedure for the PICNN.}\right)_{j</p>
<p>Although the LP formulation is appealing in its simplicity, in practice these optimization problems will have a number of variables equal to the total number of activations in the entire network. Furthermore, most LP solution methods to solve such problems require that we form and invert structured matrices with blocks such as $W_{i}^{T} W_{i}$ - the case for most interior-point methods (Wright, 1997) or even approximate algorithms such as the alternating direction method of multipliers (Boyd et al., 2011) — which are large dense matrices or have structured forms such as non-cyclic convolutions that are expensive to invert. Even incremental approaches like the Simplex method require that we form inverses of subsets of columns of these matrices, which are additionally different for structured operations like convolutions, and which overall still involve substantially more computation than a single forward pass. Furthermore, such solvers typically do not exploit the substantial effort that has gone in to accelerating the forward and backward computation passes for neural networks using hardware such as GPUs. Thus, as a whole, these do not present a viable option for optimizing the networks.</p>
<p>Algorithm 1 A typical bundle method to optimize $f$ : $\mathbb{R}^{m \times n} \rightarrow \mathbb{R}$ over $\mathbb{R}^{n}$ for $K$ iterations with a fixed $x$ and initial starting point $y^{1}$.</p>
<div class="codehilite"><pre><span></span><code>function BUNDLEMETHOD \(\left(f, x, y^{1}, K\right)\)
    \(G \leftarrow 0 \in \mathbb{R}^{K \times n}\)
    \(h \leftarrow 0 \in \mathbb{R}^{K}\)
    for \(k=1, K\) do
        \(G_{k}^{T} \leftarrow \nabla_{y} f\left(x, y^{k} ; \theta\right)^{T} \quad \triangleright k\) th row of \(G\)
        \(h_{k} \leftarrow f\left(x, y^{k} ; \theta\right)-\nabla_{y} f\left(x, y^{k} ; \theta\right)^{T} y^{k}\)
        \(y^{k+1}, t^{k+1} \leftarrow \operatorname{argmin}_{y \in \mathcal{Y}, t}\left\{t \mid G_{1: k} y+h_{1: k} \leq\right.\)
\(t 1\}\)
    end for
    return \(y^{K+1}\)
end function
</code></pre></div>

<h2>C. The bundle method for approximate inference in ICNNs</h2>
<p>We here review the basic bundle method (Smola et al., 2008) that we build upon in our bundle entropy method. The bundle method takes advantage of the fact that for a convex objective, the first-order approximation at any point is a global underestimator of the function; this lets us maintain a piecewise linear lower bound on the function by adding cutting planes formed by this first order approximation, and then repeatedly optimizing this lower bound. Specifically, the process follows the procedure shown in Algorithm 1. Denoting the iterates of the algorithm as $y^{k}$, at each iteration of the algorithm, we compute the first order approximation to the function</p>
<p>$$
f\left(x, y^{k} ; \theta\right)+\nabla_{y} f\left(x, y^{k} ; \theta\right)^{T}\left(y-y^{k}\right)
$$</p>
<p>and update the next iteration by solving the optimization problem
$y^{k+1}:=\underset{y \in \mathcal{Y}}{\operatorname{argmin}} \max <em y="y">{1 \leq i \leq k}\left{f\left(x, y^{i} ; \theta\right)+\nabla</em>\right)\right}$.
A bit more concretely, the optimization problem can be written via a set of linear inequality constraints} f\left(x, y^{i} ; \theta\right)^{T}\left(y-y^{i</p>
<p>$$
y^{k+1}, t^{k+1}:=\underset{y \in \mathcal{Y}, t}{\operatorname{argmin}}{t \mid G y+h \leq t 1}
$$</p>
<p>where $G \in \mathbb{R}^{k \times n}$ has rows equal to</p>
<p>$$
g_{i}^{T}=\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T}
$$</p>
<p>and $h \in \mathbb{R}^{k}$ has entries equal to</p>
<p>$$
h_{i}=f\left(x, y^{i} ; \theta\right)-\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T} y^{i}
$$</p>
<h2>D. Bundle Entropy Algorithm</h2>
<p>In Algorithm 2.</p>
<p>Algorithm 2 Our bundle entropy method to optimize $f$ : $\mathbb{R}^{m} \times[0,1]^{n} \rightarrow \mathbb{R}$ over $[0,1]^{n}$ for $K$ iterations with a fixed $x$ and initial starting point $y^{1}$.
function BUNDLEENTROPYMETHOD $\left(f, x, y^{1}, K\right)$
$G_{\ell} \leftarrow[]$
$h_{\ell} \leftarrow[]$
for $k=1, K$ do
$\operatorname{APPEND}\left(G_{\ell}, \nabla_{y} f\left(x, y^{k} ; \theta\right)^{T}\right)$
$\operatorname{APPEND}\left(h_{\ell}, f\left(x, y^{k} ; \theta\right)-\nabla_{y} f\left(x, y^{k} ; \theta\right)^{T} y^{k}\right)$
$a_{k} \leftarrow \operatorname{LENGTH}\left(G_{\ell}\right) \quad \triangleright$ The number of active
constraints.
$G_{k} \leftarrow \operatorname{CONCAT}\left(G_{\ell}\right) \in \mathbb{R}^{a_{k} \times n}$
$h_{k} \leftarrow \operatorname{CONCAT}\left(h_{\ell}\right) \in \mathbb{R}^{a_{k}}$
if $a_{k}=1$ then
$\lambda_{k} \leftarrow 1$
else
$\lambda_{k} \leftarrow$ PROJNEWTONLOGISTIC $\left(G_{k}, h_{k}\right)$
end if
$y^{k+1} \leftarrow\left(1+\exp \left(G_{k}^{T} \lambda_{k}\right)\right)^{-1}$
$\operatorname{DELETE}\left(G_{\ell}[i]\right.$ and $\left.h_{\ell}[i]\right.$ where $\left.\lambda_{i} \leq 0\right) \triangleright$ Prune
inactive constraints.
end for
return $y^{K+1}$
end function</p>
<h2>E. Deep Q-learning with ICNNs</h2>
<p>In Algorithm 3.</p>
<p>Algorithm 3 Deep Q-learning with ICNNs. Opt-Alg is a convex minimization algorithm such as gradient descent or the bundle entropy method. $\hat{Q}<em _theta="\theta">{\theta}$ is the objective the optimization algorithm solves. In gradient descent, $\hat{Q}</em>(s, a)=Q(s, a \mid \theta)+H(a)$.}(s, a)=Q(s, a \mid \theta)$ and with the bundle entropy method, $\hat{Q}_{\theta</p>
<p>Select a discount factor $\gamma \in(0,1)$ and moving average factor $\tau \in(0,1)$
Initialize the ICNN $-Q(s, a \mid \theta)$ with target network parameters $\theta^{\prime} \leftarrow \theta$ and a replay buffer $R \leftarrow \emptyset$
for each episode $e=1, E$ do
Initialize a random process $\mathcal{N}$ for action exploration
Receive initial observation state $s_{1}$
for $i=1, I$ do
$a_{i} \leftarrow \operatorname{OPT}-\operatorname{ALG}\left(-Q_{\theta}, s_{i}, a_{i, 0}\right)+\mathcal{N}<em 0="0" i_="i,">{i} \quad \triangleright$ For some
initial action $a</em>$
Execute $a_{i}$ and observe $r_{i+1}$ and $s_{i+1}$
$\operatorname{INSERT}\left(R,\left(s_{i}, a_{i}, s_{i+1}, r_{i+1}\right)\right)$
Sample a random minibatch from the replay buffer: $R_{M} \subseteq R$
for $\left(s_{m}, a_{m}, s_{m}^{+}, r_{m}^{+}\right) \in R_{M}$ do
$a_{m}^{+} \leftarrow \operatorname{OPT}-\operatorname{ALG}\left(-Q_{\theta^{\prime}}, s_{m}^{+}, a_{m, 0}^{+}\right) \triangleright$ Uses the target parameters $\theta^{\prime}$
$y_{m} \leftarrow r_{m}^{+}+\gamma Q\left(s_{m}^{+}, a_{m}^{+} \mid \theta^{\prime}\right)$
end for
Update $\theta$ with a gradient step to minimize $\mathcal{L}=$ $\frac{1}{\left|R_{M}\right|} \sum_{m}\left(\hat{Q}\left(s_{m}, a_{m} \mid \theta\right)-y_{m}\right)^{2}$
$\theta^{\prime} \leftarrow \tau \theta+(1-\tau) \theta^{\prime} \quad \triangleright$ Update the target network.
end for
end for</p>
<h2>F. Max-margin structured prediction</h2>
<p>In the more traditional structured prediction setting, where we do not aim to fit the energy function directly but fit the predictions made by the system to some target outputs, there are different possibilities for learning the ICNN parameters. One such method is based upon the maxmargin structured prediction framework (Tsochantaridis et al., 2005; Taskar et al., 2005). Given some training example $\left(x, y^{\star}\right)$, we would like to require that this example has a joint energy that is lower than all other possible values for $y$. That is, we want the function $\hat{f}$ to satisfy the constraint</p>
<p>$$
\hat{f}\left(x, y^{\star} ; \theta\right) \leq \min _{y} \hat{f}(x, y ; \theta)
$$</p>
<p>Unfortunately, these conditions can be trivially fit by choosing a constant $\hat{f}$ (although the entropy term alleviates this problem slightly, we can still choose an approximately constant function), so instead the max-margin approach adds a margin-scaling term that requires this gap to be larger for $y$ further from $y^{\star}$, as measured by some loss
function $\Delta\left(y, y^{\star}\right)$. Additionally adding slack variables to allow for potential violation of these constraints, we arrive at the typical max-margin structured prediction optimization problem
$\underset{\theta, \xi \geq 0}{\operatorname{minimize}} \frac{\lambda}{2}|\theta|<em i="1">{2}^{2}+\sum</em>$
subject to $\hat{f}\left(x_{i}, y_{i} ; \theta\right) \leq \min }^{m} \xi_{i<em i="i">{y \in \mathcal{Y}}\left(\hat{f}\left(x</em>$}, y ; \theta\right)-\Delta\left(y_{i}, y\right)\right)-\xi_{i</p>
<p>As a simple example, for multiclass classification tasks where $y^{\star}$ denotes a "one-hot" encoding of examples, we can use a multi-variate entropy term and let $\Delta\left(y, y^{\star}\right)=$ $y^{\star T}(1-y)$. Training requires solving this "lossaugmented" inference problem, which is convex for suitable choices of the margin scaling term.</p>
<p>The optimization problem (29) is naturally still not convex in $\theta$, but can be solved via the subgradient method for structured prediction (Ratliff et al., 2007). This algorithm iteratively selects a training example $x_{i}, y_{i}$, then 1) solves the optimization problem</p>
<p>$$
y^{\star}=\underset{y \in \mathcal{Y}}{\operatorname{argmin}} f\left(x_{i}, y ; \theta\right)-\Delta\left(y_{i}, y\right)
$$</p>
<p>and 2) if the margin is violated, updates the network's parameters according to the subgradient</p>
<p>$$
\theta:=\mathcal{P}<em _theta="\theta">{+}\left[\theta-\alpha\left(\lambda \theta+\nabla</em> ; \theta\right)\right)\right]
$$} f\left(x_{i}, y_{i}, \theta\right)-\nabla_{\theta} f\left(x_{i}, y^{\star</p>
<p>where $\mathcal{P}<em 1:="1:" k-1="k-1">{+}$denotes the projection of $W</em>$ can be used instead of the exact solution.}^{(z)}$ onto the nonnegative orthant. This method can be easily adapted to use mini-batches instead of a single example per subgradient step, and also adapted to alternative optimization methods like AdaGrad (Duchi et al., 2011) or ADAM (Kingma \&amp; $\mathrm{Ba}, 2014$ ). Further, a fast approximate solution to $y^{\star</p>
<h2>G. Proof of Proposition 3</h2>
<p>Proof (of Proposition 3). We have by the chain rule that</p>
<p>$$
\frac{\partial \ell}{\partial \theta}=\frac{\partial \ell}{\partial \hat{y}}\left(\frac{\partial \hat{y}}{\partial G} \frac{\partial G}{\partial \theta}+\frac{\partial \hat{y}}{\partial h} \frac{\partial h}{\partial \theta}\right)
$$</p>
<p>The challenging terms to compute in this equation are the $\frac{\partial \hat{y}}{\partial G}$ and $\frac{\partial \hat{y}}{\partial h}$ terms. These can be computed (although we will ultimately not compute them explicitly, but just compute the product of these matrices and other terms in the Jacobian), by implicit differentiation of the KKT conditions. Specifically, the KKT conditions of the bundle entropy method (considering only the active constraints at the</p>
<p>solution) are given by</p>
<p>$$
\begin{array}{r}
1+\log \hat{y}-\log (1-\hat{y})+G^{T} \lambda=0 \
G \hat{y}+h-t 1=0 \
1^{T} \lambda=1
\end{array}
$$</p>
<p>For simplicity of presentation, we consider first the Jacobian with respect to $h$. Taking differentials of these equations with respect to $h$ gives</p>
<p>$$
\begin{array}{r}
\operatorname{diag}\left(\frac{1}{\hat{y}}+\frac{1}{1-\hat{y}}\right) \mathrm{d} y+G^{T} \mathrm{~d} \lambda=0 \
G \mathrm{~d} y+\mathrm{d} h-\mathrm{d} t 1=0 \
1^{T} \mathrm{~d} \lambda=0
\end{array}
$$</p>
<p>or in matrix form</p>
<p>$$
\left[\begin{array}{ccc}
\operatorname{diag}\left(\frac{1}{\hat{y}}+\frac{1}{1-\hat{y}}\right) &amp; G^{T} &amp; 0 \
G &amp; 0 &amp; -1 \
0 &amp; -1^{T} &amp; 0
\end{array}\right]\left[\begin{array}{c}
\mathrm{d} y \
\mathrm{~d} \lambda \
\mathrm{~d} t
\end{array}\right]=\left[\begin{array}{c}
0 \
-\mathrm{d} h \
0
\end{array}\right]
$$</p>
<p>To compute the Jacobian $\frac{\partial \hat{y}}{\partial h}$ we can solve the system above with the right hand side given by $\mathrm{d} h=I$, and the resulting $\mathrm{d} y$ term will be the corresponding Jacobian. However, in our ultimate objective we always left-multiply the proper terms in the above equation by $\frac{\partial \ell}{\partial \hat{y}}$. Thus, we instead define</p>
<p>$$
\left[\begin{array}{c}
c^{y} \
c^{\lambda} \
c^{t}
\end{array}\right]=\left[\begin{array}{ccc}
\operatorname{diag}\left(\frac{1}{\hat{y}}+\frac{1}{1-\hat{y}}\right) &amp; G^{T} &amp; 0 \
G &amp; 0 &amp; -1 \
0 &amp; -1^{T} &amp; 0
\end{array}\right]^{-1}\left[\begin{array}{c}
-\left(\frac{\partial \ell}{\partial \hat{y}}\right)^{T} \
0 \
0
\end{array}\right]
$$</p>
<p>and we have the the simple formula for the Jacobian product</p>
<p>$$
\frac{\partial \ell}{\partial \hat{y}} \frac{\partial \hat{y}}{\partial h}=\left(c^{\lambda}\right)^{T}
$$</p>
<p>A similar set of operations taking differentials with respect to $G$ leads to the matrix equations</p>
<p>$$
\left[\begin{array}{ccc}
\operatorname{diag}\left(\frac{1}{\hat{y}}+\frac{1}{1-\hat{y}}\right) &amp; G^{T} &amp; 0 \
G &amp; 0 &amp; -1 \
0 &amp; -1^{T} &amp; 0
\end{array}\right]\left[\begin{array}{c}
\mathrm{d} y \
\mathrm{~d} \lambda \
\mathrm{~d} t
\end{array}\right]=\left[\begin{array}{c}
-\mathrm{d} G^{T} \lambda \
-\mathrm{d} G y \
0
\end{array}\right]
$$</p>
<p>and the corresponding Jacobian products / gradients are given by</p>
<p>$$
\frac{\partial \ell}{\partial \hat{y}} \frac{\partial \hat{y}}{\partial G}=c^{y} \lambda^{T}+\hat{y}\left(c^{\lambda}\right)^{T}
$$</p>
<p>Finally, using the definitions that
$g_{i}^{T}=\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T}, \quad h_{i}=f\left(x, y^{k} ; \theta\right)-\nabla_{y} f\left(x, y^{i} ; \theta\right)^{T} y^{i}$
we recover the formula presented in the proposition.</p>
<h2>H. State and action space sizes in the OpenAI gym MuJoCo benchmarks.</h2>
<table>
<thead>
<tr>
<th style="text-align: center;">Environment</th>
<th style="text-align: center;"># State</th>
<th style="text-align: center;"># Action</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">InvertedPendulum-v1</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">InvertedDoublePendulum-v1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">Reacher-v1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">HalfCheetah-v1</td>
<td style="text-align: center;">17</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: center;">Swimmer-v1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">Hopper-v1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: center;">Walker2d-v1</td>
<td style="text-align: center;">17</td>
<td style="text-align: center;">6</td>
</tr>
<tr>
<td style="text-align: center;">Ant-v1</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">8</td>
</tr>
<tr>
<td style="text-align: center;">Humanoid-v1</td>
<td style="text-align: center;">376</td>
<td style="text-align: center;">17</td>
</tr>
<tr>
<td style="text-align: center;">HumanoidStandup-v1</td>
<td style="text-align: center;">376</td>
<td style="text-align: center;">17</td>
</tr>
</tbody>
</table>
<p>Table 4. State and action space sizes in the OpenAI gym MuJoCo benchmarks.</p>
<h2>I. Synthetic classification examples</h2>
<p>We begin with a simple example to illustrate the classification performance of a two-hidden-layer FICNN and PICNN on two-dimensional binary classification tasks from the scikit-learn toolkit (Pedregosa et al., 2011). Figure 4 shows the classification performance on the dataset. The FICNN's energy function which is fully convex in $\mathcal{X} \times \mathcal{Y}$ jointly is able to capture complex, but sometimes restrictive decision boundaries. The PICNN, which is nonconvex over $\mathcal{X}$ but convex over $\mathcal{Y}$ overcomes these restrictions and can capture more complex decision boundaries.</p>
<h2>J. Multi-Label Classification Training Plots</h2>
<p>In Figure 5.</p>
<h2>K. Image Completion</h2>
<p>The losses are in Figure 6.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 4. FICNN (top) and PICNN (bottom) classification of synthetic non-convex decision boundaries. Best viewed in color.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 5. Training (blue) and test (red) macro-F1 score of a feedforward network (left) and PICNN (right) on the BibTeX multi-label classification dataset. The final test F1 scores are 0.396 and 0.415 , respectively. (Higher is better.)
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 6. Mean Squared Error (MSE) on the train (blue, rolling over 1 epoch) and test (red) images from Olivetti faces for PICNNs trained with the bundle entropy method (left) and back optimization (center), and back optimization with the convexity constraint relaxed (right). The minimum test MSEs are $833.0,872.0$, and 850.9 , respectively.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ Because there are not official DDPG or NAF implementations or results on the OpenAI gym tasks, we use the Simon Ramstedt's DDPG implementation from https://github.com/ SimonRamstedt/ddpg and have re-implemented NAF.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{3}$ We emphasize the term "input convex" since convexity in machine learning typically refers to convexity (of the loss minimization learning problem) in the parameters, which is not the case here. Note that in our notation, $f$ needs only be a convex function in $y$, and may still be non-convex in the remaining inputs $x$. Training these neural networks remains a nonconvex problem, and the convexity is only being exploited at inference time.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>