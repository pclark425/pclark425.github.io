<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-307 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-307</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-307</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-14.html">extraction-schema-14</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <p><strong>Paper ID:</strong> paper-b16c7d45183b9d595ab64301be019741b1528860</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/b16c7d45183b9d595ab64301be019741b1528860" target="_blank">Llemma: An Open Language Model For Mathematics</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> Llemma is a large language model for mathematics that outperforms all known open base models, as well as the unreleased Minerva model suite on an equi-parameter basis, and is capable of tool use and formal theorem proving without any further finetuning.</p>
                <p><strong>Paper Abstract:</strong> We present Llemma, a large language model for mathematics. We continue pretraining Code Llama on the Proof-Pile-2, a mixture of scientific papers, web data containing mathematics, and mathematical code, yielding Llemma. On the MATH benchmark Llemma outperforms all known open base models, as well as the unreleased Minerva model suite on an equi-parameter basis. Moreover, Llemma is capable of tool use and formal theorem proving without any further finetuning. We openly release all artifacts, including 7 billion and 34 billion parameter models, the Proof-Pile-2, and code to replicate our experiments.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e307.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e307.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LLEMMA-34B CoT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LlemMA 34-billion-parameter model — chain-of-thought evaluation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The 34B-parameter LlemMA model evaluated on multi-step arithmetic and quantitative reasoning benchmarks using few-shot chain-of-thought prompting (greedy decoding).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LlemMA</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>34B</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>decoder-only transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>multi-step arithmetic and quantitative reasoning including word problems, algebraic manipulations, telescoping sums, number theory (e.g., modular arithmetic), general numeric computations</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>Varied: GSM8k (middle-school integer arithmetic, typically small integers), MATH (high-school competition problems, multi-step symbolic/algebraic reasoning and number theory up to hard Level 5 problems)</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Few-shot chain-of-thought prompting (4-shot prompt for MATH as described; 8-shot for GSM8k per Wei et al. prompting), greedy decoding; evaluation also includes majority-voting experiments (reported separately).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Greedy chain-of-thought few-shot: GSM8k 51.5% accuracy, MATH 25.0% accuracy (reported Table 1). Compared to Code Llama baseline, LlemMA-34B improved ~20 percentage points on GSM8k and ~13 points on MATH.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Performance improves with model size and with continued math-specialized pretraining: LlemMA-34B > LlemMA-7B > Code Llama; continued pretraining on Proof-Pile-2 yielded substantial gains.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Remains poor on highest-difficulty MATH problems (Level 5 accuracy ~6%); struggles with many hard multi-step contest problems despite improvements; no evidence that n-gram training hits guarantee correct answers.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared to Code Llama (7B, 34B), Llama 2 (7B), and Minerva (proprietary; quoted results); comparisons include greedy CoT vs majority voting and different model sizes.</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>Continued pretraining on a math-focused corpus yields large gains in few-shot chain-of-thought arithmetic performance (34B LlemMA gives strong improvements on GSM8k and MATH over non-specialized baselines), but high-difficulty arithmetic remains challenging and no low-level mechanistic account is provided.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Llemma: An Open Language Model For Mathematics', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e307.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e307.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LLEMMA-34B + Python</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LlemMA 34B evaluated with Python tool use (program-aided arithmetic)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>LlemMA models prompted to interleave natural-language solution steps with executable Python/SymPy code to compute answers, evaluated on GSM8k+Python and MATH+Python.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LlemMA</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>34B</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>decoder-only transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>numeric computation (integer arithmetic), floating numeric operations, and symbolic math via SymPy (program-executed arithmetic and algebra)</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>GSM8k+Python produces integer answers matching GSM8k; MATH+Python outputs numeric or SymPy objects — complexity varies with problem, often small-to-moderate integers and symbolic expressions.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Few-shot program-aided prompting: prompts alternate natural-language steps and executable Python code examples; pass@1 evaluation (model generates a single program which is executed).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Pass@1 results (Table 3): LlemMA-34B GSM8k+Python 62.6% pass@1, MATH+Python 27.1% pass@1. These are higher than the analogous greedy chain-of-thought (non-tool) results.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Tool use enables the model to offload arithmetic execution to a deterministic interpreter (the model generates code which is executed to obtain exact numeric or symbolic answers), improving correctness for computation-heavy substeps.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Tool-aided performance improves with model size and with math-focused pretraining; LlemMA-34B outperforms Code Llama 34B and LlemMA-7B in the tool-use setting.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Not detailed beyond overall lower accuracy on hardest MATH problems; failures can occur if generated code is incorrect or non-executable, or if the model fails to decompose the problem into correct computational steps.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against Code Llama (7B and 34B) using the same tool-use prompts; also compared to non-tool chain-of-thought performance to show benefit of tool use.</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>Allowing the model to generate and execute code (Python/SymPy) increases arithmetic accuracy substantially vs. chain-of-thought alone, because the model can delegate exact computation to a deterministic tool.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Llemma: An Open Language Model For Mathematics', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e307.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e307.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Majority voting (self-consistency)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Majority voting / self-consistency ensemble of sampled chain-of-thought outputs</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An intervention where multiple chain-of-thought samples are generated and the most common final answer is taken (majority voting), improving arithmetic/quantitative reasoning performance.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LlemMA</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>7B and 34B (reported results for both)</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>decoder-only transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>multi-step arithmetic and quantitative reasoning (GSM8k, MATH, OCW, MMLU-STEM, SAT)</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>As per the underlying datasets (GSM8k: middle-school integers; MATH: high-school competition problems of varying difficulty)</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Majority voting / self-consistency: sample k generations (k varied by dataset, e.g., k=100 for GSM8k/OCW, k=256 for MATH, k=16 for MMLU-STEM/SAT) with temperature and nucleus sampling, then take majority final answer.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Table 2: LlemMA-34B maj@k: GSM8k 69.3%, MATH 43.1%; LlemMA-7B maj@k: GSM8k 54.0%, MATH 33.5%. These are substantial gains compared to greedy single-run accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>No low-level mechanistic analysis provided; empirically, ensembling diverse chain-of-thought samples reduces variance and raises the probability of finding a correct reasoning path (self-consistency effect).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Majority-voting gains scale with model capability and model size: larger LlemMA improves more and achieves higher ensemble accuracy; sampling budget (k) also affects gains.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against greedy decoding single-sample chain-of-thought and against Minerva reported results; also compared across model sizes.</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>Sampling multiple chain-of-thought solutions and taking a majority vote (self-consistency) significantly improves arithmetic/quantitative reasoning accuracy for LlemMA, with larger models and greater sampling budgets yielding larger gains.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Llemma: An Open Language Model For Mathematics', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e307.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e307.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Formal proving (arithmetic example)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>LlemMA few-shot formal theorem proving involving arithmetic (Isabelle/Lean example: modular arithmetic)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>LlemMA models are evaluated on formalization and tactic-prediction tasks where arithmetic (e.g., modular congruences and integer arithmetic) is required; models generate formal proofs/tactics checked by proof assistants.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LlemMA</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>7B and 34B (results reported for both)</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>decoder-only transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>modular arithmetic (congruences), integer multiplication/addition used inside formal proofs and tactic steps</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td>Typical symbolic integer arithmetic as appears in olympiad/university-level problems; examples include small integer congruences (e.g., mod 5) and algebraic manipulations.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Few-shot informal-to-formal prompting (provide informal statement + informal proof + formal statement to produce formal proof) and formal-to-formal tactic prediction using best-first search with few-shot (3 examples) prompts; proofs checked by Isabelle/Lean.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Informal-to-formal (Isabelle, miniF2F): LlemMA-7b ~20.60% (valid) / 22.13% (test); LlemMA-34b ~21.03% / 21.31% (Table 4). Formal-to-formal (Lean, best-first search N×S attempted): LlemMA-7b 26.23% (with 1×32 search budget), LlemMA-34b 25.82%.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Model can synthesize formal proof steps and call automated tactics/ATPs; gains attributed to inclusion of large formal-mathematics code corpus (AlgebraicStack and proofsteps) during pretraining rather than to an explained low-level arithmetic algorithmic mechanism.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td>Continued pretraining with formal-code data improves few-shot proving relative to Code Llama; scaling from 7B to 34B yields modest changes, not dramatic improvements in formal-proving percentages.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Many theorems remain unproven; proofs are complementary to existing automation (Sledgehammer) rather than exhaustive; success depends on ability to generate exact formal tactics and correct use of automation calls.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Compared against Sledgehammer (Isabelle automation), Code Llama baselines, ReProver and COPRA (retrieval-augmented baselines).</td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>With math- and proof-focused pretraining, LlemMA can few-shot generate formal proofs and tactic steps that solve a nontrivial fraction of formalized arithmetic problems, showing adaptation to formal arithmetic tasks without supervised finetuning.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Llemma: An Open Language Model For Mathematics', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e307.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e307.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic operations, including the types of arithmetic tasks, model properties, performance results, methods used, and any mechanistic insights about how the models solve arithmetic problems.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Memorization / n-gram hit analysis</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>N-gram overlap analysis between test arithmetic problems/solutions and the Proof-Pile-2 training corpus</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Analysis of 20/30-gram overlaps to measure dataset contamination/memorization and its effect on arithmetic benchmark performance.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LlemMA-34B</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>34B</td>
                        </tr>
                        <tr>
                            <td><strong>model_architecture</strong></td>
                            <td>decoder-only transformer</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_operation_type</strong></td>
                            <td>dataset-level analysis covering MATH and GSM8k examples (arithmetical problems/solutions)</td>
                        </tr>
                        <tr>
                            <td><strong>number_range_or_complexity</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>30-gram (and 20-gram) overlap search between test problem/solution sequences and OpenWebMath / AlgebraicStack documents in Proof-Pile-2; manual inspection of sampled hits.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Around 7% of MATH test problem statements and 0.6% of MATH test solutions had 30-gram hits in Proof-Pile-2; manual inspection found many hits were alternative solutions or problem listings rather than verbatim ground-truth solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanistic_insight</strong></td>
                            <td>Empirical finding: n-gram overlap (a nontrivial match) between training data and test examples did not imply a memorized correct answer — model accuracy on 'hit' examples was similar to 'non-hit' examples across difficulty levels, suggesting memorization is not the primary explanation for correct arithmetic outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_scaling</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>failure_modes</strong></td>
                            <td>Memorized sequences are rare; when present they commonly correspond to partial or alternate solutions and do not systematically yield correct model answers.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_finding</strong></td>
                            <td>Direct textual overlap between training corpus and arithmetic evaluation examples is limited and does not explain the observed performance gains; continued pretraining benefits cannot be attributed primarily to simple memorization of solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Llemma: An Open Language Model For Mathematics', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Solving quantitative reasoning problems with language models <em>(Rating: 2)</em></li>
                <li>Finetuned language models are zero-shot learners <em>(Rating: 1)</em></li>
                <li>Chain of Thought Prompting Elicits Reasoning in Large Language Models <em>(Rating: 2)</em></li>
                <li>Self-consistency improves chain of thought reasoning in language models <em>(Rating: 2)</em></li>
                <li>PAL: Program-Aided Language models <em>(Rating: 2)</em></li>
                <li>Training verifiers to solve math word problems <em>(Rating: 1)</em></li>
                <li>Draft, sketch, and prove: Guiding formal theorem provers with informal proofs <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-307",
    "paper_id": "paper-b16c7d45183b9d595ab64301be019741b1528860",
    "extraction_schema_id": "extraction-schema-14",
    "extracted_data": [
        {
            "name_short": "LLEMMA-34B CoT",
            "name_full": "LlemMA 34-billion-parameter model — chain-of-thought evaluation",
            "brief_description": "The 34B-parameter LlemMA model evaluated on multi-step arithmetic and quantitative reasoning benchmarks using few-shot chain-of-thought prompting (greedy decoding).",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LlemMA",
            "model_size": "34B",
            "model_architecture": "decoder-only transformer",
            "arithmetic_operation_type": "multi-step arithmetic and quantitative reasoning including word problems, algebraic manipulations, telescoping sums, number theory (e.g., modular arithmetic), general numeric computations",
            "number_range_or_complexity": "Varied: GSM8k (middle-school integer arithmetic, typically small integers), MATH (high-school competition problems, multi-step symbolic/algebraic reasoning and number theory up to hard Level 5 problems)",
            "method_or_intervention": "Few-shot chain-of-thought prompting (4-shot prompt for MATH as described; 8-shot for GSM8k per Wei et al. prompting), greedy decoding; evaluation also includes majority-voting experiments (reported separately).",
            "performance_result": "Greedy chain-of-thought few-shot: GSM8k 51.5% accuracy, MATH 25.0% accuracy (reported Table 1). Compared to Code Llama baseline, LlemMA-34B improved ~20 percentage points on GSM8k and ~13 points on MATH.",
            "mechanistic_insight": null,
            "performance_scaling": "Performance improves with model size and with continued math-specialized pretraining: LlemMA-34B &gt; LlemMA-7B &gt; Code Llama; continued pretraining on Proof-Pile-2 yielded substantial gains.",
            "failure_modes": "Remains poor on highest-difficulty MATH problems (Level 5 accuracy ~6%); struggles with many hard multi-step contest problems despite improvements; no evidence that n-gram training hits guarantee correct answers.",
            "comparison_baseline": "Compared to Code Llama (7B, 34B), Llama 2 (7B), and Minerva (proprietary; quoted results); comparisons include greedy CoT vs majority voting and different model sizes.",
            "key_finding": "Continued pretraining on a math-focused corpus yields large gains in few-shot chain-of-thought arithmetic performance (34B LlemMA gives strong improvements on GSM8k and MATH over non-specialized baselines), but high-difficulty arithmetic remains challenging and no low-level mechanistic account is provided.",
            "uuid": "e307.0",
            "source_info": {
                "paper_title": "Llemma: An Open Language Model For Mathematics",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "LLEMMA-34B + Python",
            "name_full": "LlemMA 34B evaluated with Python tool use (program-aided arithmetic)",
            "brief_description": "LlemMA models prompted to interleave natural-language solution steps with executable Python/SymPy code to compute answers, evaluated on GSM8k+Python and MATH+Python.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LlemMA",
            "model_size": "34B",
            "model_architecture": "decoder-only transformer",
            "arithmetic_operation_type": "numeric computation (integer arithmetic), floating numeric operations, and symbolic math via SymPy (program-executed arithmetic and algebra)",
            "number_range_or_complexity": "GSM8k+Python produces integer answers matching GSM8k; MATH+Python outputs numeric or SymPy objects — complexity varies with problem, often small-to-moderate integers and symbolic expressions.",
            "method_or_intervention": "Few-shot program-aided prompting: prompts alternate natural-language steps and executable Python code examples; pass@1 evaluation (model generates a single program which is executed).",
            "performance_result": "Pass@1 results (Table 3): LlemMA-34B GSM8k+Python 62.6% pass@1, MATH+Python 27.1% pass@1. These are higher than the analogous greedy chain-of-thought (non-tool) results.",
            "mechanistic_insight": "Tool use enables the model to offload arithmetic execution to a deterministic interpreter (the model generates code which is executed to obtain exact numeric or symbolic answers), improving correctness for computation-heavy substeps.",
            "performance_scaling": "Tool-aided performance improves with model size and with math-focused pretraining; LlemMA-34B outperforms Code Llama 34B and LlemMA-7B in the tool-use setting.",
            "failure_modes": "Not detailed beyond overall lower accuracy on hardest MATH problems; failures can occur if generated code is incorrect or non-executable, or if the model fails to decompose the problem into correct computational steps.",
            "comparison_baseline": "Compared against Code Llama (7B and 34B) using the same tool-use prompts; also compared to non-tool chain-of-thought performance to show benefit of tool use.",
            "key_finding": "Allowing the model to generate and execute code (Python/SymPy) increases arithmetic accuracy substantially vs. chain-of-thought alone, because the model can delegate exact computation to a deterministic tool.",
            "uuid": "e307.1",
            "source_info": {
                "paper_title": "Llemma: An Open Language Model For Mathematics",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Majority voting (self-consistency)",
            "name_full": "Majority voting / self-consistency ensemble of sampled chain-of-thought outputs",
            "brief_description": "An intervention where multiple chain-of-thought samples are generated and the most common final answer is taken (majority voting), improving arithmetic/quantitative reasoning performance.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LlemMA",
            "model_size": "7B and 34B (reported results for both)",
            "model_architecture": "decoder-only transformer",
            "arithmetic_operation_type": "multi-step arithmetic and quantitative reasoning (GSM8k, MATH, OCW, MMLU-STEM, SAT)",
            "number_range_or_complexity": "As per the underlying datasets (GSM8k: middle-school integers; MATH: high-school competition problems of varying difficulty)",
            "method_or_intervention": "Majority voting / self-consistency: sample k generations (k varied by dataset, e.g., k=100 for GSM8k/OCW, k=256 for MATH, k=16 for MMLU-STEM/SAT) with temperature and nucleus sampling, then take majority final answer.",
            "performance_result": "Table 2: LlemMA-34B maj@k: GSM8k 69.3%, MATH 43.1%; LlemMA-7B maj@k: GSM8k 54.0%, MATH 33.5%. These are substantial gains compared to greedy single-run accuracy.",
            "mechanistic_insight": "No low-level mechanistic analysis provided; empirically, ensembling diverse chain-of-thought samples reduces variance and raises the probability of finding a correct reasoning path (self-consistency effect).",
            "performance_scaling": "Majority-voting gains scale with model capability and model size: larger LlemMA improves more and achieves higher ensemble accuracy; sampling budget (k) also affects gains.",
            "failure_modes": null,
            "comparison_baseline": "Compared against greedy decoding single-sample chain-of-thought and against Minerva reported results; also compared across model sizes.",
            "key_finding": "Sampling multiple chain-of-thought solutions and taking a majority vote (self-consistency) significantly improves arithmetic/quantitative reasoning accuracy for LlemMA, with larger models and greater sampling budgets yielding larger gains.",
            "uuid": "e307.2",
            "source_info": {
                "paper_title": "Llemma: An Open Language Model For Mathematics",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Formal proving (arithmetic example)",
            "name_full": "LlemMA few-shot formal theorem proving involving arithmetic (Isabelle/Lean example: modular arithmetic)",
            "brief_description": "LlemMA models are evaluated on formalization and tactic-prediction tasks where arithmetic (e.g., modular congruences and integer arithmetic) is required; models generate formal proofs/tactics checked by proof assistants.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LlemMA",
            "model_size": "7B and 34B (results reported for both)",
            "model_architecture": "decoder-only transformer",
            "arithmetic_operation_type": "modular arithmetic (congruences), integer multiplication/addition used inside formal proofs and tactic steps",
            "number_range_or_complexity": "Typical symbolic integer arithmetic as appears in olympiad/university-level problems; examples include small integer congruences (e.g., mod 5) and algebraic manipulations.",
            "method_or_intervention": "Few-shot informal-to-formal prompting (provide informal statement + informal proof + formal statement to produce formal proof) and formal-to-formal tactic prediction using best-first search with few-shot (3 examples) prompts; proofs checked by Isabelle/Lean.",
            "performance_result": "Informal-to-formal (Isabelle, miniF2F): LlemMA-7b ~20.60% (valid) / 22.13% (test); LlemMA-34b ~21.03% / 21.31% (Table 4). Formal-to-formal (Lean, best-first search N×S attempted): LlemMA-7b 26.23% (with 1×32 search budget), LlemMA-34b 25.82%.",
            "mechanistic_insight": "Model can synthesize formal proof steps and call automated tactics/ATPs; gains attributed to inclusion of large formal-mathematics code corpus (AlgebraicStack and proofsteps) during pretraining rather than to an explained low-level arithmetic algorithmic mechanism.",
            "performance_scaling": "Continued pretraining with formal-code data improves few-shot proving relative to Code Llama; scaling from 7B to 34B yields modest changes, not dramatic improvements in formal-proving percentages.",
            "failure_modes": "Many theorems remain unproven; proofs are complementary to existing automation (Sledgehammer) rather than exhaustive; success depends on ability to generate exact formal tactics and correct use of automation calls.",
            "comparison_baseline": "Compared against Sledgehammer (Isabelle automation), Code Llama baselines, ReProver and COPRA (retrieval-augmented baselines).",
            "key_finding": "With math- and proof-focused pretraining, LlemMA can few-shot generate formal proofs and tactic steps that solve a nontrivial fraction of formalized arithmetic problems, showing adaptation to formal arithmetic tasks without supervised finetuning.",
            "uuid": "e307.3",
            "source_info": {
                "paper_title": "Llemma: An Open Language Model For Mathematics",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Memorization / n-gram hit analysis",
            "name_full": "N-gram overlap analysis between test arithmetic problems/solutions and the Proof-Pile-2 training corpus",
            "brief_description": "Analysis of 20/30-gram overlaps to measure dataset contamination/memorization and its effect on arithmetic benchmark performance.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LlemMA-34B",
            "model_size": "34B",
            "model_architecture": "decoder-only transformer",
            "arithmetic_operation_type": "dataset-level analysis covering MATH and GSM8k examples (arithmetical problems/solutions)",
            "number_range_or_complexity": null,
            "method_or_intervention": "30-gram (and 20-gram) overlap search between test problem/solution sequences and OpenWebMath / AlgebraicStack documents in Proof-Pile-2; manual inspection of sampled hits.",
            "performance_result": "Around 7% of MATH test problem statements and 0.6% of MATH test solutions had 30-gram hits in Proof-Pile-2; manual inspection found many hits were alternative solutions or problem listings rather than verbatim ground-truth solutions.",
            "mechanistic_insight": "Empirical finding: n-gram overlap (a nontrivial match) between training data and test examples did not imply a memorized correct answer — model accuracy on 'hit' examples was similar to 'non-hit' examples across difficulty levels, suggesting memorization is not the primary explanation for correct arithmetic outputs.",
            "performance_scaling": null,
            "failure_modes": "Memorized sequences are rare; when present they commonly correspond to partial or alternate solutions and do not systematically yield correct model answers.",
            "comparison_baseline": null,
            "key_finding": "Direct textual overlap between training corpus and arithmetic evaluation examples is limited and does not explain the observed performance gains; continued pretraining benefits cannot be attributed primarily to simple memorization of solutions.",
            "uuid": "e307.4",
            "source_info": {
                "paper_title": "Llemma: An Open Language Model For Mathematics",
                "publication_date_yy_mm": "2023-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Solving quantitative reasoning problems with language models",
            "rating": 2
        },
        {
            "paper_title": "Finetuned language models are zero-shot learners",
            "rating": 1
        },
        {
            "paper_title": "Chain of Thought Prompting Elicits Reasoning in Large Language Models",
            "rating": 2
        },
        {
            "paper_title": "Self-consistency improves chain of thought reasoning in language models",
            "rating": 2
        },
        {
            "paper_title": "PAL: Program-Aided Language models",
            "rating": 2
        },
        {
            "paper_title": "Training verifiers to solve math word problems",
            "rating": 1
        },
        {
            "paper_title": "Draft, sketch, and prove: Guiding formal theorem provers with informal proofs",
            "rating": 2
        }
    ],
    "cost": 0.01705725,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>LLEMMA: AN OPEN LANGUAGE MODEL FOR MATHEMATICS</h1>
<p>Zhangir Azerbayev ${ }^{1,2}$ Hailey Schoelkopf ${ }^{2}$ Keiran Paster ${ }^{3,4}$<br>Marco Dos Santos ${ }^{5}$ Stephen McAleer ${ }^{6}$ Albert Q. Jiang ${ }^{5}$ Jia Deng ${ }^{1}$<br>Stella Biderman ${ }^{2}$ Sean Welleck ${ }^{6,7}$<br>${ }^{1}$ Princeton University ${ }^{2}$ EleutherAI ${ }^{3}$ University of Toronto ${ }^{4}$ Vector Institute<br>${ }^{5}$ University of Cambridge ${ }^{6}$ Carnegie Mellon University ${ }^{7}$ University of Washington</p>
<h4>Abstract</h4>
<p>We present Llemma, a large language model for mathematics. We continue pretraining Code Llama on Proof-Pile-2, a mixture of scientific papers, web data containing mathematics, and mathematical code, yielding Llemma. On the MATH benchmark Llemma outperforms all known open base models, as well as the unreleased Minerva model suite on an equi-parameter basis. Moreover, Llemma is capable of tool use and formal theorem proving without any further finetuning. We openly release all artifacts, including 7 billion and 34 billion parameter models, the Proof-Pile-2, and code to replicate our experiments. ${ }^{1}$</p>
<h2>1 INTRODUCTION</h2>
<p>Language models trained on diverse mixtures of text display remarkably general language understanding and generation capabilities (Brown et al., 2020; Chowdhery et al., 2022), serving as base models that are adapted to a wide range of applications (Raffel et al., 2023). Applications such as open-ended dialogue (Thoppilan et al., 2022; Touvron et al., 2023) or instruction following (Ouyang et al., 2022; Wei et al., 2022) require balanced performance across the entire distribution of natural text, thus favoring generalist models. However, if we seek to maximize performance within one domain, such as medicine (Singhal et al., 2022; 2023), finance (Wu et al., 2023), or science (Taylor et al., 2022), a domain-specific language model may offer superior capabilities for a given computational cost, or lower computational cost for a given level of capability.
In this work, we train a domain-specific language model for mathematics. We have several motivations
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Continued pretraining on Proof-Pile-2 yields Llemma, a base model with improved mathematical capabilities.
for doing so. First, solving mathematical problems requires pattern matching against a large body of specialized prior knowledge, thus serving as an ideal setting for domain adaptation. Second, mathematical reasoning is in itself a central AI task, its study dating back to at least Gelernter (1959) and Wang (1960) and continuing to today (Lu et al., 2023). Third, language models capable of strong mathematical reasoning are upstream of a number of research topics, such as reward modeling (Uesato et al., 2022; Lightman et al., 2023), reinforcement learning for reasoning (Polu et al., 2022; Lample et al., 2022), and algorithmic reasoning (Zhou et al., 2022; Zhang et al., 2023).</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Although domain-specific models for mathematics have been trained in the past, they have either been closed access (Lewkowycz et al., 2022), limiting their ability to become a platform for further research, or have lagged far behind the closed access state-of-the-art (Azerbayev et al., 2023).</p>
<p>We present a recipe for adapting a language model to mathematics through continued pretraining (Lewkowycz et al., 2022; Rozière et al., 2023) on Proof-Pile-2, a diverse mixture of math-related text and code. Applying the recipe to Code Llama (Rozière et al., 2023) yields LlemMA: 7 billion and 34 billion parameter base language models with substantially improved mathematical capabilities.</p>
<p>Specifically, our contributions are as follows:</p>
<ol>
<li>We train and release the LlemMA models: 7B and 34B parameter language models specialized for mathematics. The LlemMA models are a new state-of-the-art for publicly released base models on MATH (Lewkowycz et al., 2022).</li>
<li>We release the AlgebraicStack, a dataset of 11B tokens of code specifically related to mathematics.</li>
<li>We demonstrate that LlemMA is capable of using computational tools to solve mathematical problems, namely, the Python interpreter and formal theorem provers.</li>
<li>Unlike prior mathematics language models such as Minerva (Lewkowycz et al., 2022), the LlemMA models are open access and we open source our training data and code. This allows LlemMA to serve as a platform for future research in mathematical reasoning.</li>
</ol>
<p>Our work builds on findings in Minerva (Lewkowycz et al., 2022), but differs in several ways: (1) LlemMA's training and evaluation covers a wider range of data and tasks, notably code data (e.g., the AlgebraicStack), tool use, and formal mathematics; (2) our work only depends on publicly accessible tools and data; (3) we provide new analyses related to the continued training data mixture, memorization, and additional supervised finetuning; (4) we make all artifacts publicly available.</p>
<h1>2 APPROACH</h1>
<p>LlemMA models are 7 billion and 34 billion parameter language models specialized for mathematics. Our approach is to continue pretraining Code Llama (Rozière et al., 2023) on the Proof-Pile-2.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Adaptation tokens</th>
<th style="text-align: center;">Open</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Minerva-8b</td>
<td style="text-align: center;">164 B</td>
<td style="text-align: center;">$\boldsymbol{x}$</td>
</tr>
<tr>
<td style="text-align: left;">Minerva-62b</td>
<td style="text-align: center;">109 B</td>
<td style="text-align: center;">$\boldsymbol{x}$</td>
</tr>
<tr>
<td style="text-align: left;">LlemMA-7b (ours)</td>
<td style="text-align: center;">200 B</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">LlemMA-34b (ours)</td>
<td style="text-align: center;">50 B</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">Dataset</th>
<th style="text-align: center;">Tokens</th>
<th style="text-align: center;">Open</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Minerva Dataset</td>
<td style="text-align: center;">38.5 B</td>
<td style="text-align: center;">$\boldsymbol{x}$</td>
</tr>
<tr>
<td style="text-align: left;">Proof-Pile-2 (ours)</td>
<td style="text-align: center;">55 B</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">Code (AlgebraicStack)</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">OpenWebMath (Paster et al., 2023))</td>
<td style="text-align: center;">15 B</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">ArXiv (Computer, 2023))</td>
<td style="text-align: center;">29 B</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
</tbody>
</table>
<p>Figure 2: Comparison of LlemMA and Minerva training</p>
<h3>2.1 Data: Proof-Pile-2</h3>
<p>We form the Proof-Pile-2, a 55B-token mixture of scientific papers, web data containing mathematics, and mathematical code. With the exception of the Lean proofsteps subset (see Appendix B), the Proof-Pile-2 has a knowledge cutoff of April 2023.</p>
<p>Code. Computational tools such as numerical simulations, computer algebra systems, and formal theorem provers are of ever increasing importance to mathematicians (Avigad, 2018). Motivated by this fact, we create AlgebraicStack, an 11B-token dataset of source code from 17 languages, spanning numerical, symbolic, and formal math. The dataset consists of filtered code from the Stack (Kocetkov et al., 2022), public GitHub repositories, and formal proofstep data. Table 9 shows the number of tokens by language in AlgebraicStack. See Appendix B. 1 for further details on AlgebraicStack.</p>
<p>Web data. We use OpenWebMath (Paster et al., 2023), a 15B-token dataset of high-quality web pages filtered for mathematical content. OpenWebMath filters CommonCrawl web pages based</p>
<p>on math-related keywords and a classifier-based math score, preserves mathematical formatting (e.g., LaTeX, AsciiMath), and includes additional quality filters (e.g., perplexity, domain, length) and near-deduplication. Refer to Paster et al. (2023) for a full description of OpenWebMath.</p>
<p>Scientific papers. We use the ArXiv subset of RedPajama (Computer, 2023), an open-access reproduction of the LLaMA training dataset. The ArXiv subset contains 29B tokens.</p>
<p>General natural language and code data. Following Lewkowycz et al. (2022), our training mixture consists of a small amount of general domain data, which functions as a form of regularization. Since the pretraining dataset for LLaMA 2 is undisclosed, we use the Pile (Gao et al., 2020; Biderman et al., 2022) as a surrogate training dataset. We set 95% of our training mixture to be the Proof-Pile-2, 2% to be from the Pile (with ArXiv removed, as it is separately in Proof-Pile-2), and 3% to be the GitHub subset of RedPajama (Computer, 2023).</p>
<p>Further information on dataset composition and a datasheet are in Appendix B and Appendix E, respectively. We publicly release Proof-Pile-2 at hf.co/datasets/EleutherAI/proof-pile-2.</p>
<h1>2.2 Model and Training</h1>
<p>Each model is initialized from Code Llama (Rozière et al., 2023). Code Llama models are decoderonly transformer language models initialized from Llama 2 (Touvron et al., 2023) and further trained on 500B tokens of code. We continue training the Code Llama models on Proof-Pile-2 using a standard autoregressive language modeling objective. We train the 7B model for 200B tokens, and the 34B model for 50B tokens.</p>
<p>We train all models in bfloat16 mixed precision using the GPT-NeoX library (Andonian et al., 2023) across 256 A100 40GB GPUs. We use Tensor Parallelism (Shoeybi et al., 2019) with a world size of 2 for LlemMA-7B , and a world size of 8 for LlemMA-34B, alongside ZeRO Stage 1 sharded optimizer states (Rajbhandari et al., 2020) across Data Parallel (Goyal et al., 2017) replicas. We use Flash Attention 2 (Dao, 2023) to improve throughput and further reduce memory requirements.</p>
<p>LlemMA 7B is trained for 42,000 steps with a global batch size of 4 million tokens and a 4096 token context length. This corresponds to roughly 23,000 A100-hours. The learning rate is warmed up to $1 \cdot 10^{-4}$ over 500 steps, then set to cosine decay to $1 / 30$ th of the maximum learning rate over 48,000 steps. The reason for the discrepancy between the number of training steps and the scheduler length is that we planned to train for 48,000 steps, but encountered NaN losses after step 42,000 , likely caused by unstable optimization or hardware failures (Elsen et al., 2023).</p>
<p>LlemMA 34B is trained for 12,000 steps with a global batch size of 4 million tokens and a 4096 context length. This corresponds to roughly 47,000 A100-hours. The learning rate is warmed up to $5 \cdot 10^{-5}$ over 500 steps, then decayed to $1 / 30$ th the peak learning rate.</p>
<p>Before training LlemMA 7B, we contract the RoPE (Su et al., 2022) base period of the Code Llama 7B initialization from $\theta=1,000,000$ to $\theta=10,000$. This is so that the long context finetuning procedure described in Peng et al. (2023)and Rozière et al. (2023) can be repeated on the trained LlemMA 7B (we leave actually doing so to future work). Due to compute constraints, we were unable to verify that training LlemMA 34B with a contracted RoPE base period did not come with a performance penalty, therefore for that model we preserved $\theta=1,000,000$.</p>
<h2>3 Evaluation</h2>
<p>Our goal is to evaluate LlemMA as a base model for mathematical text. To this end, we compare LlemMA models using few-shot evaluation (Brown et al., 2020), and primarily focus on state-of-theart models that have not been finetuned on supervised examples for the task. First, we evaluate the model's ability to solve mathematics problems using chain of thought reasoning (Wei et al., 2023) and majority voting (Wang et al., 2023). Our evaluations include MATH (Hendrycks et al., 2021b) and GSM8k (Cobbe et al., 2021), the de-facto standard benchmarks for evaluating quantitative reasoning in language models (Lewkowycz et al., 2022). Second, we explore few-shot tool use and formal theorem proving. Third, we study the effects of memorization and the data mixture. Appendix G contains a preliminary study of supervised finetuning with LlemMA.</p>
<h1>3.1 CHAIN-OF-THOUGHT MATHEMATICAL PROBLEM SOLVING</h1>
<p>These tasks involve generating self-contained text solutions to problems expressed in $\mathrm{ET}_{\mathrm{E}} \mathrm{X}$ or natural language, without using external tools (Lewkowycz et al., 2022). We use the following evaluation:</p>
<ul>
<li>MATH (Hendrycks et al., 2021b), a dataset with 12.5 k problems ( 5 k evaluation) from high-school math competitions. Given a problem statement, the model generates a $\mathrm{ET}_{\mathrm{E}} \mathrm{X}$ solution and an answer that must match a reference answer. We follow a similar task implementation to Lewkowycz et al. (2022), using their four-example prompt and evaluating answers for exact string match or SymPy equivalence.</li>
<li>GSM8k (Cobbe et al., 2021), a dataset of middle-school level math word problems. We use the 8 -shot prompt from Wei et al. (2023), as Lewkowycz et al. (2022) do not specify their evaluation prompt or number of few-shot examples.</li>
<li>OCWCourses (Lewkowycz et al., 2022), a collection of undergraduate-level STEM problems harvested from MIT's OpenCourseWare. We use the four-example prompt provided by (Lewkowycz et al., 2022).</li>
<li>MMLU-STEM (Hendrycks et al., 2021a), a subset of 18 out of 57 subjects in the MMLU benchmark. We follow Lewkowycz et al. (2022) and use their provided four-example chain-ofthought prompt.</li>
<li>SAT, we create a dataset consisting of the 32 math questions that do not contain figures from the May 2023 College Board SAT examination, which is after our model's knowledge cutoff.</li>
</ul>
<p>Input:
Let $f(r)=\sum_{j=2}^{2008} \frac{1}{j^{k}}=\frac{1}{2^{r}}+\frac{1}{3^{r}}+\cdots+\frac{1}{2008^{r}}$. Find $\sum_{k=2}^{\infty} f(k)$.
LLEMMA 34B solution:
We have</p>
<p>$$
\begin{aligned}
\sum_{k=2}^{\infty} f(k) &amp; =\sum_{k=2}^{\infty} \sum_{j=2}^{2008} \frac{1}{j^{k}}=\sum_{j=2}^{2008} \sum_{k=2}^{\infty} \frac{1}{j^{k}}=\sum_{j=2}^{2008} \frac{1}{j^{2}} \sum_{k=0}^{\infty} \frac{1}{j^{k}}=\sum_{j=2}^{2008} \frac{1}{j^{2}} \frac{1}{1-\frac{1}{j}} \
&amp; =\sum_{j=2}^{2008} \frac{1}{j(j-1)}=\sum_{j=2}^{2008}\left(\frac{1}{j-1}-\frac{1}{j}\right) \
&amp; =\left(\frac{1}{1}-\frac{1}{2}\right)+\left(\frac{1}{2}-\frac{1}{3}\right)+\cdots+\left(\frac{1}{2007}-\frac{1}{2008}\right) \
&amp; =1-\frac{1}{2008} \
&amp; =\left[\frac{2007}{2008}\right]
\end{aligned}
$$</p>
<p>Final Answer: The final answer is $\frac{2007}{2008}$.</p>
<p>Figure 3: Example of a LlemMA 34B solution to a MATH (Hendrycks et al., 2021a) problem. This problem is tagged with difficulty level 5, the highest in MATH. The model was conditioned on the 4 -shot prompt described in subsection 3.1, and the solution was produced by greedy decoding. The model had to apply two nontrivial steps to solve this problem: (1) noticing that swapping the order of summation simplifies the problem, and (2) noticing that the resulting sum telescopes.</p>
<p>We compare with Minerva (Lewkowycz et al., 2022), which continued pretraining the PaLM language model on a dataset of technical content; Code Llama, the initialization of LlemMA's continued pretraining; and Llama 2, the initialization of Code Llama's continued pretraining on code. For open access models, we report scores computed using our evaluation suite, which is implemented as a fork of the Language Model Evaluation Harness (Gao et al., 2021). For Minerva models, we report benchmark scores from Lewkowycz et al. (2022).</p>
<p>Results. LLEMMA’s continued pretraining on Proof-Pile-2 improves few-shot performance on the five mathematical benchmarks. LLEMMA 34B improves over Code Llama by 20 percentage points on GSM8k and 13 points on MATH, and LLEMMA 7B outperforms the proprietary Minerva model. Our approach also outperforms all open-weight language models at the time of writing. We conclude that continued pretraining on Proof-Pile-2 is effective for improving a pretrained model’s ability to perform mathematical problem solving.</p>
<p>LLEMMA is pretrained on a diverse distribution of mathematics-related data, and is not tuned for a particular task. Therefore, we expect that LLEMMA can adapt to many other tasks via task-specific finetuning and few-shot prompting.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>GSM8k</th>
<th>OCW</th>
<th>MMLU-STEM</th>
<th>SAT</th>
<th>MATH</th>
</tr>
</thead>
<tbody>
<tr>
<td>Llama 2</td>
<td>7B</td>
<td>11.8%</td>
<td>3.7%</td>
<td>29.9%</td>
<td>25.0%</td>
<td>3.2%</td>
</tr>
<tr>
<td>Code Llama</td>
<td>7B</td>
<td>10.5%</td>
<td>4.4%</td>
<td>25.1%</td>
<td>9.4%</td>
<td>4.5%</td>
</tr>
<tr>
<td>Minerva</td>
<td>8B</td>
<td>16.2%</td>
<td>7.7%</td>
<td>35.6%</td>
<td>-</td>
<td>14.1%</td>
</tr>
<tr>
<td>LLEMMA</td>
<td>7B</td>
<td>36.4%</td>
<td>7.7%</td>
<td>37.7%</td>
<td>53.1%</td>
<td>18.0%</td>
</tr>
<tr>
<td>Code Llama</td>
<td>34B</td>
<td>29.6%</td>
<td>7.0%</td>
<td>40.5%</td>
<td>40.6%</td>
<td>12.2%</td>
</tr>
<tr>
<td>LLEMMA</td>
<td>34B</td>
<td>51.5%</td>
<td>11.8%</td>
<td>49.0%</td>
<td>71.9%</td>
<td>25.0%</td>
</tr>
<tr>
<td>Minerva</td>
<td>62B</td>
<td>52.4%</td>
<td>12.0%</td>
<td>53.9%</td>
<td>-</td>
<td>27.6%</td>
</tr>
<tr>
<td>Minerva</td>
<td>540B</td>
<td>58.8%</td>
<td>17.6%</td>
<td>63.9%</td>
<td>-</td>
<td>33.6%</td>
</tr>
</tbody>
</table>
<p>Table 1: Results on our five chain-of-thought reasoning tasks with samples generated via greedy decoding. Minerva results are quoted from Lewkowycz et al. (2022). Note that CodeLlama 7B performs worse than random guessing (25%) on MMLU and SAT, largely due to failing to conclude its chain of thought with a valid answer.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>GSM8k</th>
<th>OCW</th>
<th>MMLU-STEM</th>
<th>SAT</th>
<th>MATH</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>maj@k</td>
<td>maj@k</td>
<td>maj@k</td>
<td>maj@k</td>
<td>maj@k</td>
</tr>
<tr>
<td>Minerva</td>
<td>8B</td>
<td>28.4%</td>
<td>12.5%</td>
<td>43.4%</td>
<td>-</td>
<td>25.4%</td>
</tr>
<tr>
<td>LLEMMA</td>
<td>7B</td>
<td>54.0%</td>
<td>14.3%</td>
<td>49.9%</td>
<td>78.1%</td>
<td>33.5%</td>
</tr>
<tr>
<td>LLEMMA</td>
<td>34B</td>
<td>69.3%</td>
<td>18.4%</td>
<td>59.7%</td>
<td>81.3%</td>
<td>43.1%</td>
</tr>
<tr>
<td>Minerva</td>
<td>62B</td>
<td>68.5%</td>
<td>23.5%</td>
<td>63.5%</td>
<td>-</td>
<td>43.4%</td>
</tr>
<tr>
<td>Minerva</td>
<td>540B</td>
<td>78.5%</td>
<td>30.8%</td>
<td>75.0%</td>
<td>-</td>
<td>50.3%</td>
</tr>
</tbody>
</table>
<p>Table 2: Majority voting results for LLEMMA and Minerva. Minerva results are quoted from Lewkowycz et al. (2022). Voting is done with $k=256$ for MATH, $k=100$ for GSM8k and OCW, and $k=16$ for MMLU-STEM and SAT. We sample with temperature $T=0.6$ for $k=256$ and $k=100$ and $T=0.3$ for $k=16$, and use nucleus sampling with $p=0.95$ (Holtzman et al., 2020). Due to compute constraints, we do not calculate majority voting scores for Llama 2 and Code Llama.</p>
<h1>3.2 MATHEMATICAL PROBLEM SOLVING WITH TOOL USE</h1>
<p>These tasks involve solving problems with access to computational tools. We evaluate the following:</p>
<ul>
<li>MATH+Python, the model is prompted to alternately describe a solution step in natural language, then execute that step with code. The final answer is a program that executes to a numeric type or a SymPy object. Our few-shot prompt includes examples that use built-in numeric operations, the math module, and SymPy.</li>
<li>GSM8k+Python, solving a GSM8k word problem by writing a Python program that executes to an integer answer. We use the prompt from Gao et al. (2023).</li>
</ul>
<p>Results. As seen in Table 3, LLEMMA improves over Code Llama on both tasks. Its performance on MATH and GSM8k with tools is also higher than its performance on these datasets without tools.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: center;">GSM8k+Python <br> pass@1</th>
<th style="text-align: center;">MATH+Python <br> pass@1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Code Llama</td>
<td style="text-align: left;">7B</td>
<td style="text-align: center;">$27.1 \%$</td>
<td style="text-align: center;">$17.2 \%$</td>
</tr>
<tr>
<td style="text-align: left;">LLEMMA</td>
<td style="text-align: left;">7B</td>
<td style="text-align: center;">$40.1 \%$</td>
<td style="text-align: center;">$21.5 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Code Llama</td>
<td style="text-align: left;">34B</td>
<td style="text-align: center;">$52.7 \%$</td>
<td style="text-align: center;">$23.5 \%$</td>
</tr>
<tr>
<td style="text-align: left;">LLEMMA</td>
<td style="text-align: left;">34B</td>
<td style="text-align: center;">$62.6 \%$</td>
<td style="text-align: center;">$27.1 \%$</td>
</tr>
</tbody>
</table>
<p>Table 3: Mathematical problem solving with tool use.</p>
<h1>3.3 FORMAL MATHEMATICS</h1>
<p>Interactive proof assistants such as Lean (de Moura et al., 2015), Isabelle (Wenzel et al., 2008), and Coq (Paulin-Mohring, 1989a;b) express mathematics in programming languages that allow for verification. These languages are data scarce compared to mainstream languages, especially in the context of pretraining. For instance, the Stack dataset used to pretrain language models in the BigCode project (Allal et al., 2023) has over 700 gigabytes of Python, compared to 322 megabytes of Lean. Proof assistants also require models to leverage information that is not present in raw source code, such as goal states that contain information about each step of a proof.</p>
<p>Problem (MATH Number theory 185): When a number is divided by 5, the remainder is 3. What is the remainder when twice the number is divided by 5? Show that it is 1.</p>
<p>Human-written informal proof: If our number is $n$, then $n \equiv 3(\bmod 5)$. This tells us that</p>
<p>$$
2 n=n+n \equiv 3+3 \equiv 1 \quad(\bmod 5)
$$</p>
<p>The remainder is 1 when the number is divided by 5 .</p>
<h2>Informal-to-formal (Isabelle): <br> {Problem, human-written informal proof} <br> theorem mathd_numbertheory_185: <br> fixes $n$ : :nat <br> assumes " $n \bmod 5=3$ " <br> shows " $(2+n) \bmod 5=1$ " <br> proof - <br> have " $2 * n=n+n$ " <ATP> <br> also have "... $\bmod 5=$ <br> ( $n \bmod 5+n \bmod 5) \bmod 5$ " <ATP> <br> also have "... $=(3+3) \bmod 5$ " <br> using assms <ATP> <br> also have "...=1" <ATP> <br> finally show ?thesis <ATP> <br> qed</h2>
<h2>Formal-to-formal (Lean 4):</h2>
<div class="codehilite"><pre><span></span><code><span class="n">theorem</span><span class="w"> </span><span class="n">mathd_numbertheory_185</span>
<span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">h0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">by</span>
<span class="o">--</span><span class="w"> </span><span class="n">INPUT</span><span class="w"> </span><span class="p">(</span><span class="n">step</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">:</span>
<span class="o">--</span><span class="w"> </span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="n">N</span>
<span class="o">--</span><span class="w"> </span><span class="n">h0</span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="o">--</span><span class="w"> </span><span class="p">\</span><span class="n">vdash</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="n">rw</span><span class="w"> </span><span class="p">[</span><span class="n">mul_mod</span><span class="o">,</span><span class="w"> </span><span class="n">h0</span><span class="p">]</span>
<span class="o">--</span><span class="w"> </span><span class="n">INPUT</span><span class="w"> </span><span class="p">(</span><span class="n">step</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">:</span>
<span class="o">--</span><span class="w"> </span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="n">N</span>
<span class="o">--</span><span class="w"> </span><span class="n">h0</span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="o">--</span><span class="w"> </span><span class="p">\</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="p">[</span><span class="n">h0</span><span class="o">,</span><span class="w"> </span><span class="n">mul_one</span><span class="p">]</span>
</code></pre></div>

<p>Figure 4: Example formal proofs from LlemMA-7b. Left: The model is given a problem, informal proof, and formal statement, following Jiang et al. (2023). It generates a formal proof (starting with proof -) containing Isabelle code and calls to automation (shown as $<A T P>$ ). Right: The model is given a proof state, visualized as a grey comment, and generates the subsequent step (e.g. rw [ . . ).</p>
<p>Proof-Pile-2's AlgebraicStack contains over 1.5 billion tokens of formal mathematics data, including proof states extracted from Lean and Isabelle formalizations. While a full investigation of formal math is outside the scope of this paper, we evaluate LlemMA few-shot on two tasks:</p>
<ul>
<li>Informal-to-formal proving (Jiang et al., 2023), the task of generating a formal proof, given a formal statement, an informal $\mathrm{LA}<em _mathrm_E="\mathrm{E">{\mathrm{E}} \mathrm{X}$ statement, and an informal $\mathrm{LA}</em>$ proof. The formal proof is checked by the proof assistant. We use the Isabelle proof assistant and evaluate on miniF2F (Zheng et al., 2021), a benchmark consisting of problem statements from Olympiads and undergraduate coursework. For the prompt, we use 11 (formal statement, informal statement, informal proof, formal proof) examples from Jiang et al. (2023), selecting 7 examples for number theory problems, and 6 examples for all others. We generate a single proof with greedy decoding.}} \mathrm{X</li>
<li>Formal-to-formal proving (e.g., Polu \&amp; Sutskever (2020)), the task of proving a formal statement by generating a sequence of proof steps (tactics). At each step, the input is a state $x_{t}$ given by the proof assistant, and the language model's task is to generate a proof step $y_{t}$ (a sequence of code). The proof step is checked by the proof assistant, yielding a new state $x_{t+1}$ or an error message. The process continues, stopping if a proof is completed or a timeout is reached. We prompt the model using three $\left(x_{t}, y_{t}\right)$ examples. We evaluate on miniF2F (Zheng et al., 2021) using the Lean 4 proof assistant, and use a standard best first search. See Appendix D for more details.</li>
</ul>
<p>Results. As seen in Table 4, Llemma's continued pretraining on Proof-Pile-2 improved few-shot performance on the two formal theorem proving tasks.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Method</th>
<th style="text-align: center;">Informal-to-formal</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">miniF2F-valid</td>
<td style="text-align: center;">miniF2F-test</td>
</tr>
<tr>
<td style="text-align: left;">Sledgehammer</td>
<td style="text-align: center;">$14.72 \%$</td>
<td style="text-align: center;">$20.49 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Code Llama 7b</td>
<td style="text-align: center;">$16.31 \%$</td>
<td style="text-align: center;">$17.62 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Code Llama 34b</td>
<td style="text-align: center;">$18.45 \%$</td>
<td style="text-align: center;">$18.03 \%$</td>
</tr>
<tr>
<td style="text-align: left;">LlemMA-7b</td>
<td style="text-align: center;">$20.60 \%$</td>
<td style="text-align: center;">$22.13 \%$</td>
</tr>
<tr>
<td style="text-align: left;">LlemMA-34b</td>
<td style="text-align: center;">$21.03 \%$</td>
<td style="text-align: center;">$21.31 \%$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">Method</th>
<th style="text-align: center;">Formal-to-formal</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: center;">Search</td>
<td style="text-align: center;">miniF2F-test</td>
</tr>
<tr>
<td style="text-align: left;">ReProver (fine-tuned)</td>
<td style="text-align: center;">$1 \times 64$</td>
<td style="text-align: center;">$26.50 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Code Llama 7b</td>
<td style="text-align: center;">$1 \times 32$</td>
<td style="text-align: center;">$20.49 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Code Llama 34b</td>
<td style="text-align: center;">$1 \times 32$</td>
<td style="text-align: center;">$22.13 \%$</td>
</tr>
<tr>
<td style="text-align: left;">COPRA (GPT-4)</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">$23.36 \%$</td>
</tr>
<tr>
<td style="text-align: left;">LlemMA-7b</td>
<td style="text-align: center;">$1 \times 32$</td>
<td style="text-align: center;">$26.23 \%$</td>
</tr>
<tr>
<td style="text-align: left;">LlemMA-34b</td>
<td style="text-align: center;">$1 \times 32$</td>
<td style="text-align: center;">$25.82 \%$</td>
</tr>
</tbody>
</table>
<p>Table 4: Formal theorem proving tasks. Left: Informal-to-formal proving in Isabelle, showing the percentage of proven theorems with greedy decoding. Right: Formal-to-formal proving in Lean, showing the percentage of proven theorems with the given number of attempts $\times$ generations-periteration of best first search, and a 10-minute timeout. Sledgehammer (Paulson \&amp; Nipkow, 2023) is built-in Isabelle automation. ReProver (Yang et al., 2023) is a supervised and retrieval-augmented model. COPRA (Thakur et al., 2023) is a retrieval-augmented GPT-4 based method. ${ }^{1}$ COPRA does not use best first search, but instead samples from GPT-4 (OpenAI, 2023) a maximum of 60 times.</p>
<p>On informal-to-formal proving, LlemMA-7b closes $22.1 \%$ of the theorems, improving upon its Code Llama initialization and the Sledgehammer prover. The theorems that Llemma proves are often complementary to those proved with Sledgehammer: taking the union of Sledgehammer and LlemMA proofs results in 26 new validation proofs (an 11 percentage-point increase), and 17 new test proofs (a 7 point increase); see Appendix Table 11. Prior to our work, the only demonstration of few-shot proof autoformalization used the proprietary Codex model (Jiang et al., 2023).
On Lean 4 formal-to-formal proving, LlemMA-7b improves upon its Code Llama initialization, and performs similar to ReProver (Yang et al., 2023), a retrieval-augmented language model finetuned for tactic prediction. LlemMA adapts to the task using a 3 example prompt, which to our knowledge is the first demonstration of few-shot tactic prediction for theorem proving by an open model.</p>
<h1>3.4 IMPACT OF DATA MIXTURE</h1>
<p>When training a language model, it is common to upsample high-quality subsets of the training data according to mixture weights (Brown et al., 2020; Gao et al., 2020; Xie et al., 2023). We select mixture weights by doing short training runs on several hand-picked mixture weights, then choosing the one which minimizes perplexity on a set of high-quality held-out text (we use the MATH training set). Table 5 shows the MATH training set perplexity of models trained using different mixtures of arXiv to web to code. Based on these results, we trained LlemMA with a ratio of $2: 4: 1$. Note that our methodology uses the MATH training set to determine a training hyperparameter, though we expect that the effect is similar to that of related high-quality texts.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Mixture</th>
<th style="text-align: center;">MATH training set perplexity</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Overall</td>
<td style="text-align: center;">Prealgebra</td>
<td style="text-align: center;">Algebra</td>
<td style="text-align: center;">Number <br> Theory</td>
<td style="text-align: center;">Counting \&amp; Probability</td>
<td style="text-align: center;">Geometry</td>
<td style="text-align: center;">Intermediate Algebra</td>
<td style="text-align: center;">Precalculus</td>
</tr>
<tr>
<td style="text-align: center;">2:4:1</td>
<td style="text-align: center;">1.478</td>
<td style="text-align: center;">1.495</td>
<td style="text-align: center;">1.515</td>
<td style="text-align: center;">1.552</td>
<td style="text-align: center;">1.475</td>
<td style="text-align: center;">1.519</td>
<td style="text-align: center;">1.439</td>
<td style="text-align: center;">1.331</td>
</tr>
<tr>
<td style="text-align: center;">2:4:2</td>
<td style="text-align: center;">1.482</td>
<td style="text-align: center;">1.500</td>
<td style="text-align: center;">1.519</td>
<td style="text-align: center;">1.556</td>
<td style="text-align: center;">1.477</td>
<td style="text-align: center;">1.524</td>
<td style="text-align: center;">1.443</td>
<td style="text-align: center;">1.334</td>
</tr>
<tr>
<td style="text-align: center;">4:2:1</td>
<td style="text-align: center;">1.487</td>
<td style="text-align: center;">1.505</td>
<td style="text-align: center;">1.524</td>
<td style="text-align: center;">1.561</td>
<td style="text-align: center;">1.481</td>
<td style="text-align: center;">1.534</td>
<td style="text-align: center;">1.447</td>
<td style="text-align: center;">1.338</td>
</tr>
<tr>
<td style="text-align: center;">4:2:2</td>
<td style="text-align: center;">1.489</td>
<td style="text-align: center;">1.508</td>
<td style="text-align: center;">1.527</td>
<td style="text-align: center;">1.562</td>
<td style="text-align: center;">1.483</td>
<td style="text-align: center;">1.538</td>
<td style="text-align: center;">1.447</td>
<td style="text-align: center;">1.339</td>
</tr>
<tr>
<td style="text-align: center;">4:4:1</td>
<td style="text-align: center;">1.487</td>
<td style="text-align: center;">1.506</td>
<td style="text-align: center;">1.525</td>
<td style="text-align: center;">1.561</td>
<td style="text-align: center;">1.482</td>
<td style="text-align: center;">1.529</td>
<td style="text-align: center;">1.446</td>
<td style="text-align: center;">1.335</td>
</tr>
<tr>
<td style="text-align: center;">4:4:2</td>
<td style="text-align: center;">1.485</td>
<td style="text-align: center;">1.503</td>
<td style="text-align: center;">1.523</td>
<td style="text-align: center;">1.559</td>
<td style="text-align: center;">1.480</td>
<td style="text-align: center;">1.529</td>
<td style="text-align: center;">1.444</td>
<td style="text-align: center;">1.334</td>
</tr>
</tbody>
</table>
<p>Table 5: MATH training set perplexity of Code Llama 7B models trained using different data mixtures for a reduced number of steps. Each mixture is represented by its arXiv:Web:Code ratio.</p>
<h1>3.5 DATASET OVERLAP AND MEMORIZATION</h1>
<p>Do test problems or solutions appear in the corpus? We check whether any 30-gram in a test sequence (either an input problem or an output solution) occurs in any OpenWebMath or AlgebraicStack document. If so, we say that a hit occurred between the sequence and the document. Table 6 shows hits between sequences from MATH and documents from Proof-Pile-2. Using our methodology, around $7 \%$ of MATH test problem statements and $0.6 \%$ of MATH test solutions have hits. Note that our methodology gives a lower bound on the number of semantically equivalent sequences (e.g., it does not account for alternative phrasing).
We manually inspected 100 uniformly sampled hits between a test problem statement and an OpenWebMath document. 41 of the cases had no solution, which included websites with a list of problems, discussions, or hints. 49 had an alternative solution to the MATH ground-truth solution, but with the same answer. These include solutions that solve the problem differently than the ground-truth, solutions with missing details, and discussions that include the answer. 9 cases had a missing or incorrect answer, and 1 had the same solution as in the ground-truth. In summary, we find that solutions can appear in a corpus derived from web documents, particularly alternative solutions to those in the evaluation set. We repeated our analysis with 20-gram hits and our findings were similar, though with false positives; see Appendix Figure 6 for examples.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Proof-Pile-2</th>
<th style="text-align: center;">Test</th>
<th style="text-align: center;">Problem</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Solution</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Example</td>
<td style="text-align: center;">Docs</td>
<td style="text-align: center;">Example</td>
<td style="text-align: center;">Docs</td>
</tr>
<tr>
<td style="text-align: center;">OpenWebMath</td>
<td style="text-align: center;">MATH</td>
<td style="text-align: center;">348</td>
<td style="text-align: center;">717</td>
<td style="text-align: center;">34</td>
<td style="text-align: center;">46</td>
</tr>
<tr>
<td style="text-align: center;">AlgebraicStack</td>
<td style="text-align: center;">MATH</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">OpenWebMath</td>
<td style="text-align: center;">GSM8k</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">AlgebraicStack</td>
<td style="text-align: center;">GSM8k</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;">Same solution</th>
<th style="text-align: left;">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Different solution, same answer</td>
<td style="text-align: left;">49</td>
</tr>
<tr>
<td style="text-align: left;">Different solution, different answer</td>
<td style="text-align: left;">9</td>
</tr>
<tr>
<td style="text-align: left;">No solution</td>
<td style="text-align: left;">41</td>
</tr>
<tr>
<td style="text-align: left;">Different problem</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
<p>Table 6: Left: 30-gram hits between MATH test problems or solutions and Proof-Pile-2 documents. Example and Docs are the numbers of unique test examples and Proof-Pile-2 documents with a hit. Right: manual inspection of 100 hits between a problem statement and a Proof-Pile-2 document.</p>
<h2>How do problems in the corpus impact performance?</h2>
<p>Next, we evaluate LLEMMA-34b on the test examples with a 30-gram hit, and the test examples without a 30gram hit. Table 7 shows the accuracy partitioned by MATH difficulty level. The model's accuracy remains low on difficult problems (e.g., $6.08 \%$ on Level 5 problems with a hit, versus $6.39 \%$ on problems without a hit), and we observe no clear relationship between 30-gram hits and accuracy across difficulty levels. We conclude that a nontrivial match between a test example and a training document did not imply that the model generated a memorized correct answer. We repeated the analysis with 20-grams and with the 7 b model, and our findings were analogous. Figure 7 shows an example.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">MATH <br> Level</th>
<th style="text-align: center;">Hit <br> Accuracy</th>
<th style="text-align: center;">Nonhit <br> Accuracy</th>
<th style="text-align: center;"># Hits</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Level 1</td>
<td style="text-align: center;">72.73</td>
<td style="text-align: center;">61.50</td>
<td style="text-align: center;">11</td>
</tr>
<tr>
<td style="text-align: center;">Level 2</td>
<td style="text-align: center;">35.71</td>
<td style="text-align: center;">40.18</td>
<td style="text-align: center;">28</td>
</tr>
<tr>
<td style="text-align: center;">Level 3</td>
<td style="text-align: center;">30.36</td>
<td style="text-align: center;">26.88</td>
<td style="text-align: center;">56</td>
</tr>
<tr>
<td style="text-align: center;">Level 4</td>
<td style="text-align: center;">14.89</td>
<td style="text-align: center;">16.61</td>
<td style="text-align: center;">94</td>
</tr>
<tr>
<td style="text-align: center;">Level 5</td>
<td style="text-align: center;">6.08</td>
<td style="text-align: center;">6.39</td>
<td style="text-align: center;">181</td>
</tr>
</tbody>
</table>
<p>Table 7: LLEMMA-34b's accuracy on hits (a 30-gram overlap between a problem or solution and a training sequence) and nonhits by MATH difficulty level.</p>
<p>Finally, we check 30-gram hits between LlemMA's MATH generations and OpenWebMath. There were 13 hits, which occurred when the model generated a common sequence of numbers (e.g., a list of Fibonacci numbers), plus one instance of factoring a polynomial. Appendix Figure 6 shows an example. We find all of these observations worthy of further study. Using LlemMA and Proof-Pile-2 to better understand data, memorization, and performance is an interesting future direction. We include the code for our analysis in the LlemMA repository.</p>
<h1>4 Related Work</h1>
<p>Large-scale language modeling. Recent progress in large language models involves two connected threads: the increasing scale of models and data (Hoffmann et al., 2022; Kaplan et al., 2020; Chowdhery et al., 2022), and a progression toward more generalist models (Radford et al., 2019; Brown et al., 2020) which are capable of solving diverse problems and adapting quickly to novel tasks. A third thread relates to enabling open access to language models with these capabilities (Black et al., 2022; Biderman et al., 2023; Touvron et al., 2023; Rozière et al., 2023). Our work provides a recipe for specializing these language models to the domain of mathematics, providing a platform for further research and applications.</p>
<p>Domain adaptation. Language model applications typically require a general-domain pretraining step, followed by a shorter fine-tuning step. The finetuning step is often aimed at imbuing instructionfollowing ability (Sanh et al., 2022; Wei et al., 2022) or aligning a model's outputs with human preferences (Ziegler et al., 2019; Ouyang et al., 2022; Bai et al., 2022). Other work explores adapting pretrained models to novel domains by continued training (Rozière et al., 2023; Beltagy et al., 2019), parameter-efficient finetuning methods (Yong et al., 2023), retrieval augmentation (Min et al., 2023; Asai et al., 2023), and other techniques. We provide an adaptation recipe involving continued training and targeted data collection.</p>
<p>Language models for mathematics. Applying large language models to problems in mathematics is an active subfield of machine learning, including benchmarking mathematical knowledge and reasoning at varying levels (Hendrycks et al., 2021b; Zheng et al., 2021; Welleck et al., 2022; Azerbayev et al., 2023). Although achieving strong mathematical reasoning is an important target, it is difficult to assess the correctness of models' answers and processes, especially as models become more capable (Bowman et al., 2022; Uesato et al., 2022; Lightman et al., 2023; Cobbe et al., 2021).</p>
<p>A number of recent works focus on supervised finetuning on task-relevant (input, output) pairs (e.g.,Yu et al. (2023); Yue et al. (2023)). Doing so boosts performance on some common mathematical language modeling benchmarks, but trains the model for these specific tasks. In contrast, Lewkowycz et al. (2022) and our work seek to train a base language model as a platform for further development.</p>
<p>Language models for formal mathematics. An ongoing line of work explores integrating language models with interactive proof assistants in the context of mathematics. This includes synthesizing proofs via tactic prediction (Polu \&amp; Sutskever, 2020; Han et al., 2022; Lample et al., 2022; Jiang et al., 2022), autoformalization (Wu et al., 2022; Jiang et al., 2023), and integrated tools (Welleck \&amp; Saha, 2023). Due to high computational costs of search, language models applied to this domain have traditionally been small, but recent work has demonstrated promise in the use of larger models (First et al., 2023; Jiang et al., 2023). Our work provides a demonstration of few-shot proof autoformalization and tactic prediction, a large collection of formal mathematics data, along with an open access model for further exploring these directions.</p>
<h2>5 CONCLUSION</h2>
<p>We introduce LlemMA and Proof-Pile-2, a novel base model and corpus for language modeling of mathematics. Our models, dataset, and code are openly available. We have shown that LlemMA achieves state-of-the-art results for open-weights models on mathematical problem solving benchmarks, shown capabilities of using external tools via Python code, and demonstrated few-shot tactic prediction for theorem proving. We hope that LlemMA and Proof-Pile-2 will be a useful base for future work on understanding language model generalization and dataset composition, investigating the limits of domain-specific language models, using language models as tools for mathematicians, and improving the mathematical capabilities of language models.</p>
<h1>ACKNOWLEDGEMENTS</h1>
<p>We would like to thank Dragomir Radev, Arman Cohan, Jesse Michael Han, and the Deepmind Blueshift team for valuable guidance. We thank Jonah Philion for the model name. We thank Aviya Skowron for advising us on ethical considerations in the development and release of our models. We thank Jonathan Laurent and Leo Du for contributions to our open-source code.</p>
<p>We would also like to thank several parties for donating computing resources for this project: Stability AI (training the Llemma models), CoreWeave (evaluations and finetuning), the Province of Ontario and companies sponsoring the Vector Institute for Artificial Intelligence (www. vectorinstitute.ai/partners), and Brigham Young University (finetuning). KP is supported by an NSERC PGS-D award.</p>
<h2>REFERENCES</h2>
<p>Loubna Ben Allal, Raymond Li, Denis Kocetkov, Chenghao Mou, Christopher Akiki, Carlos Munoz Ferrandis, Niklas Muennighoff, Mayank Mishra, Alex Gu, Manan Dey, Logesh Kumar Umapathi, Carolyn Jane Anderson, Yangtian Zi, Joel Lamy Poirier, Hailey Schoelkopf, Sergey Troshin, Dmitry Abulkhanov, Manuel Romero, Michael Lappert, Francesco De Toni, Bernardo García del Río, Qian Liu, Shamik Bose, Urvashi Bhattacharyya, Terry Yue Zhuo, Ian Yu, Paulo Villegas, Marco Zocca, Sourab Mangrulkar, David Lansky, Huu Nguyen, Danish Contractor, Luis Villa, Jia Li, Dzmitry Bahdanau, Yacine Jernite, Sean Hughes, Daniel Fried, Arjun Guha, Harm de Vries, and Leandro von Werra. Santacoder: don't reach for the stars! In Deep Learning for Code (DL4C) Workshop, 2023.</p>
<p>Alex Andonian, Quentin Anthony, Stella Biderman, Sid Black, Preetham Gali, Leo Gao, Eric Hallahan, Josh Levy-Kramer, Connor Leahy, Lucas Nestler, Kip Parker, Michael Pieler, Jason Phang, Shivanshu Purohit, Hailey Schoelkopf, Dashiell Stander, Tri Songz, Curt Tigges, Benjamin Thérien, Phil Wang, and Samuel Weinbach. GPT-NeoX: Large scale autoregressive language modeling in PyTorch. GitHub Repo, 9 2023. URL https://www. github.com/eleutherai/ gpt-neox.</p>
<p>Akari Asai, Sewon Min, Zexuan Zhong, and Danqi Chen. Retrieval-based language models and applications. In Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 6: Tutorial Abstracts), pp. 41-46, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-tutorials.6. URL https: //aclanthology.org/2023.acl-tutorials.6.</p>
<p>Jeremy Avigad. The mechanization of mathematics. Notices of the AMS, 65(6):681-90, 2018.
Zhangir Azerbayev, Bartosz Piotrowski, Hailey Schoelkopf, Edward W. Ayers, Dragomir R. Radev, and Jeremy Avigad. Proofnet: Autoformalizing and formally proving undergraduate-level mathematics. ArXiv, abs/2302.12433, 2023.</p>
<p>Yuntao Bai, Andy Jones, Kamal Ndousse, Amanda Askell, Anna Chen, Nova DasSarma, Dawn Drain, Stanislav Fort, Deep Ganguli, Tom Henighan, Nicholas Joseph, Saurav Kadavath, Jackson Kernion, Tom Conerly, Sheer El-Showk, Nelson Elhage, Zac Hatfield-Dodds, Danny Hernandez, Tristan Hume, Scott Johnston, Shauna Kravec, Liane Lovitt, Neel Nanda, Catherine Olsson, Dario Amodei, Tom Brown, Jack Clark, Sam McCandlish, Chris Olah, Ben Mann, and Jared Kaplan. Training a helpful and harmless assistant with reinforcement learning from human feedback. arXiv preprint arXiv:2204.05862, 2022.</p>
<p>Iz Beltagy, Kyle Lo, and Arman Cohan. SciBERT: A pretrained language model for scientific text. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pp. 3615-3620, Hong Kong, China, November 2019. Association for Computational Linguistics. doi: 10.18653/v1/D19-1371. URL https://aclanthology.org/D19-1371.</p>
<p>Stella Biderman, Hailey Schoelkopf, Quentin Gregory Anthony, Herbie Bradley, Kyle O’Brien, Eric Hallahan, Mohammad Aflah Khan, Shivanshu Purohit, USVSN Sai Prashanth, Edward Raff, et al. Pythia: A suite for analyzing large language models across training and scaling. In International Conference on Machine Learning, pp. 2397-2430. PMLR, 2023.</p>
<p>Stella Rose Biderman, Kieran Bicheno, and Leo Gao. Datasheet for the pile. ArXiv, abs/2201.07311, 2022.</p>
<p>Sidney Black, Stella Biderman, Eric Hallahan, Quentin Anthony, Leo Gao, Laurence Golding, Horace He, Connor Leahy, Kyle McDonell, Jason Phang, et al. Gpt-neox-20b: An open-source autoregressive language model. In Proceedings of BigScience Episode# 5-Workshop on Challenges \&amp; Perspectives in Creating Large Language Models, pp. 95-136, 2022.</p>
<p>Samuel R. Bowman, Jeeyoon Hyun, Ethan Perez, Edwin Chen, Craig Pettit, Scott Heiner, Kamilè Lukošiūtė, Amanda Askell, Andy Jones, Anna Chen, Anna Goldie, Azalia Mirhoseini, Cameron McKinnon, Christopher Olah, Daniela Amodei, Dario Amodei, Dawn Drain, Dustin Li, Eli TranJohnson, Jackson Kernion, Jamie Kerr, Jared Mueller, Jeffrey Ladish, Joshua Landau, Kamal Ndousse, Liane Lovitt, Nelson Elhage, Nicholas Schiefer, Nicholas Joseph, Noemí Mercado, Nova DasSarma, Robin Larson, Sam McCandlish, Sandipan Kundu, Scott Johnston, Shauna Kravec, Sheer El Showk, Stanislav Fort, Timothy Telleen-Lawton, Tom Brown, Tom Henighan, Tristan Hume, Yuntao Bai, Zac Hatfield-Dodds, Ben Mann, and Jared Kaplan. Measuring progress on scalable oversight for large language models. arXiv preprint arXiv:2211.03540, 2022.</p>
<p>Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, T. J. Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeff Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. ArXiv, abs/2005.14165, 2020.</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. Palm: Scaling language modeling with pathways. arXiv preprint arXiv:2204.02311, 2022.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168, 2021.</p>
<p>Katherine M. Collins, Albert Q. Jiang, Simon Frieder, Lionel Wong, Miri Zilka, Umang Bhatt, Thomas Lukasiewicz, Yuhuai Wu, Joshua B. Tenenbaum, William Hart, Timothy Gowers, Wenda Li, Adrian Weller, and Mateja Jamnik. Evaluating language models for mathematics through interactions. arXiv preprint arXiv:2306.01694, 2023.</p>
<p>Together Computer. Redpajama: An open source recipe to reproduce llama training dataset, April 2023. URL https://github.com/togethercomputer/RedPajama-Data.</p>
<p>Tri Dao. Flashattention-2: Faster attention with better parallelism and work partitioning. arXiv preprint arXiv:2307.08691, 2023.</p>
<p>Leonardo de Moura, Soonho Kong, Jeremy Avigad, Floris Van Doorn, and Jakob von Raumer. The lean theorem prover (system description). In Automated Deduction-CADE-25: 25th International Conference on Automated Deduction, Berlin, Germany, August 1-7, 2015, Proceedings 25, pp. 378-388. Springer, 2015.</p>
<p>Erich Elsen, Curtis Hawthorne, and Arushi Somani. The adventure of the errant hardware, 2023. URL https://www. adept.ai/blog/sherlock-sdc.</p>
<p>Emily First, Markus N. Rabe, Talia Ringer, and Yuriy Brun. Baldur: Whole-proof generation and repair with large language models. arXiv preprint arXiv:2303.04910, 2023.</p>
<p>Leo Gao, Stella Rose Biderman, Sid Black, Laurence Golding, Travis Hoppe, Charles Foster, Jason Phang, Horace He, Anish Thite, Noa Nabeshima, Shawn Presser, and Connor Leahy. The pile: An 800gb dataset of diverse text for language modeling. ArXiv, abs/2101.00027, 2020.</p>
<p>Leo Gao, Jonathan Tow, Baber Abbasi, Stella Biderman, Sid Black, Anthony DiPofi, Charles Foster, Laurence Golding, Jeffrey Hsu, Alain Le Noac'h, Haonan Li, Kyle McDonell, Niklas Muennighoff, Jason Ociepa, Chris Phang, Laria Reynolds, Hailey Schoelkopf, Aviya Skowron, Lintang Sutawika,</p>
<p>Eric Tang, Anish Thite, Ben Wang, Kevin Wang, and Andy Zou. A framework for few-shot language model evaluation, September 2021. URL https://doi.org/10.5281/zenodo. 5371628 .</p>
<p>Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and Graham Neubig. Pal: Program-aided language models. arXiv preprint arXiv:2211.10435, 2022.</p>
<p>Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and Graham Neubig. Pal: Program-aided language models. arXiv preprint arXiv:2211.10435, 2023.</p>
<p>Timnit Gebru, Jamie Morgenstern, Briana Vecchione, Jennifer Wortman Vaughan, Hanna Wallach, Hal Daumé III au2, and Kate Crawford. Datasheets for datasets, 2021.</p>
<p>Herbert L. Gelernter. Realization of a geometry theorem proving machine. In IFIP Congress, 1959. URL https://api.semanticscholar.org/CorpusID:18484295.</p>
<p>Priya Goyal, Piotr Dollár, Ross B. Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch SGD: training imagenet in 1 hour. CoRR, abs/1706.02677, 2017. URL http://arxiv.org/abs/1706.02677.</p>
<p>Jesse Michael Han, Jason Rute, Yuhuai Wu, Edward Ayers, and Stanislas Polu. Proof artifact cotraining for theorem proving with language models. In International Conference on Learning Representations, 2022. URL https://openreview.net/forum?id=rpxJc9j04U.</p>
<p>Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. arXiv preprint arXiv:2009.03300, 2021a.</p>
<p>Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song, and Jacob Steinhardt. Measuring mathematical problem solving with the math dataset. NeurIPS, 2021b.</p>
<p>Jordan Hoffmann, Sebastian Borgeaud, Arthur Mensch, Elena Buchatskaya, Trevor Cai, Eliza Rutherford, Diego de Las Casas, Lisa Anne Hendricks, Johannes Welbl, Aidan Clark, Tom Hennigan, Eric Noland, Katie Millican, George van den Driessche, Bogdan Damoc, Aurelia Guy, Simon Osindero, Karen Simonyan, Erich Elsen, Jack W. Rae, Oriol Vinyals, and L. Sifre. Training compute-optimal large language models. arXiv preprint arXiv:2203.15556, 2022.</p>
<p>Ari Holtzman, Jan Buys, Li Du, Maxwell Forbes, and Yejin Choi. The curious case of neural text degeneration, 2020.</p>
<p>Albert Q. Jiang, Wenda Li, Jesse Michael Han, and Yuhuai Wu. Lisa: Language models of isabelle proofs. 6th Conference on Artificial Intelligence and Theorem Proving, 2021.</p>
<p>Albert Q. Jiang, Wenda Li, Szymon Tworkowski, Konrad Czechowski, Tomasz Odrzygóźdź, Piotr Miłoś, Yuhuai Wu, and Mateja Jamnik. Thor: Wielding hammers to integrate language models and automated theorem provers. arXiv preprint arXiv:2205.10893, 2022.</p>
<p>Albert Qiaochu Jiang, Sean Welleck, Jin Peng Zhou, Timothee Lacroix, Jiacheng Liu, Wenda Li, Mateja Jamnik, Guillaume Lample, and Yuhuai Wu. Draft, sketch, and prove: Guiding formal theorem provers with informal proofs. In The Eleventh International Conference on Learning Representations, 2023. URL https://openreview.net/forum?id=SMa9EAovKMC.</p>
<p>Jared Kaplan, Sam McCandlish, T. J. Henighan, Tom B. Brown, Benjamin Chess, Rewon Child, Scott Gray, Alec Radford, Jeff Wu, and Dario Amodei. Scaling laws for neural language models. arXiv preprint arXiv:2001.08361, 2020.</p>
<p>Denis Kocetkov, Raymond Li, Loubna Ben Allal, Jia Li, Chenghao Mou, Carlos Muñoz Ferrandis, Yacine Jernite, Margaret Mitchell, Sean Hughes, Thomas Wolf, Dzmitry Bahdanau, Leandro von Werra, and Harm de Vries. The stack: 3 tb of permissively licensed source code. Preprint, 2022.</p>
<p>Guillaume Lample, Marie-Anne Lachaux, Thibaut Lavril, Xavier Martinet, Amaury Hayat, Gabriel Ebner, Aurélien Rodriguez, and Timothée Lacroix. Hypertree proof search for neural theorem proving. arXiv preprint arXiv:2205.11491, 2022.</p>
<p>Aitor Lewkowycz, Anders Johan Andreassen, David Dohan, Ethan Dyer, Henryk Michalewski, Vinay Venkatesh Ramasesh, Ambrose Slone, Cem Anil, Imanol Schlag, Theo Gutman-Solo, Yuhuai Wu, Behnam Neyshabur, Guy Gur-Ari, and Vedant Misra. Solving quantitative reasoning problems with language models. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho (eds.), Advances in Neural Information Processing Systems, 2022.</p>
<p>Hunter Lightman, Vineet Kosaraju, Yura Burda, Harri Edwards, Bowen Baker, Teddy Lee, Jan Leike, John Schulman, Ilya Sutskever, and Karl Cobbe. Let's verify step by step. arXiv preprint arXiv:2305.20050, 2023.</p>
<p>Pan Lu, Liang Qiu, Wenhao Yu, Sean Welleck, and Kai-Wei Chang. A survey of deep learning for mathematical reasoning. In Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp. 14605-14631, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.817. URL https://aclanthology.org/2023.acl-long.817.</p>
<p>Haipeng Luo, Qingfeng Sun, Can Xu, Pu Zhao, Jianguang Lou, Chongyang Tao, Xiubo Geng, Qingwei Lin, Shifeng Chen, and Dongmei Zhang. Wizardmath: Empowering mathematical reasoning for large language models via reinforced evol-instruct. arXiv preprint arXiv:2308.09583, 2023.</p>
<p>The mathlib Community. The lean mathematical library. In Proceedings of the 9th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2020, pp. 367-381, New York, NY, USA, 2020. Association for Computing Machinery. ISBN 9781450370974. doi: 10.1145/ 3372885.3373824. URL https://doi.org/10.1145/3372885.3373824.</p>
<p>Sewon Min, Suchin Gururangan, Eric Wallace, Hannaneh Hajishirzi, Noah A. Smith, and Luke Zettlemoyer. Silo language models: Isolating legal risk in a nonparametric datastore, 2023.</p>
<p>Scott Morrison. lean-training-data. https://github.com/semorrison/ lean-training-data, 2023.</p>
<p>OpenAI. Gpt-4 technical report, 2023.
Long Ouyang, Jeff Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, John Schulman, Jacob Hilton, Fraser Kelton, Luke Miller, Maddie Simens, Amanda Askell, Peter Welinder, Paul Christiano, Jan Leike, and Ryan Lowe. Training language models to follow instructions with human feedback. arXiv preprint arXiv:2203.02155, 2022.</p>
<p>Keiran Paster, Marco Dos Santos, Zhangir Azerbayev, and Jimmy Ba. Openwebmath: An open dataset of high-quality mathematical web text. CoRR, abs/2310.06786, 2023. doi: 10.48550/ ARXIV.2310.06786. URL https://doi.org/10.48550/arXiv.2310.06786.</p>
<p>Christine Paulin-Mohring. Extracting $\omega$ 's programs from proofs in the calculus of constructions. In Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pp. 89-104, 1989a.</p>
<p>Christine Paulin-Mohring. Extraction de programmes dans le Calcul des Constructions. PhD thesis, Université Paris-Diderot-Paris VII, 1989b.</p>
<p>Larry Paulson and Tobias Nipkow. The sledgehammer: Let automatic theorem provers write your isabelle scripts!, 2023. URL https://isabelle.in.tum.de/ website-Isabelle2009-1/sledgehammer.html.</p>
<p>Bowen Peng, Jeffrey Quesnelle, Honglu Fan, and Enrico Shippole. Yarn: Efficient context window extension of large language models. arXiv preprint arXiv:2309.00071, 2023.</p>
<p>Stanislas Polu and Ilya Sutskever. Generative language modeling for automated theorem proving. arXiv preprint arXiv:2009.03393, 2020.</p>
<p>Stanislas Polu, Jesse Michael Han, Kunhao Zheng, Mantas Baksys, Igor Babuschkin, and Ilya Sutskever. Formal mathematics statement curriculum learning. arXiv preprint arXiv:2202.01344, 2022.</p>
<p>Alec Radford, Jeff Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners. OpenAI Blog, 2019.</p>
<p>Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J. Liu. Exploring the limits of transfer learning with a unified text-to-text transformer, 2023.</p>
<p>Samyam Rajbhandari, Jeff Rasley, Olatunji Ruwase, and Yuxiong He. ZeRO: Memory optimizations toward training trillion parameter models. In Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, SC '20. IEEE Press, 2020. ISBN 9781728199986. doi: 10.5555/3433701.3433727. URL https://dl.acm.org/doi/10. $5555 / 3433701.3433727$.</p>
<p>Baptiste Rozière, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy Rapin, Artyom Kozhevnikov, Ivan Evtimov, Joanna Bitton, Manish Bhatt, Cristian Canton Ferrer, Aaron Grattafiori, Wenhan Xiong, Alexandre Défossez, Jade Copet, Faisal Azhar, Hugo Touvron, Louis Martin, Nicolas Usunier, Thomas Scialom, and Gabriel Synnaeve. Code llama: Open foundation models for code. arXiv preprint arXiv:2308.12950, 2023.</p>
<p>Victor Sanh, Albert Webson, Colin Raffel, Stephen H. Bach, Lintang Sutawika, Zaid Alyafeai, Antoine Chaffin, Arnaud Stiegler, Teven Le Scao, Arun Raja, Manan Dey, M Sailul Bari, Canwen Xu, Urmish Thakker, Shanya Sharma Sharma, Eliza Szczechla, Taewoon Kim, Gunjan Chhablani, Nihal Nayak, Debajyoti Datta, Jonathan Chang, Mike Tian-Jian Jiang, Han Wang, Matteo Manica, Sheng Shen, Zheng Xin Yong, Harshit Pandey, Rachel Bawden, Thomas Wang, Trishala Neeraj, Jos Rozen, Abheesht Sharma, Andrea Santilli, Thibault Fevry, Jason Alan Fries, Ryan Teehan, Tali Bers, Stella Biderman, Leo Gao, Thomas Wolf, and Alexander M. Rush. Multitask prompted training enables zero-shot task generalization. arXiv preprint arXiv:2110.08207, 2022.</p>
<p>Mohammad Shoeybi, Mostofa Patwary, Raul Puri, Patrick LeGresley, Jared Casper, and Bryan Catanzaro. Megatron-LM: Training multi-billion parameter language models using model parallelism. Computing Research Repository, 2019. doi: 10.48550/arXiv.1909.08053. URL https://arxiv.org/abs/1909.08053v4. Version 4.</p>
<p>Karan Singhal, Shekoofeh Azizi, Tao Tu, S. Sara Mahdavi, Jason Wei, Hyung Won Chung, Nathan Scales, Ajay Tanwani, Heather Cole-Lewis, Stephen Pfohl, Perry Payne, Martin Seneviratne, Paul Gamble, Chris Kelly, Nathaneal Scharli, Aakanksha Chowdhery, Philip Mansfield, Blaise Aguera y Arcas, Dale Webster, Greg S. Corrado, Yossi Matias, Katherine Chou, Juraj Gottweis, Nenad Tomasev, Yun Liu, Alvin Rajkomar, Joelle Barral, Christopher Semturs, Alan Karthikesalingam, and Vivek Natarajan. Large language models encode clinical knowledge, 2022.</p>
<p>Karan Singhal, Tao Tu, Juraj Gottweis, Rory Sayres, Ellery Wulczyn, Le Hou, Kevin Clark, Stephen Pfohl, Heather Cole-Lewis, Darlene Neal, Mike Schaekermann, Amy Wang, Mohamed Amin, Sami Lachgar, Philip Mansfield, Sushant Prakash, Bradley Green, Ewa Dominowska, Blaise Aguera y Arcas, Nenad Tomasev, Yun Liu, Renee Wong, Christopher Semturs, S. Sara Mahdavi, Joelle Barral, Dale Webster, Greg S. Corrado, Yossi Matias, Shekoofeh Azizi, Alan Karthikesalingam, and Vivek Natarajan. Towards expert-level medical question answering with large language models, 2023.</p>
<p>Jianlin Su, Yu Lu, Shengfeng Pan, Ahmed Murtadha, Bo Wen, and Yunfeng Liu. Roformer: Enhanced transformer with rotary position embedding. arXiv preprint arXiv:2104.09864, 2022.</p>
<p>Ross Taylor, Marcin Kardas, Guillem Cucurull, Thomas Scialom, Anthony Hartshorn, Elvis Saravia, Andrew Poulton, Viktor Kerkez, and Robert Stojnic. Galactica: A large language model for science, 2022.</p>
<p>Amitayush Thakur, Yeming Wen, and Swarat Chaudhuri. A language-agent approach to formal theorem-proving, 2023.</p>
<p>Romal Thoppilan, Daniel De Freitas, Jamie Hall, Noam Shazeer, Apoorv Kulshreshtha, Heng-Tze Cheng, Alicia Jin, Taylor Bos, Leslie Baker, Yu Du, YaGuang Li, Hongrae Lee, Huaixiu Steven Zheng, Amin Ghafouri, Marcelo Menegali, Yanping Huang, Maxim Krikun, Dmitry Lepikhin, James Qin, Dehao Chen, Yuanzhong Xu, Zhifeng Chen, Adam Roberts, Maarten Bosma, Vincent</p>
<p>Zhao, Yanqi Zhou, Chung-Ching Chang, Igor Krivokon, Will Rusch, Marc Pickett, Pranesh Srinivasan, Laichee Man, Kathleen Meier-Hellstern, Meredith Ringel Morris, Tulsee Doshi, Renelito Delos Santos, Toju Duke, Johnny Soraker, Ben Zevenbergen, Vinodkumar Prabhakaran, Mark Diaz, Ben Hutchinson, Kristen Olson, Alejandra Molina, Erin Hoffman-John, Josh Lee, Lora Aroyo, Ravi Rajakumar, Alena Butryna, Matthew Lamm, Viktoriya Kuzmina, Joe Fenton, Aaron Cohen, Rachel Bernstein, Ray Kurzweil, Blaise Aguera-Arcas, Claire Cui, Marian Croak, Ed Chi, and Quoc Le. Lamda: Language models for dialog applications. arXiv preprint arXiv:2201.08239, 2022.</p>
<p>Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, Dan Bikel, Lukas Blecher, Cristian Canton Ferrer, Moya Chen, Guillem Cucurull, David Esiobu, Jude Fernandes, Jeremy Fu, Wenyin Fu, Brian Fuller, Cynthia Gao, Vedanuj Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou, Hakan Inan, Marcin Kardas, Viktor Kerkez, Madian Khabsa, Isabel Kloumann, Artem Korenev, Punit Singh Koura, Marie-Anne Lachaux, Thibaut Lavril, Jenya Lee, Diana Liskovich, Yinghai Lu, Yuning Mao, Xavier Martinet, Todor Mihaylov, Pushkar Mishra, Igor Molybog, Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan Saladi, Alan Schelten, Ruan Silva, Eric Michael Smith, Ranjan Subramanian, Xiaoqing Ellen Tan, Binh Tang, Ross Taylor, Adina Williams, Jian Xiang Kuan, Puxin Xu, Zheng Yan, Iliyan Zarov, Yuchen Zhang, Angela Fan, Melanie Kambadur, Sharan Narang, Aurelien Rodriguez, Robert Stojnic, Sergey Edunov, and Thomas Scialom. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023.</p>
<p>Jonathan Uesato, Nate Kushman, Ramana Kumar, Francis Song, Noah Siegel, Lisa Wang, Antonia Creswell, Geoffrey Irving, and Irina Higgins. Solving math word problems with process- and outcome-based feedback, 2022.
H. Wang. Toward mechanical mathematics. IBM Journal of Research and Development, 4(1):2-22, 1960. doi: $10.1147 /$ rd.41.0002.</p>
<p>Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc V Le, Ed H. Chi, Sharan Narang, Aakanksha Chowdhery, and Denny Zhou. Self-consistency improves chain of thought reasoning in language models. In The Eleventh International Conference on Learning Representations, 2023. URL https://openreview.net/forum?id=1PL1NIMdrw.</p>
<p>Jason Wei, Maarten Bosma, Vincent Y. Zhao, Kelvin Guu, Adams Wei Yu, Brian Lester, Nan Du, Andrew M. Dai, and Quoc V. Le. Finetuned language models are zero-shot learners. arXiv preprint arXiv:2109.01652, 2022.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed Chi, Quoc Le, and Denny Zhou. Chain-of-thought prompting elicits reasoning in large language models, 2023.</p>
<p>Sean Welleck. Neural theorem proving tutorial. https://github.com/wellecks/ ntptutorial, 2023.</p>
<p>Sean Welleck and Rahul Saha. 1lmstep: Llm proofstep suggestions in lean. https://github. com/wellecks/llmstep, 2023.</p>
<p>Sean Welleck, Jiacheng Liu, Ximing Lu, Hannaneh Hajishirzi, and Yejin Choi. Naturalprover: Grounded mathematical proof generation with language models. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho (eds.), Advances in Neural Information Processing Systems, 2022. URL https://openreview.net/forum?id=rhdfTOiXBng.</p>
<p>Makarius Wenzel, Lawrence C Paulson, and Tobias Nipkow. The isabelle framework. In Theorem Proving in Higher Order Logics: 21st International Conference, TPHOLs 2008, Montreal, Canada, August 18-21, 2008. Proceedings 21, pp. 33-38. Springer, 2008.</p>
<p>Shijie Wu, Ozan Irsoy, Steven Lu, Vadim Dabravolski, Mark Dredze, Sebastian Gehrmann, Prabhanjan Kambadur, David Rosenberg, and Gideon Mann. Bloomberggpt: A large language model for finance, 2023.</p>
<p>Yuhuai Wu, Albert Qiaochu Jiang, Wenda Li, Markus Norman Rabe, Charles E Staats, Mateja Jamnik, and Christian Szegedy. Autoformalization with large language models. In Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho (eds.), Advances in Neural Information Processing Systems, 2022. URL https://openreview.net/forum?id=IUikebJ1Bf0.</p>
<p>Sang Michael Xie, Hieu Pham, Xuanyi Dong, Nan Du, Hanxiao Liu, Yifeng Lu, Percy Liang, Quoc V. Le, Tengyu Ma, and Adams Wei Yu. Doremi: Optimizing data mixtures speeds up language model pretraining. arXiv preprint arXiv:2305.10429, 2023.</p>
<p>Kaiyu Yang, Aidan Swope, Alex Gu, Rahul Chalamala, Peiyang Song, Shixing Yu, Saad Godil, Ryan Prenger, and Anima Anandkumar. LeanDojo: Theorem proving with retrieval-augmented language models. In Neural Information Processing Systems (NeurIPS), 2023.</p>
<p>Zheng Xin Yong, Hailey Schoelkopf, Niklas Muennighoff, Alham Fikri Aji, David Ifeoluwa Adelani, Khalid Almubarak, M Saiful Bari, Lintang Sutawika, Jungo Kasai, Ahmed Baruwa, Genta Winata, Stella Biderman, Edward Raff, Dragomir Radev, and Vassilina Nikoulina. BLOOM+1: Adding language support to BLOOM for zero-shot prompting. In Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp. 11682-11703, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023. acl-long.653. URL https://aclanthology.org/2023.acl-long. 653.</p>
<p>Longhui Yu, Weisen Jiang, Han Shi, Jincheng Yu, Zhengying Liu, Yu Zhang, James T. Kwok, Zhenguo Li, Adrian Weller, and Weiyang Liu. Metamath: Bootstrap your own mathematical questions for large language models. arXiv preprint arXiv:2309.12284, 2023.</p>
<p>Xiang Yue, Xingwei Qu, Ge Zhang, Yao Fu, Wenhao Huang, Huan Sun, Yu Su, and Wenhu Chen. Mammoth: Building math generalist models through hybrid instruction tuning. CoRR, abs/2309.05653, 2023. doi: 10.48550/arXiv.2309.05653. URL https://doi.org/10. 48550/arXiv.2309.05653.</p>
<p>Shizhuo Dylan Zhang, Curt Tigges, Stella Biderman, Maxim Raginsky, and Talia Ringer. Can transformers learn to solve problems recursively?, 2023.</p>
<p>Kunhao Zheng, Jesse Michael Han, and Stanislas Polu. Minif2f: a cross-system benchmark for formal olympiad-level mathematics. arXiv preprint arXiv:2109.00110, 2021.</p>
<p>Hattie Zhou, Azade Nova, Hugo Larochelle, Aaron Courville, Behnam Neyshabur, and Hanie Sedghi. Teaching algorithmic reasoning via in-context learning, 2022.</p>
<p>Daniel M Ziegler, Nisan Stiennon, Jeffrey Wu, Tom B Brown, Alec Radford, Dario Amodei, Paul Christiano, and Geoffrey Irving. Fine-tuning language models from human preferences. arXiv preprint arXiv:1909.08593, 2019.</p>
<h1>A Author Contributions</h1>
<p>Training Data. Zhangir Azerbayev, Keiran Paster, Marco Dos Santos, Sean Welleck.
Model training. Zhangir Azerbayev, Hailey Schoelkopf, Keiran Paster.
Evaluations. Zhangir Azerbayev, Hailey Schoelkopf, Keiran Paster, Marco Dos Santos, Stephen McAleer, Albert Q. Jiang, Sean Welleck.</p>
<p>Formal math evaluations. Sean Welleck.
Memorization analysis. Sean Welleck, Keiran Paster.
Senior Authorship and Advising. Jia Deng, Stella Biderman, Sean Welleck.</p>
<h2>B Data: Proof-Pile-2</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Data source</th>
<th style="text-align: center;">Tokens</th>
<th style="text-align: center;">Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Proof-Pile-2</td>
<td style="text-align: center;">55 B</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">Code (AlgebraicStack)</td>
<td style="text-align: center;">11 B</td>
<td style="text-align: center;">1.00</td>
</tr>
<tr>
<td style="text-align: left;">Web (OpenWebMath)</td>
<td style="text-align: center;">15 B</td>
<td style="text-align: center;">4.00</td>
</tr>
<tr>
<td style="text-align: left;">Papers (ArXiv)</td>
<td style="text-align: center;">29 B</td>
<td style="text-align: center;">2.00</td>
</tr>
<tr>
<td style="text-align: left;">General code (RedPajama)</td>
<td style="text-align: center;">59 B</td>
<td style="text-align: center;">0.22</td>
</tr>
<tr>
<td style="text-align: left;">General language (Pile)</td>
<td style="text-align: center;">300 B</td>
<td style="text-align: center;">0.15</td>
</tr>
</tbody>
</table>
<p>Table 8: Proof-Pile-2 data sources (top), general language and code data included during training (bottom), and the mixture weights of each component during training.</p>
<h2>B. 1 Mathematical Code: AlgebraicStack</h2>
<p>AlgebraicStack contains roughly 11B tokens of code related to mathematics. We describe its sources, filtering, and content below. Table 9 shows the number of tokens per language in AlgebraicStack.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Language</th>
<th style="text-align: right;">AlgebraicStack tokens</th>
<th style="text-align: center;">Language</th>
<th style="text-align: right;">AlgebraicStack tokens</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Agda</td>
<td style="text-align: right;">35.2 M</td>
<td style="text-align: center;">Julia</td>
<td style="text-align: right;">531.0 M</td>
</tr>
<tr>
<td style="text-align: left;">C</td>
<td style="text-align: right;">25.1 M</td>
<td style="text-align: center;">Jupyter</td>
<td style="text-align: right;">199.1 M</td>
</tr>
<tr>
<td style="text-align: left;">C++</td>
<td style="text-align: right;">954.1 M</td>
<td style="text-align: center;">Lean</td>
<td style="text-align: right;">285.6 M</td>
</tr>
<tr>
<td style="text-align: left;">Coq</td>
<td style="text-align: right;">281.9 M</td>
<td style="text-align: center;">Maple</td>
<td style="text-align: right;">2.0 M</td>
</tr>
<tr>
<td style="text-align: left;">Fortran</td>
<td style="text-align: right;">724.9 M</td>
<td style="text-align: center;">Matlab</td>
<td style="text-align: right;">65.8 M</td>
</tr>
<tr>
<td style="text-align: left;">GAP</td>
<td style="text-align: right;">3.6 M</td>
<td style="text-align: center;">Python</td>
<td style="text-align: right;">$6,098.8 \mathrm{M}$</td>
</tr>
<tr>
<td style="text-align: left;">Haskell</td>
<td style="text-align: right;">9.1 M</td>
<td style="text-align: center;">R</td>
<td style="text-align: right;">71.3 M</td>
</tr>
<tr>
<td style="text-align: left;">Idris</td>
<td style="text-align: right;">10.9 M</td>
<td style="text-align: center;">Tex</td>
<td style="text-align: right;">567.7 M</td>
</tr>
<tr>
<td style="text-align: left;">Isabelle</td>
<td style="text-align: right;">$1,089.7 \mathrm{M}$</td>
<td style="text-align: center;">Total</td>
<td style="text-align: right;">$\mathbf{1 0 , 9 5 5 . 7} \mathbf{~ M}$</td>
</tr>
</tbody>
</table>
<p>Table 9: Tokens in AlgebraicStack, computed with the Llama tokenizer.</p>
<h2>B.1.1 GitHub CODE</h2>
<p>The following programming languages were either barely present in the Stack or consisted of largely incorrect filetypes, so we downloaded data for these languages directly via the Github Python API.</p>
<ul>
<li>
<p>Coq : We filter for files with the .v extension, and include Coq via including files that match a heuristic filter for the keywords "Theorem", "Proof", "Qed", "Inductive", "Definition", "Fixpoint" and exclude Verilog files via the keyword blacklist "pragma", "endmodule", "posedge", "negedge", "wire". We additionally exclude files noted as automatically generated.</p>
</li>
<li>
<p>Isabelle : We filter for files with the .thy extension and include files matching the keyword whitelist "theorem ", "lemma ". We keep only isabelle-prover/mirror-afp-devel and discard all other older copies of the Archive of Formal Proofs. We further remove theorem statements and proofs that have a theorem name in the PISA (Jiang et al., 2021) test set.</p>
</li>
<li>Lean : We filter for files with the . lean extension, using the keyword whitelist "theorem ", "lemma ", "example ". We remove all dependency files, and in order to avoid known benchmark contamination, we blacklist the ProofNet and MiniF2F repositories. We further remove theorems or lemmas that share a theorem name with the LeanDojo (Yang et al., 2023) val or test sets.</li>
<li>MATLAB : We filter for files with the .m extension, using the keyword whitelist "#import", "interface", "implementation", "property", and blacklist C files via the keywords "#include" and the regex $r^{\prime}$ main $\backslash{. *}$ '</li>
</ul>
<p>We implemented a cutoff date for our Github API downloads, and used a cutoff date of April 1, 2023.
For all languages, unless otherwise stated, we additionally filtered out files with a filesize greater than 1048575 bytes or with a numerical density (ratio of digit characters to non-digit characters) of 0.5 . We additionally perform document-level exact deduplication by removing documents which contain an overlapping 2048-character chunk as another document.</p>
<h1>B.1.2 LEAN PROOFSTEPS</h1>
<p>We extract a dataset of (tactic state, next tactic) pairs from Mathlib 4 (mathlib Community, 2020) using the lean-training-data (Morrison, 2023) tool. We use Mathlib 4 commit c779bd5, which was created on August 20th 2023.</p>
<h2>B.1.3 Isabelle ProofSTEPS</h2>
<p>We construct a dataset of Isabelle proofs, building upon the PISA dataset Jiang et al. (2021). Isabelle Proofsteps comprises proofs from the Archive of Formal Proofs and Isabelle Standard Library, scraped with PISA Jiang et al. (2021). Each entry in the dataset includes the theorem statement, the proof states and the proof steps, separated by specific tags. To maintain the integrity of evaluations using the PISA test set, we decontaminate Isabelle Proofsteps by removing theorems whose names overlap with those in the PISA test set. Although this approach results in a strict filtering - removing more than 10,000 theorems although there are only 3600 in the PISA test set - we consider it acceptable in order to mitigate data contamination. After filtering, Isabelle Proofsteps contains 251,000 theorems.</p>
<h2>B.1.4 STACK Filtering</h2>
<p>We source the following programming languages from the Stack (Kocetkov et al., 2022) dataset, and describe our filtering process and quality issues we chose to mitigate beyond our default quality heuristics:</p>
<ul>
<li>Agda: Only standard filters applied.</li>
<li>C : We include documents based on a keyword whitelist, namely: "#include <fftw.h>", "#include <fftw3.h>", "#include <rfftw.h>", "#include &lt;gsl", "#include <cblas.h>", "#include <blas.h>", "#include <lapacke.h>", "#include <nlopt.h>", "#include <petsc.h>".</li>
<li>C++ : We include documents based on a keyword whitelist, namely: "#include <adept_arrays.h>", "#include <adept.h>", "#include <alglib>, "#include &lt;boost", "#include &lt;armadillo", "#include &lt;blitz", "#include &lt;Eigen", "#include &lt;deal.II", "#include &lt;dlib", "#include &lt;NTL", "#include &lt;mtl".</li>
<li>Fortran : Only standard filters applied.</li>
<li>GAP : Only standard filters applied.</li>
<li>
<p>Haskell : We filtered the data to only contain files with the following imports: Numeric.LinearAlgebra, Numeric.SpecFunctions, Numeric.Vector, Statistics, Data.Complex.</p>
</li>
<li>
<p>Idris : Only standard filters applied.</p>
</li>
<li>Julia : We filtered out mislabeled JSON lines files. We removed files larger than 10,000 characters long which both were not files containing tests and which had a lower numerical density than 0.5 , and otherwise ignored numerical density. We additionally only accepted files within a specific keyword whitelist, to attempt to control relevance to scientific computing, namely: "LinearAlgebra", "DifferentialEquations", "Symbolics", "Distributions", "DataFrames", "DynamicalSystems", "Turing", "Gen", "JuMP", "sqrt", "abs", "zeros", "ones", "sin", "cos", "tan", "log", "exp", "integrate", "likelihood", "Matrix", $\pi$, "pi", "rand", "grad".</li>
<li>Jupyter : We found that many Jupyter notebook files were large due to containing long cell outputs, such as base64 images, long tracebacks, or other extra JSON cell metadata. We use nbconvert to convert notebooks to a markdown format, removing metadata.</li>
<li>Maple : We filtered out files with a size greater than 100, 000 bytes, and found that some files were XML. We filtered all files beginning with an XML declaration.</li>
<li>Python : We filtered notebooks and JSON files out by excluding documents with beginning " " characters, and included only files importing from a fixed list of libraries.</li>
<li>R : We excluded all files beginning with an XML declaration. We additionally filtered out all notebooks, and filtered all files containing MacOS "Resource Fork" files.</li>
<li>Tex : We used a max file size of 10,000,000 bytes. We excluded tex files found in directories named "latex/" because these were often auto-generated files, and excluded documents using gnuplot. We included only documents containing one of the keywords " $\backslash$ chapter{", " $\backslash$ chapter<em> ${"$, " $\backslash$ section ${"$, " $\backslash$ section</em> ${"$, " $\backslash$ subsection ${"$, " $\backslash$ subsection<em> ${"$, " $\backslash$ subsubsection ${"$, " $\backslash$ subsubsection</em> ${"$, " $\backslash$ paragraph ${"$, " $\backslash$ subparagraph ${"$, and additionally only included documents identified as English by a classifier from the langid package.</li>
</ul>
<p>For all languages we used within the Stack, unless otherwise stated, we additionally filtered out files with a filesize greater than 1048575 bytes or with a numerical density (ratio of digit characters to non-digit characters) of 0.5 .</p>
<p>We used v1.2 of the near-deduplicated Stack as a base for processing.</p>
<h1>B. 2 Papers: ARXIV</h1>
<p>We use the entirety of ArXiv, as accessed by Computer (2023) in April 2023. For further information on preprocessing applied to ArXiv, see Computer (2023).</p>
<h2>B. 3 Web: OpenWebMath</h2>
<p>For the web portion of our training dataset, we use OpenWebMath (Paster et al., 2023).</p>
<h2>C Evaluation Harness</h2>
<p>We implement a variety of math-related tasks and evaluation protocols into a public fork of the Language Model Evaluation Harness (Gao et al., 2021). The Harness provides a model-agnostic framework for standardized, reproducible evaluation of language models.</p>
<p>We add the following tasks for the evaluations in this paper:</p>
<ul>
<li>hendrycks_math_ppl: Perplexity evaluation on MATH (Hendrycks et al., 2021a) sub-tasks.</li>
<li>minif2f_isabelle: Proof autoformalization in Isabelle on the miniF2F benchmark based on Jiang et al. (2023), with a Portal-to-Isabelle (Jiang et al., 2021) proof checker.</li>
<li>minerva_math: The MATH benchmark with the prompt and Sympy evaluation from Minerva (Lewkowycz et al., 2022).</li>
<li>
<p>minerva-hendrycksTest: MMLU-STEM tasks following Lewkowycz et al. (2022).</p>
</li>
<li>
<p>ocw_courses: The OCW Courses task from Lewkowycz et al. (2022).</p>
</li>
<li>python_gsm8k: GSM8k with Python, based on Gao et al. (2022).</li>
<li>sympy_math: MATH with Sympy evaluation.</li>
</ul>
<p>We include a link to the implementations for these tasks, including full prompts, in our public codebase.</p>
<h1>D Evaluation: Experiment Details</h1>
<h2>D. 1 Isabelle Informal-to-Formal Theorem Proving</h2>
<p>We follow Jiang et al. (2023), allowing the model to issue a call to built-in Isabelle automation in the output proof by generating sledgehammer. This calls Sledgehammer (Paulson \&amp; Nipkow, 2023) and the list of heuristics listed in Jiang et al. (2023). Following Jiang et al. (2023), as a baseline we use Sledgehammer and the heuristics executed at the beginning of the proof (referred to as Sledgehammer in the main text for brevity). We use a 30 -second timeout for Sledgehammer and implement proof checking via Portal-to-Isabelle (Jiang et al., 2021). Refer to the implementation in the Evaluation Harness for further details.</p>
<h2>D. 2 Lean Theorem Proving</h2>
<p>Theorem proving via tactic prediction involves interacting with a proof assistant after each step of a proof. Implementing these interactions within the evaluation harness is outside the scope of this work. Therefore, for the Lean theorem proving task we use a separate evaluation setup based on an open-source implementation (Welleck, 2023). We include our evaluation code in our public codebase.</p>
<p>Setup. We evaluate on miniF2F (Zheng et al., 2021), which consists of 488 formalized statements from math competitions and undergraduate coursework. Given a formalized statement, the task is to generate a formal proof that is checked by Lean.</p>
<p>We use best first search, commonly used for neural tactic prediction models (e.g., Polu \&amp; Sutskever (2020)). Best first search is parameterized by the number of attempts (N), generated tactics per iteration (S), and maximum iterations (T). We define the search budget to be the maximum number of generated tactics, $N \times S \times T$. We set our search budget to $N=1, S=32$, and $T=100$, less than that of the baseline model. Following Yang et al. (2023), we generate tactics with beam search and use a 10 minute timeout. We adapt the proof search implementation from Welleck (2023), which uses LeanDojo v.1.1.2 (Yang et al., 2023) for interaction. We use Lean 4 miniF2F, using https://github.com/rah4927/lean-dojo-mew commit d00c776260c77de7e70125ef0cd119de6c0ff1de. Note that the ReProver baseline from (Yang et al., 2023) reports performance with Lean 3.
Prompt. We prompt the model with three (state, tactic) examples, shown in Figure 5.</p>
<div class="codehilite"><pre><span></span><code><span class="s">&quot;&quot;&quot;Given the Lean 4 tactic state, suggest a next tactic.</span>
<span class="n">Here</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">examples</span><span class="o">:</span>
<span class="n">Tactic</span><span class="w"> </span><span class="n">state</span><span class="o">:</span>
<span class="o">---</span>
<span class="err">\</span><span class="n">alpha</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">u_1</span>
<span class="nl">r</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Prop</span><span class="err">#</span>
<span class="n">inst</span><span class="err">&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">DecidableEq</span><span class="w"> </span><span class="n">ot</span>
<span class="nl">inst</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IsIrrefl</span><span class="w"> </span><span class="n">α</span><span class="w"> </span><span class="n">r</span>
<span class="err">\</span><span class="n">vdash</span><span class="w"> </span><span class="n">CutExpand</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">InvImage</span><span class="w"> </span><span class="p">(</span><span class="n">Finsupp</span><span class="p">.</span><span class="n">Lex</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">r</span><span class="w"> </span><span class="n">II</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x_1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="n">x_1</span><span class="p">)</span>
<span class="w">        </span><span class="n">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x_1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x_1</span><span class="p">)</span><span class="w"> </span><span class="err">↑</span><span class="n">toFinsupp</span>
<span class="o">---</span>
<span class="n">Next</span><span class="w"> </span><span class="n">tactic</span><span class="o">:</span>
<span class="o">---</span>
<span class="n">rintro</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">hr</span><span class="p">,</span><span class="w"> </span><span class="n">he</span><span class="p">)</span>
<span class="o">---</span>
<span class="n">Tactic</span><span class="w"> </span><span class="n">state</span><span class="o">:</span>
<span class="o">---</span>
<span class="err">\</span><span class="n">iota</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">u_lt</span>
<span class="n">I</span><span class="w"> </span><span class="n">tU</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Box</span><span class="w"> </span><span class="err">\</span><span class="n">iota</span>
<span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">\</span><span class="n">iota</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">R</span>
<span class="n">I</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">WithBot</span><span class="w"> </span><span class="p">(</span><span class="n">Box</span><span class="w"> </span><span class="err">\</span><span class="n">iota</span><span class="p">)</span>
<span class="err">\</span><span class="n">vdash</span><span class="w"> </span><span class="err">↑</span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">↑</span><span class="n">J</span><span class="w"> </span><span class="err">\</span><span class="n">leftrightarrow</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">J</span>
<span class="o">---</span>
<span class="n">Next</span><span class="w"> </span><span class="n">tactic</span><span class="o">:</span>
<span class="o">---</span>
<span class="n">simp</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="p">[</span><span class="n">Subset</span><span class="p">.</span><span class="n">antisymm_iff</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">leftarrow</span><span class="w"> </span><span class="n">le_antisymm_iff</span><span class="p">,</span>
<span class="w">        </span><span class="n">withBotCoe_subset_iff</span><span class="p">]</span>
<span class="o">---</span>
<span class="n">Tactic</span><span class="w"> </span><span class="n">state</span><span class="o">:</span>
<span class="o">---</span>
<span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">N</span>
<span class="nl">h</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Nat</span><span class="p">.</span><span class="n">coprime</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span>
<span class="err">\</span><span class="n">vdash</span><span class="w"> </span><span class="n">Nat</span><span class="p">.</span><span class="n">gcd</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="o">---</span>
<span class="n">Next</span><span class="w"> </span><span class="n">tactic</span><span class="o">:</span>
<span class="o">---</span>
<span class="n">rw</span><span class="w"> </span><span class="p">[</span><span class="err">\</span><span class="n">leftarrow</span><span class="w"> </span><span class="n">h</span><span class="p">.</span><span class="n">gcd_eq_one</span><span class="p">]</span>
<span class="o">---</span>
<span class="n">Tactic</span><span class="w"> </span><span class="n">state</span><span class="o">:</span>
<span class="o">---</span>
<span class="nf">%s</span>
<span class="o">---</span>
<span class="n">Next</span><span class="w"> </span><span class="n">tactic</span><span class="o">:</span>
<span class="o">---</span><span class="s">&quot;&quot;&quot;</span>
</code></pre></div>

<p>Figure 5: Prompt for the Lean theorem proving experiments.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ https://github.com/EleutherAI/math-lm&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>