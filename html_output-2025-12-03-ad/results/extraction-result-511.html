<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-511 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-511</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-511</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-15.html">extraction-schema-15</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models encode, represent, or utilize spatial knowledge, procedural knowledge, or object-relational knowledge for embodied planning, navigation, or manipulation tasks, particularly when the model operates without direct sensory input.</div>
                <p><strong>Paper ID:</strong> paper-5dbffedcabe3fa43060ebbe2b1789500edfd871f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/5dbffedcabe3fa43060ebbe2b1789500edfd871f" target="_blank">Reasoning with Language Model is Planning with World Model</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> A new LLM reasoning framework, RAP, which repurposes the LLM as both a world model and a reasoning agent, and incorporates a principled planning algorithm (based on Monto Carlo Tree Search) for strategic exploration in the vast reasoning space.</p>
                <p><strong>Paper Abstract:</strong> Large language models (LLMs) have shown remarkable reasoning capabilities, especially when prompted to generate intermediate reasoning steps (e.g., Chain-of-Thought, CoT). However, LLMs can still struggle with problems that are easy for humans, such as generating action plans for executing tasks in a given environment, or performing complex math, logical, and commonsense reasoning. The deficiency stems from the key fact that LLMs lack an internal $\textit{world model}$ to predict the world $\textit{state}$ (e.g., environment status, intermediate variable values) and simulate long-term outcomes of actions. This prevents LLMs from performing deliberate planning akin to human brains, which involves exploring alternative reasoning paths, anticipating future states and rewards, and iteratively refining existing reasoning steps. To overcome the limitations, we propose a new LLM reasoning framework, $\underline{R}$easoning vi$\underline{a}$ $\underline{P}$lanning $\textbf{(RAP)}$. RAP repurposes the LLM as both a world model and a reasoning agent, and incorporates a principled planning algorithm (based on Monto Carlo Tree Search) for strategic exploration in the vast reasoning space. During reasoning, the LLM (as agent) incrementally builds a reasoning tree under the guidance of the LLM (as world model) and task-specific rewards, and obtains a high-reward reasoning path efficiently with a proper balance between exploration $\textit{vs.}$ exploitation. We apply RAP to a variety of challenging reasoning problems including plan generation, math reasoning, and logical inference. Empirical results on these tasks demonstrate the superiority of RAP over various strong baselines, including CoT and least-to-most prompting with self-consistency. RAP on LLAMA-33B surpasses CoT on GPT-4 with 33% relative improvement in a plan generation setting.</p>
                <p><strong>Cost:</strong> 0.018</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e511.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e511.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models encode, represent, or utilize spatial knowledge, procedural knowledge, or object-relational knowledge for embodied planning, navigation, or manipulation tasks, particularly when the model operates without direct sensory input.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RAP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reasoning via Planning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A framework that repurposes a frozen LLM to act both as a world model (predicting next textual states) and a reasoning agent, and couples it with Monte Carlo Tree Search to plan high-reward reasoning traces by simulating state-action rollouts entirely in language.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LLaMA-33B (evaluated); Llama-2 70B (evaluated)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>33B / 70B</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Frozen transformer language models (LLaMA-33B, Llama-2 70B) used without fine-tuning; repurposed at inference via few-shot/in-context prompting to (a) generate candidate actions given a text-encoded state, and (b) act as a world model that predicts the next state in natural-language form. No direct sensory modules; all transition dynamics are produced by the LLM's generative distribution conditioned on prompts and demonstrations.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>General planning / multi-step reasoning (applied to Blocksworld plan generation, GSM8k math decomposition, PrOntoQA logical proofs)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Produce multi-step action sequences and/or intermediate state descriptions to reach a goal or final answer. The framework defines task-specific notions of state (textual descriptions of environment configuration, intermediate variable values, or focused facts) and action (textual subquestions, block-moving instructions, or rule selections). The LLM simulates sequences (s0,a0,s1,...,sT) via its world-model role; MCTS explores alternative traces and backpropagates rewards.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>multi-step planning / reasoning (applied to embodied manipulation planning, mathematical decomposition, logical proof generation)</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>procedural + object-relational (+ spatial when tasks encode spatial relations in text); i.e., action sequences, object relations (on/clear/holding), and spatial relations encoded as textual predicates</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_source</strong></td>
                            <td>pre-training on large text corpora (implicit knowledge in weights) + in-context few-shot demonstrations provided in prompts during inference</td>
                        </tr>
                        <tr>
                            <td><strong>has_direct_sensory_input</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>elicitation_method</strong></td>
                            <td>few-shot / in-context prompting to elicit actions and state transitions from the LLM; Monte Carlo Tree Search planning over sampled actions and LLM-predicted state transitions; RAP-Aggregation for ensembling final answers when applicable</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_representation</strong></td>
                            <td>States represented explicitly as natural-language symbolic descriptions (e.g., 'red block is on top of blue block', 'hand is empty'); actions as natural-language instructions or subquestions; transition dynamics encoded implicitly in model weights but exposed via prompted textual next-state outputs (textual/symbolic state transitions).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>task-dependent: plan success rate (Blocksworld), answer accuracy (GSM8k), prediction/proof accuracy (PrOntoQA)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>Blocksworld (LLaMA-33B RAP(20)): success rates by minimal steps: 2-step 100%, 4-step 88%, 6-step 42% (Table 1). Full Blocksworld (Llama-2 70B RAP(10)): 'Easy' overall 65%, 'Hard' overall 51% (Table 4). GSM8k (LLaMA-33B RAP(10)): accuracy 48.6%, +aggregation 51.6% (Table 2). PrOntoQA (LLaMA-33B RAP): prediction accuracy 94.2%, proof accuracy 78.8% (Table 3).</td>
                        </tr>
                        <tr>
                            <td><strong>success_patterns</strong></td>
                            <td>The LLM-as-world-model successfully (1) encodes object-relational relations (e.g., on/clear/holding) in text and uses them to constrain valid actions; (2) simulates multi-step procedural plans by predicting textual next states, enabling lookahead and backtracking; (3) avoids illegal moves by consulting the textual state representation; (4) benefits from reward signals (action likelihood, state confidence, self-evaluation, task-specific heuristics) to prioritize promising actions during MCTS.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_patterns</strong></td>
                            <td>Failures arise when required plan horizon exceeds iteration budget (longer multi-step plans, e.g., many 6+ step cases); noisy or unconstrained natural-language action proposals can reduce reliability (especially in free-form domains like math); some reward components may misguide search in certain domains (action-likelihood reward can be noisy for unconstrained textual steps), and the simulated world model can make incorrect state-prediction errors leading MCTS down unproductive branches.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Compared to Chain-of-Thought (CoT) with LLaMA-33B which nearly fails on Blocksworld (2-step 17%, 4-step 2%, 6-step 0%), RAP yields much higher success (Table 1). RAP with LLaMA-33B outperforms GPT-4 with CoT on Blocksworld by a reported ~33% relative improvement in that setting. On GSM8k, RAP(10) (48.6%) beats CoT+Self-Consistency baselines; on PrOntoQA RAP improves both prediction and proof accuracy over CoT.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td>Reward ablations (Blocksworld Table 5): action-likelihood (R1) + task-specific (R2) yields success 0.88; adding self-eval (R3) raises to 0.91. Removing R1 drops to 0.21 or lower depending on combination; with no rewards success 0.02. GSM8k ablations (Table 6) show state transition confidence and self-evaluation together give best single-iteration results; action-likelihood can help or hurt depending on iteration budget. These ablations indicate reward design is critical to guide MCTS and that different reward modalities matter for different domains.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>A language model can act as an internal textual world model: representing states as natural-language symbolic descriptions and predicting next states via prompting enables planning without any direct sensory input. Coupling this with MCTS permits structured exploration (backtracking, lookahead) and yields large improvements over autoregressive CoT baselines on embodied-style planning (Blocksworld) and other multi-step reasoning tasks. Careful reward design (likelihood priors, state-confidence, self-evaluation, task heuristics) is essential to bias search toward feasible, high-reward trajectories.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reasoning with Language Model is Planning with World Model', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e511.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e511.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models encode, represent, or utilize spatial knowledge, procedural knowledge, or object-relational knowledge for embodied planning, navigation, or manipulation tasks, particularly when the model operates without direct sensory input.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RAP-Blocksworld</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>RAP applied to Blocksworld plan generation</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Concrete application of RAP to an embodied manipulation benchmark where states are textual block configurations and actions are block-manipulation instructions; the LLM predicts next textual states and MCTS searches for valid plans to reach a goal stack configuration without any visual or proprioceptive input.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LLaMA-33B (primary experiments); Llama-2 70B (full dataset experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>33B / 70B</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Frozen autoregressive LLMs used as (1) an action generator p_phi(a|s) to sample currently-valid candidate actions conditioned on a textual state and domain restrictions, and (2) a state transition predictor p_theta(s_{t+1}|s_t,a_t,c') that outputs the new textual state after the action; prompts include few-shot demonstrations and domain rules. No fine-tuning or sensory modules.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>Blocksworld plan generation (rearrangement of blocks into target stacks)</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Given an initial textual description of block positions and a textual goal (desired 'on' relations), generate a sequence of block-manipulation actions (Pickup, PutDown, Unstack, Stack) that transforms the initial state to a state satisfying the goal. State is updated by the LLM world-model in text; planning halts when goal conditions are met or depth limit reached.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>object manipulation / multi-step planning</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>spatial + procedural + object-relational (spatial relations 'on top of', object properties 'clear', 'in-hand'; procedural actions: pickup/unstack/put down/stack)</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_source</strong></td>
                            <td>pre-training (implicit), in-context few-shot demonstrations (prompting) to encode domain rules and example transitions</td>
                        </tr>
                        <tr>
                            <td><strong>has_direct_sensory_input</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>elicitation_method</strong></td>
                            <td>few-shot prompting to elicit valid actions and state transitions; MCTS (RAP-MCTS) to sample actions, simulate rollouts, and backpropagate rewards; action-space restricted by generating only currently-valid actions from the LLM conditioned on state and action constraints</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_representation</strong></td>
                            <td>State encoded as natural-language predicates (e.g., 'red block is on top of blue block', 'hand is empty', 'orange block is clear'); actions are textual operations; transitions are textual state updates produced by LLM prompts (example-driven), i.e., explicit symbolic language-based state representation rather than vector maps.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>plan success rate (proportion of test cases for which produced plan achieves goal conditions)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>LLaMA-33B RAP(20): success rates — 2-step 1.00 (100%), 4-step 0.88 (88%), 6-step 0.42 (42%) (Table 1). CoT (LLaMA-33B) was 0.17/0.02/0.00 for 2/4/6 steps. Full Blocksworld with Llama-2 70B RAP(10): 'Easy' All 0.65, 'Hard' All 0.51 (Table 4). RAP(10/20) substantially outperforms CoT and some GPT-4 CoT numbers in specific groupings.</td>
                        </tr>
                        <tr>
                            <td><strong>success_patterns</strong></td>
                            <td>Succeeding cases show the model (via textual state) recognizes legal actions at each step, simulates the consequences of actions accurately in text, backtracks from dead-end traces via MCTS, and uses task-specific reward (matching predicted state to goal) to prioritize goal-progressing actions.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_patterns</strong></td>
                            <td>Failures concentrate on longer-horizon problems where search budget is insufficient (search space grows combinatorially); occasional incorrect textual state predictions (world-model errors) cause MCTS to explore wrong branches; when action proposals are noisy or invalid and not filtered by the state, planning degrades.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>Baselines: Chain-of-Thought (CoT) with LLaMA-33B (2-step 17%, 4-step 2%, 6-step 0%), CoT pass@10 slightly better but still poor. GPT-4 with CoT achieved 0.50/0.63/0.40 for 2/4/6-step groups in this experimental setting; RAP with LLaMA-33B (and Llama-2 70B) outperforms LLaMA-33B CoT by large margins and surpasses GPT-4 CoT by a reported ~33% relative improvement in one setting (paper claim).</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td>Reward ablation (Table 5): using action-likelihood (R1) + task-specific reward (R2) yields success 0.88; adding self-evaluation (R3) increases success to 0.91. R1 alone 0.46; R2 alone 0.21; R3 alone 0.14; none 0.02. This indicates the action-likelihood prior and task-specific heuristics are crucial to find valid plans, with self-eval providing further gains.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>When the LLM explicitly encodes world state in natural language and is prompted to predict state transitions, it can simulate embodied manipulation plans (stacking/unstacking) without sensory input. Constraining action proposals by current textual state and using MCTS + appropriate rewards (especially task-specific goal matching and action-likelihood priors) are critical to generate legal and goal-directed plans and to enable backtracking and exploration that CoT autoregressive approaches lack.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reasoning with Language Model is Planning with World Model', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e511.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e511.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models encode, represent, or utilize spatial knowledge, procedural knowledge, or object-relational knowledge for embodied planning, navigation, or manipulation tasks, particularly when the model operates without direct sensory input.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RAP-PrOntoQA</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>RAP applied to PrOntoQA logical reasoning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Application of RAP to logical inference tasks where states are single focused textual facts and actions are selections of rules to derive new facts; the LLM world-model performs one-hop deductions in text and MCTS searches for a proof chain leading to the hypothesis without any sensory input.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>LLaMA-33B</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td>33B</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Frozen LLaMA-33B used as both action proposer (choose a rule given current focused fact) and world-model (apply a rule to predict the next fact in textual form); self-evaluation reward used to score reasoning steps.</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>PrOntoQA logical reasoning / proof generation</td>
                        </tr>
                        <tr>
                            <td><strong>task_description</strong></td>
                            <td>Given a set of textual facts and rules (an ontology) and a hypothesis, the task is to verify the hypothesis (true/false) and produce a detailed proof (sequence of applied rules and derived facts). RAP defines state as the currently-focused fact, actions as selecting a rule to apply, and simulates one-hop deductions as next states until the hypothesis is derived or dead-ends.</td>
                        </tr>
                        <tr>
                            <td><strong>task_type</strong></td>
                            <td>logical reasoning / proof generation (structured multi-step inference)</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_type</strong></td>
                            <td>object-relational (facts and relations among entities) + procedural (deduction steps / rule application)</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_source</strong></td>
                            <td>pre-training (implicit), in-context few-shot examples for action-quality calibration and self-evaluation prompts</td>
                        </tr>
                        <tr>
                            <td><strong>has_direct_sensory_input</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>elicitation_method</strong></td>
                            <td>few-shot prompting for action proposal and next-state (one-hop) prediction; self-evaluation reward to score step correctness; MCTS to search proof trees and balance exploration/exploitation</td>
                        </tr>
                        <tr>
                            <td><strong>knowledge_representation</strong></td>
                            <td>Facts and rules are represented as exact textual sentences; the state is a focused textual fact (working-memory style), actions select exact rule sentences; deductions are produced as new textual facts — an explicit symbolic textual representation used for planning.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>prediction accuracy (true/false) and full-proof accuracy (correct derivation chain)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_result</strong></td>
                            <td>On PrOntoQA (500 sampled examples): RAP prediction accuracy 94.2%, proof accuracy 78.8% (Table 3). CoT baseline prediction 87.8%, proof 64.8%; CoT+SC prediction 89.8%.</td>
                        </tr>
                        <tr>
                            <td><strong>success_patterns</strong></td>
                            <td>RAP reliably composes multi-hop logical deductions by treating facts as states and rules as actions; the world-model LLM produces consistent one-hop inferences, self-evaluation rewards help identify incorrect steps, and MCTS enables finding correct proof chains and avoiding dead ends via backpropagated signals.</td>
                        </tr>
                        <tr>
                            <td><strong>failure_patterns</strong></td>
                            <td>Proof-level failures occur when the LLM's one-hop inference is incorrect or when search budget is insufficient to explore alternative rule sequences; errors in state-prediction (incorrectly applying a rule) cause propagation of incorrect facts.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td>CoT (LLaMA-33B): prediction 87.8%, proof 64.8%; CoT+Self-Consistency improved prediction to 89.8% but did not match RAP's proof accuracy. RAP shows +14% proof accuracy above CoT and +4.4% prediction accuracy above CoT+SC.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td>While domain-specific reward ablations are not listed per PrOntoQA, the paper reports that self-evaluation reward is especially helpful in logical/mathematical tasks (Table 6 and Section 5.2), indicating that removing self-evaluation reduces the ability to detect and avoid incorrect deductive steps.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Representing working-memory facts explicitly in text and using the LLM to perform one-hop deductions (world-model role) allows effective search for multi-hop proofs using MCTS. Self-evaluation rewards are particularly valuable for logical proofs because errors are often easier to detect after generation, enabling the planner to avoid bad branches and assemble correct proofs without sensory inputs.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reasoning with Language Model is Planning with World Model', 'publication_date_yy_mm': '2023-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Large language models still can't plan (a benchmark for llms on planning and reasoning about change) <em>(Rating: 2)</em></li>
                <li>On the planning abilities of large language models (a critical investigation with a proposed benchmark) <em>(Rating: 2)</em></li>
                <li>Inner monologue: Embodied reasoning through planning with language models <em>(Rating: 2)</em></li>
                <li>Language models meet world models: Embodied experiences enhance language models <em>(Rating: 2)</em></li>
                <li>LLM+P: Empowering large language models with optimal planning proficiency <em>(Rating: 1)</em></li>
                <li>Task and motion planning with large language models for object rearrangement <em>(Rating: 1)</em></li>
                <li>Daydreamer: World models for physical robot learning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-511",
    "paper_id": "paper-5dbffedcabe3fa43060ebbe2b1789500edfd871f",
    "extraction_schema_id": "extraction-schema-15",
    "extracted_data": [
        {
            "name_short": "RAP",
            "name_full": "Reasoning via Planning",
            "brief_description": "A framework that repurposes a frozen LLM to act both as a world model (predicting next textual states) and a reasoning agent, and couples it with Monte Carlo Tree Search to plan high-reward reasoning traces by simulating state-action rollouts entirely in language.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LLaMA-33B (evaluated); Llama-2 70B (evaluated)",
            "model_size": "33B / 70B",
            "model_description": "Frozen transformer language models (LLaMA-33B, Llama-2 70B) used without fine-tuning; repurposed at inference via few-shot/in-context prompting to (a) generate candidate actions given a text-encoded state, and (b) act as a world model that predicts the next state in natural-language form. No direct sensory modules; all transition dynamics are produced by the LLM's generative distribution conditioned on prompts and demonstrations.",
            "task_name": "General planning / multi-step reasoning (applied to Blocksworld plan generation, GSM8k math decomposition, PrOntoQA logical proofs)",
            "task_description": "Produce multi-step action sequences and/or intermediate state descriptions to reach a goal or final answer. The framework defines task-specific notions of state (textual descriptions of environment configuration, intermediate variable values, or focused facts) and action (textual subquestions, block-moving instructions, or rule selections). The LLM simulates sequences (s0,a0,s1,...,sT) via its world-model role; MCTS explores alternative traces and backpropagates rewards.",
            "task_type": "multi-step planning / reasoning (applied to embodied manipulation planning, mathematical decomposition, logical proof generation)",
            "knowledge_type": "procedural + object-relational (+ spatial when tasks encode spatial relations in text); i.e., action sequences, object relations (on/clear/holding), and spatial relations encoded as textual predicates",
            "knowledge_source": "pre-training on large text corpora (implicit knowledge in weights) + in-context few-shot demonstrations provided in prompts during inference",
            "has_direct_sensory_input": false,
            "elicitation_method": "few-shot / in-context prompting to elicit actions and state transitions from the LLM; Monte Carlo Tree Search planning over sampled actions and LLM-predicted state transitions; RAP-Aggregation for ensembling final answers when applicable",
            "knowledge_representation": "States represented explicitly as natural-language symbolic descriptions (e.g., 'red block is on top of blue block', 'hand is empty'); actions as natural-language instructions or subquestions; transition dynamics encoded implicitly in model weights but exposed via prompted textual next-state outputs (textual/symbolic state transitions).",
            "performance_metric": "task-dependent: plan success rate (Blocksworld), answer accuracy (GSM8k), prediction/proof accuracy (PrOntoQA)",
            "performance_result": "Blocksworld (LLaMA-33B RAP(20)): success rates by minimal steps: 2-step 100%, 4-step 88%, 6-step 42% (Table 1). Full Blocksworld (Llama-2 70B RAP(10)): 'Easy' overall 65%, 'Hard' overall 51% (Table 4). GSM8k (LLaMA-33B RAP(10)): accuracy 48.6%, +aggregation 51.6% (Table 2). PrOntoQA (LLaMA-33B RAP): prediction accuracy 94.2%, proof accuracy 78.8% (Table 3).",
            "success_patterns": "The LLM-as-world-model successfully (1) encodes object-relational relations (e.g., on/clear/holding) in text and uses them to constrain valid actions; (2) simulates multi-step procedural plans by predicting textual next states, enabling lookahead and backtracking; (3) avoids illegal moves by consulting the textual state representation; (4) benefits from reward signals (action likelihood, state confidence, self-evaluation, task-specific heuristics) to prioritize promising actions during MCTS.",
            "failure_patterns": "Failures arise when required plan horizon exceeds iteration budget (longer multi-step plans, e.g., many 6+ step cases); noisy or unconstrained natural-language action proposals can reduce reliability (especially in free-form domains like math); some reward components may misguide search in certain domains (action-likelihood reward can be noisy for unconstrained textual steps), and the simulated world model can make incorrect state-prediction errors leading MCTS down unproductive branches.",
            "baseline_comparison": "Compared to Chain-of-Thought (CoT) with LLaMA-33B which nearly fails on Blocksworld (2-step 17%, 4-step 2%, 6-step 0%), RAP yields much higher success (Table 1). RAP with LLaMA-33B outperforms GPT-4 with CoT on Blocksworld by a reported ~33% relative improvement in that setting. On GSM8k, RAP(10) (48.6%) beats CoT+Self-Consistency baselines; on PrOntoQA RAP improves both prediction and proof accuracy over CoT.",
            "ablation_results": "Reward ablations (Blocksworld Table 5): action-likelihood (R1) + task-specific (R2) yields success 0.88; adding self-eval (R3) raises to 0.91. Removing R1 drops to 0.21 or lower depending on combination; with no rewards success 0.02. GSM8k ablations (Table 6) show state transition confidence and self-evaluation together give best single-iteration results; action-likelihood can help or hurt depending on iteration budget. These ablations indicate reward design is critical to guide MCTS and that different reward modalities matter for different domains.",
            "key_findings": "A language model can act as an internal textual world model: representing states as natural-language symbolic descriptions and predicting next states via prompting enables planning without any direct sensory input. Coupling this with MCTS permits structured exploration (backtracking, lookahead) and yields large improvements over autoregressive CoT baselines on embodied-style planning (Blocksworld) and other multi-step reasoning tasks. Careful reward design (likelihood priors, state-confidence, self-evaluation, task heuristics) is essential to bias search toward feasible, high-reward trajectories.",
            "uuid": "e511.0",
            "source_info": {
                "paper_title": "Reasoning with Language Model is Planning with World Model",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "RAP-Blocksworld",
            "name_full": "RAP applied to Blocksworld plan generation",
            "brief_description": "Concrete application of RAP to an embodied manipulation benchmark where states are textual block configurations and actions are block-manipulation instructions; the LLM predicts next textual states and MCTS searches for valid plans to reach a goal stack configuration without any visual or proprioceptive input.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LLaMA-33B (primary experiments); Llama-2 70B (full dataset experiments)",
            "model_size": "33B / 70B",
            "model_description": "Frozen autoregressive LLMs used as (1) an action generator p_phi(a|s) to sample currently-valid candidate actions conditioned on a textual state and domain restrictions, and (2) a state transition predictor p_theta(s_{t+1}|s_t,a_t,c') that outputs the new textual state after the action; prompts include few-shot demonstrations and domain rules. No fine-tuning or sensory modules.",
            "task_name": "Blocksworld plan generation (rearrangement of blocks into target stacks)",
            "task_description": "Given an initial textual description of block positions and a textual goal (desired 'on' relations), generate a sequence of block-manipulation actions (Pickup, PutDown, Unstack, Stack) that transforms the initial state to a state satisfying the goal. State is updated by the LLM world-model in text; planning halts when goal conditions are met or depth limit reached.",
            "task_type": "object manipulation / multi-step planning",
            "knowledge_type": "spatial + procedural + object-relational (spatial relations 'on top of', object properties 'clear', 'in-hand'; procedural actions: pickup/unstack/put down/stack)",
            "knowledge_source": "pre-training (implicit), in-context few-shot demonstrations (prompting) to encode domain rules and example transitions",
            "has_direct_sensory_input": false,
            "elicitation_method": "few-shot prompting to elicit valid actions and state transitions; MCTS (RAP-MCTS) to sample actions, simulate rollouts, and backpropagate rewards; action-space restricted by generating only currently-valid actions from the LLM conditioned on state and action constraints",
            "knowledge_representation": "State encoded as natural-language predicates (e.g., 'red block is on top of blue block', 'hand is empty', 'orange block is clear'); actions are textual operations; transitions are textual state updates produced by LLM prompts (example-driven), i.e., explicit symbolic language-based state representation rather than vector maps.",
            "performance_metric": "plan success rate (proportion of test cases for which produced plan achieves goal conditions)",
            "performance_result": "LLaMA-33B RAP(20): success rates — 2-step 1.00 (100%), 4-step 0.88 (88%), 6-step 0.42 (42%) (Table 1). CoT (LLaMA-33B) was 0.17/0.02/0.00 for 2/4/6 steps. Full Blocksworld with Llama-2 70B RAP(10): 'Easy' All 0.65, 'Hard' All 0.51 (Table 4). RAP(10/20) substantially outperforms CoT and some GPT-4 CoT numbers in specific groupings.",
            "success_patterns": "Succeeding cases show the model (via textual state) recognizes legal actions at each step, simulates the consequences of actions accurately in text, backtracks from dead-end traces via MCTS, and uses task-specific reward (matching predicted state to goal) to prioritize goal-progressing actions.",
            "failure_patterns": "Failures concentrate on longer-horizon problems where search budget is insufficient (search space grows combinatorially); occasional incorrect textual state predictions (world-model errors) cause MCTS to explore wrong branches; when action proposals are noisy or invalid and not filtered by the state, planning degrades.",
            "baseline_comparison": "Baselines: Chain-of-Thought (CoT) with LLaMA-33B (2-step 17%, 4-step 2%, 6-step 0%), CoT pass@10 slightly better but still poor. GPT-4 with CoT achieved 0.50/0.63/0.40 for 2/4/6-step groups in this experimental setting; RAP with LLaMA-33B (and Llama-2 70B) outperforms LLaMA-33B CoT by large margins and surpasses GPT-4 CoT by a reported ~33% relative improvement in one setting (paper claim).",
            "ablation_results": "Reward ablation (Table 5): using action-likelihood (R1) + task-specific reward (R2) yields success 0.88; adding self-evaluation (R3) increases success to 0.91. R1 alone 0.46; R2 alone 0.21; R3 alone 0.14; none 0.02. This indicates the action-likelihood prior and task-specific heuristics are crucial to find valid plans, with self-eval providing further gains.",
            "key_findings": "When the LLM explicitly encodes world state in natural language and is prompted to predict state transitions, it can simulate embodied manipulation plans (stacking/unstacking) without sensory input. Constraining action proposals by current textual state and using MCTS + appropriate rewards (especially task-specific goal matching and action-likelihood priors) are critical to generate legal and goal-directed plans and to enable backtracking and exploration that CoT autoregressive approaches lack.",
            "uuid": "e511.1",
            "source_info": {
                "paper_title": "Reasoning with Language Model is Planning with World Model",
                "publication_date_yy_mm": "2023-05"
            }
        },
        {
            "name_short": "RAP-PrOntoQA",
            "name_full": "RAP applied to PrOntoQA logical reasoning",
            "brief_description": "Application of RAP to logical inference tasks where states are single focused textual facts and actions are selections of rules to derive new facts; the LLM world-model performs one-hop deductions in text and MCTS searches for a proof chain leading to the hypothesis without any sensory input.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "LLaMA-33B",
            "model_size": "33B",
            "model_description": "Frozen LLaMA-33B used as both action proposer (choose a rule given current focused fact) and world-model (apply a rule to predict the next fact in textual form); self-evaluation reward used to score reasoning steps.",
            "task_name": "PrOntoQA logical reasoning / proof generation",
            "task_description": "Given a set of textual facts and rules (an ontology) and a hypothesis, the task is to verify the hypothesis (true/false) and produce a detailed proof (sequence of applied rules and derived facts). RAP defines state as the currently-focused fact, actions as selecting a rule to apply, and simulates one-hop deductions as next states until the hypothesis is derived or dead-ends.",
            "task_type": "logical reasoning / proof generation (structured multi-step inference)",
            "knowledge_type": "object-relational (facts and relations among entities) + procedural (deduction steps / rule application)",
            "knowledge_source": "pre-training (implicit), in-context few-shot examples for action-quality calibration and self-evaluation prompts",
            "has_direct_sensory_input": false,
            "elicitation_method": "few-shot prompting for action proposal and next-state (one-hop) prediction; self-evaluation reward to score step correctness; MCTS to search proof trees and balance exploration/exploitation",
            "knowledge_representation": "Facts and rules are represented as exact textual sentences; the state is a focused textual fact (working-memory style), actions select exact rule sentences; deductions are produced as new textual facts — an explicit symbolic textual representation used for planning.",
            "performance_metric": "prediction accuracy (true/false) and full-proof accuracy (correct derivation chain)",
            "performance_result": "On PrOntoQA (500 sampled examples): RAP prediction accuracy 94.2%, proof accuracy 78.8% (Table 3). CoT baseline prediction 87.8%, proof 64.8%; CoT+SC prediction 89.8%.",
            "success_patterns": "RAP reliably composes multi-hop logical deductions by treating facts as states and rules as actions; the world-model LLM produces consistent one-hop inferences, self-evaluation rewards help identify incorrect steps, and MCTS enables finding correct proof chains and avoiding dead ends via backpropagated signals.",
            "failure_patterns": "Proof-level failures occur when the LLM's one-hop inference is incorrect or when search budget is insufficient to explore alternative rule sequences; errors in state-prediction (incorrectly applying a rule) cause propagation of incorrect facts.",
            "baseline_comparison": "CoT (LLaMA-33B): prediction 87.8%, proof 64.8%; CoT+Self-Consistency improved prediction to 89.8% but did not match RAP's proof accuracy. RAP shows +14% proof accuracy above CoT and +4.4% prediction accuracy above CoT+SC.",
            "ablation_results": "While domain-specific reward ablations are not listed per PrOntoQA, the paper reports that self-evaluation reward is especially helpful in logical/mathematical tasks (Table 6 and Section 5.2), indicating that removing self-evaluation reduces the ability to detect and avoid incorrect deductive steps.",
            "key_findings": "Representing working-memory facts explicitly in text and using the LLM to perform one-hop deductions (world-model role) allows effective search for multi-hop proofs using MCTS. Self-evaluation rewards are particularly valuable for logical proofs because errors are often easier to detect after generation, enabling the planner to avoid bad branches and assemble correct proofs without sensory inputs.",
            "uuid": "e511.2",
            "source_info": {
                "paper_title": "Reasoning with Language Model is Planning with World Model",
                "publication_date_yy_mm": "2023-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Large language models still can't plan (a benchmark for llms on planning and reasoning about change)",
            "rating": 2
        },
        {
            "paper_title": "On the planning abilities of large language models (a critical investigation with a proposed benchmark)",
            "rating": 2
        },
        {
            "paper_title": "Inner monologue: Embodied reasoning through planning with language models",
            "rating": 2
        },
        {
            "paper_title": "Language models meet world models: Embodied experiences enhance language models",
            "rating": 2
        },
        {
            "paper_title": "LLM+P: Empowering large language models with optimal planning proficiency",
            "rating": 1
        },
        {
            "paper_title": "Task and motion planning with large language models for object rearrangement",
            "rating": 1
        },
        {
            "paper_title": "Daydreamer: World models for physical robot learning",
            "rating": 1
        }
    ],
    "cost": 0.01757675,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Reasoning with Language Model is Planning with World Model</h1>
<p>Shibo Hao ${ }^{\star \Delta}$ Yi Gu ${ }^{\star \Delta}$ Haodi Ma ${ }^{\diamond}$ Joshua Jiahua Hong ${ }^{\Delta}$<br>Zhen Wang ${ }^{\text {A }}$ Daisy Zhe Wang ${ }^{\diamond}$ Zhiting Hu ${ }^{\Delta}$<br>${ }^{\text {A }}$ UC San Diego, ${ }^{\diamond}$ University of Florida<br>${ }^{\Delta}$ Mohamed bin Zayed University of Artificial Intelligence<br>{s5hao, yig025, jjhong, zhw085, zhh019}@ucsd.edu<br>{ma.haodi, daisyw}@ufl.edu</p>
<h4>Abstract</h4>
<p>Large language models (LLMs) have shown remarkable reasoning capabilities, particularly with chain-of-thought (CoT) prompting. However, LLMs sometimes still struggle with problems that are easy for humans, such as generating action plans to achieve given goals in an environment, or performing complex math or logical reasoning. The deficiency stems from the key fact that LLMs lack an internal world model to predict the world state (e.g., environment status, intermediate variable values) and simulate long-term outcomes of actions. This prevents LLMs from performing deliberate planning akin to human brains, which involves exploring alternative reasoning paths, anticipating future states and rewards, and iteratively refining existing reasoning steps. To overcome the limitations, we propose a new LLM reasoning framework, Reasoning via Planning (RAP). RAP repurposes the LLM as both a world model and a reasoning agent, and incorporates a principled planning algorithm based on Monte Carlo Tree Search for strategic exploration in the vast reasoning space. During reasoning, the LLM (as agent) incrementally builds a reasoning tree under the guidance of the LLM (as world model) and rewards, and efficiently obtains a high-reward reasoning path with a proper balance between exploration $v s$. exploitation. We apply RAP to various challenging reasoning problems including plan generation, math reasoning, and logical inference, and demonstrate its superiority over strong baselines. RAP with LLaMA-33B even surpasses CoT with GPT-4, achieving $33 \%$ relative improvement in a plan generation setting. ${ }^{1}$</p>
<h2>1 Introduction</h2>
<p>Large language models (LLMs) have exhibited emergent reasoning abilities in a wide range of tasks (Brown et al., 2020; Chowdhery et al., 2022;</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup>OpenAI, 2023). Recent approaches further boost their ability by prompting LLMs to generate intermediate reasoning steps, e.g., Chain-of-Thought, CoT (Wei et al., 2022) or answer a series of subquestions, e.g., least-to-most prompting (Zhou et al., 2022). However, LLMs still face difficulties with tasks that humans find easy. For example, in creating action plans to move blocks to a target state, GPT-3 (Brown et al., 2020) achieves a success rate of only $1 \%$, compared to $78 \%$ for humans (Valmeekam et al., 2022); these models also struggle with complex tasks that require multiple steps of math, logical, or commonsense reasoning (Huang and Chang, 2022; Mialon et al., 2023).</p>
<p>Humans possess an internal world model, a mental representation of the environment (JohnsonLaird, 1983, 2010; Gentner and Stevens, 2014), which enables humans to simulate actions and their effects on the world's state for deliberate planning for complex tasks of motor control, imagery, inference, and decision making (Tolman, 1948; Briscoe, 2011; Schulkin, 2012; LeCun, 2022). For example, to make an action plan towards a goal, planning with the world model involves exploring various alternative courses of actions, assessing the likely outcomes by rolling out possible future scenarios, and iteratively refining the plan based on the assessment (Huys et al., 2012; Gasparski and Orel, 2014; Ho et al., 2021). This is in stark contrast to the current LLM reasoning, which instinctively generates a reasoning trace in an autoregressive manner. In particular, we identify several key limitations of the current reasoning with LLMs, including (1) the lack of an internal world model to simulate the state of the world (e.g., the configuration of blocks, the values of intermediate variables), which is the foundation of human planning; (2) the absence of a reward mechanism to assess and guide the reasoning towards the desired state; and due to both limitations, (3) the incapability of balancing exploration vs. exploitation to efficiently explore vast</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: An overview of Reasoning via Planning (RAP). Compared with previous LLM reasoning methods like Chain-of-Thought (Wei et al., 2022), we explicitly model the world state from a world model (repurposed from the language model), and leverage advanced planning algorithms to solve the reasoning problems.</p>
<p>reasoning space.</p>
<p>To address these limitations, this paper proposes a new framework, <strong>Reasoning via Planning (RAP)</strong>, that enables LLMs to reason in a manner close to humans' conscious planning. RAP augments the LLM with a world model, and reasons with principled planning (specifically <em>Monte Carlo Tree Search, MCTS</em>) to produce high-reward reasoning traces after efficient exploration (Figure 1). Notably, we acquire the world model by repurposing the LLM itself with appropriate prompts. During the reasoning, the LLM strategically builds a reasoning tree by iteratively considering the most promising reasoning steps (<em>actions</em>) and using the world model (the same, repurposed LLM) to look ahead for future outcomes. The estimated future rewards are then backpropagated to update the LLM's beliefs about the current reasoning steps, guiding it to refine the reasoning by exploring better alternatives. Our MCTS-based planning effectively maintains a proper balance between exploration (of unvisited reasoning traces) and exploitation (of the best reasoning steps identified so far).</p>
<p>We show RAP is a general framework applicable to a diverse range of challenging problems and achieves substantial improvements over recent popular LLM reasoning methods. For plan generation, particularly in 2/4/6-step problems of Blocksworld (Valmeekam et al., 2023), RAP achieves an average success rate of 64% while CoT fails almost completely. Moreover, LLaMA-33B with RAP surpasses GPT-4 with CoT by 33% relative improvement. In the domains of mathematical reasoning, such as GSM8K (Cobbe et al., 2021) and logical inference exemplified by PrOntoQA (Saparov and He, 2022), RAP also consistently improves over strong baselines, including CoT, least-to-most prompting, and their self-consistency variants.</p>
<h2>2 Related Work</h2>
<p>Reasoning with LLMs. LLM reasoning typically involves decomposing complex questions into sequential intermediate steps (a.k.a. chains) before producing the final answer, exemplified by Chain-of-Thought (CoT) prompting and its variants (Wei et al., 2022; Kojima et al., 2022). The basic CoT generates chains all at once and can induce additional errors as the step count increases. Self-Consistency (Wang et al., 2022) samples multiple chains to choose the best answer via majority voting. Least-to-most prompting (Zhou et al., 2022) reduces the question into simpler subquestions and answers them sequentially. Similar to our reward formulation, recent works have explored self-evaluation approaches to provide feedback for intermediate steps (Welleck et al., 2022; Shinn et al., 2023; Paul et al., 2023). Aligned with our state formulation, Li et al. (2022) incorporate latent "situations" into LLMs, referring to the state of entities from the context. More relevantly, recent works have started to explore more complex structures guided by some search algorithms. For instance, CoRe (Zhu et al., 2022) fine-tunes reasoning step generator and verifier for math word problems with MCTS for decoding. Concurrently to our work, Yao et al. (2023) apply heuristic-based</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: RAP for plan generation in Blocksworld (left), math reasoning in GSM8K (middle), and logical reasoning in PrOntoQA (right).</p>
<p>search, like depth-/breadth-first search, for better reasoning paths. However, none of the above methods formally introduce the world model and instantiates the reward and state into a unified framework. Compared with these search-guided methods, RAP is a more principled framework to combine world model and reward with advanced planning.</p>
<p><strong>Planning with LLMs.</strong> Planning, a central ability in intelligent agents, involves generating a series of actions to achieve a specific goal (McCarthy, 1963; Bylander, 1994). Classical planning methods have been widely adopted in robots and embodied environments (Camacho and Alba, 2013; Jiang et al., 2019). Recently, prompting LLMs to do planning directly has gained attention and shown potential (Huang et al., 2022; Singh et al., 2022; Ding et al., 2023). Moreover, based on LLMs' powerful programming ability (Lyu et al., 2023; Jojic et al., 2023; Liu et al., 2023), recent works first translate natural language instructions into the executable programming languages, such as Planning Domain Description Language (PDDL), and runs classical planning algorithms, such as LLM+P (Liu et al., 2023). However, code-based planning is constrained by its narrow domains and the environment, while RAP can handle open-domain problems, such as math and logical reasoning. More related works on <em>world models and planning</em> are discussed in the Appendix D.</p>
<h2>3 Reasoning via Planning (RAP)</h2>
<p>In this section, we present the Reasoning via Planning (RAP) framework that enables LLMs to strategically plan a coherent reasoning trace for solving a wide range of reasoning tasks. We first build the world model by repurposing the LLM with prompting (Section 3.1). The world model serves as the foundation for deliberate planning, by allowing the LLM to plan ahead and seek out the expected outcomes in the future. We then introduce the rewards for assessing each state during reasoning in Section 3.2. Guided by the world model and rewards, the planning with Monte Carlo Tree Search (MCTS) efficiently explores the vast reasoning space and finds optimal reasoning traces (Section 3.3). Finally, when multiple promising reasoning traces are acquired during planning, we further introduce an aggregation method in Section 3.4 that yields an ensembled result and further boosts the reasoning performance.</p>
<h3>3.1 Language Model as World Model</h3>
<p>In general, a world model predicts the next <em>state</em> of the reasoning after applying an <em>action</em> to the current state (Ha and Schmidhuber, 2018b; Matsuo et al., 2022). RAP enables us to instantiate the general concepts of state and action in different ways depending on the specific reasoning problems at hand (Figure 2). For example, in Blocksworld, it is natural to define a state as the configuration of blocks (described in natural language), and an action to be a behavior of moving a block (e.g., "pickup the orange block"). In a math reasoning problem, we use the state to represent the values of intermediate variables, and set an action to be a subquestion that drives the reasoning to derive new values. In logical reasoning, a state is a fact we are focusing on, and an action is to choose a rule for the next deduction.</p>
<p>With the definition of state and action, the reasoning process can thus be described as a Markov decision process (MDP): given the current state</p>
<p>$s_{t,t=0,1, \ldots, T}$, e.g., the initial state $s_{0}$, the LLM (as a reasoning agent) generates an action space by sampling from its generative distribution $a_{t} \sim$ $p\left(a \mid s_{t}, c\right)$, where $c$ is a proper prompt (e.g., incontext demonstrations). Once an action is chosen, the world model then predicts the next state $s_{t+1}$ of the reasoning. Specifically, we repurpose the same LLM to obtain a state transition distribution $p\left(s_{t+1} \mid s_{t}, a_{t}, c^{\prime}\right)$, where $c^{\prime}$ is another prompt to guide the LLM to generate a state. For instance, in Blocksworld, the LLM (as the world model) generates text $s_{t+1}$ to describe the new configuration of blocks, given previous state $s_{t}$ and the action $a_{t}$.</p>
<p>Continuing the process results in a reasoning trace, which consists of a sequence of interleaved states and actions $\left(s_{0}, a_{0}, s_{1}, \ldots, a_{T-1}, s_{T}\right)$. This differs from the previous reasoning methods, such as Chain-of-Thought (Wei et al., 2022), where the intermediate reasoning steps consist of only a sequence of actions, e.g., ( $a_{0}=$ "pickup red block", $a_{1}=$ "stack on yellow block", ...) (see comparisons in Figure 1). Augmenting the reasoning with the (predicted) world states helps the LLM with a more grounded and coherent inference. Note that the full reasoning trace is simulated by the LLM itself (as a reasoning agent with an internal world model) without interacting with the external real environment. This resembles humans contemplating a possible plan in their minds. The capability of simulating future states, by introducing the world model, allows us to incorporate principled planning algorithms to efficiently explore the vast reasoning space as described in Section 3.3.</p>
<h3>3.2 Reward Design</h3>
<p>During reasoning, we want to assess the feasibility and desirability of each reasoning step, and guide the reasoning based on the assessment (Section 3.3). The assessment of each reasoning step (i.e., applying an action $a_{t}$ to the state $s_{t}$ ) is performed by a reward function $r_{t}=r\left(s_{t}, a_{t}\right) \in \mathbb{R}$. Similar to the state and action, the reward function can be specified in different ways to accommodate any knowledge or preferences about the reasoning problem of interest. Here we introduce several common rewards applicable to different tasks and shown to be effective in our experiments.
Likelihood of the action. When an action is generated by the LLM conditioning on the in-context demonstration and the current state, the probability of the specific action reflects the LLM's preference.
We thus can incorporate the log probability of the action as a reward. This reward reflects the "instinct" of LLMs as an agent, and can be also used as a prior for which action to explore.
Confidence of the state. State prediction is nontrivial in some problems, e.g., in math reasoning (Figure 2, middle), given an action (i.e., a subquestion), the world model predicts the next state by answering the subquestion. We incorporate the confidence of the state (i.e., answers in this case) as a reward. Specifically, we draw multiple sample answers from the world model, and use the proportion of the most frequent answer as the confidence. Higher confidence indicates that the state prediction is more consistent with the world knowledge of LLMs (Hao et al., 2023b), which typically leads to a more reliable reasoning step.
Self-evaluation by the LLM. It's sometimes easier to recognize the errors in reasoning than avoid generating them in advance. Thus, it's beneficial to allow the LLM to criticize itself with the question "Is this reasoning step correct?", and use the next-word probability of the token "Yes" as a reward. The reward evaluates LLM's own estimation of the correctness of reasoning. Note that the specific problems for self-evaluation can be different depending on the tasks.
Task-specific heuristics. RAP also allows us to flexibly plug in other task-specific heuristics into the reward function. For example, in plan generation for Blocksworld, we compare the predicted current state of blocks with the goal to calculate a reward (Section 4.1). The reward encourages the plan of movements to actively pace towards the target.</p>
<h3>3.3 Planning with Monte Carlo Tree Search</h3>
<p>Once equipped with the world model (Section 3.1) and rewards (Section 3.2), LLMs can reason with any planning algorithms. We adopt Monte Carlo Tree Search (MCTS) (Kocsis and Szepesvári, 2006; Coulom, 2007), a powerful planning algorithm that strategically explores the space of reasoning trees and strikes a proper balance between exploration and exploitation to find high-reward reasoning traces efficiently.</p>
<p>Specifically, MCTS builds a reasoning tree iteratively, where each node represents a state, and each edge represents an action and the transition from the current state to the next state after applying the action (Figure 1). To guide the LLM agent</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: An illustration of the four phases in an iteration in MCTS planning (Section 3.3).</p>
<p>to expand and explore the most promising nodes of the tree, the algorithm maintains a state-action value function Q: S × A → R, where Q(s, a) estimates the <em>expected future reward</em> of taking action a in state s. Figure 3 illustrates four operations in each iteration to expand the tree and update Q values. The process continues until a specified computational budget (e.g., the number of iterations) is reached, and the resulting traces are acquired from the tree. More details and the pseudo-code of the planning algorithm are given in Appendix A and Algorithm 1.</p>
<p><strong>Selection.</strong> The first phase selects a portion of the existing tree that is most promising for further expansion in the next phase. Starting from the root node (i.e., initial state s₀), at each level of the tree, the algorithm selects a child node as the next node. The phase finishes when a leaf node of the current tree is reached. Figure 3(a) highlights the selected path in red. To balance between exploration (of less-visited nodes) and exploitation (of high-value nodes), we use the well-known <em>Upper Confidence bounds applied to Trees (UCT)</em> (Kocsis and Szepesvári, 2006) to select each child node. Specifically, at node s, we select the action in the tree by considering both the Q value (for exploitation) and uncertainty (for exploration):</p>
<p>$$a^* = \arg\max_{a \in A(s)} \left[ Q(s, a) + w \sqrt{\frac{\ln N(s)}{N(c(s, a))}} \right], \qquad (1)$$</p>
<p>where N(s) is the number of times node s has been visited in previous iterations, and c(s, a) is the child node of applying a in state s. The less a child node was visited before (i.e., the more uncertain about this child node), the higher the second term in the equation. The weight w controls the balance between exploration and exploitation.</p>
<p><strong>Expansion.</strong> This phase expands the tree by adding new child nodes to the leaf node selected above. Given the state of the leaf node, we use the LLM (as agent) to sample d possible actions (e.g., subquestions in math reasoning), and then use the LLM (as world model) to predict the respective next state, resulting in d child nodes. Note that if the leaf node selected above is a terminal node (the end of a reasoning chain) already, we will skip expansion and jump to back-propagation.</p>
<p><strong>Simulation.</strong> To estimate the expected future rewards (Q values), this phase simulates the future situations of the current node using the world model. Starting from the current node as above, at each node s, we create an action following a <em>roll-out policy</em> and use the world model to predict the next state. The roll-out process continues until a terminal state is reached. There could be many ways to define the roll-out policy (e.g., by adding different randomness). In our experiments, for simplicity and reduced noises, we follow a similar process as in the expansion above, i.e., generating d candidate actions and picking one of the largest local reward a' = max_a' r(s, a). In practice, for efficiency, we discard the computationally costly components in r (e.g., the reward from the confidence of state requires sampling the answer multiple times), and use the resulting lightweight reward function for selecting actions during simulation.</p>
<p><strong>Back-propagation.</strong> Once we reach a terminal state in the above phases, we obtain a reasoning path from the root node to the terminal node. We now back-propagate the rewards on the path to update</p>
<p>the $Q$ value of each state-action pair along the path. Specifically, we update $Q(s, a)$ by aggregating the rewards in all future steps of node $s$.</p>
<p>Once a predetermined number of MCTS iterations is reached, we terminate the algorithm and select the final reasoning trace from the constructed tree for evaluation. There are various ways for the selection. One is to start from the root node and iteratively choose the action with the highest $Q$ value until reaching a terminal. Also, one can directly select the path from the iterations that yielded the highest reward, or opt to choose the leaf node (and the respective root-to-leaf path) that has been visited the most. In practice, we observed that the second strategy often yields the best results.</p>
<h3>3.4 RAP-Aggregation</h3>
<p>For problems, such as math reasoning (Section 4.2) where only the final answer is required, RAP could produce multiple traces and answers from different MCTS iterations, which will be aggregated to produce the final answer. We refer to such a mechanism as RAP-Aggregation. Note that problems like plan generation or logical inference require a complete reasoning trace as output; thus, RAPAggregation will not be applied.</p>
<h2>4 Experiments</h2>
<p>In this section, we demonstrate the flexibility and effectiveness of our RAP framework by applying it to a wide range of problems, including plan generation in an embodied environment (4.1), mathematical reasoning for solving math word problems (4.2), and logical reasoning for verifying hypotheses (4.3). The subsequent sections demonstrate how the world model formulation in RAP enables a versatile design of the state and action, catering to various reasoning contexts.</p>
<p>We primarily compare RAP with chain-ofthought (CoT) (Wei et al., 2022), and its variants like least-to-most prompting (Zhou et al., 2022) as baselines. We also consider ensembling multiple reasoning paths if applicable (also known as selfconsistency (Wang et al., 2022)). Moreover, we compare RAP with GPT-4 (OpenAI, 2023) when computation resources allow. By default, we use the LLaMA-33B model (Touvron et al., 2023a) as the base LLM for both our methods and baselines, with a sampling temperature of 0.8 . All prompts are listed in Appendix C.</p>
<h3>4.1 Plan Generation</h3>
<p>The plan generation task aims to produce a sequence of actions to achieve a given goal, possibly with additional constraints. The ability to generate plans is important for intelligent embodied agents, e.g. household robots (Puig et al., 2018).</p>
<p>Task setup. To explore the viability of the RAP framework for plan generation tasks, we adapt and evaluate RAP on the Blocksworld benchmark (Valmeekam et al., 2022), where an agent is asked to rearrange the blocks into stacks in a particular order. We define a state as the current orientation of the blocks and an action as an instruction that moves blocks. Specifically, an action is composed of one of the 4 verbs (i.e., STACK, UNSTACK, Put, and Pickup) and manipulated objects. For the action space, we generate the currently valid actions given the domain restrictions on actions and the current orientation of the blocks. To transit between states, we take the current action and query the LLM to predict the state changes to the relevant blocks. We then update the current state by adding the new block conditions and removing the conditions that are no longer true. Once a state has met all conditions in the goal or the depth limit of the tree is reached, we terminate the associated node.</p>
<p>To assess the quality of actions within this domain, we use two separate rewards. First, we prompt the LLM with some example test cases along with their solutions, and then calculate the log probability of the action given the current state ("Likelihood of action" reward in Section 3.2), denoted as $r_{1}$. This reward reflects the intuition of the LLM as the reasoning agent. It's typically indicative when there are few steps left to the goal, while not as reliable for a distant goal. Additionally, we compare the new state after performing an action with the goal and provide a reward, $r_{2}$, scaling with the number of conditions met ("Task-specific heuristics" reward). Specifically, when all the conditions are met, we assign a super large reward to make sure this plan will be selected as the solution. Results. We use test cases from the Blocksworld dataset (Valmeekam et al., 2023) and group them by minimum number of actions required, resulting in 30 cases solvable within 2 steps, 57 cases within 4 steps, and 114 cases within 6 steps. There are at most 5 blocks in each test case. As the baseline method, we prompt the LLM with 4 test cases with corresponding solutions, and ask it to generate a</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Comparing reasoning traces in Blocksworld from CoT (left) and RAP (right).</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>2-step</th>
<th>4-step</th>
<th>6-step</th>
</tr>
</thead>
<tbody>
<tr>
<td>CoT</td>
<td>0.17</td>
<td>0.02</td>
<td>0.00</td>
</tr>
<tr>
<td>CoT - pass@10</td>
<td>0.23</td>
<td>0.07</td>
<td>0.00</td>
</tr>
<tr>
<td>CoT (GPT-4)</td>
<td>0.50</td>
<td>0.63</td>
<td>0.40</td>
</tr>
<tr>
<td>RAP(10)</td>
<td>1.00</td>
<td>0.86</td>
<td>0.26</td>
</tr>
<tr>
<td>RAP(20)</td>
<td>1.00</td>
<td>0.88</td>
<td>0.42</td>
</tr>
</tbody>
</table>
<p>Table 1: Results on Blocksworld. RAP(10) and RAP(20) refer to our method where the iteration number is set to 10 and 20, respectively. "pass@10" means 10 plans are sampled for each test case, and the test case is regarded as solved if at least one plan is correct. All other settings including RAP, only evaluate a single plan.</p>
<p>plan for a new question. This setting is the same as one described in <em>Valmeekam et al. (2022)</em>, and we denote it as Chain-of-Thought (CoT) as the solution is generated step by step. For RAP, the same prompt is shown to help LLMs calculate <em>r</em>1.</p>
<p>As shown in Table 1, CoT with LLaMA-33B can only generate successful plans for a few 2-step cases, and completely fails on harder problems. RAP substantially improves over CoT by nearly solving all problems within 4 steps, and a part of 6-step problems, achieving an average success rate of 64%. It's worth noting that the searching space of 6-step problems can be as large as 5⁶, while our algorithm can find a successful plan 42% of the time within 20 iterations. Even more, our framework allows LLaMA-33B to outperform GPT-4 by 33% relative gain, which is known to have much stronger reasoning ability <em>Bubeck et al. (2023)</em>.</p>
<p>Case study. We compare the reasoning paths from CoT and RAP in Figure 4. We summarize the reasons accounting for the improvement: (1) By maintaining the world state during reasoning, RAP can recognize valid actions for the current state, avoiding generating illegal plans. (2) RAP is capable of backtracking and trying out other solutions when the first intuition from the LLM doesn't work. Specifically, CoT attempts to achieve the second goal, i.e. "orange on red", and achieve that with the first two steps. However, accomplishing the second goal first would prevent the first goal from being satisfied. On the contrary, even though RAP makes the same mistakes in the first iterations, our framework drives the agent to explore other possible paths (as described in Section 3.3) and finally generate a successful plan. (3) When calculating <em>rt</em>, we can only feed the current state to the LLM and hide the history. E.g., in the case of Figure 4, to calculate the reward for <em>a</em>2, the LLM is provided with a "new" test case, in which <em>s</em>2 is the initial state. This significantly lowers the difficulties of the last few steps, and saves more iterations for harder decisions of the first few steps.</p>
<h3>4.2 Math Reasoning</h3>
<p>Task setup. Math reasoning tasks, such as GSM8k <em>Cobbe et al. (2021)</em>, often include a description and a final question. To arrive at the answer to the final question, it is necessary to undertake multi-step mathematical calculations based on the problem's context. It is thus natural to decompose the final question into a sequence of smaller sub-questions (Figure 2, right). We define a state as the values of intermediate variables, and an action as to propose an incremental sub-question about a unknown intermediate variable. The world model then responds to the sub-question using the intermediate variables and the problem description, adding the new intermediate variable value into the next state. We combine the self-evaluation of helpfulness by LLM <em>rt</em>1, and the confidence of state <em>rt</em>2 using weighted geometric mean <em>rt</em> = <em>rt</em>0<em> t</em> <em>rt</em>1−<em>o</em> as the reward function. This reward encourages more relevant and useful sub-questions. To account for the</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Accuracy (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chain-of-Thought</td>
<td>29.4</td>
</tr>
<tr>
<td>+ SC^{(10)}</td>
<td>46.8</td>
</tr>
<tr>
<td>Least-to-Most</td>
<td>25.5</td>
</tr>
<tr>
<td>+ SC^{(10)}</td>
<td>42.5</td>
</tr>
<tr>
<td>RAP^{(1)}</td>
<td>40.0</td>
</tr>
<tr>
<td>RAP^{(10)}</td>
<td>48.6</td>
</tr>
<tr>
<td>+ aggr</td>
<td>51.6</td>
</tr>
</tbody>
</table>
<p>Table 2: Results on GSM8k. The superscripts indicate the number of samples or iterations.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 5: Results on GSM-8K, with different numbers of sampled paths or iterations.
impact of the reasoning path's length on the reward, we compute the $Q$ value by using the maximum of average rewards in future steps.</p>
<p>$$
Q^{*}\left(s_{t}, a_{t}\right)=\max <em t="t">{s</em>\right)
$$}, a_{t}, r_{t}, \ldots, s_{l}, a_{l}, r_{l}, s_{l+1}} \operatorname{avg}\left(r_{t}, \ldots, r_{l</p>
<p>As a related work, Least-to-Most prompting (Zhou et al., 2022) shares a similar idea to us in sub-question decomposition, but they generate subquestions all at once. On the contrary, RAP considers each action $a_{t}$ based on the current state $s_{t}$, which enables more informed decisions.
Results. We evaluate our framework on GSM8k, a dataset of grade school math word problems. We also evaluate the base model with CoT prompting (Wei et al., 2022), Least-to-Most prompting (Zhou et al., 2022), and their self-consistency (Wang et al., 2022) variants, as the baselines. We use the same 4 -shot examples demonstrations for all methods.</p>
<p>As shown in Table 2, our RAP framework answers $48.8 \%$ of the problems correctly, outperforming both the Chain-of-Thought and the Least-toMost prompting with Self-Consistency. Notably, this result is achieved when RAP only selects only one reasoning trace based on the reward. The introduction of RAP-Aggregate further improves the accuracy by $\sim 3 \%$. We also calculate the accuracy with different numbers of iterations in MCTS and self-consistency samples in baselines, as illustrated</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Method</th>
<th style="text-align: center;">Pred Acc</th>
<th style="text-align: center;">Proof Acc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">CoT</td>
<td style="text-align: center;">87.8</td>
<td style="text-align: center;">64.8</td>
</tr>
<tr>
<td style="text-align: center;">CoT + SC</td>
<td style="text-align: center;">89.8</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">RAP (Ours)</td>
<td style="text-align: center;">94.2</td>
<td style="text-align: center;">78.8</td>
</tr>
</tbody>
</table>
<p>Table 3: Results on ProntoQA.
in Figure 5. We find that across all numbers of iterations/samples, RAP-Aggregation outperforms baselines consistently, which indicates that when only a few iterations/samples are allowed, our framework is significantly better at finding reliable reasoning paths with the guide of reward.</p>
<h3>4.3 Logical Reasoning</h3>
<p>Task setup. A logical reasoning task (e.g. PrOntoQA (Saparov and He, 2022)) typically provides a set of facts and logical rules, and a model is required to verify if a hypothesis fact is true or false by applying the logical rules to the given facts, as illustrated in Figure 2. These tasks not only require the correct final answer (true/false), but also a detailed proof demonstrating the result. To apply our framework, we define the state as a fact we are focusing on, analogous to the human's working memory (Baddeley, 1992) for inference. An action is defined as selecting a rule from the fact set. The world model performs a one-hop reasoning step to get a new fact as the next state. The reward is calculated with Self-evaluation (Section 3.2. Specifically, we prompt the LLM with a few examples with their labels to help it better understand the quality of reasoning steps. We use the average reward of future steps to update the $Q$ function, the same as Equation (2) for GSM8k.
Results. We assess the performance of our RAP framework on PrOntoQA (Saparov and He, 2022) and adopt their settings of "true" ontology (using real-world knowledge), "random" ordering of rules. We mix the examples requiring 3,4 , and 5 reasoning hops in a correct proof to prevent LLM from memorizing when to finish the reasoning. We sample 500 examples from the generation script released by Saparov and He (2022). We compare both the prediction accuracy of the final answer and the accuracy of the entire proof. We do 20 iterations for MCTS and 20 samples for self-consistency.</p>
<p>As the results presented in Table 3, our framework achieves a correct answer rate of $94.2 \%$ and a proof accuracy of $78.8 \%$, surpassing the CoT baseline by $14 \%$ proof accuracy and the selfconsistency CoT baseline by $4.4 \%$ prediction accuracy. Such substantial improvements clearly</p>
<table>
<thead>
<tr>
<th>Setting</th>
<th>Method</th>
<th>2-step</th>
<th>4-step</th>
<th>6-step</th>
<th>8-step</th>
<th>10-step</th>
<th>12-step</th>
<th>All</th>
</tr>
</thead>
<tbody>
<tr>
<td>Easy</td>
<td>CoT</td>
<td>0.49</td>
<td>0.18</td>
<td>0.06</td>
<td>0.01</td>
<td>0.01</td>
<td>0.00</td>
<td>0.08</td>
</tr>
<tr>
<td></td>
<td>$\mathrm{RAP}^{(10)}$</td>
<td>1.00</td>
<td>0.99</td>
<td>0.75</td>
<td>0.61</td>
<td>0.32</td>
<td>0.32</td>
<td>0.65</td>
</tr>
<tr>
<td>Hard</td>
<td>CoT</td>
<td>0.22</td>
<td>0.14</td>
<td>0.02</td>
<td>0.02</td>
<td>0.00</td>
<td>0.00</td>
<td>0.05</td>
</tr>
<tr>
<td></td>
<td>$\mathrm{RAP}^{(10)}$</td>
<td>0.67</td>
<td>0.76</td>
<td>0.74</td>
<td>0.48</td>
<td>0.17</td>
<td>0.09</td>
<td>0.51</td>
</tr>
</tbody>
</table>
<p>Table 4: Results on the full Blocksworld with Llama-2 70B.
demonstrate the effectiveness of RAP in solving logical reasoning problems in PrOntoQA. Also, as the case illustrated in Figure 2, RAP can effectively recognize when a reasoning chain comes to a dead end, and propagate the signal back to earlier reasoning steps, with the planning algorithm allowing it to explore alternatives to the previous steps. The selfevaluation reward further helps RAP to recognize potential incorrect reasoning steps, encouraging the agent to avoid them in future iterations.</p>
<h2>5 Analysis</h2>
<h3>5.1 Complex problems</h3>
<p>To further study whether RAP can help stronger LLMs to solve more complex problems, we conduct experiments on the full Blocksworld (Valmeekam et al., 2023) dataset using a more capable LLM, Llama-2 70B (Touvron et al., 2023b).</p>
<p>The full Blocksworld (Valmeekam et al., 2023) comprises 602 test cases. We group them based on the minimum number of actions required for each test case. Our experiments are conducted in two distinct settings: Easy and Hard. In Easy setting, we assume prior knowledge of the minimum number of actions for each case. Leveraging this information, we use demonstration cases that share the same minimum number of actions as the test case. For each group of cases, we randomly select 10 cases to create a pool of demonstration cases, leaving the remaining cases as the test set. During inference, we randomly sample 4-shot demonstration cases from this pool and utilize them to formulate prompts. In the Hard setting, we randomly select 10 cases from the full dataset to form a demonstration pool and subsequently exclude these cases from the test set. During inference, we randomly sample 4-shot demonstration cases from this global pool, irrespective of the minimum number of actions required for the test case.</p>
<p>We employ chain-of-thought prompting (Wei et al., 2022) as a baseline, and evaluate our $\mathrm{RAP}^{(10)}$ (with 10 iterations) with an improved prompting technique (Appendix E). Our experimental results are summarized in Table 4. In both the Easy and</p>
<p>Hard settings, RAP demonstrates superior performance over CoT by a substantial margin. Notably, when the test case necessitates a larger number of steps (six or more) to solve, CoT exhibits a severe drop in success rates, whereas RAP maintains a relatively high success rate. Comparing these results with Section 4.1, we additionally conclude that RAP is a general framework able to enhance the reasoning abilities of LLMs, regardless of their intrinsic capabilities.</p>
<h3>5.2 Reward Choice</h3>
<p>In our main experiments, we choose the combination of rewards in our current experiments based on heuristics and our exploratory experiments. To understand the effects of the reward choice for LLM reasoning, we supplement comprehensive experiments on rewards for plan generation (Table 5) and math reasoning (Table 6).</p>
<p>Generally, the combination of multiple rewards contributes to the performance. However, the effects of a reward depends on the nature of tasks. For example, the action likelihood reward is essential for plan generation, but not very helpful to mathmatical reasoning. More discussions are in Appendix F.</p>
<h2>6 Conclusion</h2>
<p>In this paper, we present Reasoning via Planning (RAP), a novel LLM reasoning framework that equips LLMs with an ability to reason akin to human-like strategic planning. Our framework, which repurposes the LLM to act as both a world model and a reasoning agent, enables the LLM to simulate states of the world and anticipate action outcomes, and achieve an effective balance between exploration and exploitation via MonteCarlo Tree Search. Extensive experiments on a variety of challenging reasoning problems demonstrate RAP's superiority over several contemporary CoT-based reasoning approaches, and even the advanced GPT-4 in certain settings.</p>
<h2>Limitations</h2>
<p>In this work, we mainly focus on utilizing frozen LLMs, whose abilities might be bounded by the pre-training. In the future, it is worth exploring how to fine-tune LLMs to better reason and serve as a world model (Xiang et al., 2023), as well as how to combine external tools (Hao et al., 2023a; Schick et al., 2023) with RAP to solve more complex realworld problems.</p>
<h2>Ethics Statement</h2>
<p>In this paper, we primarily focus on the applications on plan generation, mathematical reasoning, and logical reasoning, posing no significant ethical concerns. We recognize that future research on border applications of reasoning with LLMs may pose a risk of misuse, and we recommend careful consideration of all aspects of safety before relevant techniques are applied to the real world.</p>
<h2>References</h2>
<p>Alan Baddeley. 1992. Working memory. Science, 255(5044):556-559.</p>
<p>Robert Eamon Briscoe. 2011. Mental imagery and the varieties of amodal perception. Pacific Philosophical Quarterly, 92(2):153-173.</p>
<p>Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. 2020. Language models are few-shot learners. Advances in neural information processing systems, 33:1877-1901.</p>
<p>Sébastien Bubeck, Varun Chandrasekaran, Ronen Eldan, Johannes Gehrke, Eric Horvitz, Ece Kamar, Peter Lee, Yin Tat Lee, Yuanzhi Li, Scott Lundberg, et al. 2023. Sparks of artificial general intelligence: Early experiments with gpt-4. arXiv preprint arXiv:2303.12712.</p>
<p>Tom Bylander. 1994. The computational complexity of propositional strips planning. Artificial Intelligence, 69(1-2):165-204.</p>
<p>Eduardo F Camacho and Carlos Bordons Alba. 2013. Model predictive control. Springer science \&amp; business media.</p>
<p>Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaarav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al. 2022. Palm: Scaling language modeling with pathways. arXiv preprint arXiv:2204.02311.</p>
<p>Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, et al. 2021. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168.</p>
<p>Rémi Coulom. 2007. Efficient selectivity and backup operators in monte-carlo tree search. In Computers and Games: 5th International Conference, CG 2006, Turin, Italy, May 29-31, 2006. Revised Papers 5, pages 72-83. Springer.</p>
<p>Yan Ding, Xiaohan Zhang, Chris Paxton, and Shiqi Zhang. 2023. Task and motion planning with large language models for object rearrangement. arXiv preprint arXiv:2303.06247.</p>
<p>Wojciech W Gasparski and Tufan Orel. 2014. Designology: Studies on Planning for Action, volume 1. Transaction Publishers.</p>
<p>Dedre Gentner and Albert L Stevens. 2014. Mental models. Psychology Press.</p>
<p>David Ha and Jürgen Schmidhuber. 2018a. Recurrent world models facilitate policy evolution. Advances in neural information processing systems, 31.</p>
<p>David Ha and Jürgen Schmidhuber. 2018b. World models. arXiv preprint arXiv:1803.10122.</p>
<p>Danijar Hafner, Timothy Lillicrap, Jimmy Ba, and Mohammad Norouzi. 2019. Dream to control: Learning behaviors by latent imagination. arXiv preprint arXiv:1912.01603.</p>
<p>Danijar Hafner, Timothy Lillicrap, Mohammad Norouzi, and Jimmy Ba. 2020. Mastering atari with discrete world models. arXiv preprint arXiv:2010.02193.</p>
<p>Shibo Hao, Tianyang Liu, Zhen Wang, and Zhiting Hu. 2023a. Toolkengpt: Augmenting frozen language models with massive tools via tool embeddings. Advances in neural information processing systems, 36.</p>
<p>Shibo Hao, Bowen Tan, Kaiwen Tang, Bin Ni, Xiyan Shao, Hengzhe Zhang, Eric Xing, and Zhiting Hu. 2023b. Bertnet: Harvesting knowledge graphs with arbitrary relations from pretrained language models. In Findings of the Association for Computational Linguistics: ACL 2023, pages 5000-5015.</p>
<p>Mark K Ho, David Abel, Carlos G Correa, Michael L Littman, Jonathan D Cohen, and Thomas L Griffiths. 2021. Control of mental representations in human planning. arXiv e-prints, pages arXiv-2105.</p>
<p>Jie Huang and Kevin Chen-Chuan Chang. 2022. Towards reasoning in large language models: A survey. arXiv preprint arXiv:2212.10403.</p>
<p>Wenlong Huang, Fei Xia, Ted Xiao, Harris Chan, Jacky Liang, Pete Florence, Andy Zeng, Jonathan Tompson, Igor Mordatch, Yevgen Chebotar, et al. 2022. Inner monologue: Embodied reasoning through planning with language models. arXiv preprint arXiv:2207.05608.</p>
<p>Quentin JM Huys, Neir Eshel, Elizabeth O’Nions, Luke Sheridan, Peter Dayan, and Jonathan P Roiser. 2012. Bonsai trees in your head: how the pavlovian system sculpts goal-directed choices by pruning decision trees. PLoS computational biology, 8(3):e1002410.</p>
<p>Yu-qian Jiang, Shi-qi Zhang, Piyush Khandelwal, and Peter Stone. 2019. Task planning in robotics: an empirical comparison of pddl-and asp-based systems. Frontiers of Information Technology \&amp; Electronic Engineering, 20:363-373.</p>
<p>Philip N Johnson-Laird. 2010. Mental models and human reasoning. Proceedings of the National Academy of Sciences, 107(43):18243-18250.</p>
<p>Philip Nicholas Johnson-Laird. 1983. Mental models: Towards a cognitive science of language, inference, and consciousness. 6. Harvard University Press.</p>
<p>Ana Jojic, Zhen Wang, and Nebojsa Jojic. 2023. Gpt is becoming a turing machine: Here are some ways to program it. arXiv preprint arXiv:2303.14310.</p>
<p>Levente Kocsis and Csaba Szepesvári. 2006. Bandit based monte-carlo planning. In Machine Learning: ECML 2006: 17th European Conference on Machine Learning Berlin, Germany, September 18-22, 2006 Proceedings 17, pages 282-293. Springer.</p>
<p>Takeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. 2022. Large language models are zero-shot reasoners. arXiv preprint arXiv:2205.11916.</p>
<p>Yann LeCun. 2022. A path towards autonomous machine intelligence version 0.9. 2, 2022-06-27. Open Review, 62.</p>
<p>Belinda Z Li, Maxwell Nye, and Jacob Andreas. 2022. Language modeling with latent situations. arXiv preprint arXiv:2212.10012.</p>
<p>Bo Liu, Yuqian Jiang, Xiaohan Zhang, Qiang Liu, Shiqi Zhang, Joydeep Biswas, and Peter Stone. 2023. Llm+ p: Empowering large language models with optimal planning proficiency. arXiv preprint arXiv:2304.11477.</p>
<p>Qing Lyu, Shreya Havaldar, Adam Stein, Li Zhang, Delip Rao, Eric Wong, Marianna Apidianaki, and Chris Callison-Burch. 2023. Faithful chain-ofthought reasoning. arXiv preprint arXiv:2301.13379.</p>
<p>Yutaka Matsuo, Yann LeCun, Maneesh Sahani, Doina Precup, David Silver, Masashi Sugiyama, Eiji Uchibe, and Jun Morimoto. 2022. Deep learning, reinforcement learning, and world models. Neural Networks.</p>
<p>John McCarthy. 1963. Situations, actions, and causal laws. Technical report, STANFORD UNIV CA DEPT OF COMPUTER SCIENCE.</p>
<p>Grégoire Mialon, Roberto Dessì, Maria Lomeli, Christoforos Nalmpantis, Ram Pasunuru, Roberta Raileanu, Baptiste Rozière, Timo Schick, Jane Dwivedi-Yu, Asli Celikyilmaz, et al. 2023. Augmented language models: a survey. arXiv preprint arXiv:2302.07842.</p>
<p>OpenAI. 2023. Gpt-4 technical report.
Debjit Paul, Mete Ismayilzada, Maxime Peyrard, Beatriz Borges, Antoine Bosselut, Robert West, and Boi Faltings. 2023. Refiner: Reasoning feedback on intermediate representations. arXiv preprint arXiv:2304.01904.</p>
<p>Xavier Puig, Kevin Ra, Marko Boben, Jiaman Li, Tingwu Wang, Sanja Fidler, and Antonio Torralba. 2018. Virtualhome: Simulating household activities via programs.</p>
<p>Abulhair Saparov and He He. 2022. Language models are greedy reasoners: A systematic formal analysis of chain-of-thought. arXiv preprint arXiv:2210.01240.</p>
<p>Timo Schick, Jane Dwivedi-Yu, Roberto Dessì, Roberta Raileanu, Maria Lomeli, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom. 2023. Toolformer: Language models can teach themselves to use tools. arXiv preprint arXiv:2302.04761.</p>
<p>Julian Schrittwieser, Ioannis Antonoglou, Thomas Hubert, Karen Simonyan, Laurent Sifre, Simon Schmitt, Arthur Guez, Edward Lockhart, Demis Hassabis, Thore Graepel, et al. 2020. Mastering atari, go, chess and shogi by planning with a learned model. Nature, 588(7839):604-609.</p>
<p>Jay Schulkin. 2012. Action, perception and the brain: Adaptation and cephalic expression. Springer.</p>
<p>Ramanan Sekar, Oleh Rybkin, Kostas Daniilidis, Pieter Abbeel, Danijar Hafner, and Deepak Pathak. 2020. Planning to explore via self-supervised world models. In International Conference on Machine Learning, pages 8583-8592. PMLR.</p>
<p>Noah Shinn, Beck Labash, and Ashwin Gopinath. 2023. Reflexion: an autonomous agent with dynamic memory and self-reflection. ArXiv, abs/2303.11366.</p>
<p>David Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur Guez, Marc Lanctot, Laurent Sifre, Dharshan Kumaran, Thore Graepel, et al. 2017. Mastering chess and shogi by self-play with a general reinforcement learning algorithm. arXiv preprint arXiv:1712.01815.</p>
<p>Ishika Singh, Valts Blukis, Arsalan Mousavian, Ankit Goyal, Danfei Xu, Jonathan Tremblay, Dieter Fox, Jesse Thomason, and Animesh Garg. 2022. Progprompt: Generating situated robot task plans using large language models. arXiv preprint arXiv:2209.11302.</p>
<p>Edward C Tolman. 1948. Cognitive maps in rats and men. Psychological review, 55(4):189.</p>
<p>Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timothée Lacroix, Baptiste Rozière, Naman Goyal, Eric Hambro, Faisal Azhar, et al. 2023a. Llama: Open and efficient foundation language models. arXiv preprint arXiv:2302.13971.</p>
<p>Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. 2023b. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288.</p>
<p>Karthik Valmeekam, Alberto Olmo, Sarath Sreedharan, and Subbarao Kambhampati. 2022. Large language models still can't plan (a benchmark for llms on planning and reasoning about change). arXiv preprint arXiv:2206.10498.</p>
<p>Karthik Valmeekam, Sarath Sreedharan, Matthew Marquez, Alberto Olmo, and Subbarao Kambhampati. 2023. On the planning abilities of large language models (a critical investigation with a proposed benchmark). arXiv preprint arXiv:2302.06706.</p>
<p>Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc Le, Ed Chi, and Denny Zhou. 2022. Self-consistency improves chain of thought reasoning in language models. arXiv preprint arXiv:2203.11171.</p>
<p>Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Ed Chi, Quoc Le, and Denny Zhou. 2022. Chain of thought prompting elicits reasoning in large language models. arXiv preprint arXiv:2201.11903.</p>
<p>Sean Welleck, Ximing Lu, Peter West, Faeze Brahman, Tianxiao Shen, Daniel Khashabi, and Yejin Choi. 2022. Generating sequences by learning to self-correct. arXiv preprint arXiv:2211.00053.</p>
<p>Philipp Wu, Alejandro Escontrela, Danijar Hafner, Pieter Abbeel, and Ken Goldberg. 2023. Daydreamer: World models for physical robot learning. In Conference on Robot Learning, pages 2226-2240. PMLR.</p>
<p>Jiannan Xiang, Tianhua Tao, Yi Gu, Tianmin Shu, Zirui Wang, Zichao Yang, and Zhiting Hu. 2023. Language models meet world models: Embodied experiences enhance language models. Advances in neural information processing systems, 36.</p>
<p>Shunyu Yao, Dian Yu, Jeffrey Zhao, Izhak Shafran, Thomas L Griffiths, Yuan Cao, and Karthik Narasimhan. 2023. Tree of thoughts: Deliberate problem solving with large language models. arXiv preprint arXiv:2305.10601.</p>
<p>Denny Zhou, Nathanael Schärli, Le Hou, Jason Wei, Nathan Scales, Xuezhi Wang, Dale Schuurmans, Olivier Bousquet, Quoc Le, and Ed Chi. 2022. Least-to-most prompting enables complex reasoning in large language models. arXiv preprint arXiv:2205.10625.</p>
<p>Xinyu Zhu, Junjie Wang, Lin Zhang, Yuxiang Zhang, Ruyi Gan, Jiaxing Zhang, and Yujiu Yang. 2022. Solving math word problem via cooperative reasoning induced language models. arXiv preprint arXiv:2210.16257.</p>
<h2>A MCTS Planning</h2>
<p>We adapt MCTS to search for the optimal reasoning path (Algorithm 1). Compared with traditional applications of MCTS, we are faced with a large reasoning space, and the heavy computational cost of LLMs. Thus, we made several modifications to the classic MCTS in our implementation: (1) For open domain problems, e.g., math problems, it's impossible to enumerate all actions (subquestions), so we reduce the action space by sampling a fixed number of potential actions from LLMs, conditioned on a prompt of the current state and incontext demonstration. (2) In the selection phase, if there are actions that haven't been visited before, we estimate the Q value with lightweight local rewards, e.g., self-evaluation reward, and then select the action with UCT. This provides prior knowledge for the exploration, which is crucial given the limited iteration budgets.</p>
<h2>B Experiment Settings</h2>
<h2>B. 1 Language Model Decoding</h2>
<p>We use random sampling with a temperature of 0.8 . The generation is cut off at the maximum length of 2048 or a newline token.</p>
<h2>B. 2 Computing Resources</h2>
<p>All of our experiments run on $4 \times$ NVIDIA A5000 GPUs with 24GB memory.</p>
<h2>C Prompt</h2>
<h2>C. 1 Plan Generation</h2>
<p>We show the prompt to calculate the action likelihood for RAP below. The same prompt is also applied in CoT baseline. <init_state> and <goals> would be instantiated by the problem to solve.</p>
<p>I am playing with a set of blocks where I need to arrange the blocks into stacks. Here are the actions I can do</p>
<p>Pick up a block
Unstack a block from on top of another block
Put down a block
Stack a block on top of another block
I have the following restrictions on my actions:</p>
<p>I can only pick up or unstack one block at a time.
I can only pick up or unstack a block if my hand is empty.
I can only pick up a block if the block is on the table and the block is clear. A block is clear if the block has no other blocks on top of it and if the block is not picked up.
I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block.
I can only unstack a block from on top of another block if the block I am unstacking is clear.
Once I pick up or unstack a block, I am holding the block.
I can only put down a block that I am holding.
I can only stack a block on top of another block if I am holding the block being stacked.
I can only stack a block on top of another block if the block onto which I am stacking the block is clear.
Once I put down or stack a block, my hand becomes empty.</p>
<h2>[STATEMENT]</h2>
<p>As initial conditions I have that, the red block is clear, the yellow block is clear, the hand is empty, the red block is on top of the blue block, the yellow block is on top of the orange block, the blue block is on the table and the orange block is on the table.
My goal is to have that the orange block is on top of the red block.</p>
<p>My plan is as follows:</p>
<h2>[PLAN]</h2>
<p>unstack the yellow block from on top of the orange block
put down the yellow block
pick up the orange block</p>
<h1>Algorithm 1 RAP-MCTS</h1>
<p>Require: Initial state $s_{0}$, state transition probability function $p_{\theta}$, reward function $r_{\theta}$, action generator $p_{\phi}$, number of generated actions $d$, depth limit $L$, number of roll-outs $N$, and exploration weight $w$
1: Initialize memory of actions $A: \mathcal{S} \mapsto \mathcal{A}$, children $c: \mathcal{S} \times \mathcal{A} \mapsto \mathcal{S}$ and rewards $r: \mathcal{S} \times \mathcal{A} \mapsto \mathbb{R}$
2: Initialize the state-action value function $Q: \mathcal{S} \times \mathcal{A} \mapsto \mathbb{R}$ and visit counter $N: \mathcal{S} \mapsto \mathbb{N}$
3: for $n \leftarrow 0, \ldots, N-1$ do
$4: \quad t \leftarrow 0$
5: while $N\left(s_{t}\right)&gt;0$ do
6: $\quad N\left(s_{t}\right) \leftarrow N\left(s_{t}\right)+1$
7: $\quad a_{t} \leftarrow \arg \max <em t="t">{a \in A\left(s</em>\right]$
8: $\quad r_{t}=r\left(s_{t}, a_{t}\right), s_{t+1} \leftarrow c\left(s_{t}, a_{t}\right)$
9: $\quad t \leftarrow t+1$
10: end while
11: while $s_{t}$ is not a terminal state $\wedge t \leq L$ do
12: for $i \leftarrow 1, \ldots, d$ do
13: Sample $a_{t}^{(i)} \sim p_{\phi}\left(a \mid s_{t}\right), s_{t+1}^{(i)} \sim p_{\theta}\left(s_{t}, a_{t}^{(i)}\right)$, and $r_{t}^{(i)} \sim r_{\theta}\left(s_{t}, a_{t}^{(i)}\right)$
14: $\quad$ Update $A\left(s_{t}\right) \leftarrow\left{a_{t}^{(i)}\right}}\right)}\left[Q\left(s_{t}, a\right)+w \sqrt{\frac{\ln N\left(s_{t}\right)}{N\left(c\left(s_{t}, a\right)\right)}<em t="t">{t=1}^{\theta}, c\left(s</em>$
15: end for
16: $\quad a_{t+1} \leftarrow \arg \max }, a_{t}^{(i)}\right) \leftarrow s_{t+1}^{(i)}$, and $r\left(s_{t}, a_{t}\right) \leftarrow r_{t}^{(i)<em t="t">{a \in A\left(s</em>\right)$
17: $\quad r_{t} \leftarrow r\left(s_{t}, a_{t}\right), s_{t+1} \leftarrow c\left(s_{t}, a_{t}\right)$
18: $\quad t \leftarrow t+1$
19: end while
20: for $t^{\prime} \leftarrow t, \ldots, 0$ do
21: $\quad$ Update $Q\left(s_{t^{\prime}}, a_{t^{\prime}}\right)$ with $\left{r_{t^{\prime}}, r_{t^{\prime}+1}, \ldots, r_{t}\right}$
22: end for
23: end for
stack the orange block on top of the red block
[PLAN END]}\right)} r\left(s_{t}, a_{t</p>
<h2>[STATEMENT]</h2>
<p>As initial conditions I have that, the orange block is clear, the yellow block is clear, the hand is empty, the blue block is on top of the red block, the orange block is on top of the blue block, the red block is on the table and the yellow block is on the table.
My goal is to have that the blue block is on top of the red block and the yellow block is on top of the orange block.</p>
<p>My plan is as follows:</p>
<h2>[PLAN]</h2>
<p>pick up the yellow block
stack the yellow block on top of the orange block
[PLAN END]</p>
<h2>[STATEMENT]</h2>
<p>As initial conditions I have that, the red block is clear, the blue block
is clear, the orange block is clear, the hand is empty, the blue block is on top of the yellow block, the red block is on the table, the orange block is on the table and the yellow block is on the table.
My goal is to have that the blue block is on top of the orange block and the yellow block is on top of the red block.</p>
<p>My plan is as follows:</p>
<h2>[PLAN]</h2>
<p>unstack the blue block from on top of the yellow block
stack the blue block on top of the orange block
pick up the yellow block
stack the yellow block on top of the red block
[PLAN END]</p>
<h2>[STATEMENT]</h2>
<p>As initial conditions I have that, the red block is clear, the blue block is clear, the yellow block is clear, the hand is empty, the</p>
<p>yellow block is on top of the orange block, the red block is on the table, the blue block is on the table and the orange block is on the table.
My goal is to have that the orange block is on top of the blue block and the yellow block is on top of the red block.</p>
<p>My plan is as follows:
[PLAN]
unstack the yellow block from on top of the orange block
stack the yellow block on top of the red block
pick up the orange block
stack the orange block on top of the blue block
[PLAN END]
[STATEMENT]
As initial conditions I have that, <initial_state>
My goal is to have that <goals>.
My plan is as follows:
[PLAN]
For the next state prediction with the world model, we apply the prompts conditioned on the last action. Here we show the prompt to update the state after a "pick up" action as an example. Again, <state> and <action> would be instantiated with the current state and action.</p>
<p>I am playing with a set of blocks where I need to arrange the blocks into stacks. Here are the actions I can do</p>
<p>Pick up a block
Unstack a block from on top of another block
Put down a block
Stack a block on top of another block
I have the following restrictions on my actions:
I can only pick up or unstack one block at a time.</p>
<p>I can only pick up or unstack a block if my hand is empty.
I can only pick up a block if the block is on the table and the block is clear. A block is clear if the block has no other blocks on top of it and if the block is not picked up.
I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block.
I can only unstack a block from on top of another block if the block I am unstacking is clear. Once I pick up or unstack a block, I am holding the block.
I can only put down a block that I am holding.
I can only stack a block on top of another block if I am holding the block being stacked.
I can only stack a block on top of another block if the block onto which I am stacking the block is clear. Once I put down or stack a block, my hand becomes empty.</p>
<p>After being given an initial state and an action, give the new state after performing the action.
[SCENARIO 1]
[STATE 0] I have that, the white block is clear, the cyan block is clear, the brown block is clear, the hand is empty, the white block is on top of the purple block, the purple block is on the table, the cyan block is on the table and the brown block is on the table.
[ACTION] Pick up the brown block.
[CHANGE] The hand was empty and is now holding the brown block, the brown block was on the table and is now in the hand, and the brown block is no longer clear.
[STATE 1] I have that, the white block is clear, the cyan block is clear, the brown block is in the hand, the hand is holding the brown block,</p>
<p>the white block is on top of the purple block, the purple block is on the table and the cyan block is on the table.</p>
<h2>[SCENARIO 2]</h2>
<p>[STATE 0] I have that, the purple block is clear, the cyan block is clear, the white block is clear, the hand is empty, the white block is on top of the brown block, the purple block is on the table, the cyan block is on the table and the brown block is on the table.
[ACTION] Pick up the cyan block.
[CHANGE] The hand was empty and is now holding the cyan block, the cyan block was on the table and is now in the hand, and the cyan block is no longer clear.
[STATE 1] I have that, the cyan block is in the hand, the white block is clear, the purple block is clear, the hand is holding the cyan block, the white block is on top of the brown block, the purple block is on the table and the brown block is on the table.</p>
<h2>[SCENARIO 3]</h2>
<p>[STATE 0] <state>
[ACTION] <action>
[CHANGE]</p>
<h2>C. 2 Math Reasoning</h2>
<p>We show the prompt of RAP for math reasoning as below. The prompt is used for both action proposal and next state prediction. After instantiate <question>, we append a prefix Question 5.1 to the prompt, so that we can sample the first action with the LLM. The future actions are sampled similarly, except that all previous sub-questions and sub-answers need to be appended to the prompt, following the formats of in-context demonstration. The next state prediction, i.e., answering the subquestion, works in the same way.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">Given</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">question</span>,<span class="w"> </span><span class="nv">please</span><span class="w"> </span><span class="nv">decompose</span><span class="w"> </span><span class="nv">it</span>
<span class="w">    </span><span class="nv">into</span><span class="w"> </span><span class="nv">sub</span><span class="o">-</span><span class="nv">questions</span>.<span class="w"> </span><span class="k">For</span><span class="w"> </span><span class="nv">each</span>
<span class="w">    </span><span class="nv">sub</span><span class="o">-</span><span class="nv">question</span>,<span class="w"> </span><span class="nv">please</span><span class="w"> </span><span class="nv">answer</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">a</span>
<span class="w">    </span><span class="nv">complete</span><span class="w"> </span><span class="nv">sentence</span>,<span class="w"> </span><span class="nv">ending</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="err">&quot;The</span>
<span class="w">    </span><span class="nv">answer</span><span class="w"> </span><span class="nv">is</span><span class="err">&quot;. When the original</span>
</code></pre></div>

<p>question is answerable, please start the subquestion with "Now we can answer the question: ".</p>
<p>Question 1: Four years ago, Kody was only half as old as Mohamed. If Mohamed is currently twice as 30 years old, how old is Kody?
Question 1.1: How old is Mohamed?
Answer 1.1: He is currently $30 * 2=60$ years old. The answer is 60.
Question 1.2: How old was Mohamed four years ago?
Answer 1.2: Four years ago, he must have been $60-4=56$ years old. The answer is 56.
Question 1.3: How old was Kody four years ago?
Answer 1.3: Kody was half as old as Mohamed four years ago. Thus, Kody was $56 / 2=28$ years old. The answer is 28 .
Question 1.4: Now we can answer the question: How old is Kody?
Answer 1.4: She is currently $28+4=$ 32 years old. The answer is 32.</p>
<p>Question 2: On a moonless night, three fireflies danced in the evening breeze. They were joined by four less than a dozen more fireflies before two of the fireflies flew away. How many fireflies remained?
Question 2.1: How many fireflies joined?
Answer 2.1: The fireflies were joined by four less than a dozen more fireflies, which are $12-4=8$ fireflies. The answer is 8 .
Question 2.2: Now we can answer the question: How many fireflies remained?
Answer 2.2: Three fireflies were dancing originally. They were joined by 8 fireflies before two of them flew away. So there were $3+8$ $-2=9$ remaining. The answer is 9 .</p>
<p>Question 3: Ali has four $\$ 10$ bills and six $\$ 20$ bills that he saved after working for Mr. James on his farm. Ali gives her sister half of the</p>
<p>total money he has and uses $3 / 5$ of the remaining amount of money to buy dinner. Calculate the amount of money he has after buying the dinner.
Question 3.1: How much money does Ali have in total?
Answer 3.1: Ali has four $\$ 10$ bills and six $\$ 20$ bills. So he has $4 * 10+6$ * $20=160$ dollars. The answer is 160.</p>
<p>Question 3.2: How much money does Ali give to his sister?
Answer 3.2: Ali gives half of the total money he has to his sister. So he gives $160 / 2=80$ dollars to his sister. The answer is 80 .
Question 3.3: How much money does Ali have after giving his sister the money?
Answer 3.3: After giving his sister the money, Ali has $160-80=80$ dollars left. The answer is 80 .
Question 3.4: How much money does Ali use to buy dinner?
Answer 3.4: Ali uses $3 / 5$ of the remaining amount of money to buy dinner. So he uses $80 * 3 / 5=48$ dollars to buy dinner. The answer is 48 .
Question 3.5: Now we can answer the question: How much money does Ali have after buying the dinner?
Answer 3.5: After buying the dinner, Ali has $80-48=32$ dollars left. The answer is 32 .</p>
<p>Question 4: A car is driving through a tunnel with many turns. After a while, the car must travel through a ring that requires a total of 4 right-hand turns. After the 1st turn, it travels 5 meters. After the 2nd turn, it travels 8 meters. After the 3rd turn, it travels a little further and at the 4th turn, it immediately exits the tunnel. If the car has driven a total of 23 meters around the ring, how far did it have to travel after the 3rd turn?</p>
<p>Question 4.1: How far did the car travel except for the 3rd turn?
Answer 4.1: It travels 5 meters after the 1st, 8 meters after the 2nd, and 0 meters after the 4th turn. It's a total of $5+8+0=13$ meters. The answer is 13 .
Question 4.2: Now we can answer the question: How far did the car have to travel after the 3rd turn?
Answer 4.2: The car has driven a total of 23 meters around the ring. It travels 13 meters except for the 3rd turn. So it has to travel 23 $13=10$ meters after the 3rd turn. The answer is 10 .</p>
<p>Question 5: <question></p>
<h2>C. 3 Logical Reasoning</h2>
<p>We show the prompt for action proposal, action likelihood calculation, and next state prediction. <fact> and <query> would be instantiated with the problem.</p>
<p>Given a list of facts, and a current claim, output one possible fact as the next step. Be sure to copy the exact sentences in the facts. Do not change any wording. Do not create your own words.</p>
<p>Facts 1: Each lepidopteran is an insect. Each arthropod is a protostome. Every animal is multicellular. Protostomes are invertebrates. Each whale is bony. Each painted lady is a butterfly. Invertebrates are animals. Butterflies are lepidopterans. Each insect is six-legged. Every insect is an arthropod. Arthropods are not bony.
Query 1: True or false: Sally is not bony.
Claim 1.1: Sally is an insect.
Next 1.1: Each insect is six-legged.
Claim 1.2: Sally is a butterfly.
Next 1.2: Butterflies are lepidopterans.
Claim 1.3: Sally is a lepidopteran.
Next 1.3: Each lepidopteran is an insect.</p>
<p>Claim 1.4: Sally is not bony.
Next 1.4: Finish.
Claim 1.5: Sally is an arthropod.
Next 1.5: Arthropods are not bony.
Claim 1.6: Sally is a painted lady.
Next 1.6: Each painted lady is a butterfly.</p>
<p>Facts 2: Prime numbers are natural numbers. Every Mersenne prime is not composite. Imaginary numbers are not real. Every real number is a number. Natural numbers are integers. Every real number is real. Every Mersenne prime is a prime number. Natural numbers are positive. Prime numbers are not composite. Integers are real numbers.
Query 2: True or false: 127 is not real.
Claim 2.1: 127 is real.
Next 2.1: Finish.
Claim 2.1: 127 is a natural number.
Next 2.1: Natural numbers are integers.
Claim 2.2: 127 is a prime number.
Next 2.2: Prime numbers are natural numbers.
Claim 2.3: 127 is a real number.
Next 2.3: Every real number is real.
Claim 2.4: 127 is a Mersenne prime.
Next 2.4: Every Mersenne prime is a prime number.
Claim 2.5: 127 is an integer.
Next 2.5: Integers are real numbers.</p>
<p>Facts 3: Lepidopterans are insects. Every animal is multicellular. Each insect is an arthropod. Each invertebrate is an animal. Insects are six-legged. Arthropods are small. Arthropods are invertebrates. Each butterfly is a lepidopteran. Whales are not small.
Query 3: True or false: Polly is not small.
Claim 3.1: Polly is an arthropod.
Next 3.1: Arthropods are small.
Claim 3.2: Polly is an insect.
Next 3.2: Each insect is an arthropod.
Claim 3.3: Polly is small.
Next 3.3: Finish.</p>
<p>Claim 3.4: Polly is a lepidopteran.
Next 3.4: Lepidopterans are insects.</p>
<p>Facts 4: Every cat is a feline. Mammals are vertebrates. Bilaterians are animals. Vertebrates are chordates. Carnivores are mammals. Mammals are not cold-blooded. Each chordate is a bilaterian. Every feline is a carnivore. Snakes are cold-blooded. Animals are not unicellular. Every carnivore is not herbivorous.
Query 4: True or false: Fae is not cold-blooded.
Claim 4.1: Fae is a feline.
Next 4.1: Every feline is a carnivore.
Claim 4.2: Fae is not cold-blooded.
Next 4.2: Finish.
Claim 4.2: Fae is a mammal.
Next 4.2: Mammals are not cold-blooded.
Claim 4.3: Fae is a cat.
Next 4.3: Every cat is a feline.
Claim 4.4: Fae is a carnivore.
Next 4.4: Carnivores are mammals.</p>
<p>Facts 5: Prime numbers are prime. Real numbers are numbers. Every integer is a real number. Real numbers are not imaginary. Mersenne primes are prime numbers. Complex numbers are imaginary. Each prime number is a natural number. Natural numbers are positive. Each Mersenne prime is prime. Each natural number is an integer.
Query 5: True or false: 7 is imaginary.
Claim 5.1: 7 is not imaginary.
Next 5.1: Finish.
Claim 5.1: 7 is a natural number.
Next 5.1: Each natural number is an integer.
Claim 5.2: 7 is a prime number.
Next 5.2: Each prime number is a natural number.
Claim 5.3: 7 is a real number.
Next 5.3: Real numbers are not imaginary.
Claim 5.4: 7 is an integer.
Next 5.4: Every integer is a real number.</p>
<table>
<thead>
<tr>
<th>Facts 6: Spiders are not six-legged.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Insects are six-legged. Insects are</td>
<td></td>
</tr>
<tr>
<td>arthropods. Every animal is not</td>
<td></td>
</tr>
<tr>
<td>unicellular. Invertebrates are</td>
<td></td>
</tr>
<tr>
<td>animals. Lepidopterans are insects.</td>
<td></td>
</tr>
<tr>
<td>Every arthropod is segmented.</td>
<td></td>
</tr>
<tr>
<td>Arthropods are invertebrates. Every</td>
<td></td>
</tr>
<tr>
<td>butterfly is a lepidopteran. Stella</td>
<td></td>
</tr>
<tr>
<td>is a butterfly.</td>
<td></td>
</tr>
<tr>
<td>Query 6: True or false: Stella is</td>
<td></td>
</tr>
<tr>
<td>six-legged.</td>
<td></td>
</tr>
<tr>
<td>Claim 6.1: Stella is an insect.</td>
<td></td>
</tr>
<tr>
<td>Next 6.1: Insects are six-legged.</td>
<td></td>
</tr>
<tr>
<td>Claim 6.2: Stella is a lepidopteran.</td>
<td></td>
</tr>
<tr>
<td>Next 6.2: Lepidopterans are insects.</td>
<td></td>
</tr>
<tr>
<td>Claim 6.3: Stella is a butterfly.</td>
<td></td>
</tr>
<tr>
<td>Next 6.3: Every butterfly is a</td>
<td></td>
</tr>
<tr>
<td>lepidopteran.</td>
<td></td>
</tr>
<tr>
<td>Claim 6.4: Stella is six-legged.</td>
<td></td>
</tr>
<tr>
<td>Next 6.4: Finish.</td>
<td></td>
</tr>
<tr>
<td>Facts 7: <fact></td>
<td></td>
</tr>
<tr>
<td>Query 7: <query></td>
<td></td>
</tr>
</tbody>
</table>
<p>| Facts 7: <fact> | |
| Query 7: <query> | |</p>
<h2>D Related work: world model and planning</h2>
<p>Recent years have witnessed successful applications of planning algorithms <em>Sekar et al. (2020)</em>, such as AlphaZero <em>Silver et al. (2017)</em>, and MuZero <em>Schrittwieser et al. (2020)</em>. These algorithms are typically based on tree-structured search and are designed to effectively maintain the balance of exploration and exploitation. Knowledge of transition dynamics is the prerequisite for planning, and recent research on model-based reinforcement learning propose to learn a world model (or dynamics model) to plan or assist policy learning. To improve sample efficiency, previous research attempts to learn a world model from offline trajectories, and directly learn a policy within the world model <em>Ha and Schmidhuber (2018a, b)</em>. With latent imagination in a world model, RL agents can be trained to solve long-horizon tasks <em>Hafner et al. (2019, 2020)</em>. Besides, the world model is also shown to be helpful to physical robot learning <em>Wu et al. (2023)</em>. In this paper, we use LLMs as world models and apply a planning algorithm to search for a reasoning path. This is similar in spirit to model predictive control <em>Camacho and Alba (2013)</em>. Compared with previous works, our framework uses general LLMs as the world model and can be adapted to a wide</p>
<p>Table 5: Ablation study on Blocksworld. $R_{1}$ is action likelihood reward, $R_{2}$ is task-specific reward, and $R_{3}$ is self-evaluation reward.</p>
<table>
<thead>
<tr>
<th>$R_{1}$</th>
<th>$R_{2}$</th>
<th>$R_{3}$</th>
<th>Success</th>
</tr>
</thead>
<tbody>
<tr>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>0.88</td>
</tr>
<tr>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>0.91</td>
</tr>
<tr>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>0.46</td>
</tr>
<tr>
<td>✗</td>
<td>✓</td>
<td>✗</td>
<td>0.21</td>
</tr>
<tr>
<td>✗</td>
<td>✗</td>
<td>✓</td>
<td>0.14</td>
</tr>
<tr>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>0.02</td>
</tr>
</tbody>
</table>
<p>Table 6: Ablation study on GSM8k (first 300 examples). $R_{1}$ is state transition confidence reward, $R_{2}$ is action likelihood reward, and $R_{3}$ is self-evaluation reward.</p>
<table>
<thead>
<tr>
<th>$R_{1}$</th>
<th>$R_{2}$</th>
<th>$R_{3}$</th>
<th>$\text{RAP}^{(1)}$</th>
<th>$\text{RAP}^{(10)}$</th>
<th>+aggr</th>
</tr>
</thead>
<tbody>
<tr>
<td>✓</td>
<td>✗</td>
<td>✓</td>
<td>0.410</td>
<td>0.450</td>
<td>0.503</td>
</tr>
<tr>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>0.350</td>
<td>0.447</td>
<td>0.490</td>
</tr>
<tr>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>0.373</td>
<td>0.423</td>
<td>0.443</td>
</tr>
</tbody>
</table>
<p>range of open-domain reasoning tasks. Xiang et al. (2023) propose to train LLMs wih a external world model to gain embodied experience, while RAP focuses on the inference stage and is compatible with any training methods.</p>
<h2>E Adaptive Prompting</h2>
<p>Through our preliminary experiments, we observed that the performance of LLMs is impacted by the discrepancy in difficulty between demonstration cases and the test cases. In the case of RAP, when a new state is predicted, we reformulate the remaining task as a new test case, initialized with the predicted new state. This new test case would require a smaller minimum number of actions, leading to a disparity in the distribution of the demonstration cases and the new cases. To mitigate this issue, we pre-compute the intermediate states of the demonstration cases beforehand. During inference, we truncate the trace from the beginning for each new state in an iteration, which reduces the minimum action number of the demonstration cases as the search tree deepens. This technique significantly enhances the performance of RAP, especially for more intricate problems, which are more susceptible to distribution mismatches.</p>
<h2>F Reward Choice</h2>
<p>Results. We conduct comprehensive experiments on rewards for plan generation (Table 5) and math reasoning (Table 6). Note that, in both tables, the first row indicates the setting we use in the main experiments. As shown in Table 5, the combination of action likelihood and task-specific reward (row 1) can significantly outperform the single reward baselines (row 3, 4, 5). Interestingly, adding the self-evaluation reward can further improve the performance slightly (row 2). Furthermore, as the results on the first 300 samples of GSM8k shown in Table 6, we can see adding either action likelihood (row 3) or self-evaluation (row 1) on top of confidence reward (row 2) can boost the RAP performance of only using confidence reward (row 1) with one iteration, but action likelihood reward downgrades the accuracy with more iterations. The self-evaluation reward leads to the best performance overall. This indicates the importance of self-evaluation reward in guiding reasoning as an effective and computationally efficient prior to exploration.
Self-evaluation and action likelihood. The rewards of self-evaluation and action likelihood are of particular interest, as they can be applied to a wide range of reasoning tasks. Generally, the best usage and combination with other rewards require empirical design and understanding of the task nature, and their effectiveness can vary significantly across different tasks. Here, we provide some intuitions behind the reward choices:
(a) For the problems in which one reasoning step is short and structured, the action likelihood can be very indicative. Otherwise, it may be disturbed by unimportant tokens and become unreliable. For instance, a single step within the Blocksworld domain typically adheres to specific patterns (e.g., PICK/PUT/STACK a block...), rendering the action likelihood indicative. However, in the math domain, a reasoning step is expressed in natural language sentences, allowing for greater freedom and potentially introducing noise.
(b) For the problems where it's easier to recognize some errors afterward than avoid them during generation, self-evaluation emerges as a helpful mechanism for enhancing reasoning accuracy. In mathematical reasoning, LLMs may struggle to generate a correct reasoning step in the first place, but the detection of calculation or logic errors is more feasible. In Blocksworlds, however, assessing the quality of a candidate action is not straightforward and still requires multi-step reasoning. This characteristic diminishes the accuracy of the selfevaluation reward, making it less helpful especially given that likelihood already provides a good intuition for search.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{\wedge}$ equal contribution
${ }^{1}$ The code is available at https://github.com/Ber666/ llm-reasoners&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>