<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8508 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8508</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8508</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-152.html">extraction-schema-152</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <p><strong>Paper ID:</strong> paper-264426101</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2310.14628v2.pdf" target="_blank">Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts</a></p>
                <p><strong>Paper Abstract:</strong> As large language models (LLMs) have shown effectiveness with different prompting methods, such as Chain of Thought, Program of Thought, we find that these methods have formed a great complementarity to each other on math reasoning tasks. In this work, we propose XoT, an integrated problem solving framework by prompting LLMs with diverse reasoning thoughts. For each question, XoT always begins with selecting the most suitable method then executes each method iteratively. Within each iteration, XoT actively checks the validity of the generated answer and incorporates the feedback from external executors, allowing it to dynamically switch among different prompting methods. Through extensive experiments on 10 popular math reasoning datasets, we demonstrate the effectiveness of our proposed approach and thoroughly analyze the strengths of each module. Moreover, empirical results suggest that our framework is orthogonal to recent work that makes improvements on single reasoning methods and can further generalise to logical reasoning domain. By allowing method switching, XoT provides a fresh perspective on the collaborative integration of diverse reasoning thoughts in a unified framework. The code is available at https://github.com/tengxiaoliu/XoT.</p>
                <p><strong>Cost:</strong> 0.017</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8508.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8508.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>XoT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>X-of-Thoughts (XoT) framework</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An integrated iterative problem-solving framework that plans, reasons, verifies, and dynamically switches among multiple prompting-based reasoning methods (CoT, PoT, EoT) using passive and active verification to improve LLM math and logical reasoning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>OpenAI gpt-3.5-turbo accessed via API; few-shot in-context prompting (8 examples typically), greedy decoding, average of 3 runs reported.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Chain-of-Thought (CoT)', 'Program-of-Thought / Program-Aided Language Model (PoT / PAL)', 'Equation-of-Thought (EoT)', 'Self-refinement (optional, within reasoning module)', 'Tool/executor use (Python interpreter, sympy equation solver)']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>CoT: natural-language, step-by-step textual rationales performing calculations inline; PoT/PAL: generate Python code to perform deterministic computation with external execution; EoT: model problem as linear equations and solve with symbolic solver (sympy) treating unknowns explicitly; self-refinement: model re-analyses and edits its own solution within same prompting method before switching; verification uses (a) passive checks from external tool execution (syntax/runtime errors) and (b) active verification where the model, given intermediate values, emits assertions checked by executor.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>diverse (primary design uses multiple distinct methods and allows switching among them); framework also supports similar/repeated use via self-refinement when desired (both).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>Core experiments compare XoT (iterative switching among CoT, PoT, EoT under planning+verification) to single-method baselines (CoT only, PoT only, EoT only), to a repeated-single-method ablation (PoT repeated for multiple iterations, termed PoT3), to majority-vote ensemble of all three methods, and to oracle analysis (if any method produces the correct answer). Ablations include removing the planning module (fixed method order), removing verification entirely, and comparing passive-only verification vs passive+active verification.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>Ten math reasoning datasets including GSM8K, SVAMP, AQuA, Algebra, GSM-hard, AddSub, SingleOP, SingleEQ, MultiArith, MATH; additionally logical reasoning on FOLIO (First-Order Logic reasoning).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>Across the 10 math datasets XoT achieves an average improvement of +5.49% over the strongest single-method baseline. Example dataset-level numbers (gpt-3.5-turbo): GSM8K: CoT 80.2%, PoT 77.2%, EoT 63.8%, XoT 83.3%, oracle 92.5%; Algebra (subset): CoT ~82.4% (varied by subtopic), PoT ~14.4-...? (see paper), XoT 89.9% on Algebra. On average XoT: ~84.63% vs majority-vote ensemble 82.59% (Table 7). On logical dataset FOLIO, XoT reached 62.75% vs oracle 77.45% (validation set). Removing verification degrades performance (e.g., GSM8K down by 4.9%). PoT repeated (PoT3) final performance on combined set: 78.39% vs XoT 82.71% (paper-reported numbers for that experiment); oracle where any method works is much higher (example oracle gaps up to >10%).</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>The methods are complementary: some problems solved uniquely by EoT (unknown-variable / algebraic structure), others by PoT (precise arithmetic via code) or CoT (flexible natural-language reasoning). Planning improves efficiency (XoT averages 1.46 iterations on GSM8K vs 1.58 for best fixed order) and higher first-iteration solve rate (68.8% vs 57.2%). Passive verification alone has very high false-positive acceptance (letting incorrect answers pass) and thus prevents switching; active verification (model-issued assertions checked by executor) substantially reduces false positives at cost of some false negatives, improving overall final accuracy (~+2.3% gain). Majority-vote ensembles perform worse than XoT in accuracy and cost more tokens; repeated use of the same method (PoT3) yields limited complementarity vs switching among diverse methods.</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>Switching adaptively among diverse reasoning thoughts (CoT, PoT, EoT) using planning plus verification yields consistent and significant improvements over any single method or simple ensembling; complementarity across methods provides an oracle upper bound substantially above single methods (>10% in some datasets), and verification (especially active) is critical to enable safe switching and exploration.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8508.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8508.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>EoT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Equation-of-Thought (EoT)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prompting method that represents math word problems as systems of linear equations with unknown variables and solves them deterministically using a symbolic solver (sympy); introduced as a complementary reasoning method to CoT and PoT.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Few-shot prompting to produce equation systems; solver (sympy) executes equations to obtain values; intermediate variable values are exposed for verification.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Equation-based reasoning (linear systems)', 'External symbolic solving (sympy)']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>Prompt the LLM to translate the problem into algebraic linear equations with named unknowns; submit equations to a symbolic solver to compute values without requiring the model to assign concrete initial numeric values to unknowns.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>diverse (used as one distinct method among CoT and PoT in XoT).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>EoT included as one of the three core methods in XoT; ablations consider combinations (PE, PC, EP, EC, EPC, PEC) and fixed orders to evaluate contributions of EoT relative to PoT/CoT.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>Particularly effective on algebraic problems and datasets with unknown variables (e.g., Algebra dataset); evaluated across GSM8K, Algebra, GSM-hard, etc.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>Per-table examples: EoT on GSM8K: 63.8%; EoT on Algebra/subsets shows strong performance (paper reports e.g., 82.3% on some Algebra splits); EoT complements other methods raising oracle upper bound; in some datasets EoT outputs cannot be executed for a non-trivial fraction of cases (e.g., across runs 30.3% of EoT answers on AQuA couldn't be executed).</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>EoT excels where problems are naturally expressible as linear equations and where backward reasoning over unknowns is needed; PoT can hallucinate when forced to assign concrete values to unknown variables, whereas EoT avoids that by keeping variables symbolic.</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>EoT provides important complementary capability (especially for algebraic/unknown-variable problems) that, combined with PoT and CoT within XoT, substantially raises achievable accuracy relative to any single-method baseline.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8508.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8508.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PoT3</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Repeated single-method refinement (PoT3)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An ablation where the same prompting method (PoT) is reused across multiple iterations (three), either with the same few-shot examples or varying examples, to test whether repeatedly applying one method yields similar complementarity to switching.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>PoT few-shot prompting to generate Python programs; either repeated with identical shots (PoT3) or different few-shot examples across iterations (PoT3-d).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Repeated Program-of-Thought (PoT) with self-refinement/rehinting']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>At each iteration the model reattempts reasoning using PoT; in the PoT3-d variant the few-shot exemplars change across iterations to induce diversity within the same method.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>similar (single method repeated across iterations)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>Direct comparison to XoT (diverse switching among PoT, CoT, EoT) and to oracle; measures how much complementarity is achievable by repeated use of the same method vs by switching methods.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>Same set of math datasets used for XoT experiments (e.g., GSM8K, SVAMP, etc.).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>Paper reports that under oracle setting repetitive exploitation of a single method attains 84.08% (oracle for PoT repeated), which is 8.64% less than XoT's oracle. Final measured performance: PoT3 78.39% vs XoT 82.71% (reported combined numbers for one experiment).</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>Repeating a single method gives limited additional complementarity compared to genuinely diverse methods; using different few-shot exemplars across iterations (PoT3-d) offers modest gains but still lags behind multi-method switching.</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>Simply retrying the same reasoning method multiple times yields substantially less benefit than switching among diverse reasoning methods; diversity of method type (language rationale vs program vs equations) is a major source of complementarity.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8508.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8508.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MajorityVote</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Majority-vote ensemble over CoT, PoT, EoT</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A baseline ensemble that generates one answer per method (CoT, PoT, EoT) and picks the majority answer (or fallback) to evaluate ensemble benefit versus XoT's iterative, verified switching.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Generate one solution per method under the same few-shot setup and take majority voting across answers.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Ensemble majority vote of CoT, PoT, EoT outputs']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>Run each method once, collect final answers, and select the majority answer as final prediction (no iterative switching or verification-driven method changes).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>diverse (post-hoc aggregation of different methods)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>Compared majority-vote (one-shot each of three methods) to XoT (iterative validated switching); compute accuracy and token usage cost.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>Same math datasets; results aggregated in Table 7.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>Majority voting average accuracy 82.59% vs XoT 84.63% (average). Example: on Algebra majority vote 79.73% vs XoT 89.94%. Majority voting required more tokens (reported ~95.4k) vs XoT (~34.5k) averaged across datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>Majority vote can fail on datasets where one method strongly aligns with question type; ensemble uses more computation and tokens because it executes all methods for every question while XoT stops early when verification passes.</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>XoT outperforms simple majority voting both in accuracy and efficiency because XoT verifies and stops early, and because adaptive switching exploits complementarity more effectively than blind aggregation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8508.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8508.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Verification</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Passive and Active Verification</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Two complementary verification strategies used in XoT: passive verification uses executor errors/results (syntax/runtime execution) to filter bad solutions; active verification asks the LLM to assert/check whether intermediate values and final answer satisfy problem conditions, with assertions executed by external tools.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Verification module implemented via prompts: passive verification inspects execution exceptions and outputs; active verification prompts the model to produce assertion statements that are then executed with intermediate values provided by executors.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Passive verification (tool-execution checks)', 'Active verification (model-generated assertions checked with tool and intermediate values)']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>Passive: treat execution errors or runtime exceptions as verification failures; Active: LLM is instructed to check solution by producing assertions re-evaluated with intermediate numeric values (reasoning expressions intentionally excluded to avoid mimicry). Solutions pass active verification if executor runs assertions without error.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>enables diverse switching by certifying when to accept or reject a method's output; not a reasoning method per se but crucial for method diversity management.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>Ablation comparing passive-only verification vs passive+active verification; measured false positive/negative rates and final accuracy impact. Also experiment removing verification entirely.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>GSM8K reported in detail; general across datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>Passive-only verification produced high false-positive rates (paper cites ~89.5% and ~41.0% for PoT and EoT matrices respectively in one analysis). Adding active verification reduced false positives by about 56.8% and 24.3% respectively and produced a net +2.3% gain in overall XoT performance, while slightly increasing false negatives. Removing verification (no iterative switching) reduced accuracy (GSM8K down 4.9%, SVAMP down 2.9% in reported ablation).</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>Passive checks are necessary but insufficient (they often accept incorrect solutions); active verification reduces erroneous acceptances enabling effective method switching; active verification trades some false negatives for much lower false positives, which is beneficial since other methods can still be attempted.</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>Effective verification (especially active verification) is essential to enable safe switching among diverse reasoning methods: it reduces false acceptances, enabling exploration of alternative methods and improving final accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8508.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e8508.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Planning module</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Planning module (method selection)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A learned (prompted) planning component that selects which reasoning method to try first from the available set, aiming to reduce iterations and improve efficiency and final accuracy.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Implemented with an LLM few-shot prompt that, given the problem, selects the most suitable method (PoT/EoT/CoT) to try first; selection is removed from the candidate set after try.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Method selection / planning as a meta-reasoner']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>Prompt-based planner inspects the question and chooses the method believed most likely to succeed; planner is used at each iteration (after a failed attempt it picks the next best method among remaining ones).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>enables diverse approach by determining order of trying multiple methods (supports diversity management); contributes to both diversity and efficiency.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>Ablation compares XoT with planner vs fixed pre-defined method orders (e.g., EPC, PEC, etc.); metrics include final accuracy and average number of iterations.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>Reported across datasets, example GSM8K used to quantify iteration reductions.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>XoT with planning outperforms all predetermined execution sequences on average (Table 4). Example: average iterations on GSM8K 1.46 with planner vs 1.58 with best fixed order (EPC); first-iteration solve rate 68.8% with planner vs 57.2% with best fixed order.</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>Planning both increases robustness across datasets (dynamically tailoring method order to question type) and improves efficiency (fewer iterations on average).</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>A planning module that chooses the likely-best method first increases overall XoT effectiveness and efficiency; dynamic ordering beats fixed method sequences.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8508.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e8508.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models use diverse or similar reasoning methods to solve reasoning problems, including details of the reasoning methods, whether multiple or single methods are used, the tasks or benchmarks, performance results, and any explicit comparisons or ablations between diverse and similar reasoning approaches.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Self-refinement in XoT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Self-refinement (iterative improvement within same method)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Integration of self-refinement (model self-feedback and re-answering) within the reasoning module before switching methods, allowing the model to try to fix errors while staying within the same method.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>gpt-3.5-turbo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>After a first attempt, the model analyzes its response, summarizes advice, then re-attempts the same method guided by these hints; implemented for CoT, PoT, EoT using prior self-refinement prompts (Madaan et al. style).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods</strong></td>
                            <td>['Self-refinement within CoT/PoT/EoT']</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_methods_description</strong></td>
                            <td>The model inspects its prior solution line-by-line, proposes corrections or hints, and runs a second pass under the same prompting method; resulting solution is then subject to verification before deciding to switch methods.</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity</strong></td>
                            <td>similar (staying within same method for additional iterations), but used inside a broader diverse-switching framework (both).</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_diversity_experimental_setup</strong></td>
                            <td>Compare XoT with and without integrated one-round self-refinement; self-refinement applied prior to switching methods in each iteration; results measured on GSM8K.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_benchmark</strong></td>
                            <td>GSM8K reported; applied across other datasets as well in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_results</strong></td>
                            <td>On GSM8K, adding one round of self-refinement yields marginal within-method gains (CoT 80.4 -> 81.7, PoT 76.9 -> 76.9 marginal, EoT 64.1 -> 66.5) but when combined within XoT leads to a larger overall gain: XoT improves from 82.7 to 84.5 on GSM8K when refinement is added (Table 8).</td>
                        </tr>
                        <tr>
                            <td><strong>qualitative_findings</strong></td>
                            <td>Self-refinement can improve single-method outputs slightly; more importantly, combining self-refinement with method switching yields additive benefits.</td>
                        </tr>
                        <tr>
                            <td><strong>explicit_comparison</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>key_claims_or_conclusions</strong></td>
                            <td>Self-refinement is complementary to the XoT switching mechanism: limited gains within single methods but further improves collective performance when integrated into diverse-method framework.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts', 'publication_date_yy_mm': '2023-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Chain-of-thought prompting elicits reasoning in large language models <em>(Rating: 2)</em></li>
                <li>PAL: program-aided language models <em>(Rating: 2)</em></li>
                <li>Program-of-thoughts prompting: Disentangling computation from reasoning for numerical reasoning tasks <em>(Rating: 2)</em></li>
                <li>Self-refine: Iterative refinement with self-feedback <em>(Rating: 2)</em></li>
                <li>Solving math word problems by combining language models with symbolic solvers <em>(Rating: 2)</em></li>
                <li>Tree of thoughts: Deliberate problem solving with large language models <em>(Rating: 1)</em></li>
                <li>Logic-lm: Empowering large language models with symbolic solvers for faithful logical reasoning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8508",
    "paper_id": "paper-264426101",
    "extraction_schema_id": "extraction-schema-152",
    "extracted_data": [
        {
            "name_short": "XoT",
            "name_full": "X-of-Thoughts (XoT) framework",
            "brief_description": "An integrated iterative problem-solving framework that plans, reasons, verifies, and dynamically switches among multiple prompting-based reasoning methods (CoT, PoT, EoT) using passive and active verification to improve LLM math and logical reasoning.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "OpenAI gpt-3.5-turbo accessed via API; few-shot in-context prompting (8 examples typically), greedy decoding, average of 3 runs reported.",
            "reasoning_methods": [
                "Chain-of-Thought (CoT)",
                "Program-of-Thought / Program-Aided Language Model (PoT / PAL)",
                "Equation-of-Thought (EoT)",
                "Self-refinement (optional, within reasoning module)",
                "Tool/executor use (Python interpreter, sympy equation solver)"
            ],
            "reasoning_methods_description": "CoT: natural-language, step-by-step textual rationales performing calculations inline; PoT/PAL: generate Python code to perform deterministic computation with external execution; EoT: model problem as linear equations and solve with symbolic solver (sympy) treating unknowns explicitly; self-refinement: model re-analyses and edits its own solution within same prompting method before switching; verification uses (a) passive checks from external tool execution (syntax/runtime errors) and (b) active verification where the model, given intermediate values, emits assertions checked by executor.",
            "reasoning_diversity": "diverse (primary design uses multiple distinct methods and allows switching among them); framework also supports similar/repeated use via self-refinement when desired (both).",
            "reasoning_diversity_experimental_setup": "Core experiments compare XoT (iterative switching among CoT, PoT, EoT under planning+verification) to single-method baselines (CoT only, PoT only, EoT only), to a repeated-single-method ablation (PoT repeated for multiple iterations, termed PoT3), to majority-vote ensemble of all three methods, and to oracle analysis (if any method produces the correct answer). Ablations include removing the planning module (fixed method order), removing verification entirely, and comparing passive-only verification vs passive+active verification.",
            "task_or_benchmark": "Ten math reasoning datasets including GSM8K, SVAMP, AQuA, Algebra, GSM-hard, AddSub, SingleOP, SingleEQ, MultiArith, MATH; additionally logical reasoning on FOLIO (First-Order Logic reasoning).",
            "performance_results": "Across the 10 math datasets XoT achieves an average improvement of +5.49% over the strongest single-method baseline. Example dataset-level numbers (gpt-3.5-turbo): GSM8K: CoT 80.2%, PoT 77.2%, EoT 63.8%, XoT 83.3%, oracle 92.5%; Algebra (subset): CoT ~82.4% (varied by subtopic), PoT ~14.4-...? (see paper), XoT 89.9% on Algebra. On average XoT: ~84.63% vs majority-vote ensemble 82.59% (Table 7). On logical dataset FOLIO, XoT reached 62.75% vs oracle 77.45% (validation set). Removing verification degrades performance (e.g., GSM8K down by 4.9%). PoT repeated (PoT3) final performance on combined set: 78.39% vs XoT 82.71% (paper-reported numbers for that experiment); oracle where any method works is much higher (example oracle gaps up to &gt;10%).",
            "qualitative_findings": "The methods are complementary: some problems solved uniquely by EoT (unknown-variable / algebraic structure), others by PoT (precise arithmetic via code) or CoT (flexible natural-language reasoning). Planning improves efficiency (XoT averages 1.46 iterations on GSM8K vs 1.58 for best fixed order) and higher first-iteration solve rate (68.8% vs 57.2%). Passive verification alone has very high false-positive acceptance (letting incorrect answers pass) and thus prevents switching; active verification (model-issued assertions checked by executor) substantially reduces false positives at cost of some false negatives, improving overall final accuracy (~+2.3% gain). Majority-vote ensembles perform worse than XoT in accuracy and cost more tokens; repeated use of the same method (PoT3) yields limited complementarity vs switching among diverse methods.",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "Switching adaptively among diverse reasoning thoughts (CoT, PoT, EoT) using planning plus verification yields consistent and significant improvements over any single method or simple ensembling; complementarity across methods provides an oracle upper bound substantially above single methods (&gt;10% in some datasets), and verification (especially active) is critical to enable safe switching and exploration.",
            "uuid": "e8508.0",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "EoT",
            "name_full": "Equation-of-Thought (EoT)",
            "brief_description": "A prompting method that represents math word problems as systems of linear equations with unknown variables and solves them deterministically using a symbolic solver (sympy); introduced as a complementary reasoning method to CoT and PoT.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "Few-shot prompting to produce equation systems; solver (sympy) executes equations to obtain values; intermediate variable values are exposed for verification.",
            "reasoning_methods": [
                "Equation-based reasoning (linear systems)",
                "External symbolic solving (sympy)"
            ],
            "reasoning_methods_description": "Prompt the LLM to translate the problem into algebraic linear equations with named unknowns; submit equations to a symbolic solver to compute values without requiring the model to assign concrete initial numeric values to unknowns.",
            "reasoning_diversity": "diverse (used as one distinct method among CoT and PoT in XoT).",
            "reasoning_diversity_experimental_setup": "EoT included as one of the three core methods in XoT; ablations consider combinations (PE, PC, EP, EC, EPC, PEC) and fixed orders to evaluate contributions of EoT relative to PoT/CoT.",
            "task_or_benchmark": "Particularly effective on algebraic problems and datasets with unknown variables (e.g., Algebra dataset); evaluated across GSM8K, Algebra, GSM-hard, etc.",
            "performance_results": "Per-table examples: EoT on GSM8K: 63.8%; EoT on Algebra/subsets shows strong performance (paper reports e.g., 82.3% on some Algebra splits); EoT complements other methods raising oracle upper bound; in some datasets EoT outputs cannot be executed for a non-trivial fraction of cases (e.g., across runs 30.3% of EoT answers on AQuA couldn't be executed).",
            "qualitative_findings": "EoT excels where problems are naturally expressible as linear equations and where backward reasoning over unknowns is needed; PoT can hallucinate when forced to assign concrete values to unknown variables, whereas EoT avoids that by keeping variables symbolic.",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "EoT provides important complementary capability (especially for algebraic/unknown-variable problems) that, combined with PoT and CoT within XoT, substantially raises achievable accuracy relative to any single-method baseline.",
            "uuid": "e8508.1",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "PoT3",
            "name_full": "Repeated single-method refinement (PoT3)",
            "brief_description": "An ablation where the same prompting method (PoT) is reused across multiple iterations (three), either with the same few-shot examples or varying examples, to test whether repeatedly applying one method yields similar complementarity to switching.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "PoT few-shot prompting to generate Python programs; either repeated with identical shots (PoT3) or different few-shot examples across iterations (PoT3-d).",
            "reasoning_methods": [
                "Repeated Program-of-Thought (PoT) with self-refinement/rehinting"
            ],
            "reasoning_methods_description": "At each iteration the model reattempts reasoning using PoT; in the PoT3-d variant the few-shot exemplars change across iterations to induce diversity within the same method.",
            "reasoning_diversity": "similar (single method repeated across iterations)",
            "reasoning_diversity_experimental_setup": "Direct comparison to XoT (diverse switching among PoT, CoT, EoT) and to oracle; measures how much complementarity is achievable by repeated use of the same method vs by switching methods.",
            "task_or_benchmark": "Same set of math datasets used for XoT experiments (e.g., GSM8K, SVAMP, etc.).",
            "performance_results": "Paper reports that under oracle setting repetitive exploitation of a single method attains 84.08% (oracle for PoT repeated), which is 8.64% less than XoT's oracle. Final measured performance: PoT3 78.39% vs XoT 82.71% (reported combined numbers for one experiment).",
            "qualitative_findings": "Repeating a single method gives limited additional complementarity compared to genuinely diverse methods; using different few-shot exemplars across iterations (PoT3-d) offers modest gains but still lags behind multi-method switching.",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "Simply retrying the same reasoning method multiple times yields substantially less benefit than switching among diverse reasoning methods; diversity of method type (language rationale vs program vs equations) is a major source of complementarity.",
            "uuid": "e8508.2",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "MajorityVote",
            "name_full": "Majority-vote ensemble over CoT, PoT, EoT",
            "brief_description": "A baseline ensemble that generates one answer per method (CoT, PoT, EoT) and picks the majority answer (or fallback) to evaluate ensemble benefit versus XoT's iterative, verified switching.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "Generate one solution per method under the same few-shot setup and take majority voting across answers.",
            "reasoning_methods": [
                "Ensemble majority vote of CoT, PoT, EoT outputs"
            ],
            "reasoning_methods_description": "Run each method once, collect final answers, and select the majority answer as final prediction (no iterative switching or verification-driven method changes).",
            "reasoning_diversity": "diverse (post-hoc aggregation of different methods)",
            "reasoning_diversity_experimental_setup": "Compared majority-vote (one-shot each of three methods) to XoT (iterative validated switching); compute accuracy and token usage cost.",
            "task_or_benchmark": "Same math datasets; results aggregated in Table 7.",
            "performance_results": "Majority voting average accuracy 82.59% vs XoT 84.63% (average). Example: on Algebra majority vote 79.73% vs XoT 89.94%. Majority voting required more tokens (reported ~95.4k) vs XoT (~34.5k) averaged across datasets.",
            "qualitative_findings": "Majority vote can fail on datasets where one method strongly aligns with question type; ensemble uses more computation and tokens because it executes all methods for every question while XoT stops early when verification passes.",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "XoT outperforms simple majority voting both in accuracy and efficiency because XoT verifies and stops early, and because adaptive switching exploits complementarity more effectively than blind aggregation.",
            "uuid": "e8508.3",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Verification",
            "name_full": "Passive and Active Verification",
            "brief_description": "Two complementary verification strategies used in XoT: passive verification uses executor errors/results (syntax/runtime execution) to filter bad solutions; active verification asks the LLM to assert/check whether intermediate values and final answer satisfy problem conditions, with assertions executed by external tools.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "Verification module implemented via prompts: passive verification inspects execution exceptions and outputs; active verification prompts the model to produce assertion statements that are then executed with intermediate values provided by executors.",
            "reasoning_methods": [
                "Passive verification (tool-execution checks)",
                "Active verification (model-generated assertions checked with tool and intermediate values)"
            ],
            "reasoning_methods_description": "Passive: treat execution errors or runtime exceptions as verification failures; Active: LLM is instructed to check solution by producing assertions re-evaluated with intermediate numeric values (reasoning expressions intentionally excluded to avoid mimicry). Solutions pass active verification if executor runs assertions without error.",
            "reasoning_diversity": "enables diverse switching by certifying when to accept or reject a method's output; not a reasoning method per se but crucial for method diversity management.",
            "reasoning_diversity_experimental_setup": "Ablation comparing passive-only verification vs passive+active verification; measured false positive/negative rates and final accuracy impact. Also experiment removing verification entirely.",
            "task_or_benchmark": "GSM8K reported in detail; general across datasets.",
            "performance_results": "Passive-only verification produced high false-positive rates (paper cites ~89.5% and ~41.0% for PoT and EoT matrices respectively in one analysis). Adding active verification reduced false positives by about 56.8% and 24.3% respectively and produced a net +2.3% gain in overall XoT performance, while slightly increasing false negatives. Removing verification (no iterative switching) reduced accuracy (GSM8K down 4.9%, SVAMP down 2.9% in reported ablation).",
            "qualitative_findings": "Passive checks are necessary but insufficient (they often accept incorrect solutions); active verification reduces erroneous acceptances enabling effective method switching; active verification trades some false negatives for much lower false positives, which is beneficial since other methods can still be attempted.",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "Effective verification (especially active verification) is essential to enable safe switching among diverse reasoning methods: it reduces false acceptances, enabling exploration of alternative methods and improving final accuracy.",
            "uuid": "e8508.4",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Planning module",
            "name_full": "Planning module (method selection)",
            "brief_description": "A learned (prompted) planning component that selects which reasoning method to try first from the available set, aiming to reduce iterations and improve efficiency and final accuracy.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "Implemented with an LLM few-shot prompt that, given the problem, selects the most suitable method (PoT/EoT/CoT) to try first; selection is removed from the candidate set after try.",
            "reasoning_methods": [
                "Method selection / planning as a meta-reasoner"
            ],
            "reasoning_methods_description": "Prompt-based planner inspects the question and chooses the method believed most likely to succeed; planner is used at each iteration (after a failed attempt it picks the next best method among remaining ones).",
            "reasoning_diversity": "enables diverse approach by determining order of trying multiple methods (supports diversity management); contributes to both diversity and efficiency.",
            "reasoning_diversity_experimental_setup": "Ablation compares XoT with planner vs fixed pre-defined method orders (e.g., EPC, PEC, etc.); metrics include final accuracy and average number of iterations.",
            "task_or_benchmark": "Reported across datasets, example GSM8K used to quantify iteration reductions.",
            "performance_results": "XoT with planning outperforms all predetermined execution sequences on average (Table 4). Example: average iterations on GSM8K 1.46 with planner vs 1.58 with best fixed order (EPC); first-iteration solve rate 68.8% with planner vs 57.2% with best fixed order.",
            "qualitative_findings": "Planning both increases robustness across datasets (dynamically tailoring method order to question type) and improves efficiency (fewer iterations on average).",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "A planning module that chooses the likely-best method first increases overall XoT effectiveness and efficiency; dynamic ordering beats fixed method sequences.",
            "uuid": "e8508.5",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        },
        {
            "name_short": "Self-refinement in XoT",
            "name_full": "Self-refinement (iterative improvement within same method)",
            "brief_description": "Integration of self-refinement (model self-feedback and re-answering) within the reasoning module before switching methods, allowing the model to try to fix errors while staying within the same method.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "gpt-3.5-turbo",
            "model_description": "After a first attempt, the model analyzes its response, summarizes advice, then re-attempts the same method guided by these hints; implemented for CoT, PoT, EoT using prior self-refinement prompts (Madaan et al. style).",
            "reasoning_methods": [
                "Self-refinement within CoT/PoT/EoT"
            ],
            "reasoning_methods_description": "The model inspects its prior solution line-by-line, proposes corrections or hints, and runs a second pass under the same prompting method; resulting solution is then subject to verification before deciding to switch methods.",
            "reasoning_diversity": "similar (staying within same method for additional iterations), but used inside a broader diverse-switching framework (both).",
            "reasoning_diversity_experimental_setup": "Compare XoT with and without integrated one-round self-refinement; self-refinement applied prior to switching methods in each iteration; results measured on GSM8K.",
            "task_or_benchmark": "GSM8K reported; applied across other datasets as well in experiments.",
            "performance_results": "On GSM8K, adding one round of self-refinement yields marginal within-method gains (CoT 80.4 -&gt; 81.7, PoT 76.9 -&gt; 76.9 marginal, EoT 64.1 -&gt; 66.5) but when combined within XoT leads to a larger overall gain: XoT improves from 82.7 to 84.5 on GSM8K when refinement is added (Table 8).",
            "qualitative_findings": "Self-refinement can improve single-method outputs slightly; more importantly, combining self-refinement with method switching yields additive benefits.",
            "explicit_comparison": true,
            "key_claims_or_conclusions": "Self-refinement is complementary to the XoT switching mechanism: limited gains within single methods but further improves collective performance when integrated into diverse-method framework.",
            "uuid": "e8508.6",
            "source_info": {
                "paper_title": "Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts",
                "publication_date_yy_mm": "2023-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Chain-of-thought prompting elicits reasoning in large language models",
            "rating": 2
        },
        {
            "paper_title": "PAL: program-aided language models",
            "rating": 2
        },
        {
            "paper_title": "Program-of-thoughts prompting: Disentangling computation from reasoning for numerical reasoning tasks",
            "rating": 2
        },
        {
            "paper_title": "Self-refine: Iterative refinement with self-feedback",
            "rating": 2
        },
        {
            "paper_title": "Solving math word problems by combining language models with symbolic solvers",
            "rating": 2
        },
        {
            "paper_title": "Tree of thoughts: Deliberate problem solving with large language models",
            "rating": 1
        },
        {
            "paper_title": "Logic-lm: Empowering large language models with symbolic solvers for faithful logical reasoning",
            "rating": 1
        }
    ],
    "cost": 0.016677249999999998,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts</p>
<p>Tengxiao Liu 
School of Computer Science
Fudan University</p>
<p>Qipeng Guo 
Amazon AWS AI</p>
<p>Yuqing Yang yuqingyang21@m.fudan.edu.cn 
School of Computer Science
Fudan University</p>
<p>Xiangkun Hu 
Amazon AWS AI</p>
<p>Yue Zhang zhangyue@westlake.edu.cn 
School of Engineering
Westlake University</p>
<p>Xipeng Qiu xpqiu@fudan.edu.cn 
School of Computer Science
Fudan University</p>
<p>Zheng Zhang 
Amazon AWS AI</p>
<p>Plan, Verify and Switch: Integrated Reasoning with Diverse X-of-Thoughts
9F5FFB673C99D80E9129432AC7909E70
As large language models (LLMs) have shown effectiveness with different prompting methods, such as Chain of Thought, Program of Thought, we find that these methods have formed a great complementarity to each other on math reasoning tasks.In this work, we propose XoT, an integrated problem solving framework by prompting LLMs with diverse reasoning thoughts.For each question, XoT always begins with selecting the most suitable method then executes each method iteratively.Within each iteration, XoT actively checks the validity of the generated answer and incorporates the feedback from external executors, allowing it to dynamically switch among different prompting methods.Through extensive experiments on 10 popular math reasoning datasets, we demonstrate the effectiveness of our proposed approach and thoroughly analyze the strengths of each module.Moreover, empirical results suggest that our framework is orthogonal to recent work that makes improvements on single reasoning methods and can further generalise to logical reasoning domain.By allowing method switching, XoT provides a fresh perspective on the collaborative integration of diverse reasoning thoughts in a unified framework.</p>
<p>Introduction</p>
<p>The AI community has long sought to achieve automated reasoning (Hewitt, 1969), which is an important component of Artificial General Intelligence (Steunebrink et al., 2016).Mathematical reasoning, as a cognitive skill essential for humans yet challenging for language models, attracts increasing interests and commitment from researchers (Feigenbaum and Feldman, 1963;Wang et al., 2017;Lu et al., 2022).</p>
<p>With the abilities endowed by in-context learning (ICL), Large Language Models (LLMs) Figure 1: CoT only reasons in a single pass, while selfrefine involves refinement using the same method.XoT integrates a verification module that makes a difference in method planning, enabling the attempts of diverse reasoning thoughts within an iterative framework.(Brown et al., 2020;Chowdhery et al., 2022;Touvron et al., 2023a;OpenAI, 2023) are able to solve mathematical problems through textual rationales with Chain-of-Thought prompting (Wei et al., 2022) (CoT) or through Python functions with Program-Aided Language Model (Gao et al., 2022) and Program-of-Thought prompting (Chen et al., 2022) (PAL or PoT).These prompting methods exhibit unique strengths and limitations.CoT generates a step-by-step reasoning flow in natural language and performs calculations on the fly.This approach enables a more flexible solution format, but may result in a loss of precision since language models often struggle with arithmetic calculations (Lewkowycz et al., 2022;Wei et al., 2022).On the other hand, PoT or PAL resolves problems through Python statements, relying on Python interpreters to ensure calculation accuracy.Another noteworthy and intriguing prompting method is to form math problems as linear equation systems (He-Yueya et al., 2023).Similarly, inspired by Linear Algebra, we propose Equation-of-Thought (EoT), which performs math reasoning in a more direct way.The diversity inherent in each method does not arXiv:2310.14628v2[cs.CL] 27 Dec 2023 render them as competing or mutually exclusive alternatives.On the contrary, in practical problem solving scenarios, possessing multiple methods can always yield a range of complementary advantages.</p>
<p>The distinct problem-solving approaches can contribute to synergistic benefits that surpass the outcomes of any single approach.We find that this intuition also applies to the realm of math reasoning.With the availability of CoT, PoT and EoT, we hold the hypothesis that a model has the potential to solve a problem if it reaches the correct answer using any one of the prompting methods.As illustrated in Figure 2, our analysis shows that the model exhibits the potential to solve 92.72% of the problems, surpassing the best performing single method by over 10%.</p>
<p>Motivated by this observation, we propose XoT, an integrated math problem solving framework, which improves the LLM's reasoning ability by switching among diverse reasoning thoughts.Since there is no guarantee that LLMs can always solve the problem in a single attempt, we follow the human intuition and allow the model to rethink and switch to a different method when encountering difficulties or obstacles.We apply two complementary verification methods to facilitate the model to decide whether it is time to switch to another method: passive and active verification.Passive verification relies on the external executors to provide determinable results based on the generated programs (Chen et al., 2023;Le et al., 2022).It offers shallow inspections, such as program syntax issues or the runtime errors.For active verification, we ask the model to verify the solution by checking whether the answer adheres to the conditions outlined in the original question.</p>
<p>As shown in Figure 1, XoT consists of three modules that work in an iterative framework: planning, reasoning and verification.Given a problem as input, the planning module first proposes the most appropriate method.The reasoning module then generates one solution using the planned prompting method.With the outputs and the results from external executors, the model is asked to assess the answers in the context of the questions.If the answer fails the verification, we will go back to the planning module for another round of iteration and attempt alternative methods.The iterative process concludes when the verification confirms the correctness of the answer or after exhausting all available methods.To demonstrate the effectiveness of XoT, we conduct extensive experiments on 10 popular mathematical reasoning datasets and achieve consistent improvement.Empirical results suggest that XoT can accommodate recent work that focuses on improving single reasoning methods.Additional experiments also indicate that XoT can generalise to other domains such as logical reasoning tasks.</p>
<p>We summarize the main contributions as follows.First, we propose an integrated problem solving framework XoT, utilising the complementarity of different reasoning thoughts.Second, we introduce EoT which solves math problems with a system of linear equations, serving as a complementary method to existing approaches.Third, we incorporate passive and active verification to facilitate the framework to switch among diverse reasoning thoughts, empowering the framework to make informed decisions regarding the subsequent steps to be taken.More generally, XoT sheds lights on a new direction of interacting with diverse reasoning methods and tools.As shown in Figure 1, instead of sticking to one determined method, LLMs can benefit from the verification and the flexible switching among available reasoning thoughts.1 2 Related Work</p>
<p>Math Reasoning with LLMs</p>
<p>As the field of large language models continues to prosper, many prompting techniques have emerged to unlock the reasoning abilities of LLMs (Qiao et al., 2022).Early success includes reasoning with step-by-step chain of thought (Wei et al., 2022), decomposing questions into sub-questions in a least-to-most fashion (Zhou et al., 2022), zero-shot prompting LLMs with simply one sentence (Kojima et al., 2022), writing programs to solve procedural tasks (Gao et al., 2022;Chen et al., 2022).Despite generating solutions in single forward pass, one line of work employs multiple reasoning results and ensembles them by majority vote (Wang et al., 2022), and stepwise verifier (Li et al., 2022).Additionally, Tree-of-Thoughts (Yao et al., 2023) deliberately explores multiple reasoning paths and searches over a tree-structured reasoning states.Imani et al. (2023) propose to vote over multiple solutions generated with algebraic and program prompts.One concurrent work (Zhao et al., 2023) considers the difference of CoT and PoT and asks the LLM to choose one better reasoning rationale.In contrast to their work, XoT involves more reliable verification modules and switches methods when necessary.</p>
<p>Iterative Refinement</p>
<p>One stream of work is dedicated to iteratively enhancing LLMs by continuously reevaluating and refining outputs until the desired quality is achieved.Madaan et al. (2023) prompts the model to write feedback based on previously generated drafts and leverages the feedback to generate high-quality outputs.Similarly, Chen et al. (2023) iteratively debugs the code by utilizing external program execution results and code explanations generated by the model itself.In order to avoid repetitive mistakes, Shinn et al. (2023) builds a memory of previous errors, while Wang and Li (2023) collects all mistakes during the training phase to provide a global insight.When considering sources of hints to guide rethinking, Paul et al. (2023) focuses on intermediate reasoning steps, while Zheng et al. (2023) directly utilizes the previously generated answers.Qi et al. (2023) propose to emulate the divideand-conquer fashion of human thinking strategy and involve self-questioning and recursive thinking processes in the problem solving framework.Although these approaches contribute to improving the reasoning quality of LLMs, they are limited in retrying without looking around for other possible thoughts.In contrast, our proposed method aims to explore alternative solutions, and it is orthogonal to iterative refinement, as we have the flexibility to switch solutions when refining no longer leads to further improvement.</p>
<p>Preliminary</p>
<p>Prompting methods</p>
<p>For math reasoning tasks, we use three reasoning thoughts in this work, namely Chain-of-Thought (CoT), Program-of-Thought (PoT) and Equation-of-Thought (EoT).Despite the wellknown strengths of CoT and PoT methods, our proposed EoT excels particularly in reasoning with unknown variables.For each problem, EoT attempts to model the questions as linear equations and involves unknown values in the description.</p>
<p>A detailed formulation of EoT prompting can be found in Table 12 of Appendix C. As illustrated in Figure 3, while CoT correctly sets up the equations, it fails in accurately performing the calculations.PoT falls short in dealing with unknown variables, as Python requires that every variable is defined with a value.Assigning a value to an unknown variable (david_insects) hallucinates PoT to generate a misleading step (the highlighted line).In comparison, EoT manages to express the question context in straightforward equations and solves them with a deterministic equation solver.</p>
<p>Complementarity</p>
<p>Given a question q, we denote the correctness of the reasoning answers using each method as RX (q), where X  {CoT, P oT, EoT } denotes the diverse reasoning methods.RX (q) = {0, 1} represents whether the generated answer is correct according to the gold label.We define the accuracy under the oracle setting as:
ACC oracle = q RCoT (q) RP oT (q) REoT (q).
(1) The oracle setting represents that the model has the potential for solving one given problem if any of the methods accurately generates the answer.It also implies that in cases where the generated answer does not match the gold answers, XoT will make further attempts using alternative methods to answer the question.Under oracle setting, the model can potentially achieve more than 10% gains on various datasets.In Figure 2, the bar at the bottom represents the highest performance achieved by employing a single method, followed by the optimal performance achieved through the use of two methods.The overall stacked bar shows the utilization of all three methods, which indicates the upper bound that can be reached through the combined collaboration of various methods.</p>
<p>XoT</p>
<p>Our goal is to develop a generalized problem solving framework that can automatically select the appropriate method for different problems and has the capability to switch among reasoning thoughts using both active and passive verification.We first describe the overall framework and introduce each module in detail.</p>
<p>Overall Framework</p>
<p>The overall pipeline is described in Algorithm 1.The inputs of our framework include a question q and a predefined set of methods M .With the user input, XoT employs its three built-in modules to output the final solution, namely planning module P , reasoning module R and verification module V .</p>
<p>These three modules collaborate in an iterative manner.Suppose at iteration t, the planning module P first chooses the most appropriate method available: m t = P (M ).The chosen method is subsequently excluded from the set of methods.The reasoning module is then tasked to generate Algorithm 1 XoT Reasoning Algorithm Require: input question q, method set M , planning module P , reasoning module R, verifica-
tion module V 1: t  0 2: while |M | &gt; 0 do 3: m t  P (M )  Choose method 4: M  M \ {m t } 5: y  R mt (q) 6: if V (y) then 7: break  Verification passed 8:
else 9:
t  t + 1  Continue next iteration 10:
end if 11: end while 12: return y  Return the solution one solution y using the proposed method m t .Following this, the verification module evaluates the solution by rethinking the answer within the given conditions.If the answer successfully passes the verification, we proceed to return the current solution.Otherwise, XoT will move forward to the next iteration.Every module is implemented with a LLM through inference under few-shot setting.</p>
<p>We will elaborate each module with details.</p>
<p>Planning and Reasoning</p>
<p>The planning module is responsible for selecting the appropriate method at the beginning of each round of iteration.Recent work shows the necessity to equip reasoning framework with the ability to plan ahead (Lu et al., 2023).As elaborated in Section 3, it is evident that each method possesses distinct strengths.Our intuition is to consistently initiate the process with the optimal method to enhance reasoning efficiency.</p>
<p>The reasoning module performs few-shot reasoning with the planned prompting method.Each round of reasoning operates independently, meaning that subsequent iterations do not rely on the failed reasoning attempts of previous iterations.</p>
<p>Verification module</p>
<p>The verification module assesses the effectiveness of the reasoning solution through two approaches: passive verification and active verification.</p>
<p>When solutions involve offloading computation to external tools, the execution results naturally serve as a passive verification.Any occurrence of errors or exceptions during the execution directly 222  2  GSM-hard (Gao et al., 2022) 1,313 3.25 MATH (Hendrycks et al., 2021) 5,000  3  AddSub (Hosseini et al., 2014) 395 1 SingleOP (Roy et al., 2015) 562 1 SingleEQ (Koncel-Kedziorski et al., 2015) 508 1.31 MultiArith (Roy and Roth, 2015) 600 2 results in a failure in the verification process.Solutions that pass the passive verification stage then proceed to active verification.</p>
<p>In the case of active verification, the module rethinks the answer within the context of the given question.It first acquires all intermediate values associated with each variable mentioned in the solution.These values are computed by external executors.We intentionally exclude the reasoning process (expressions) leading to the results to prevent the verification module from emulating the solution's thinking process.With the intermediate results and final answer in hand, the module is expected to recheck whether the answer satisfies the conditions specified in the question.The desired format for this evaluation is an assertion statement, as shown in Figure 4.This assertion is subsequently combined with the original solution for external tools to execute.If no issues arise during this execution phase, it means the solution successfully passes the verification.A detailed illustration of the prompts we use can be found in Appendix C. The verification module is specially designed for PoT and EoT as the intermediate values can be easily obtained.We leave the exploration of a more effective verification for CoT as future work.</p>
<p>Experiments</p>
<p>Experimental Setting</p>
<p>Datasets Our experiments are conducted on a comprehensive set of 10 math reasoning datasets, encompassing various challenging math reasoning scenarios.Some widely used datasets include GSM8K, SVAMP, AQuA, MATH and MAWPS (AddSub, SingleOP, SingleEQ, Multi-Arith) (Koncel-Kedziorski et al., 2016).Besides, we also incorporate several recently introduced datasets, namely Algebra, GSM-hard.Algebra comprises a collection of solely algebraic word problems that can be resolved through the use of equations.To increase the complexity of calculations, GSM-hard replaced small numerical values with larger ones.The details of the statistics of the datasets can be found in Table 1.</p>
<p>Model We query OpenAI API for experiments 2 .Specifically we use gpt-3.5-turboas the inference engine.If not further explained, we manually construct the prompts with 8 examples sampled from the training set.For CoT and PoT, we directly use the examples released by published paper (Fu et al., 2022;Gao et al., 2022;Chen et al., 2022).For model generation strategy, we employ greedy decoding in all runs.Due to the non-deterministic APIs, we report the average performance and the standard deviation across 3 runs.We also evaluate XoT with various base models in Appendix A.2.</p>
<p>Main Results</p>
<p>The main results are shown in Table 2.We consider three prompting methods as baselines, namely CoT, PoT and EoT.On average, XoT achieves a significant improvement of 5.49% across the datasets.For MATH dataset, we show the breakdown results of different question subtopics in Table 3.We also represent the performance enhancement over the strongest baseline as .As questions in MATH are too complex for equation systems to solve, we only consider CoT and PoT with passive verification.Specifically, on the AQuA dataset, which consists of multiple-choice questions, we observe that PoT or EoT often fails to generate a valid answer due to the diverse answer formats.Across the three runs, 24.4% of the PoT answers and 30.3% of the EoT answers cannot be executed.Therefore, applying passive verification is adequate to ensure the explortion of other method options.When post processing the generated results, we further enforce a restriction that the model cannot make a random guess if it fails to extract an answer from the generated output.Such instances should be proceeded to the next iteration to guarantee a fair evaluation of the performance.</p>
<p>Notably, we observe that the enhancements are more pronounced for the challenging datasets compared to the easier ones.Difficult datasets usually contain longer questions and more than 3 reasoning steps while easier datasets such as SingleEQ require only one equation to solve the problem.We find that the improvement directly correlates with the complementary nature of the three methods employed across different datasets.On easier datasets, each method performs well individually, resulting in only minor complementarity.Figure 5 reveals that XoT demonstrates superior performance on 2 https://openai.comdatasets that exhibit stronger enhancement under oracle setting.The bars in the figure represent the improvement under XoT, while the line indicates the upper bound of the improvement under oracle setting.The comparison indicates that MultiArith and SingleEQ allow minimal room for improvement, therefore the overall XoT performance is negatively impacted by the accumulated errors introduced by the verification module.</p>
<p>Additionally, we conduct experiments on logical reasoning task to evaluate the generalisability of XoT.Details can be found in Appendix A.1.</p>
<p>Analysis</p>
<p>In this section, we first analyze the effectiveness and necessity of each module within XoT.Then we provide comparison with majority voting and describe how model's self refinement can be integrated in our framework.</p>
<p>Ablation Study</p>
<p>Planning The planning module decides which method to attempt at the beginning of each iteration.We are curious about how well it performs in selecting the most suitable method among the available options.The planning module is expected to select from PoT and EoT at the beginning because these two methods can be verified with both active and passive verification.To demonstrate the necessity of the planning module, we conduct an experiment in which XoT is asked to execute each method in a predefined order.Whether to switch the method is still determined by the verification module.We break down the performance of each dataset with respect to different combinations of methods in Table 4.</p>
<p>Our findings align with two design ethos of the planning module.First, it demonstrates robustness across different datasets.While specific combinations excel at different datasets, XoT equipped with the planning module outperforms all other predetermined combinations on average.For instance, on GSM-hard, the combination of PoT and EoT achieves the best performance, which highlights the importance of leveraging external tools to handle calculation involving large numbers.Additionally, on SingleEQ and MultiArith where XoT fails to offer improvement, the combination of two methods proves to be efficient, surpassing the single method baselines.With the inclusion of the planning module, XoT can dynamically adjust the  execution order based on different questions, which ensures a more consistent and robust performance.Second, the planning module enhances efficiency, facilitating XoT to reach the final answer in fewer iterations by always starting from the most possible method.To illustrate, on GSM8K, XoT needs 1.46 iterations on average in comparison with 1.58 iterations with the fixed EPC order (EoT-&gt;PoT-&gt;CoT, the best performing fixed order).Specifically, 68.8% of the questions are resolved in the first iteration with XoT, as opposed to 57.2% when employing the fixed EPC order.</p>
<p>Reasoning How important is it to try different methods instead of exclusively relying on a single method?To investigate this, we restrict the available method options to utilizing PoT only, denoted as PoT 3 .In other words, if the generated solution fails to pass the verification, it reconsiders its reasoning using the same prompting method instead of changing to another.The results are demonstrated in Figure 6.PoT 3 uses the same few-shot examples in three iterations while PoT Table 4: Results across different datasets without the planning module.We manually define the execution sequence, denoted as the combination of the first letter in each method.For example, 'PEC' indicates PoT-EoT-CoT.This suggests the necessity employing various reasoning methods in our framework.</p>
<p>Verification The verification module facilitates seamless switching between iterations.We here explore how helpful the active and passive verifications are. Figure 7  such a simplistic verification approach yields an alarmingly high false positive rate of 89.5% and 41.0%, as shown in Table 5.This drawback is particularly critical as our XoT's essence lies in the ability to adaptively switch methods, and a high false positive rate restricts the model's ability to explore alternative method options.By additionally incorporating active verification, despite a slight compromise in accuracy, the false positive rate is substantially reduced by 56.8% and 24.3%.We also note that this approach inevitably leads to an increase in the false negative rate.However, this is a minor drawback as the subsequent method options still have chances to get it correct.Consequently, employing active verification offers 2.3% gains to the overall XoT performance.Additionally, we explore the necessity of the iterative nature of XoT by removing the entire verification module.In this scenario, we only reason once with the most suitable method suggested by the planning module.The results are presented in Table 6.As our planning module mainly chooses the method from PoT or EoT, we here restrict the available methods to PoT and EoT only in XoT framework, which is denoted as 'XoT (only PE)'.By removing the verification module, the framework, denoted by 'XoT (w/o verification)' is no more capable of rechecking the answer thus cannot  perform iterative attempts to switch methods.This leads to a performance degradation of 4.9% and 2.9% on GSM8K and SVAMP respectively.</p>
<p>Comparison with Majority Voting</p>
<p>We additionally conduct experiments involving the majority vote of three distinct methods.The vote is based on three answers generated by three methods (one answer per method).As shown in Table 7, taking the majority vote of the three methods achieves 82.59 on average, while XoT achieves better performance at 84.63.Additionally, we observe that the majority vote fails on datasets containing questions that align exceptionally well with a specific method.Specifically, the majority vote achieves 79.73 on Algebra, while XoT achieves 89.94.The majority vote needs to execute all three methods to reach an answer, while XoT will stop when the answer passes the verification.We calculate the total token count as #total_token = #input_token + #output_token * 2, according to OpenAI's pricing policy 3 .As shown from the table, XoT is able to achieve higher performance with a lower budget, exhibiting a reduction of 16.7% in expenses.The token count includes all the incontext examples used and is averaged across the number of the total questions in 9 datasets.</p>
<p>Self-refinement</p>
<p>The design principle underlying XoT is its adaptable capability to switch methods, allowing for smooth integration with research aimed at improving individual methods.The line of iterative refinement methods enhances the model performance 3 https://openai.com/pricingby asking the model to rethink on its previous response, serving as a good alternative for the reasoning module in XoT.Specifically, before moving on to another method at each iteration, we allow the model to first make self refinement on its current approach, making the best use of current method.</p>
<p>Inspired by previous work (Madaan et al., 2023), after reasoning with one method for the first time, we require the model to analyze its response lineby-line and summarize several advice to mitigate the potential errors.Then, the model answers the question for a second time in the same method, with the summarized advice as a hint.After that, we verify the results produced by the second round and determine whether to switch to another method.</p>
<p>To achieve the iterative refinement in CoT, we follow Zheng et al. (2023) to progressively hint the model with the answers generated before.For PoT and EoT, we follow the released self-refinement prompts from Madaan et al. (2023).The results are shown in Table 8.We only allow the model to think twice using each prompting method.Though adding only one round of refinement yields marginal improvement within each single method, their collaboration contributes to a more significant improvement under XoT framework.</p>
<p>Conclusion</p>
<p>We propose XoT, an integrated problem solving framework that utilizes diverse reasoning thoughts to prompt LLMs.XoT integrates planning, reasoning and verification into a unified framework, enabling the model to explore multiple methods based on the active and passive verification of the solutions.We conduct extensive experiments on 10 math reasoning datasets to thoroughly evaluate the advantages of each module and showcase the efficacy of our proposed approach.Further results also show that the design ethos of XoT can generalize to logic reasoning domain.We consider its generalisation to more diverse tasks as a compelling avenue for future exploration.</p>
<p>A Further Analysis</p>
<p>A.1 Generalisation to logical domain</p>
<p>We analyze the generalisability of XoT framework to logical reasoning domain.One recent work (Pan et al., 2023) proposed LogicLM to solve logical reasoning questions using First Order Logic expressions and executed them in external symbolic reasoners.Following LogicLM, we design similar formal language expressions to represent First Order Logic and conduct experiments on FOLIO (Han et al., 2022), an expert-written, logically complex and diverse dataset for natural language reasoning.Our findings in Table 9 suggest that different methods in logical domain also show strong complementarity, achieving 77.45% under oracle setting.After involving the verification module, XoT performs at 62.75% on the validation set of FOLIO.These results underscore the applicability of XoT as a general problem solving framework.</p>
<p>A.2 Experiments on other models</p>
<p>We further assess the performance of XoT across various base models, such as Llama-2 series (Touvron et al., 2023b).The results are shown in Table 10, and we illustrate the performance scaling  10. curve in Figure 8.With less capable models, different prompting methods still demonstrate strong complementarity under oracle setting.Our observations suggest that smaller models tend to yield suboptimal results, likely due to the unbalanced performance across different reasoning approaches and the models' limited capability for active verification.This limitation inhibits the model's ability to timely switch between methods.However, as the model's size increases, XoT consistently shows its strength across the datasets.</p>
<p>A.3 Proportion of XoT</p>
<p>Figure 9 illustrates the proportion of different methods that XoT selects as the final answers.On GSM8K, 56.7% questions end up being solved with PoT, while 28.3% are tackled by EoT.The remaining 15% is left for CoT to solve.</p>
<p>B XoT with self refinement</p>
<p>We here offer the details of how we combine iterative self-refinement with XoT framework.As shown in Figure 10, the self refinement process can be integrated in the reasoning module, where the dashed line indicates rethinking using the same method.When the desired number of self refinement iterations is reached, the generated solutions will proceed to the verification module.Then the verification will determine whether to use the current solution or change to another method.</p>
<p>C Examples</p>
<p>In this section, we show the input and output examples of each module in XoT.Full prompts are available in public Github repository: https: //github.com/tengxiaoliu/XoT.For EoT, we use sympy4 library to solve the linear equations.</p>
<p>Figure 2 :
2
Figure 2: Complementarity of X-of-Thought methods on different datasets.The stacked bars indicate the best performance achieved by using one, two and three methods separately.Employing multiple methods under oracle setting can offer significant performance gains.</p>
<p>QuestionFigure 3 :
3
Figure 3: In particular cases where CoT and PoT fall short, EoT successfully solves the problem, which serves as a good complement.</p>
<p>Question##Figure 4 :
4
Figure4: Overview of XoT.Following the suggestion of the planning module, XoT first reasons with PoT.However, the generated answer fails in the verification module.In the second iteration, the selected method is EoT.The reasoning module successfully generates the solution that passes the verification.</p>
<p>Figure 5 :
5
Figure5: The correlation between oracle performance and final improvement.A higher oracle gain allows more room for XoT to improve.</p>
<p>PoT 3 Figure 6 :
36
Figure 6: Repeatedly exploiting the same method (PoT 3 ) results in limited complementarity compared to XoT with three methods.PoT 3 -d denotes we use different few-shot examples in three iterations.</p>
<p>Figure 7 :
7
Figure 7: Comparison of passive and active verifications.The blue and green matrices represent verifications for PoT and EoT respectively.</p>
<p>Figure 8 :
8
Figure 8: Performance scaling curve on different base models.The performance is averaged across the four datasets shown in Table10.</p>
<p>Figure 9 :
9
Figure 9: The proportion of different methods that XoT finally chooses as the answer on GSM8K.</p>
<p>Figure 10 :
10
Figure 10: Self refinement can be integrated in the XoT framework.The dashed block indicates the reasoning module with the inclusion self refinement.Within each self refinement process, the model repeatedly exploits the same method.</p>
<p>Table 1 :
1
Statistics of the datasets we used.# Steps denotes the average number of reasoning steps in the gold answers. indicates a rough estimate due to the inconsistent rationale formats.</p>
<p>Table 2 :
2
GSM8K SVAMP AQuA  Algebra GSM-hard AddSub SingleOP SingleEQ MultiArith Average Main experiment results across various math reasoning datasets.Under oracle setting, XoT switches the method if the generated answer does not match the gold answers. denotes we only use passive verification. represents the improvement over the best performing baseline.
CoT80.2 0.279.5 0.655.1 1.0 81.5 0.842.4 0.188.4 0.393.4 0.394.3 0.197.5 0.379.14PoT77.2 0.379.5 0.349.2 1.0 62.5 0.761.8 0.488.4 0.293.4 0.498.1 0.197.2 0.078.59EoT63.8 0.469.6 0.746.7 0.5 82.3 0.553.8 0.271.6 1.075.4 0.485.8 0.878.6 0.669.73XoT83.3 0.583.6 0.661.7 0.6 89.9 0.363.4 0.590.5 0.494.3 0.397.7 0.197.3 0.384.63oracle 92.5 0.292.7 0.377.0 1.4 95.5 0.574.3 0.493.9 0.397.5 0.099.1 0.199.3 0.091.31+3.1+4.1+6.6+7.6+1.6+2.1+0.9-0.4-0.2+5.49InterAlgebra Precalculus Geometry NumTheory Probability PreAlgebra Algebra OverallCoT17.8 0.420.3 0.424.4 0.432.2 1.030.4 0.656.6 0.449.7 0.4 35.77 0.4PoT14.4 0.115.5 0.18.8 0.331.2 0.719.6 0.236.5 0.238.2 0.1 25.79 0.1XoT25.1 0.126.0 0.325.3 0.748.1 0.636.1 0.462.0 0.257.3 0.4 42.81 0.0oracle28.1 0.231.2 0.127.6 0.450.5 0.139.0 0.768.0 0.464.1 0.4 47.35 0.2+7.3+5.7+0.9+15.9+5.7+5.4+7.6+7.04</p>
<p>Table 3 :
3
Experiment results on MATH dataset.We only employ two methods and passive verification on MATH.</p>
<p>3 -d uses differente examples randomly sampled from the training set.It is observed that under orcale setting, repetitive exploitation of a single method has limited complementarity of 84.08%, which is 8.64% less than XoT.As a result, the final performance reflects such a gap with PoT 3 of 78.39% and XoT of 82.71%.
Methods GSM8K SVAMP AQuA Algebra GSM-hard AddSub SingleOP SingleEQ MultiArith AveragePE77.7 0.380.7 0.256.7 1.0 81.7 0.563.4 0.389.6 0.393.8 0.398.0 0.295.0 0.281.85PC81.8 0.282.7 0.661.7 1.5 83.6 0.559.6 0.490.4 0.094.4 0.298.3 0.197.8 0.283.36EP80.9 0.480.8 0.458.0 0.6 83.8 0.964.6 0.388.4 0.494.1 0.596.7 0.097.8 0.282.80EC82.4 0.581.4 0.660.0 0.6 92.0 0.356.2 0.487.3 0.493.7 0.295.1 0.197.3 0.282.82EPC82.6 0.582.6 0.663.1 1.0 89.9 0.363.1 0.488.7 0.694.5 0.396.7 0.097.5 0.084.29PEC82.6 0.483.1 0.561.8 1.0 85.3 0.563.3 0.390.1 0.394.4 0.398.2 0.197.4 0.384.02XoT83.3 0.583.6 0.661.7 0.6 89.9 0.363.4 0.590.5 0.494.3 0.397.7 0.197.3 0.384.63</p>
<p>Table 5 :
5
Ablation results of different verification methods on GSM8K.Employing active verification significantly reduces false positive rate and results in a notable improvement in the overall XoT performance.</p>
<p>Table 6 :
6
Ablation results of excluding the entire verification module on GSM8K and SVAMP.XoT (only PE) is equipped with the verification module.The lack of this module compromises its ability for iterative methodswitching, resulting in diminished performance.
illustrates the performancecomparison when considering different verificationaspects. If we solely depend on passive verifica-tion, only 2.43% of the PoT results and 24.18% ofthe EoT results are deemed "incorrect" and subse-quently advanced to the next iteration. However,</p>
<p>GSM8K SVAMP AQuA Algebra GSM-hard AddSub SingleOP SingleEQ MultiArith Average #Tokens
XoT 83.3 0.583.6 0.6 61.7 0.6 89.9 0.363.4 0.590.5 0.494.3 0.397.7 0.197.3 0.384.634.5kVote 82.4 0.284.7 0.8 55.6 1.9 79.7 0.561.3 1.189.4 0.494.4 0.197.2 0.198.5 0.282.595.4k</p>
<p>Table 7 :
7
Comparison between XoT and Majority Voting.XoT outperforms the majority vote approach in a more efficient manner, yielding an average gain of 2.04 with a reduction of 16.7% in token count.#Tokens denotes the average number of tokens consumed for one case (including prompts, question and response).
ACC ACC + refineCoT 80.481.7PoT 76.976.9EoT 64.166.5XoT 82.784.5Table 8: Results of adding self-refinement within rea-soning module on GSM8K test set.</p>
<p>Table 9 :
9
XoT performance on logical reasoning task FOLIO validation set.Normal text reasoning and formal language FOL are complement to each other under oracle setting and XoT framework.
Method FOLIO ACCCoT58.82FOL42.65Oracle77.45XoT62.75
Code is publicly available at: https://github.com/ tengxiaoliu/XoT.
https://www.sympy.org/
AcknowledgementsWe would like to thank the anonymous reviewers for their valuable suggestions and feedback.This work was supported by the National Natural Science Foundation of China (No. 62236004 and No.  62022027).LimitationsWe acknowledge that our approach falls short on easier and more straightforward datasets where different methods exhibit limited complementary relations.Our current approach relies on the availability of diverse prompting methods for reasoning tasks.Further research is required to explore new problem solving methods for general reasoning tasks.Moreover, we observe that our method works better on larger base models.Although different reasoning methods do exhibit notable complementarity on smaller models, the inherent potential is not yet fully unleashed in current XoT design.Ethics StatementThe data used in our work all comes from public dataset, and our proposed method can be further integrated with other methods.Our work is conformant to ACL Ethics Policy.Input:You need to choose the best method for the given question.Each method has its own strength.The methods are described as follows:-Python Program: This method generates a Python program that can solve the given question.It takes in the question and possible context and produces a program.Normally, we consider using this method when the questions and contexts involve forward reasoning, such as arithmetic operations over multiple numbers, or when the questions involve complex logical operations, such as "if-else" statements.-System of linear equations: This method builds a math model and generates a system of linear equations that contains the answer as an unknown variable.Normally, we consider using this method when the questions and contexts involve an unknown variable that must be used to build an equation, especially when the question can be better modeled with abstract mathematical declarations, or when the unknown variable appears at the beginning of the questions and needs backward reasoning to solve.Below are some examples that choose the most appropriate method for the math word problems.{Examples} Question: Alyssa, Keely, and Kendall ordered 100 chicken nuggets from a fast-food restaurant.Keely and Kendall each ate twice as many as Alyssa.How many did Alyssa eat? Method:Output: System of linear equations  Program: nuggets_total = 100 nuggets_keely = 2 * nuggets_alyssa nuggets_kendall = 2 * nuggets_alyssa nuggets_alyssa = (nuggets_total -nuggets_keely -nuggets_kendall) / 5 ans = nuggets_alyssa Python Interpreter: NameError: name 'nuggets_alyssa' is not defined
Alec Radford, Ilya Sutskever, and Dario Amodei. Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems. Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish; NeurIPS2020. 2020. 2020. December 6-12, 2020Language models are few-shot learners</p>
<p>Program of thoughts prompting: Disentangling computation from reasoning for numerical reasoning tasks. Wenhu Chen, Xueguang Ma, Xinyi Wang, William W Cohen, 10.48550/arXiv.2211.12588CoRR, abs/2211.125882022</p>
<p>Teaching large language models to self-debug. Xinyun Chen, Maxwell Lin, Nathanael Schrli, Denny Zhou, 10.48550/arXiv.2304.05128CoRR, abs/2304.051282023</p>
<p>. Aakanksha Chowdhery, Sharan Narang, Jacob Devlin, Maarten Bosma, Gaurav Mishra, Adam Roberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, Parker Schuh, Kensen Shi, Sasha Tsvyashchenko, Joshua Maynez, Abhishek Rao, Parker Barnes, Yi Tay, Noam Shazeer, Emily Vinodkumar Prabhakaran, Nan Reif, Ben Du, Reiner Hutchinson, James Pope, Jacob Bradbury, Michael Austin, Guy Isard, Pengcheng Gur-Ari, Toju Yin, Anselm Duke, Sanjay Levskaya, Sunipa Ghemawat, Henryk Dev, Xavier Michalewski, Vedant Garcia, Kevin Misra, Liam Robinson, Denny Fedus, Daphne Zhou, David Ippolito, Hyeontaek Luan, Barret Lim, Alexander Zoph, Ryan Spiridonov, David Sepassi, Shivani Dohan, Mark Agrawal, Omernick, 10.48550/arXiv.2204.02311M. Dai, Thanumalayan Sankaranarayana Pillai, Marie Pellat, Aitor Lewkowycz, Erica Moreira, Rewon Child, Oleksandr Polozov, Katherine Lee, Zongwei Zhou, Xuezhi Wang, Brennan Saeta, Mark Diaz, Orhan Firat, Michele Catasta, Jason Wei, Kathy Meier-Hellstern, Douglas EckJeff Dean, Slav Petrovand Noah Fiedel. 2022. Palm: Scaling language modeling with pathways. CoRR, abs/2204.02311</p>
<p>Training verifiers to solve math word problems. Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, John Schulman, CoRR, abs/2110.141682021</p>
<p>Edward A Feigenbaum, Julian Feldman, Computers and thought. 1963</p>
<p>Complexity-based prompting for multi-step reasoning. Yao Fu, Hao Peng, Ashish Sabharwal, Peter Clark, Tushar Khot, 10.48550/arXiv.2210.00720CoRR, abs/2210.007202022</p>
<p>PAL: program-aided language models. Luyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, Graham Neubig, 10.48550/arXiv.2211.10435CoRR, abs/2211.104352022</p>
<p>FOLIO: natural language reasoning with first-order logic. Simeng Han, Hailey Schoelkopf, Yilun Zhao, Zhenting Qi, Martin Riddell, Luke Benson, Lucy Sun, Ekaterina Zubova, Yujie Qiao, Matthew Burtell, David Peng, Jonathan Fan, Yixin Liu, Brian Wong, Malcolm Sailor, Ansong Ni, Linyong Nan, Jungo Kasai, Tao Yu, Rui Zhang, Shafiq R Joty, Alexander R Fabbri, Wojciech Kryscinski, 10.48550/arXiv.2209.00840CoRR, abs/2209.008402022Xi Victoria Lin, Caiming Xiong, and Dragomir Radev</p>
<p>Solving math word problems by combining language models with symbolic solvers. Joy He-Yueya, Gabriel Poesia, Rose E Wang, Noah D Goodman, 10.48550/arXiv.2304.09102CoRR, abs/2304.091022023</p>
<p>Measuring mathematical problem solving with the MATH dataset. Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song, Jacob Steinhardt, Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks 1, NeurIPS Datasets and Benchmarks 2021. the Neural Information Processing Systems Track on Datasets and Benchmarks 1, NeurIPS Datasets and Benchmarks 20212021. December 2021</p>
<p>PLANNER: A language for proving theorems in robots. Carl Hewitt, Proceedings of the 1st International Joint Conference on Artificial Intelligence. the 1st International Joint Conference on Artificial IntelligenceWashington, DC, USAWilliam Kaufmann1969. May 7-9, 1969</p>
<p>Learning to solve arithmetic word problems with verb categorization. Mohammad Javad Hosseini, Hannaneh Hajishirzi, Oren Etzioni, Nate Kushman, 10.3115/v1/d14-1058Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing. the 2014 Conference on Empirical Methods in Natural Language ProcessingDoha, QatarACL2014. 2014. October 25-29, 2014A meeting of SIGDAT, a Special Interest Group of the ACL</p>
<p>Mathprompter: Mathematical reasoning using large language models. Shima Imani, Liang Du, Harsh Shrivastava, 10.48550/arXiv.2303.05398CoRR, abs/2303.053982023</p>
<p>Large language models are zero-shot reasoners. Takeshi Kojima, Shane Shixiang, Machel Gu, Yutaka Reid, Yusuke Matsuo, Iwasawa, NeurIPS. 2022</p>
<p>Parsing algebraic word problems into equations. Rik Koncel-Kedziorski, Hannaneh Hajishirzi, Ashish Sabharwal, Oren Etzioni, Siena Dumas, Ang , 10.1162/tacl_a_00160Trans. Assoc. Comput. Linguistics. 32015</p>
<p>MAWPS: A math word problem repository. Rik Koncel-Kedziorski, Subhro Roy, Aida Amini, Nate Kushman, Hannaneh Hajishirzi, 10.18653/v1/n16-1136The 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. San Diego California, USAThe Association for Computational Linguistics2016. June 12-17, 2016NAACL HLT 2016</p>
<p>Coderl: Mastering code generation through pretrained models and deep reinforcement learning. Hung Le, Yue Wang, Akhilesh Deepak Gotmare, Silvio Savarese, Steven Chu, -Hong Hoi, NeurIPS. 2022</p>
<p>Solving quantitative reasoning problems with language models. Aitor Lewkowycz, Anders Andreassen, David Dohan, Ethan Dyer, Henryk Michalewski, V Vinay, Ambrose Ramasesh, Slone, Cem Anil, Imanol Schlag. Theo Gutman-Solo, Yuhuai Wu, Behnam Neyshabur, Guy Gur-Ari, and Vedant Misra2022In NeurIPS</p>
<p>On the advance of making language models better reasoners. Yifei Li, Zeqi Lin, Shizhuo Zhang, Qiang Fu, Bei Chen, Jian-Guang Lou, Weizhu Chen, 10.48550/arXiv.2206.02336CoRR, abs/2206.023362022</p>
<p>Program induction by rationale generation: Learning to solve and explain algebraic word problems. Wang Ling, Dani Yogatama, Chris Dyer, Phil Blunsom, 10.18653/v1/P17-1015Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics. Long Papers. the 55th Annual Meeting of the Association for Computational LinguisticsVancouver, CanadaAssociation for Computational Linguistics2017. 2017. July 30 -August 41</p>
<p>Pan Lu, Baolin Peng, Hao Cheng, Michel Galley, Kai-Wei Chang, Ying Nian Wu, Song-Chun Zhu, Jianfeng Gao, 10.48550/arXiv.2304.09842CoRR, abs/2304.09842Chameleon: Plug-and-play compositional reasoning with large language models. 2023</p>
<p>A survey of deep learning for mathematical reasoning. Pan Lu, Liang Qiu, Wenhao Yu, Sean Welleck, Kai-Wei Chang, 10.48550/arXiv.2212.10535CoRR, abs/2212.105352022</p>
<p>Self-refine: Iterative refinement with self-feedback. Aman Madaan, Niket Tandon, Prakhar Gupta, Skyler Hallinan, Luyu Gao, Sarah Wiegreffe, Uri Alon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, Sean Welleck, Prasad Bodhisattwa, Shashank Majumder, Amir Gupta, Peter Yazdanbakhsh, Clark, 10.48550/arXiv.2303.17651CoRR, abs/2303.176512023</p>
<p>10.48550/arXiv.2303.08774CoRR, abs/2303.08774GPT-4 technical report. 2023OpenAI</p>
<p>Logic-lm: Empowering large language models with symbolic solvers for faithful logical reasoning. Liangming Pan, Alon Albalak, Xinyi Wang, William Wang, Findings of the Association for Computational Linguistics: EMNLP 2023. SingaporeAssociation for Computational Linguistics2023. December 6-10, 2023</p>
<p>Are NLP models really able to solve simple math word problems?. Arkil Patel, Satwik Bhattamishra, Navin Goyal, 10.18653/v1/2021.naacl-main.168Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2021. the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2021Association for Computational Linguistics2021. June 6-11, 2021</p>
<p>Debjit Paul, Mete Ismayilzada, Maxime Peyrard, Beatriz Borges, Antoine Bosselut, Robert West, Boi Faltings, 10.48550/arXiv.2304.01904CoRR, abs/2304.01904REFINER: reasoning feedback on intermediate representations. 2023</p>
<p>The art of SOCRATIC QUESTIONING: zero-shot multimodal reasoning with recursive thinking and selfquestioning. Jingyuan Qi, Zhiyang Xu, Ying Shen, Minqian Liu, Di Jin, Qifan Wang, Lifu Huang, 10.48550/arXiv.2305.14999CoRR, abs/2305.149992023</p>
<p>Reasoning with language model prompting: A survey. Shuofei Qiao, Yixin Ou, Ningyu Zhang, Xiang Chen, Yunzhi Yao, Shumin Deng, Chuanqi Tan, Fei Huang, Huajun Chen, 10.48550/arXiv.2212.09597CoRR, abs/2212.095972022</p>
<p>Solving general arithmetic word problems. Subhro Roy, Dan Roth, 10.18653/v1/d15-1202Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing. the 2015 Conference on Empirical Methods in Natural Language ProcessingLisbon, PortugalThe Association for Computational Linguistics2015. 2015. September 17-21, 2015</p>
<p>Reasoning about quantities in natural language. Subhro Roy, Tim Vieira, Dan Roth, 10.1162/tacl_a_00118Trans. Assoc. Comput. Linguistics. 32015</p>
<p>Reflexion: an autonomous agent with dynamic memory and self-reflection. Noah Shinn, Beck Labash, Ashwin Gopinath, 10.48550/arXiv.2303.11366CoRR, abs/2303.113662023</p>
<p>R Bas, Pei Steunebrink, Ben Wang, Goertzel, 10.1007/978-3-319-41649-6Artificial General Intelligence -9th International Conference, AGI 2016. Lecture Notes in Computer Science. New York, NY, USASpringer2016. July 16-19, 20169782</p>
<p>Edouard Grave, and Guillaume Lample. 2023a. Llama: Open and efficient foundation language models. Thibaut Hugo Touvron, Gautier Lavril, Xavier Izacard, Marie-Anne Martinet, Timothe Lachaux, Baptiste Lacroix, Naman Rozire, Eric Goyal, Faisal Hambro, Aurlien Azhar, Armand Rodriguez, Joulin, 10.48550/arXiv.2302.13971CoRR, abs/2302.13971</p>
<p>Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, Dan Bikel, Lukas Blecher, Cristian Canton-Ferrer, Moya Chen, Guillem Cucurull, David Esiobu, Jude Fernandes, Jeremy Fu, Wenyin Fu, Brian Fuller, Cynthia Gao, Vedanuj Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou, Hakan Inan, Marcin Kardas, Viktor Kerkez, Madian Khabsa, Isabel Kloumann, Artem Korenev, Punit Singh Koura, Marie-Anne Lachaux, Thibaut Lavril, Jenya Lee, Diana Liskovich, Yinghai Lu, Yuning Mao, Xavier Martinet, Todor Mihaylov ; Zheng Yan, Iliyan Zarov, Yuchen Zhang, 10.48550/arXiv.2307.09288Pushkar Mishra, Igor Molybog. Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan Saladi, Alan Schelten, Ruan Silva, Eric Michael Smith, Ranjan Subramanian, Xiaoqing , Ellen Tan, Binh Tang, Ross Taylor, Adina Williams, Jian Xiang Kuan, Puxin Xu, Angela Fan, Melanie Kambadur, Sharan Narang; Robert Stojnic, Sergey EdunovAurlien Rodriguezand Thomas Scialom. 2023b. Llama 2: Open foundation and fine-tuned chat models. CoRR, abs/2307.09288</p>
<p>Learn from mistakes through cooperative interaction with study assistant. Danqing Wang, Lei Li, 10.48550/arXiv.2305.13829CoRR, abs/2305.138292023</p>
<p>Selfconsistency improves chain of thought reasoning in language models. Xuezhi Wang, Jason Wei, Dale Schuurmans, Quoc V Le, Ed H Chi, Denny Zhou, 10.48550/arXiv.2203.11171CoRR, abs/2203.111712022</p>
<p>Deep neural solver for math word problems. Yan Wang, Xiaojiang Liu, Shuming Shi, 10.18653/v1/d17-1088Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing. the 2017 Conference on Empirical Methods in Natural Language ProcessingCopenhagen, DenmarkAssociation for Computational Linguistics2017. 2017. September 9-11, 2017</p>
<p>Chain-of-thought prompting elicits reasoning in large language models. Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed H Chi, V Quoc, Denny Le, Zhou, 2022In NeurIPS</p>
<p>Tree of thoughts: Deliberate problem solving with large language models. Shunyu Yao, Dian Yu, Jeffrey Zhao, Izhak Shafran, Thomas L Griffiths, Yuan Cao, Karthik Narasimhan, 10.48550/arXiv.2305.10601CoRR, abs/2305.106012023</p>
<p>Automatic model selection with large language models for reasoning. Xu Zhao, Yuxi Xie, Kenji Kawaguchi, Junxian He, Qizhe Xie, 10.48550/arXiv.2305.14333CoRR, abs/2305.143332023</p>
<p>Progressive-hint prompting improves reasoning in large language models. Chuanyang Zheng, Zhengying Liu, Enze Xie, Zhenguo Li, Yu Li, 10.48550/arXiv.2304.09797CoRR, abs/2304.097972023</p>
<p>Least-to-most prompting enables complex reasoning in large language models. Denny Zhou, Nathanael Schrli, Le Hou, Jason Wei, Nathan Scales, Xuezhi Wang, Dale Schuurmans, Olivier Bousquet, Quoc Le, Ed H Chi, 10.48550/arXiv.2205.10625CoRR, abs/2205.106252022</p>            </div>
        </div>

    </div>
</body>
</html>