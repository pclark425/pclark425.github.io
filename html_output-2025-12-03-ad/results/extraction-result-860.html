<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-860 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-860</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-860</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-21.html">extraction-schema-21</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of agents that use external tools for planning in partially observable text environments, including how they maintain belief states, incorporate tool outputs, and perform navigation or path-finding tasks.</div>
                <p><strong>Paper ID:</strong> paper-3ee01ec27e4e66e089b72a9989724be611c2ad90</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/3ee01ec27e4e66e089b72a9989724be611c2ad90" target="_blank">Neural Map: Structured Memory for Deep Reinforcement Learning</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Learning Representations</p>
                <p><strong>Paper TL;DR:</strong> This paper develops a memory system with an adaptable write operator that is customized to the sorts of 3D environments that DRL agents typically interact with and demonstrates empirically that the Neural Map surpasses previous DRL memories on a set of challenging 2D and 3D maze environments.</p>
                <p><strong>Paper Abstract:</strong> A critical component to enabling intelligent reasoning in partially observable environments is memory. Despite this importance, Deep Reinforcement Learning (DRL) agents have so far used relatively simple memory architectures, with the main methods to overcome partial observability being either a temporal convolution over the past k frames or an LSTM layer. More recent work (Oh et al., 2016) has went beyond these architectures by using memory networks which can allow more sophisticated addressing schemes over the past k frames. But even these architectures are unsatisfactory due to the reason that they are limited to only remembering information from the last k frames. In this paper, we develop a memory system with an adaptable write operator that is customized to the sorts of 3D environments that DRL agents typically interact with. This architecture, called the Neural Map, uses a spatially structured 2D memory image to learn to store arbitrary information about the environment over long time lags. We demonstrate empirically that the Neural Map surpasses previous DRL memories on a set of challenging 2D and 3D maze environments and show that it is capable of generalizing to environments that were not seen during training.</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-860",
    "paper_id": "paper-3ee01ec27e4e66e089b72a9989724be611c2ad90",
    "extraction_schema_id": "extraction-schema-21",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00461625,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>NEURAL MAP: STRUCTURED MEMORY FOR DEEP REINFORCEMENT LEARNING</h1>
<p>Emilio Parisotto \&amp; Ruslan Salakhutdinov<br>Department of Machine Learning<br>Carnegie Mellon University<br>Pittsburgh, PA 15213, USA<br>{eparisot, rsalakhu}@cs.cmu.edu</p>
<h4>Abstract</h4>
<p>A critical component to enabling intelligent reasoning in partially observable environments is memory. Despite this importance, Deep Reinforcement Learning (DRL) agents have so far used relatively simple memory architectures, with the main methods to overcome partial observability being either a temporal convolution over the past $k$ frames or an LSTM layer. More recent work (Oh et al., 2016) has went beyond these architectures by using memory networks which can allow more sophisticated addressing schemes over the past $k$ frames. But even these architectures are unsatisfactory due to the reason that they are limited to only remembering information from the last $k$ frames. In this paper, we develop a memory system with an adaptable write operator that is customized to the sorts of 3D environments that DRL agents typically interact with. This architecture, called the Neural Map, uses a spatially structured 2D memory image to learn to store arbitrary information about the environment over long time lags. We demonstrate empirically that the Neural Map surpasses previous DRL memories on a set of challenging 2D and 3D maze environments and show that it is capable of generalizing to environments that were not seen during training.</p>
<h2>1 INTRODUCTION</h2>
<p>Memory is a crucial aspect of an intelligent agent's ability to plan and reason in partially observable environments. Without memory, agents must act reflexively according only to their immediate percepts and cannot execute plans that occur over an extended time interval. Recently, Deep Reinforcement Learning agents have been capable of solving many challenging tasks such as Atari Arcade Games (Mnih et al., 2015), robot control (Levine et al., 2016) and 3D games such as Doom (Lample \&amp; Chaplot, 2016), but successful behaviours in these tasks have often only been based on a relatively short-term temporal context or even just a single frame. On the other hand, many tasks require long-term planning, such as a robot gathering objects or an agent searching a level to find a key in a role-playing game.</p>
<p>Neural networks that utilized external memories have recently had an explosion in variety, which can be distinguished along two main axis: memories with write operators and those without. Writeless external memory systems, often referred to as "Memory Networks" (Sukhbaatar et al., 2015; Oh et al., 2016), typically fix which memories are stored. For example, at each time step, the memory network would store the past M states seen in an environment. What is learnt by the network is therefore how to access or read from this fixed memory pool, rather than what contents to store within it.</p>
<p>The memory network approach has been successful in language modeling, question answering (Sukhbaatar et al., 2015) and was shown to be a sucessful memory for deep reinforcement learning agents in complex 3D environments (Oh et al., 2016). By side-steping the difficulty involved in learning what information is salient enough to store in memory, the memory network introduces two main disadvantages. The first disadvantage is that a potentially significant amount of redundant information could be stored. The second disadvantage is that a domain expert must choose what to store in the memory, e.g. for the DRL agent, the expert must set M to a value that is larger than the time horizon of the currently considered task.</p>
<p>On the other hand, external neural memories having write operations are potentially far more efficient, since they can learn to store salient information for unbounded time steps and ignore any other useless information, without explicitly needing any a priori knowledge on what to store. One prominent research direction within write-based architectures has been neural memories based on the types of memory structures that are found in computers, such as tapes (Graves et al., 2014), RAM (Kurach et al., 2016), and GPUs (Kaiser \&amp; Sutskever, 2016). In contrast to typical recurrent neural networks, these neural computer emulators have far more structured memories which follow many of the same design paradigms that digital computers have traditionally utilized. One such model, the Differentiable Neural Computer (DNC) (Graves et al., 2016) and its predecessor the Neural Turing Machine (NTM) (Graves et al., 2014), structure the architecture to explicitly separate memory from computation. The DNC has a recurrent neural controller that can access an external memory resource by executing differentiable read and write operations. This allows the DNC to act and memorize in a structured manner resembling a computer processor, where read and write operations are sequential and data is store distinctly from computation. The DNC has been used sucessfully to solve complicated algorithmic tasks, such as finding shortest paths in a graph or querying a database for entity relations.</p>
<p>Building off these previous external memories, we introduce a new architecture called the Neural Map, a structured memory designed specifically for reinforcement learning agents in 3D environments. The Neural Map architecture overcomes some of the shortcomings of the previously mentioned neural memories. First, it uses an adaptable write operation and so its size and computational cost does not grow with the time horizon of the environment as it does with memory networks. Second, we impose a particular inductive bias on the write operation so that it is 1) well suited to 3D environments where navigation is a core component of sucessful behaviours, and 2) uses a sparse write operation that prevents frequent overwriting of memory locations that can occur with NTMs and DNCs. To accomplish this, we structure a DNC-style external memory in the form of a 2-dimensional map, where each position in the map is a distinct memory.</p>
<p>To demonstrate the effectiveness of the neural map, we run it in on variety of 2D partially-observable maze-based environments and test it against LSTM and memory network policies. Finally, to establish its scalability, we run a Neural Map agent on a challenging 3D maze environment based on the video game Doom.</p>
<h1>2 BACKGROUND</h1>
<p>A Markov Decision Process (MDP) is defined as a tuple $(\mathcal{S}, \mathcal{A}, \mathcal{T}, \gamma, \mathcal{R})$ where $\mathcal{S}$ is a finite set of states, $\mathcal{A}$ is a finite set of actions, $\mathcal{T}\left(s^{\prime} \mid s, a\right)$ is the transition probability of arriving in state $s^{\prime}$ when executing action $a$ in initial state $s, \gamma$ is a discount factor, and $\mathcal{R}\left(s, a, s^{\prime}\right)$ is the reward function of executing action $a$ in state $s$ and ending up at state $s^{\prime}$. We define a policy $\pi(\cdot \mid s)$ as a mapping from a state $s$ to a distribution over actions, where $\pi\left(a_{i} \mid s\right)$ denotes the probability of action $a_{i}$ given that we are in state $s$. The value of a policy $V^{\pi}(s)$ is the expected discounted cumulative reward when starting from state $s$ and sampling actions according to $\pi$, i.e.:</p>
<p>$$
V^{\pi}(s)=\mathbb{E}<em t="0">{\pi}\left[\sum</em>=s\right]
$$}^{\infty} \gamma^{t} R_{t} \mid s_{0</p>
<p>An optimal value function, denoted $V^{<em>}(s)$, is the maximum value we can get from state $s$ according to any policy, i.e. $V^{</em>}(s)=\max _{\pi} V^{\pi}(s)$. An optimal policy $\pi^{<em>}$ is defined as a policy which achieves optimal value at each state, i.e. $V^{\pi^{</em>}}(s)=V^{*}(s)$. An optimal policy is guaranteed to exist (Sutton $\&amp;$ Barto, 1998).</p>
<p>The REINFORCE algorithm (Williams, 1992) iteratively updates a given policy $\pi$ in the direction of the optimal policy. This update direction is defined by $\nabla_{\pi} \log \pi\left(a_{t} \mid s_{t}\right) G_{t}$ with $G_{t}=\sum_{k=0}^{\infty} \gamma^{k} R_{t+k}$ being the future cumulated reward for a particular episode rollout. The variance of this update is typically high but can be reduced by using a "baseline" $b_{t}\left(s_{t}\right)$, which is a function of the current state. Therefore the baseline-augmented update equation is $\nabla_{\pi} \log \pi\left(a_{t} \mid s_{t}\right)\left(G_{t}-b_{t}\left(s_{t}\right)\right)$. The typically used baseline is the value function, $b_{t}\left(s_{t}\right)=V^{\pi}\left(s_{t}\right)$. This combination of REINFORCE with value function baseline is commonly termed the "Actor-Critic" algorithm.</p>
<p>In this paper, we utilize a modified Asynchronous Advantage Actor-Critic (A3C) (Mnih et al., 2016), which can be seen as a specialization of the actor-critic framework when using deep networks to</p>
<p>parameterize the policy and value function. The policy is a function of the state, parameterized as a deep neural network: $\pi(a \mid s)=f_{\theta}(s, a)$, where f is a deep neural network with parameter vector $\theta$.</p>
<p>We make a modification to the A3C framework where instead of executing and updating a policy asynchronously in several concurrent environments and then occasionally synchronizing network parameters after several updates, we execute and update the policy synchronously at each time step across several concurrent environments, meaning that the network parameters never require synchronization. Other than this modification, the algorithm is identical to the one used in A3C, including the methods used to update the value and policy networks (refer to (Mnih et al., 2016) for details).</p>
<h1>3 NeURAL MAP</h1>
<p>In this section, we will describe the details of the neural map. We assume we want our agent to act within some 2- or 3-dimensional environment. The neural map is the agent's internal memory storage that can be read from and written to during interaction with its environment, but where the write operator is selectively limited to affect only the part of the neural map that represents the area where the agent is currently located. For this paper, we assume for simplicity that we are dealing with a 2-dimensional map. This can easily be extended to 3-dimensional or even higher-dimensional maps (i.e. a 4D map with a 3D sub-map for each cardinal direction the agent can face).</p>
<p>Let the agent's position be $(x, y)$ with $x \in \mathbb{R}$ and $y \in \mathbb{R}$ and let the neural map $M$ be a $C \times H \times W$ feature block, where $C$ is the feature dimension, $H$ is the vertical extent of the map and $W$ is the horizontal extent. Assume there exists some coordinate normalization function $\psi(x, y)$ such that every unique $(x, y)$ can be mapped into $\left(x^{\prime}, y^{\prime}\right)$, where $x^{\prime} \in{0, \ldots, W}$ and $y^{\prime} \in{0, \ldots, H}$. For ease of notation, suppose in the sequel that all coordinates have been normalized by $\psi$ into neural map space.</p>
<p>Let $s_{t}$ be the current state embedding, $M_{t}$ be the current neural map, and $\left(x_{t}, y_{t}\right)$ be the current position of the agent within the neural map. The Neural Map is defined by the following set of equations:</p>
<p>$$
\begin{aligned}
r_{t} &amp; =\operatorname{read}\left(M_{t}\right) \
c_{t} &amp; =\operatorname{context}\left(M_{t}, s_{t}, r_{t}\right) \
w_{t+1}^{\left(x_{t}, y_{t}\right)} &amp; =\operatorname{write}\left(s_{t}, r_{t}, c_{t}, M_{t}^{\left(x_{t}, y_{t}\right)}\right) \
M_{t+1} &amp; =\operatorname{update}\left(M_{t}, w_{t+1}^{\left(x_{t}, y_{t}\right)}\right) \
o_{t} &amp; =\left[r_{t}, c_{t}, w_{t+1}^{\left(x_{t}, y_{t}\right)}\right] \
\pi_{t}(a \mid s) &amp; =\operatorname{Softmax}\left(f\left(o_{t}\right)\right)
\end{aligned}
$$</p>
<p>where $w_{t}^{\left(x_{t}, y_{t}\right)}$ represents the feature at position $\left(x_{t}, y_{t}\right)$ at time $t,\left[x_{1}, \ldots, x_{k}\right]$ represents a concatenation operation, and $o_{t}$ is the output of the neural map at time $t$ which is then processed by another deep network $f$ to get the policy outputs $\pi_{t}(a \mid s)$. We will now separately describe each of the above operations in more detail.</p>
<h3>3.1 Global Read Operation</h3>
<p>The read operation passes the current neural map $M_{t}$ through a deep convolutional network and produces a $C$-dimensional feature vector $r_{t}$. The global read vector $r_{t}$ summarizes information about the entire map.</p>
<h3>3.2 CONTEXT REAd OPERATION</h3>
<p>The context operation performs context-based addressing to check whether certain features are stored in the map. It takes as input the current state embedding $s_{t}$ and the current global read vector $r_{t}$ and first produces a query vector $q_{t}$. The inner product of the query vector and each feature $M_{t}^{(x, y)}$ in the neural map is then taken to get scores $a_{t}^{(x, y)}$ at all positions $(x, y)$. The scores are then normalized to get a probability distribution $\alpha_{t}^{(x, y)}$ over every position in the map, also known as "soft attention" (Bahdanau et al., 2015). This probability distribution is used to compute a weighted</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: A visualization of two time steps of the neural map.
average $c_{t}$ over all features $M_{t}^{(x, y)}$. To summarize:</p>
<p>$$
\begin{aligned}
q_{t} &amp; =W\left[s_{t}, r_{t}\right] \
a_{t}^{(x, y)} &amp; =q_{t} \cdot M_{t}^{(x, y)} \
\alpha_{t}^{(x, y)} &amp; =\frac{e^{a_{t}^{(x, y)}}}{\sum_{(w, z)} e^{a_{t}^{(w, z)}}} \
c_{t} &amp; =\sum_{(x, y)} \alpha_{t}^{(x, y)} M_{t}^{(x, y)}
\end{aligned}
$$</p>
<p>where $W$ is a weight matrix. The context read operation allows the neural map to operate as an associative memory: the agent provides some possibly incomplete memory (the query vector $q_{t}$ ) and the operation will return the completed memory that most closely matches $q_{t}$. So, for example, the agent can query whether it has seen something similar to a particular landmark that is currently within its view.</p>
<h1>3.3 LOCAL Write OPERATION</h1>
<p>Given the agent's current position $\left(x_{t}, y_{t}\right)$ at time $t$, the write operation takes as input the current state embedding $s_{t}$, the global read output $r_{t}$, the context read vector $c_{t}$ and the current feature at position $\left(x_{t}, y_{t}\right)$ in the neural map $M_{t}^{\left(x_{t}, y_{t}\right)}$ and produces, using a deep neural network $f$, a new C-dimensional vector $w_{t+1}^{\left(x_{t}, y_{t}\right)}$. This vector functions as the new local write candidate vector at the current position $\left(x_{t}, y_{t}\right)$ :</p>
<p>$$
w_{t+1}^{\left(x_{t}, y_{t}\right)}=f\left(\left[s_{t}, r_{t}, c_{t}, M_{t}^{\left(x_{t}, y_{t}\right)}\right]\right)
$$</p>
<h3>3.4 MAP Update OPERATION</h3>
<p>The update operation creates the neural map for the next time step. The new neural map $M_{t+1}$ is equal to the old neural map $M_{t}$, except at the current agent position $\left(x_{t}, y_{t}\right)$, where the current write candidate vector $w_{t+1}^{\left(x_{t}, y_{t}\right)}$ is stored:</p>
<p>$$
M_{t+1}^{(a, b)}= \begin{cases}w_{t+1}^{\left(x_{t}, y_{t}\right)}, &amp; \text { for }(a, b)=\left(x_{t}, y_{t}\right) \ M_{t}^{(a, b)}, &amp; \text { for }(a, b) \neq\left(x_{t}, y_{t}\right)\end{cases}
$$</p>
<h3>3.5 OPERATION VARIANTS</h3>
<p>There are several modifications that can be made to the standard operations as defined above. Below we discuss some variants.</p>
<h1>3.5.1 Localized Read Operation</h1>
<p>Instead of passing the entire neural map through a deep convolutional network, a spatial subset of the map can be passed instead. For example, a Spatial Transformer Network (Jaderberg et al., 2015) can be used to attentively subsample the neural map at particular locations and scales. This can be helpful when the environment requires a large high-resolution map which can be computationally expensive to process in its entirety at each time step.</p>
<h3>3.5.2 Key-Value Context Read Operation</h3>
<p>We can impose a stronger bias on the context addressing operation by splitting each feature of the neural map into two parts $M_{t}^{(x, y)}=\left[k_{t}^{(x, y)}, v_{t}^{(x, y)}\right]$, where $k_{t}^{(x, y)}$ is the $(C / 2)$-dimensional "key" feature and $v_{t}^{(x, y)}$ is the $(C / 2)$-dimensional "value" feature Miller et al. (2016). The key features are matched against the query vector (which is now a $(C / 2)$-dimensional vector) to get the probability distribution $\alpha_{t}^{(x, y)}$, and the weighted average is taken over the value features. Concretely:</p>
<p>$$
\begin{aligned}
q_{t} &amp; =W\left[s_{t}, r_{t}\right] \
M_{t}^{(x, y)} &amp; =\left[k_{t}^{(x, y)}, v_{t}^{(x, y)}\right] \
a_{t}^{(x, y)} &amp; =q_{t} \cdot k_{t}^{(x, y)} \
\alpha_{t}^{(x, y)} &amp; =\frac{e^{a_{t}^{(x, y)}}}{\sum_{(w, z)} e^{a_{t}^{(w, z)}}} \
c_{t} &amp; =\sum_{(x, y)} \alpha_{t}^{(x, y)} v_{t}^{(x, y)}
\end{aligned}
$$</p>
<p>Having distinct key-value features allows the network to more explicitly separate the addressing feature space from the content feature space.</p>
<h3>3.5.3 GRU-based Local Write Operation</h3>
<p>As previously defined, the write operation simply replaces the vector at the agent's current position with a new feature produced by a deep network. Instead of this hard rewrite of the current position's feature vector, we can use a gated write operation based on the recurrent update equations of the Gated Recurrent Unit (GRU) (Chung et al., 2014). Gated write operations have a long history in unstructured recurrent networks and they have shown a superior ability to maintain information over long time lags versus ungated networks. The GRU-based write operation is defined as:</p>
<p>$$
\begin{aligned}
r_{t+1}^{\left(x_{t}, y_{t}\right)} &amp; =\sigma\left(W_{r}\left[s_{t}, r_{t}, c_{t}, M_{t}^{\left(x_{t}, y_{t}\right)}\right]\right) \
\tilde{w}<em t="t">{t+1}^{\left(x</em>\right)\right) \
z_{t+1}^{\left(x_{t}, y_{t}\right)} &amp; =\sigma\left(W_{z}\left[s_{t}, r_{t}, c_{t}, M_{t}^{\left(x_{t}, y_{t}\right)}\right]\right) \
w_{t+1}^{\left(x_{t}, y_{t}\right)} &amp; =\left(1-z_{t+1}^{\left(x_{t}, y_{t}\right)}\right) \odot M_{t}^{\left(x_{t}, y_{t}\right)}+z_{t+1}^{\left(x_{t}, y_{t}\right)} \odot \tilde{w}}, y_{t}\right)} &amp; =\tanh \left(W_{\tilde{h}}\left[s_{t}, r_{t}, c_{t}\right]+U_{\tilde{h}}\left(r_{t+1}^{\left(x_{t}, y_{t}\right)} \odot M_{t}^{\left(x_{t}, y_{t}\right)<em t="t">{t+1}^{\left(x</em>
\end{aligned}
$$}, y_{t}\right)</p>
<p>where $x \odot y$ is the Hadamard product between vectors $x$ and $y, \sigma(\cdot)$ is the sigmoid activation function and $W_{<em>}$ and $U_{</em>}$ are weight matrices. Using GRU terminology, $r_{t+1}^{\left(x_{t}, y_{t}\right)}$ is the reset gate, $\tilde{w}<em t="t">{t+1}^{\left(x</em>$ is the update gate. By making use of the reset and update gates, the GRU-based update can modulate how much the new write vector should differ from the currently stored feature.}, y_{t}\right)}$ is the candidate activation and $z_{t+1}^{\left(x_{t}, y_{t}\right)</p>
<h2>4 EXPERIMENTS</h2>
<p>To demonstrate the effectiveness of the Neural Map, we run it on 2D and 3D maze-based environments where memory is crucial to optimal behaviour. We compare to previous memory-based DRL agents, namely a simple LSTM-based agent which consists of a single pre-output LSTM layer as well as MemNN (Oh et al., 2016) agents. Of the agents presented in Oh et al. (2016), we use the MQN version, i.e. the stand-alone memory network without an LSTM layer.</p>
<table>
<thead>
<tr>
<th>Agent</th>
<th>Goal-Search</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Train</td>
<td></td>
<td></td>
<td>Test</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>7-11</td>
<td>13-15</td>
<td>Total</td>
<td>7-11</td>
<td>13-15</td>
<td>Total</td>
</tr>
<tr>
<td>Random</td>
<td>41.9\%</td>
<td>25.7\%</td>
<td>38.1\%</td>
<td>46.0\%</td>
<td>29.6\%</td>
<td>38.8\%</td>
</tr>
<tr>
<td>LSTM</td>
<td>60.6\%</td>
<td>41.8\%</td>
<td>59.3\%</td>
<td>65.5\%</td>
<td>47.5\%</td>
<td>57.4\%</td>
</tr>
<tr>
<td>MemNN-32</td>
<td>85.1\%</td>
<td>58.2\%</td>
<td>77.8\%</td>
<td>92.6\%</td>
<td>69.7\%</td>
<td>83.4\%</td>
</tr>
<tr>
<td>Neural Map</td>
<td>92.4\%</td>
<td>80.5\%</td>
<td>89.2\%</td>
<td>93.5\%</td>
<td>87.9\%</td>
<td>91.7\%</td>
</tr>
<tr>
<td>Neural Map (GRU)</td>
<td>97.0\%</td>
<td>89.2\%</td>
<td>94.9\%</td>
<td>97.7\%</td>
<td>94.0\%</td>
<td>96.4\%</td>
</tr>
</tbody>
</table>
<p>Table 1: Results of several different agent architectures on the "Goal-Search" environment. The "train" columns represents the number of mazes solved when sampling from the same distribution as used during training. The "test" columns represents the number of mazes solved when run on a set of held-out maze samples which are guaranteed not to have been sampled during training.
<img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Images showing the 2D maze environments. The left side (Fig. 2a) represents the fully observable maze while the right side (Fig. 2b) represents the agent observations. The agent is represented by the yellow pixel with its orientation indicated by the black arrow within the yellow block. The starting position is always the topmost position of the maze. The red bounding box represents the area of the maze that is subsampled for the agent observation. In "Goal-Search", the goal of the agent is to find a certain color block (either red or teal), where the correct color is provided by an indicator (either green or blue). This indicator has a fixed position near the start position of the agent.</p>
<h1>4.1 2D GOAL-SEARCH ENVIRONMENT</h1>
<p>The "Goal-Search" environment is adapted from Oh et al. (2016). Here the agent starts in a fixed starting position within some randomly generated maze with two randomly positioned goal states. It then observes an indicator at a fixed position near the starting state (i.e. the green tile at the top of the maze in Fig. 2a). This indicator will tell the agent which of the two goals it needs to go to (blue indicator $\rightarrow$ teal goal, green indicator $\rightarrow$ red goal). If the agent goes to the correct goal, it gains a positive reward while if it goes to the incorrect goal it gains a negative reward. Therefore the agent needs to remember the indicator as it searches for the correct goal state.</p>
<p>The mazes during training are generated using a random generator. A held-out set of 1000 random mazes is kept for testing. This test set therefore represents maze geometries that have never been seen during training, and measure the agent's ability to generalize to new environments. The mazes sampled during training range from a size of $5 \times 5$ to $15 \times 15$. In the maze generation process, we first sample maze sizes uniformly and then generate the maze. Sampling different maze sizes from easy to difficult during training is similar to a style of curriculum learning. The episode is terminated early if the agent goes 100 steps without reaching a goal.
The agent's state observations are a $5 \times 15 \times 3$ subsample of the complete maze so that the agent is able to see 15 pixel forward and 3 pixels on the side (center pixel + one pixel on each side of the agent) which is depicted in Fig.2b. This view is obscured so the agent is prevented from seeing the identity of anything behind walls. The 5 binary channels in the observation represent object identities: channel 1 represents presence of walls, 2 represents the green indicator, 3 the blue indicator, 4 the red goal, and 5 the teal goal.</p>
<p>The first baseline agent we evaluate is a recurrent network with 128 LSTM units. The other baseline is the MQN, which is a memory-network-based architecture that performs attention over the past</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Training curves for all 4 agent architectures on the "Goal-Search" environment. The x -axis is an epoch ( 250 k concurrent steps) and the y -axis is the average undiscounted episode return. The curves show that the GRU-based Neural Map learns faster and is more stable than the standard update Neural Map.</p>
<p>32 states it has seen. In more detail, the MQN stores all previous 32 states in memory and passes them all through a deep network to get an embedding, then performs a context-based lookup on this memory pool using a query vector computed from the current state. Finally, we test two Neural Map architectures, one with the standard update and one with the GRU-based update. The Neural Map architectures have an internal map size of $15 \times 15$ with a feature channel size of 32 . To get $r_{t}$, the global read operation passes the neural map first through a 3-layer convolutional network, with each convolution having filter size $3 \times 3$ and 8 channels, followed by a 256 unit linear layer and then a final 32 unit linear layer. Both Neural Maps are identical minus the difference in write operations. All agents are trained using a synchronized Advantage Actor-Critic with 16 concurrent environments trained for 10 million steps per environment ( 160 million total).</p>
<p>The results are reported in Table 1. During testing, we extend the maximum episode length from 100 to 500 steps so that the agent is given more time to solve the maze. From the results we can see that the Neural Map solves the most mazes in both the training and test distributions. The results show that the Neural Map based architectures can better succeed at finding the correct goal over all other methods. In particular, the GRU-based Neural Map solves almost all of the train/test mazes. One thing to note is that the accuracy on the training distribution is slightly lower than the test set. This is because the training set encompasses almost all random mazes except the 1000 of the test set thus it is likely that the agent sees each training map only once.</p>
<p>Beyond train/test splits, the results are further separated by maze size, which will give an idea of whether the agent is limited by the amount of time it can store information since larger mazes will require remembering information over longer time steps. We split the 1000 test mazes into 572 small mazes (sizes between $7 \times 7$ to $11 \times 11$ ) and 428 large mazes (sizes between $13 \times 13$ to $15 \times 15$ ). Table 1 shows that the memory network and LSTM agents have significant difficulty learning how to solve longer maze sizes. On the other hand, the neural map with either standard or GRU-based updates is capable of solving larger maze sizes at a much higher rate.</p>
<p>The training curves are plotted in Fig. 3. We can see that the Neural Map agents get the highest final reward, but both initially learn slower than the LSTM and the MemNN. It is not surprising that the MemNN learns faster because it is a feedforward network that does not need to maintain a recurrent state. The LSTM initially learns quickly but plateaus at a pretty low average reward. Results in Table 1 suggest that this relatively higher initial score might be due to the LSTM quickly learning how to solve the small mazes. For the Neural Maps, the GRU-based update was observed to learn much faster as well as surpass the final score of the standard update. Another benefit of the GRU-based write operation was that it typically made the Neural Map much more stable during training.</p>
<p>To gain some insight into what the neural map learned to do internally, we ran it on an example maze shown in Figure 4. In this figure, the top row of images are the agent observations, the center row are the fully observable mazes and the bottom row are the probability distributions over locations from the context operation, e.g. the $\alpha_{t}^{(1 ; p)}$ values defined by Eq. 10. In this maze, the indicator is blue, which indicates that the teal goal should be visited. We can see that once the agent sees the incorrect red goal, the context distribution faintly focuses on the map location where the agent had observed the indicator. On the other hand, when the agent first observes the correct teal goal, the</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: A few sampled states from an example episode demonstrating how the agent learns to use the context addressing operation of the Neural Map. The top row of images is the observations made by the agent, the center is the fully observable mazes and the bottom image is the probability distributions over locations induced by the context operation at that step.
<img alt="img-4.jpeg" src="img-4.jpeg" />
(a) Green Torch $\rightarrow$ Green Tower
<img alt="img-5.jpeg" src="img-5.jpeg" />
(b) Red Torch $\rightarrow$ Red Tower</p>
<p>Figure 5: Images of the Doom maze environment. The agent starts in the middle of a maze looking in the direction of a torch indicator. The torch can be either green (top-left image) or red (bottom-left image) and indicates which of the goals to search for. The goals are two towers which are randomly located within the maze and match the indicator color. The episode ends whenever the agent touches a tower, whereupon it receives a positive reward if it reached the correct tower, while a negative reward otherwise. Alternatively, the episode is also terminated if the agent has not reached a tower in 420 steps.
location where the agent observed the indicator lights up brightly. This means that the agent is using its context retrieval operation to keep track of the landmark (the indicator) that it has previously seen.</p>
<h1>4.2 3D DOOM ENVIRONMENT</h1>
<p>To demonstrate that our method can work in much more complicated 3D environments with longer time lags, we implemented the 2D maze environment in 3D using the ViZDoom (Kempka et al., 2016) environment and a random maze generator. In the Doom environment, the indicator is a torch of either red or green color that is always at a fixed location in view of the player's starting state. The goals are red/green towers that are randomly positioned throughout the maze. The corresponding torch indicators and goal towers are illustrated in Figure 5. We terminate an episode if more than 420 steps are taken.</p>
<p>To train the agent, we used a deep network as a state embedding. The state observations were the 5 previous $100 \times 75$ RGB colour images. The network was pre-initialized with the weights from a</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Agent</th>
<th style="text-align: center;">Training Map</th>
<th style="text-align: center;">Unseen Maps</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Random</td>
<td style="text-align: center;">20.9\%</td>
<td style="text-align: center;">22.1\%</td>
</tr>
<tr>
<td style="text-align: center;">MemNN</td>
<td style="text-align: center;">68.2\%</td>
<td style="text-align: center;">60.3\%</td>
</tr>
<tr>
<td style="text-align: center;">LSTM</td>
<td style="text-align: center;">69.2\%</td>
<td style="text-align: center;">52.4\%</td>
</tr>
<tr>
<td style="text-align: center;">LSTM+Neural</td>
<td style="text-align: center;">78.3\%</td>
<td style="text-align: center;">66.6\%</td>
</tr>
<tr>
<td style="text-align: center;">Map (GRU)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Table 2: Doom results showing the percentage of 1000 episodes that resulted in the agent successfully finding the correct goal within 420 steps. We trained all agents on a single map. On one column, we report the success on the training map while on the other we report results on a heldout set of 6 unseen mazes. The goal tower locations are randomly sampled each episode.
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 6: An episode showing the LSTM + Neural Map (GRU) agent walking down a corridor, seeing the wrong green goal tower, and then backtracking back to the indicator until it sees the correct red goal tower. Read using left-right, top-bottom order. This episode lasted around 110 time steps, demonstrating that the environment requires information about the indicator to be stored for very long time lags. The MemNN agent would be unable to solve such a maze due to its limited memory size.
network trained to play Doom taken from Lample \&amp; Chaplot (2016). We used an action repeat of 5. To map from 3D positions to neural map space, we rescaled the coordinates provided from the game and did nearest neighbor quantization. The mazes consisted of $3 \times 3$ rooms, where a wall could be generated between any adjacent room and a tower can be located at the center. For the Neural Map agent, we used an internal map size of $32 \times 9 \times 9$.
The agents we tested on are an LSTM baseline and an LSTM + Neural Map with GRU-based updates. Due to the large size of the state embedding network, the memory network implementation quickly ran out of memory with more than 16 states so we only trained an agent with a memory size of 16 . Additionally, it was observed that because the Neural Map has coarse granularity in the 3D maze (several positions in the maze occupy the same "pixel" position in the map), the neural map agents that lacked an LSTM added to the top often repeated the same actions. So, for example, when the agent would face a wall it would often start turning but the next frame it did not remember which direction it started turning towards. Therefore the agent would sometimes be stuck facing the wall and oscillate between turning left or right. To get around this, the LSTM pre-output layer keeps track of what actions were done in previous frames and so can enable the agent to more easily turn in a consistent direction. Due to this behaviour, we do not present results for stand-alone Neural Map agents.</p>
<p>We trained all agents on a single training maze (i.e. the wall geometry was constant for all training episodes) for up to 7 million frames. For testing, we used a held-out set of 6 mazes to see whether the agents were capable of zero-shot learning. In both training and testing settings, for every episode we sample new random goal tower locations. The results are shown in Table 2. For each agent, we chose the best performing network that was seen during the 7 million training frames, where performance was measured with respect to the training map. We can see LSTM + Neural Map (GRU) surpasses all other methods on both the training map and on the 6 unseen maps. On the training map, the LSTM does almost as well as the memory network which is limited to the past 16 frames. This suggests that the LSTM is potentially only learning to solve the scenarios where the goal towers are closer to the indicator. Figure 6 shows an example episode where the Neural Map agent successfully backtracks.</p>
<h1>5 Extension: Ego-Centric Neural Map</h1>
<p>A major disadvantage of the neural map as previously described is that it requires some oracle to provide the current $(x, y)$ position of the agent. This is a difficult problem in and of itself, and, despite being well studied, it is far from solved. The alternative to using absolute positions within the map is to use relative positions. That is, whenever the agent moves between time steps with some velocity $(u, v)$, the map is counter-transformed by $(-u,-v)$, i.e. each feature in the map is shifted in the $H$ and $W$ dimensions. This will mean that the map will be ego-centric, i.e. the agent's position will stay stationary in the center of the neural map while the world as defined by the map moves around them. Therefore in this setup we only need some way of extracting the agent's velocity, which is typically a simpler task in real environments. Here we assume that there is some function $\xi\left(u^{\prime}, v^{\prime}\right)$ that discretizes the agent velocities $\left(u^{\prime}, v^{\prime}\right)$ so that they represent valid velocities within the neural map $(u, v)$. In the sequel, we assume that all velocities have been properly normalized by $\xi$ into neural map space.
Let $(p w, p h)$ be the center position of the neural map. The ego-centric neural map operations are shown below:</p>
<p>$$
\begin{aligned}
\bar{M}<em t="t">{t} &amp; =\text { CounterTransform }\left(M</em>\right)\right) \
r_{t} &amp; =\operatorname{read}\left(\bar{M}},\left(u_{t}, v_{t<em t="t">{t}\right), c</em>}=\operatorname{context}\left(\bar{M<em t="t">{t}, s</em>\right) \
w_{t+1}^{(p w, p h)} &amp; =\operatorname{write}\left(s_{t}, r_{t}, c_{t}, \bar{M}}, r_{t<em t_1="t+1">{t}^{(p w, p h)}\right) \
M</em>} &amp; =\operatorname{egoupdate}\left(\bar{M<em t_1="t+1">{t}, w</em>\right) \
o_{t} &amp; =\left[r_{t}, c_{t}, w_{t+1}^{(p w, p h)}\right] \
\pi_{t} &amp; =\operatorname{Softmax}\left(f\left(o_{t}\right)\right)
\end{aligned}
$$}^{(p w, p h)</p>
<p>where $\bar{M}<em t="t">{t}$ is the current neural map reverse transformed by the current velocity $\left(u</em>\right)$ so that the agents map position remains in the center $(p w, p h)$.}, v_{t</p>
<h2>Counter Transform Operation:</h2>
<p>The CounterTransform operation transforms the current neural map $M_{t}$ by the inverse of the agent's current velocity $\left(u_{t}, v_{t}\right)$. Written formally:</p>
<p>$$
\bar{M}<em t_1="t+1">{t}^{(a, b)}= \begin{cases}M</em>
(a-u) \in{1, \ldots, W} \wedge \
(b-v) \in{1, \ldots, H}
\end{array} \
0, &amp; \text { else }\end{cases}
$$}^{(a-u, b-v)}, &amp; \text { for } \begin{array}{c</p>
<p>While here we only deal with reverse translation, it is possible to handle rotations as well if the agent can measure it's angular velocity.</p>
<h2>Map Egoupdate Operation:</h2>
<p>The egoupdate operation is functionally equivalent to the update operation except only the center position $(p w, p h)$ is only ever written to:</p>
<p>$$
M_{t+1}^{(a, b)}= \begin{cases}w_{t+1}^{(p w, p h)}, &amp; \text { for }(a, b)=(p w, p h) \ \bar{M}_{t}^{(a, b)}, &amp; \text { for }(a, b) \neq(p w, p h)\end{cases}
$$</p>
<h2>6 RELATED WORK</h2>
<p>Other than the straightforward architectures of combining an LSTM with Deep Reinforcement Learning (DRL) (Mnih et al., 2016; Hausknecht \&amp; Stone, 2015), there has also been work on using more advanced external memory systems with DRL agents to handle partial observability. Oh et al. (2016) used a memory network (MemNN) to solve maze-based environments similar to the ones presented in this paper. MemNN keeps the last $M$ states in memory and encodes them into (key, value) feature pairs. It then queries this memory using a soft attention mechanism similar to the context operation of the Neural Map, except in the Neural Map the key/value features were written by the agent and aren't just a stored representation of the last $M$ frames seen. Oh et al. (2016) tested a few variants of this basic model, including ones which combined both LSTM and memory-network style memories.</p>
<p>In contrast to memory networks, another research direction is to design recurrent architectures that mimic computer memory systems. These architectures explicitly separate computation and memory</p>
<p>in a way anagolous to a modern digital computer, in which some neural controller (akin to a CPU) interacts with an external memory (RAM). One recent model is similar to the Neural Map, called the Differentiable Neural Computer (DNC) (Graves et al., 2016), which combines a recurrent controller with an external memory system that allows several types of read/write access. In addition to defining an unconstrained write operator (in contrast to the neural map's write location being fixed), the DNC has a selective read operation that reads out the memory either by content or in the order that it was written. While the DNC is more specialized to solving algorithmic problems, the Neural Map can be seen as an extension of this Neural Computer framework to 3D environments, with a specific inductive bias on its write operator that allows sparse writes. Recently work has also been done toward sparsifying the read and write operations of the DNC (Rae et al., 2016). This work was not focused on 3D environments and did not make any use of task-specific biases like agent location, but instead used more general biases like "Least-Recently-Used" memory addresses to force sparsity.
Additionally, a recent paper has used the idea of augmenting the state of an agent with an internal map when acting in 3D environments (Bhatti et al., 2016). Their approach uses a sophisticated pipeline of hard-coded sub-modules, such as SLAM (Simultaneous Localization And Mapping), image segmentation, etc., to augment the image inputs that are typically fed to DRL agents. In contrast, the Neural Map is trained fully end-to-end without even weak supervision and therefore it can learn by itself what currently relevant information it should store within in its internal knowledge map of the environment.
A similar paper that also had a 2D map structured memory was recently made public concurrently with our submission. Gupta et al. (2017) designed a spatial memory that was used to do robot navigation in 3D environments. These environments were based off image scans of real office buildings, and they were preprocessed into a grid-world by quantizing the possible positions and orientations the agent could assume. In contrast to our paper, which presents the Neural Map more as a general memory architecture for DRL agents, Gupta et al. (2017) focuses mainly on solving the task of robot navigation. More concretely, the task in these environments was to navigate to a goal state, with the goal position either stated semantically (find a chair) or stated in terms of the position relative to the robot's coordinate frame. Owing to this focus on navigation, they force their internal map representation (e.g. $M_{t}$ ) to be a prediction of free space around the robot. Finally, their method used DAGGER (Ross et al., 2011), an imitation learning algorithm, to train their agent. Since Doom actions affect translational/rotational accelerations, training using imitation learning is more difficult since a search algorithm cannot be used as supervision. An interesting addition they made was the use of a multi-scale map representation and a Value Iteration network (Tamar et al., 2016) to do better path planning.</p>
<h1>7 CONCLUSION</h1>
<p>In this paper we developed a neural memory architecture that organizes the spatial structure of its memory in the form of a 2D map, and allows sparse writes to this memory where the memory address of the write is in a correspondence to the agent's current position in the environment. We showed its ability to learn, using a reinforcement signal, how to behave within a challenging 2D maze task that required storing information over long time steps. The results demonstrated that our architecture surpassed baseline memories used in previous work. They also revealed that the GRU-based update equation we defined was crucial to improving both learning speed and training stability. Finally, to show that our method can scale up to more difficult 3D environments, we reimplemented the maze environment in Doom. Using a hybrid Neural Map + LSTM model, we were able to solve most of the scenarios, surpassing both LSTM and MemNN baseline agents.</p>
<h2>REFERENCES</h2>
<p>D. Bahdanau, K. H. Cho, and Y. Bengio. Neural machine translation by jointly learning to align and translate. In Proceedings of the 3rd International Conference on Learning Representations 2015, 2015.
S. Bhatti, A. Desmaison, O. Miksik, N. Nardelli, N. Siddharth, and P. H. S. Torr. Playing doom with slam-augmented deep reinforcement learning. CoRR, abs/1612.00380, 2016. URL https: //arxiv.org/abs/1612.00380.</p>
<p>J. Chung, C. Gulcehre, K. Cho, and Y. Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. CoRR, abs/1412.3555, 2014. URL https://arxiv.org/ abs/1412.3555.
A. Graves, G. Wayne, and I. Danihelka. Neural turing machines. CoRR, abs/1410.5401, 2014. URL https://arxiv.org/abs/1410.5401.
A. Graves, G. Wayne, M. Reynolds, T. Harley, I. Danihelka, A. Grabska-Barwiska, S. G. Colmenarejo, E. Grefenstette, T. Ramalho, J. Agapiou, A. P. Badia, K. M. Hermann, Y. Zwols, G. Ostrovski, A. Cain, H. King, C. Summerfield, P. Blunsom, K. Kavukcuoglu, and D. Hassabis. Hybrid computing using a neural network with dynamic external memory. Nature, 538: $471-476,2016$.
S. Gupta, J. Davidson, S. Levine, R. Sukthankar, and J. Malik. Cognitive mapping and planning for visual navigation. CoRR, abs/1702.03920, 2017. URL https://arxiv.org/abs/1702. 03920 .
M. Hausknecht and P. Stone. Deep recurrent q-learning for partially observable mdps. CoRR, abs/1507.06527, 2015. URL https://arxiv.org/abs/1507.06527.
M. Jaderberg, K. Simonyan, and A. Zisserman. Spatial transformer networks. In Advances in Neural Information Processing Systems, pp. 2017-2025, 2015.
L. Kaiser and I. Sutskever. Neural gpus learn algorithms. In Proceedings of the 4th International Conference on Learning Representations 2016, 2016.</p>
<p>Michał Kempka, Marek Wydmuch, Grzegorz Runc, Jakub Toczek, and Wojciech Jaśkowski. ViZDoom: A Doom-based AI research platform for visual reinforcement learning. In IEEE Conference on Computational Intelligence and Games, pp. 341-348, Santorini, Greece, Sep 2016. IEEE.
K. Kurach, M. Andrychowicz, and I. Sutskever. Neural random-access machines. In Proceedings of the 4th International Conference on Learning Representations 2016, 2016.
G. Lample and D. S. Chaplot. Playing fps games with deep reinforcement learning. CoRR, abs/1609.05521, 2016. URL https://arxiv.org/abs/1609.05521.</p>
<p>Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep visuomotor policies. Journal of Machine Learning Research, 17(39):1-40, 2016.
A. Miller, A. Fisch, J. Dodge, A. Karimi, A. Bordes, and J. Weston. Key-value memory networks for directly reading documents. CoRR, abs/1606.03126, 2016. URL https://arxiv.org/ abs/1606.03126".
V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran, D. Wierstra, S. Legg, and D. Hassabis. Human-level control through deep reinforcement learning. Nature, 518:529-533, 2015.
V. Mnih, A. P. Badia, M. Mirza, A. Graves, T. Harley, T. P. Lillicrap, D. Silver, and K. Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In Proceedings of the 33rd International Conference on Machine Learning (ICML), 2016.
J. Oh, V. Chockalingam, S. Singh, and H. Lee. Control of memory, active perception, and action in minecraft. In Proceedings of the 33rd International Conference on Machine Learning (ICML), 2016.
J. W. Rae, J. J. Hunt, T. Harley, I. Danihelka, A. Senior, G. Wayne, A. Graves, and T. Lillicrap. Scaling memory-augmented neural networks with sparse reads and writes. CoRR, abs/1610.09027, 2016. URL https://arxiv.org/abs/1610.09027.</p>
<p>Stéphane Ross, Geoffrey J Gordon, and Drew Bagnell. A reduction of imitation learning and structured prediction to no-regret online learning. In AISTATS, volume 1, pp. 6, 2011.</p>
<p>S. Sukhbaatar, A. Szlam, J. Weston, and R. Fergus. End-to-end memory networks. In Advances in Neural Information Processing Systems, pp. 2440-2448, 2015.
R. Sutton and A. Barto. Reinforcement Learning: an Introduction. MIT Press, 1998.</p>
<p>Aviv Tamar, Yi Wu, Garrett Thomas, Sergey Levine, and Pieter Abbeel. Value iteration networks. In Advances in Neural Information Processing Systems, pp. 2146-2154, 2016.
R. J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning, 8(3):229-256, 1992.</p>            </div>
        </div>

    </div>
</body>
</html>