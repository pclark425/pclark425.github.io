<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1767 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1767</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1767</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-32.html">extraction-schema-32</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of sim-to-real transfer for robotic agents, scientific discovery agents, or laboratory automation systems, including details about simulation fidelity, transfer success, and the conditions that enable or hinder skill transfer from virtual to real environments.</div>
                <p><strong>Paper ID:</strong> paper-6bd1e6f70626772013a3c969c4b11d17dbb3d599</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/6bd1e6f70626772013a3c969c4b11d17dbb3d599" target="_blank">Preparing for the Unknown: Learning a Universal Policy with Online System Identification</a></p>
                <p><strong>Paper Venue:</strong> Robotics: Science and Systems</p>
                <p><strong>Paper TL;DR:</strong> UP-OSI is a robust control policy that can be used across a wide range of dynamic models, and that is also responsive to sudden changes in the environment, and holds out promise of narrowing the Reality Gap between simulated and real physical systems.</p>
                <p><strong>Paper Abstract:</strong> We present a new method of learning control policies that successfully operate under unknown dynamic models. We create such policies by leveraging a large number of training examples that are generated using a physical simulator. Our system is made of two components: a Universal Policy (UP) and a function for Online System Identification (OSI). We describe our control policy as universal because it is trained over a wide array of dynamic models. These variations in the dynamic model may include differences in mass and inertia of the robots' components, variable friction coefficients, or unknown mass of an object to be manipulated. By training the Universal Policy with this variation, the control policy is prepared for a wider array of possible conditions when executed in an unknown environment. The second part of our system uses the recent state and action history of the system to predict the dynamics model parameters mu. The value of mu from the Online System Identification is then provided as input to the control policy (along with the system state). Together, UP-OSI is a robust control policy that can be used across a wide range of dynamic models, and that is also responsive to sudden changes in the environment. We have evaluated the performance of this system on a variety of tasks, including the problem of cart-pole swing-up, the double inverted pendulum, locomotion of a hopper, and block-throwing of a manipulator. UP-OSI is effective at these tasks across a wide range of dynamic models. Moreover, when tested with dynamic models outside of the training range, UP-OSI outperforms the Universal Policy alone, even when UP is given the actual value of the model dynamics. In addition to the benefits of creating more robust controllers, UP-OSI also holds out promise of narrowing the Reality Gap between simulated and real physical systems.</p>
                <p><strong>Cost:</strong> 0.01</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1767.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1767.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of sim-to-real transfer for robotic agents, scientific discovery agents, or laboratory automation systems, including details about simulation fidelity, transfer success, and the conditions that enable or hinder skill transfer from virtual to real environments.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>UP-OSI</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Universal Policy with Online System Identification</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A two-part control system trained entirely in simulation: (1) a Universal Policy (UP) π(x, μ) trained with TRPO over a wide parameterized family of dynamics, and (2) an Online System Identification network (OSI) φ that predicts dynamic model parameters μ from a short history of states and actions; the OSI output is fed to UP at run-time to adapt control online.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_system_name</strong></td>
                            <td>UP-OSI controller</td>
                        </tr>
                        <tr>
                            <td><strong>agent_system_description</strong></td>
                            <td>A learned controller for robotic agents that combines a universal neural-network policy conditioned on dynamic model parameters with a supervised OSI module that estimates those parameters from recent state-action history, enabling online adaptation to varying dynamics.</td>
                        </tr>
                        <tr>
                            <td><strong>domain</strong></td>
                            <td>general robotics dynamic motor control (locomotion and manipulation)</td>
                        </tr>
                        <tr>
                            <td><strong>virtual_environment_name</strong></td>
                            <td>PyDart2 / DART</td>
                        </tr>
                        <tr>
                            <td><strong>virtual_environment_description</strong></td>
                            <td>A multibody physics simulator (DART) accessed via PyDart2; it simulates rigid-body dynamics, contacts, joint dynamics, friction, and multibody interactions at a fixed simulation timestep (0.002 s).</td>
                        </tr>
                        <tr>
                            <td><strong>simulation_fidelity_level</strong></td>
                            <td>high-fidelity multibody physics simulation (rigid-body dynamics and contact modeling) but not a full sensor/actuator noise/latency model</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_aspects_modeled</strong></td>
                            <td>multibody rigid-body dynamics, contact dynamics (foot-ground and object contacts), mass/inertia properties, friction coefficients, joint dynamics; precise numerical integration with small timestep (0.002 s).</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_aspects_simplified</strong></td>
                            <td>No explicit modeling of sensor noise, actuator noise or delays/latency, communication timing effects, hardware-specific limitations/calibration errors, or photorealistic rendering; uncertainty in sensors/actuators and other unmodeled real-world disturbances are not modeled.</td>
                        </tr>
                        <tr>
                            <td><strong>real_environment_description</strong></td>
                            <td>No real-world robot experiments were performed in this work; authors state intent to test on real robotic platforms in future work but only simulated tests are reported.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_skill_transferred</strong></td>
                            <td>Simulated training of multiple dynamic motor skills (double inverted pendulum balancing, cart-pole swing-up, hopper locomotion, manipulator block-throwing); paper discusses potential sim-to-real transfer but does not perform it.</td>
                        </tr>
                        <tr>
                            <td><strong>training_method</strong></td>
                            <td>UP: reinforcement learning (Trust Region Policy Optimization, TRPO) over an ensemble of parameterized dynamics; OSI: supervised learning (regression) trained on simulated rollouts, with iterative augmentation using mismatched μ-control cases.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success_metric</strong></td>
                            <td>In-simulation: normalized accumulated reward per episode, maximum block height (for throwing task), maximum forward distance traveled before termination (hopper), success of swing-up-and-balance (cart-pole/double pendulum); intended sim-to-real success metrics not measured because no real tests were run.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance_sim</strong></td>
                            <td>UP-OSI attains performance close to UP given true μ (UP-true) across the training parameter ranges and, in some extrapolated parameter regimes (outside training range), UP-OSI even outperforms UP-true; quantitative values are reported as normalized rewards and plotted per task but exact scalar summaries for real transfer are not provided.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance_real</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_used</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_details</strong></td>
                            <td>The training ensemble explicitly samples dynamic model parameters μ from uniform distributions: masses, inertias, center-of-mass offsets, friction coefficients, object mass, pole length, attached mass, etc. (i.e. randomized dynamics parameters across tasks). Additionally, iterative training injects mismatched μ-control examples to make OSI robust to prediction errors.</td>
                        </tr>
                        <tr>
                            <td><strong>sim_to_real_gap_factors</strong></td>
                            <td>Paper lists standard Reality Gap contributors: simplified dynamic models, inaccurate model parameters, approximated hardware limitations, absence of sensor/actuator uncertainty and latency, and other unmodeled factors; in this work specifically, sensor/actuator noise and latency were not modeled and are identified as potential gap sources.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_enabling_conditions</strong></td>
                            <td>Key enabling choices: training UP across a wide parameterized ensemble (conditioning policy on μ), using OSI to estimate μ online from recent motion history so policy can adapt, iterative augmentation of OSI training with mismatched-control examples (to handle prediction errors), and large-scale simulated data (many rollouts) to cover likely trajectories.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_requirements_identified</strong></td>
                            <td>Authors emphasize that accurate modeling of contact dynamics and having an expressive parameterization μ that can capture real-world variations are important; no quantitative fidelity thresholds are given — the paper stresses the need to parameterize important real-world variability (masses, friction, inertial offsets) and to allow time-varying μ for expressiveness.</td>
                        </tr>
                        <tr>
                            <td><strong>fine_tuning_in_real_world</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fine_tuning_details</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_fidelity_levels</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Training a universal policy conditional on dynamic parameters together with an online system-identification module, using only simulated data, yields controllers that are robust across large ranges of dynamics and can adapt online to sudden changes (e.g., varying friction); UP-OSI matches or nearly matches the performance of a policy given true model parameters in simulation and can generalize beyond training ranges, suggesting promise for narrowing the Reality Gap, but no real-world transfer experiments were performed and limitations include unmodeled sensor/actuator uncertainty, latency, and challenges scaling OSI to high-dimensional μ.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Preparing for the Unknown: Learning a Universal Policy with Online System Identification', 'publication_date_yy_mm': '2017-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Ensemble-CIO: Full-body dynamic motion planning that transfers to physical humanoids <em>(Rating: 2)</em></li>
                <li>Sim-to-real robot learning from pixels with progressive nets <em>(Rating: 2)</em></li>
                <li>3D Simulation for Robot Arm Control with Deep Q-Learning <em>(Rating: 2)</em></li>
                <li>EPOpt: Learning Robust Neural Network Policies Using Model Ensembles <em>(Rating: 2)</em></li>
                <li>Crossing the reality gap in evolutionary robotics by promoting transferable controllers <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1767",
    "paper_id": "paper-6bd1e6f70626772013a3c969c4b11d17dbb3d599",
    "extraction_schema_id": "extraction-schema-32",
    "extracted_data": [
        {
            "name_short": "UP-OSI",
            "name_full": "Universal Policy with Online System Identification",
            "brief_description": "A two-part control system trained entirely in simulation: (1) a Universal Policy (UP) π(x, μ) trained with TRPO over a wide parameterized family of dynamics, and (2) an Online System Identification network (OSI) φ that predicts dynamic model parameters μ from a short history of states and actions; the OSI output is fed to UP at run-time to adapt control online.",
            "citation_title": "here",
            "mention_or_use": "use",
            "agent_system_name": "UP-OSI controller",
            "agent_system_description": "A learned controller for robotic agents that combines a universal neural-network policy conditioned on dynamic model parameters with a supervised OSI module that estimates those parameters from recent state-action history, enabling online adaptation to varying dynamics.",
            "domain": "general robotics dynamic motor control (locomotion and manipulation)",
            "virtual_environment_name": "PyDart2 / DART",
            "virtual_environment_description": "A multibody physics simulator (DART) accessed via PyDart2; it simulates rigid-body dynamics, contacts, joint dynamics, friction, and multibody interactions at a fixed simulation timestep (0.002 s).",
            "simulation_fidelity_level": "high-fidelity multibody physics simulation (rigid-body dynamics and contact modeling) but not a full sensor/actuator noise/latency model",
            "fidelity_aspects_modeled": "multibody rigid-body dynamics, contact dynamics (foot-ground and object contacts), mass/inertia properties, friction coefficients, joint dynamics; precise numerical integration with small timestep (0.002 s).",
            "fidelity_aspects_simplified": "No explicit modeling of sensor noise, actuator noise or delays/latency, communication timing effects, hardware-specific limitations/calibration errors, or photorealistic rendering; uncertainty in sensors/actuators and other unmodeled real-world disturbances are not modeled.",
            "real_environment_description": "No real-world robot experiments were performed in this work; authors state intent to test on real robotic platforms in future work but only simulated tests are reported.",
            "task_or_skill_transferred": "Simulated training of multiple dynamic motor skills (double inverted pendulum balancing, cart-pole swing-up, hopper locomotion, manipulator block-throwing); paper discusses potential sim-to-real transfer but does not perform it.",
            "training_method": "UP: reinforcement learning (Trust Region Policy Optimization, TRPO) over an ensemble of parameterized dynamics; OSI: supervised learning (regression) trained on simulated rollouts, with iterative augmentation using mismatched μ-control cases.",
            "transfer_success_metric": "In-simulation: normalized accumulated reward per episode, maximum block height (for throwing task), maximum forward distance traveled before termination (hopper), success of swing-up-and-balance (cart-pole/double pendulum); intended sim-to-real success metrics not measured because no real tests were run.",
            "transfer_performance_sim": "UP-OSI attains performance close to UP given true μ (UP-true) across the training parameter ranges and, in some extrapolated parameter regimes (outside training range), UP-OSI even outperforms UP-true; quantitative values are reported as normalized rewards and plotted per task but exact scalar summaries for real transfer are not provided.",
            "transfer_performance_real": null,
            "transfer_success": null,
            "domain_randomization_used": true,
            "domain_randomization_details": "The training ensemble explicitly samples dynamic model parameters μ from uniform distributions: masses, inertias, center-of-mass offsets, friction coefficients, object mass, pole length, attached mass, etc. (i.e. randomized dynamics parameters across tasks). Additionally, iterative training injects mismatched μ-control examples to make OSI robust to prediction errors.",
            "sim_to_real_gap_factors": "Paper lists standard Reality Gap contributors: simplified dynamic models, inaccurate model parameters, approximated hardware limitations, absence of sensor/actuator uncertainty and latency, and other unmodeled factors; in this work specifically, sensor/actuator noise and latency were not modeled and are identified as potential gap sources.",
            "transfer_enabling_conditions": "Key enabling choices: training UP across a wide parameterized ensemble (conditioning policy on μ), using OSI to estimate μ online from recent motion history so policy can adapt, iterative augmentation of OSI training with mismatched-control examples (to handle prediction errors), and large-scale simulated data (many rollouts) to cover likely trajectories.",
            "fidelity_requirements_identified": "Authors emphasize that accurate modeling of contact dynamics and having an expressive parameterization μ that can capture real-world variations are important; no quantitative fidelity thresholds are given — the paper stresses the need to parameterize important real-world variability (masses, friction, inertial offsets) and to allow time-varying μ for expressiveness.",
            "fine_tuning_in_real_world": false,
            "fine_tuning_details": null,
            "comparison_across_fidelity_levels": false,
            "fidelity_comparison_results": null,
            "key_findings": "Training a universal policy conditional on dynamic parameters together with an online system-identification module, using only simulated data, yields controllers that are robust across large ranges of dynamics and can adapt online to sudden changes (e.g., varying friction); UP-OSI matches or nearly matches the performance of a policy given true model parameters in simulation and can generalize beyond training ranges, suggesting promise for narrowing the Reality Gap, but no real-world transfer experiments were performed and limitations include unmodeled sensor/actuator uncertainty, latency, and challenges scaling OSI to high-dimensional μ.",
            "uuid": "e1767.0",
            "source_info": {
                "paper_title": "Preparing for the Unknown: Learning a Universal Policy with Online System Identification",
                "publication_date_yy_mm": "2017-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Ensemble-CIO: Full-body dynamic motion planning that transfers to physical humanoids",
            "rating": 2
        },
        {
            "paper_title": "Sim-to-real robot learning from pixels with progressive nets",
            "rating": 2
        },
        {
            "paper_title": "3D Simulation for Robot Arm Control with Deep Q-Learning",
            "rating": 2
        },
        {
            "paper_title": "EPOpt: Learning Robust Neural Network Policies Using Model Ensembles",
            "rating": 2
        },
        {
            "paper_title": "Crossing the reality gap in evolutionary robotics by promoting transferable controllers",
            "rating": 1
        }
    ],
    "cost": 0.009871749999999999,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Preparing for the Unknown: Learning a Universal Policy with Online System Identification</h1>
<p>Wenhao $\mathrm{Yu}^{1}$, Jie $\mathrm{Tan}^{2}$, C. Karen Liu ${ }^{1}$, and Greg Turk ${ }^{1}$<br>wenhaoyu@gatech.edu, jietan@google.com, karenliu@cc.gatech.edu, turk@cc.gatech.edu<br>${ }^{1}$ Interactive Computing, Georgia Institute of Technology, USA<br>${ }^{2}$ Google Brain, Google, USA</p>
<h4>Abstract</h4>
<p>We present a new method of learning control policies that successfully operate under unknown dynamic models. We create such policies by leveraging a large number of training examples that are generated using a physical simulator. Our system is made of two components: a Universal Policy (UP) and a function for Online System Identification (OSI). We describe our control policy as universal because it is trained over a wide array of dynamic models. These variations in the dynamic model may include differences in mass and inertia of the robots components, variable friction coefficients, or unknown mass of an object to be manipulated. By training the Universal Policy with this variation, the control policy is prepared for a wider array of possible conditions when executed in an unknown environment. The second part of our system uses the recent state and action history of the system to predict the dynamics model parameters $\mu$. The value of $\mu$ from the Online System Identification is then provided as input to the control policy (along with the system state). Together, UP-OSI is a robust control policy that can be used across a wide range of dynamic models, and that is also responsive to sudden changes in the environment. We have evaluated the performance of this system on a variety of tasks, including the problem of cart-pole swing-up, the double inverted pendulum, locomotion of a hopper, and block-throwing of a manipulator. UP-OSI is effective at these tasks across a wide range of dynamic models. Moreover, when tested with dynamic models outside of the training range, UP-OSI outperforms the Universal Policy alone, even when UP is given the actual value of the model dynamics. In addition to the benefits of creating more robust controllers, UP-OSI also holds out promise of narrowing the Reality Gap between simulated and real physical systems.</p>
<h2>I. INTRODUCTION</h2>
<p>Numerical simulation of physical phenomena is a powerful tool that has been embraced by researchers and practitioners in computer animation. The success in simulating highly dynamic motion in computer animation, however, has not been transferred in full to robotics. The discrepancy between what can be achieved in simulation and that in real world is referred as the "Reality Gap" in the Evolutionary Robotics community [22, 14]. Researchers have put forth a long list of possible factors that give rise to the Reality Gap, such as simplified dynamic models, inaccurate model parameters, approximated hardware limitations, the absence of uncertainty and latency in sensors and actuators, and other unmodelled factors. Closing the Reality Gap has recently been a major focus in robotics because the ability to transfer knowledge learned in simulation to the real world can potentially unlock the full capability of deep reinforcement learning for robotic applications.</p>
<p>There are two general approaches to learning control policies for real-world operations. One can design a robust control policy to handle a reasonable amount of noise based on a hypothesized dynamic model and hope that the control policy will succeed in the real world without any intervention. This approach is effective if the hypothesized dynamic model is not too far off from the real one. Unfortunately, this is typically not the case for complex robotic system that are performing dynamic tasks involving contacts. Alternatively, one can learn a more accurate dynamic model from real-world data by alternating between control policy optimization, data collection, and dynamic model fitting (or system identification). One potential limiting factor of this approach is the need for a large amount of real-world trials which can be expensive, timeconsuming, and sometimes dangerous to the robot, humans and objects in its surroundings.</p>
<p>This paper introduces a different approach to combat the Reality Gap. We present a new algorithm that only uses data from a generic physical simulator to learn motor control policies that successfully operate under unknown dynamic models. Our key idea is to aggressively explore the "virtual world" through physical simulation and precompute many of the possible situations the robot might encounter when operating in real world. Although it is easy to dismiss such an approach based on the curse of dimensionality argument, in light of recent disruptive development in deep learning and the availability of large-scale computing capability, we believe it is time to revisit this pre-computation approach. Suppose that we have a way to precompute the optimal control policy for every dynamic model in a parameterized space. Suppose further that we have a fast method that tells us which dynamic model best fits an observed motion sequence. With these two scenarios, during online execution in the real world, we only need to select the right dynamic model by looking at the recent history of robot motion, and then select the corresponding control policy for that dynamic model to achieve optimal motion. While it might not be possible to pre-learn a control policy or pre-explore the entire space of motions for every possible dynamic model, it might be possible to do so for everything that is important for the task of interest.</p>
<p>To this end, we introduce a new approach that exploits a massive amount of simulated data to learn a) a universal control policy (UP) that is capable under a parameterized</p>
<p>space of dynamic models, when provided with the appropriate dynamic model parameters, and b) an on-line system identification model (OSI) that predicts the dynamic model parameters given the current state and the recent history of state-action pairs. Figure 1 shows the relationship between the universal policy and the on-line system identification. Once trained, the combined algorithm, UP-OSI, can be executed in an unknown dynamic environment. At each time instance, the dynamic model parameters $\boldsymbol{\mu}$ is first predicted by the learned system identification model. The universal control policy then takes the predicted model parameters along with the current state to compute the the optimal action (Figure 1).</p>
<p>UP-OSI is sample-efficient by design because the algorithm does not require real-world samples during offline training. Another important advantage of UP-OSI is that it does not require the model parameters to be identified prior to execution. While some model parameters might not change over time (e.g. mass, length of a body part) and can be identified offline, other parameters related to the unknown environment, such as the friction coefficient of the floor or the mass of objects being manipulated, cannot be easily identified in advance. Part of the power of UP-OSI is that it can dynamically adapt to changing factors in the environment.</p>
<p>We evaluate our method by learning dynamic motor skills and executing them under unknown dynamic models in simulation. In each of the examples, the control policy can successfully execute the task without knowing some crucial parameters of the dynamic model, such as the inertial and geometric parameters of the robot, variable friction coefficients in the environment, and other task-related parameters. Furthermore, we demonstrate that UP-OSI can operate successfully outside the space of dynamic models used for training, as well as under sudden changes in the environment.</p>
<h2>II. RELATED WORK</h2>
<h2>A. Deep Reinforcement Learning</h2>
<p>In recent years, researchers have used deep reinforcement learning to train highly dynamic motor skills in simulated environments that have high-dimensional state and action spaces [23, 30, 29, 18, 20, 10]. For example, Schulman et al. demonstrated learning of fullbody humanoid running and getting up with just feedback from the reward function using Trust Region Policy Optimization (TRPO) [29] and Generalized Advantage Estimation (GAE) [30]. Lillicrap et al. [18] extended their work of Deep Q-Learning [19] and Deterministic Policy Gradient (DPG) [31] to learn robotic motor skills such as hopping, reaching and 2D walking directly from pixel input. These methods usually require a large amount of interaction time between the agent and the environment, which poses a significant challenge to the robot as well as the experimenter when applying them directly to learn a realworld robotic control task.</p>
<p>In addition, progress has been made in directly learning neural network control policies of manipulation tasks for real robots [16, 24, 17]. While the results are impressive, these methods usually require extensive amount of experimental data
[17, 24] or relatively restrictive settings [16]. It is unclear whether these method would work directly on more dynamic motor skills in the real-world, such as locomotion.</p>
<h2>B. Transfer Learning in Reinforcement Learning</h2>
<p>Transferring policy learned in simulation to real-world robot has the potential to address the problem of learning complex motor skills for real robots. Much previous effort focused on classical system identification, which provides a framework to address the general problem of model inconsistency. In practice, system identification is often interleaved with control policy optimization to minimize the number of required realworld experiments [3, 9, 5]. Some widely-used models, such as linear models [3], Gaussian processes [8, 11], and differential equations [34, 4], have proven effective for continuous dynamics and control tasks with relatively low action space. For example, Abbeel and Ng [3] used a time-variant linear function to model the dynamics of a helicopter from the realworld data while learning a control policy to perform inverted autonomous helicopter flight. Deisenroth and Rasmussen [8] trained a Gaussian process model from real-world data to analytically calculate the control policy gradient, significantly reducing the number of samples compared to sampling-based policy gradient estimation. Ross and Bagnell [27] provided a proof that such iterative processes can converge to an optimal policy, given an accurate dynamic model learning method and a good policy search algorithm. More recently, deep neural networks have been applied to learn both forward dynamics [25] and inverse dynamics [6] from the real-world data, which can potentially model more complicated dynamics. A key drawback of these methods is that their success depends on the quantity and the quality of the real-world data. For highly dynamic or contact-rich tasks, learning an accurate dynamic model and control policy would require a large amount of high quality data, which can be difficult to acquire.</p>
<p>Another line of research utilizes simulated data to train a policy and then directly applies it or adapts it to the real world. James and Johns [13] demonstrated a simulationtrained manipulation controller learned from photo-realistic rendering data that show similar behaviors in the real-world. Rusu et al. [28] used progressive networks to efficiently learn a manipulation task on a Jaco arm from a policy that was trained in simulation. One important assumption made by this approach is that the dynamics modeled by the simulator is similar to the real world dynamics. It is unclear whether these methods can work in the situations where the policy is sensitive to the discrepancy in the assumed dynamics model.</p>
<p>In this work, we avoid the need of explicit modeling of system dynamics by learning a Universal Policy (UP) that simultaneously optimizes a wide range of model parameters and an Online System Identification (OSI) network that estimates the dynamic parameters during execution. The concept of UP is similar to Mordatch et al. [21] who optimized the motion trajectory for an ensemble of dynamic models perturbed from the assumed one. Their method shows high success rate when tracking a real-world reference trajectory. The motor skills we</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Fig. 1. Overview of UP-OSI. The online system identification model (OSI) takes as input the recent history of the motion and identify the model parameters μ. The universal control policy (UP) then takes the predicted model parameters along with the current state x to compute the optimal control u.</p>
<p>are studying require a complex feedback policy, which cannot be achieved by tracking a reference trajectory. Rajeswaran et al. [26] also proposed training a control policy using an ensemble of dynamic models. They used an adversarial training scheme to improve the policy performance while iteratively updating the distribution of the dynamic models using data from the target environment. The resulting controller is robust to unknown parameters. In contrast, training our UP to achieve a high reward for a variety of dynamic models is an easier learning task because UP explicitly takes model parameters as part of the input.</p>
<h3><em>C. Learning Policy in Unknown Environment</em></h3>
<p>Our work is also related to learning a control policy in an environment with unknown parameters, i.e. Partial Observable Markov Decision Process (POMDP). One example of such work is the idea of event-learning proposed by Szita et al. [33]. They demonstrated that when combined with Static and Dynamic State (SDS) controller, their method performs better than standard method like SARSA in an dynamically varying environment. In contrast to their work, we explicitly incorporate the model parameters as the input to the control policy. With this additional information as input, the control policy has the potential to achieve better performance for a larger range of model parameters.</p>
<p>Based on the Deterministic Policy Gradient method [31], Heess et al. [12] proposed a method that represents a control policy as a recurrent neural network. They demonstrated control policies that identify and memorize task-related signals presented in the observable data sequences, such as the mass of the robot or the position of the target to be grasped. Our work shares a similar goal in learning controllers that can be applied to systems with unknown dynamic model parameters. However, their focus is on learning memory-related tasks rather than transfer to unseen dynamic environments. On the other hand, our work currently does not handle memory-related tasks as our controller only takes a small window of motion history as input.</p>
<h3>III. METHODS</h3>
<p>Our algorithm consists of two components, a universal policy (UP) and an on-line system identification model (OSI), shown in Figure 1. First, we formulate a reinforcement learning problem to learn a universal policy (UP), π : (x, μ) ↦ u, for a space of dynamic models, xt+1 = fμ(xt, ut), parameterized by the dynamic model parameters μ. Unlike a conventional control policy which maps a state vector x to a control vector u, UP takes as input both the state and the dynamic model parameters (i.e. μ) and outputs a control vector. Second, we formulate a supervised learning problem to train an online system identification model (OSI), φ : (xt-t, ut-h:t-1) ↦ μ, that predicts the dynamic model parameters μ, given the current state xt and the past h time instances of the state-action pairs. Unlike the conventional system identification approach, our goal is not to identify a particular system, but to create a <em>function</em> that can identify the model parameters for any given trajectory. Both components are represented as a standard neural network and trained offline using simulated data only.</p>
<p>Putting UP and OSI together, at every time instance, we first use OSI (φ) to predict the dynamic model parameters μ based on the current state of the robot xt and the recent history of motion (xt-t, ut-1, · · · , kt-h, ut-h). Once μ is identified, we feed both μ and the current state xt into UP (π) to evaluate the optimal action ut under the predicted dynamic model. We execute ut on the robot and push xt and ut into the history queue. The new state of the system becomes the current state xt and the algorithm advances to the next time step (Fig 1).</p>
<p>We propose a novel framework to train the control policy and the system identification model. Conventional approaches alternate between system identification and control policy optimization, which requires a reasonable initial policy or/and an initial system identification model to optimize efficiently. Our method breaks this mutual dependence by first training UP preemptively to anticipate all of the possible dynamic models that OSI might explore during optimization.</p>
<h4><em>A. Learning Universal Policy</em></h4>
<p>Our goal is to learn a control policy that can be generalized to a parameterized space of dynamic models. Many existing methods [7, 32] employ an ensemble approach by learning a discrete set of control policies and consolidating them into one regression model. Our initial attempt with the ensemble approach showed that, for many dynamic tasks, sometimes a small change in the model parameter requires a drastically different control policy to succeed at the given task. Fitting a regression model to this non-smooth landscape of policies often yields poor generalizability.</p>
<p>In this work, we found that it is possible to directly train a large neural net to represent a universal control policy, π(x, μ), for a space of dynamic models parameterized by μ. With a powerful policy optimization algorithm and sufficient data, the universal policy can achieve high rewards across the space of μ, with comparable performance to policies that have been trained for a specific μ.</p>
<p>We use the Trust Region Policy Optimization (TRPO) method [29] and show that by simply augmenting the input state with the model parameters $\boldsymbol{\mu}$, TRPO can successfully train a universal control policy. However, we need to modify the exploration scheme of TRPO because the part of the state space that represents $\boldsymbol{\mu}$ is not affected by forward simulation when generating rollouts. Our algorithm (Algorithm 1) samples $K$ different $\boldsymbol{\mu}$ from a uniform distribution $\rho_{\mu}$. For each $\boldsymbol{\mu}<em i="i">{i}$, we generate a set of rollouts under the policy $\pi\left(\mathbf{x}, \boldsymbol{\mu}</em>$. Once the state-action pairs are collected in this manner, the update of $\pi$ follows TRPO exactly.}\right)$ and the dynamic model $f_{\boldsymbol{\mu}_{i}</p>
<h2>B. Learning Online System Identification Model</h2>
<p>Even with the ability to perform control under different dynamic models, UP can only succeed at a task when given accurate model parameters, and this information is typically not readily available. We propose to learn an online system identification model (OSI), $\phi:\left(\mathbf{x}<em t-1="t-1" t-h:="t-h:">{t-h: t}, \mathbf{u}</em>$ for UP, when given a short recent history of the states and actions.}\right) \mapsto \boldsymbol{\mu}$, that continuously identifies the correct model parameters $\boldsymbol{\mu</p>
<p>The training process can be formulated as a supervised learning problem with the input being a history rollout $H$ and the output being the model parameters $\boldsymbol{\mu}$ under which the input rollout is generated:</p>
<p>$$
\theta^{*}=\underset{\theta}{\operatorname{argmin}} \sum_{\left(H_{i}, \boldsymbol{\mu}<em _theta="\theta">{i}\right) \subseteq B}\left|\phi</em>
$$}\left(H_{i}\right)-\boldsymbol{\mu}_{i}\right|^{2</p>
<p>where $\theta$ are the parameters of the neural net $\phi_{\theta}$.
Although the training data can be entirely obtained from simulation, the amount of data can be intractably large to thoroughly cover the input space. Our key observation is that OSI only needs to be accurate for the trajectories that are likely to be observed when performing the tasks of interest. As such, we randomly sample the space of $\boldsymbol{\mu}$ where UP is trained for. For each sampled $\tilde{\boldsymbol{\mu}}<em i="i">{i}$, we simulate $N$ rollouts using the policy $\pi\left(\mathbf{x}, \tilde{\boldsymbol{\mu}}</em>$. We then generate short history segments from each rollout and store them in the training buffer $B$ (Line 3-13, Algorithm 2).}\right)$ and under the dynamics $f_{\tilde{\boldsymbol{\mu}}_{i}</p>
<p>After optimizing $\phi$ using Equation 1, we found that the performance of the combined system, UP-OSI, was much worse than simply using UP given true model parameters $\tilde{\boldsymbol{\mu}}$. This result is not surprising (retrospectively) because our OSI has only "seen" the motion sequences generated by a control policy $\pi(\mathbf{x}, \tilde{\boldsymbol{\mu}})$ under a dynamic model $f_{\tilde{\boldsymbol{\mu}}}$ where their model parameters are consistent. In other words, all the training examples so far only cover the "good cases" where the control policy is operating optimally under a given dynamic model. When we tested OSI with an unseen initial sequence, OSI was likely to make some error in the prediction. This error is exacerbated because the next sequence that OSI will see is generated by a control using an erroneously predicted $\tilde{\boldsymbol{\mu}}$ under the true model parameters $f_{\tilde{\boldsymbol{\mu}}}$, where $\tilde{\boldsymbol{\mu}} \neq \tilde{\boldsymbol{\mu}}$.</p>
<p>Our solution is to iteratively improve OSI by introducing "bad cases" with mismatched model parameters used for control $(\pi(\mathbf{x}, \tilde{\boldsymbol{\mu}}))$ and for forward simulation $\left(f_{\tilde{\boldsymbol{\mu}}}\right)$. For each iteration, we generate more training examples using the current OSI</p>
<div class="codehilite"><pre><span></span><code>Algorithm 1 Learning UP
    Randomly initialize UP network \(\pi\)
    for \(i=1: K\) do
        Initialize rollout buffer \(R\)
        \(\boldsymbol{\mu} \sim \rho_{\mu}\)
        \(\mathbf{x} \sim \rho_{0}\)
        while R.size \(\leq\) MaxStep do
            \(\mathbf{u}=\pi(\mathbf{x}, \boldsymbol{\mu})\)
            \(\mathbf{x}=f_{\boldsymbol{\mu}}(\mathbf{x}, \mathbf{u})\)
            \(r\), terminated \(=\operatorname{Reward}(\mathbf{x}, \mathbf{u})\)
            Push ( \(\mathbf{x}, \mathbf{u}, r)\) into \(R\)
            if terminated then
                \(\boldsymbol{\mu} \sim \rho_{\mu}\)
                \(\mathbf{x} \sim \rho_{0}\)
        Update \(\pi\) with data in \(R\) using TRPO
    return \(\pi\)
</code></pre></div>

<p>and UP. We randomly sample in the space of $\boldsymbol{\mu}$ and generate rollouts like before. However, we feed the $\boldsymbol{\mu}$ predicted by the current OSI into UP, instead of the true model parameters $\tilde{\boldsymbol{\mu}}$ used for forward simulation. Note that in Line 25 of Algorithm 2, the dynamic model has the parameter $\tilde{\boldsymbol{\mu}}$ which is different from the one used for the control (Line 22, 24). Mixing the mismatched training examples with previously generated ones, we train OSI again using Equation 1. After a small number of iterations (3-5, see Section IV), the performance of UP-OSI becomes close to the performance of UP that is provided with the true model parameters.</p>
<h2>IV. Evaluation</h2>
<p>We evaluate UP-OSI on four dynamic motor control problems. In each example, the control policy does not know the true model parameters in advance and relies on OSI to identify the parameters during execution. We vary different model parameters, such as mass, inertia, friction coefficient, or task-related parameters to demonstrate that UP-OSI can successfully perform all the motor skills under unknown dynamic models. We compare the performance of UP-OSI against the performance of the condition, UP-true, which uses UP given the true model parameters. The performance of UPtrue can be regarded as an informal upper bound for UP-OSI.</p>
<p>Further, we demonstrate that UP-OSI can also perform well when the model parameters of the testing environment are outside of the training range. This result is particularly interesting when comparing against UP-true. We found that UP-OSI unexpectedly outperforms the UP-true under dynamic models that were unseen during training.</p>
<p>All results presented in this work are simulated in PyDart2 [2], a python wrapper for DART [1] ${ }^{1}$, which is a multibody physics simulator supported by Gazebo. The simulation timestep is set to 0.002 s . Please see supplementary video for visualizing simulated motion sequences. For UP, we use a neural network with two hidden layers, comprised of 64 units</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Algorithm 2 Learning OSI
1: Randomly initialize OSI network $\phi$
2: Initialize training buffer $B$
3: for $i=1: K$ do
4: $\overline{\boldsymbol{\mu}} \sim \rho_{\mu}$
5: for $j=1: N$ do
6: Initialize history queue $H$
7: Fill $H$ by simulating under $\pi(\mathbf{x}, \overline{\boldsymbol{\mu}})$ and $f_{\overline{\boldsymbol{\mu}}}$
8: for $t=0: T-1$ do
9: Pop $H$
10: $\mathbf{u}<em t="t">{t}=\pi\left(\mathbf{x}</em>\right)$
11: $\mathbf{x}}, \overline{\boldsymbol{\mu}<em _overline_boldsymbol_mu="\overline{\boldsymbol{\mu">{t+1}=f</em>}}}\left(\mathbf{x<em t="t">{t}, \mathbf{u}</em>\right)$
12: Push $\left(\mathbf{x}<em t="t">{t+1}, \mathbf{u}</em>\right)$ in $H$
13: Store $(H, \overline{\boldsymbol{\mu}})$ in $B$
14: Optimize $\phi$ using data in $B$
15: while not converge do
16: for $i=1: K$ do
17: $\overline{\boldsymbol{\mu}} \sim \rho_{\mu}$
18: for $j=1: N$ do
19: Initialize history queue $H$
20: Fill $H$ by simulating under $\pi(\mathbf{x}, \overline{\boldsymbol{\mu}})$ and $f_{\overline{\boldsymbol{\mu}}}$ for $t=0: T-1$ do
21: $\overline{\boldsymbol{\mu}}=\phi(H)$
22: Pop $H$
23: $\mathbf{u}<em t="t">{t}=\pi\left(\mathbf{x}</em>\right)$
24: $\mathbf{x}}, \overline{\boldsymbol{\mu}<em _overline_boldsymbol_mu="\overline{\boldsymbol{\mu">{t+1}=f</em>}}}\left(\mathbf{x<em t="t">{t}, \mathbf{u}</em>\right)$
25: Push $\left(\mathbf{x}<em t="t">{t+1}, \mathbf{u}</em>\right)$ in $H$
26: Store $(H, \overline{\boldsymbol{\mu}})$ in $B$
27: Optimize $\phi$ using data in $B$ return $\phi$
in both hidden layers with tanh activation functions, followed by a linear fully connected final layer. For OSI, we use three hidden layers, with 256, 128, and 64 hidden units and tanh activation functions. We add a dropout layer for OSI after each hidden layer with a dropout rate of 0.1 .</p>
<p>The learning process for UP takes 500 iterations of TRPO updates. The amount of data collected during each iteration varies by the difficulty of the tasks. We run five iterations for training OSI. At each iteration we sample 30 different $\boldsymbol{\mu}$ values and collect 5 seconds for each $\boldsymbol{\mu}$. For all the examples shown here, we use a motion history length of three, which is the minimal length to learn a second-order dynamic model.</p>
<h2>A. Double inverted pendulum with unknown center of mass</h2>
<p>We begin with a classic motor control problem: balancing a double inverted pendulum. We define the reward function as,</p>
<p>$$
r(\mathbf{x})=-k_{1}\left(\sigma_{1}+\sigma_{2}\right)^{2}-k_{2}\left|p_{\text {cart }}\right|+10
$$</p>
<p>where $\sigma_{1}$ and $\sigma_{2}$ are angles of the two poles from the upright configuration, $p_{\text {cart }}$ is the position of the cart and $k_{1}$ and $k_{2}$ are the corresponding weights of the two terms. We normalize the angles to be in $[0, \pi]$ and use $k_{1}=10.0, k_{2}=1.0$ in our experiment. The length of the two poles are both 0.5 m . We terminate the simulation when $\left|p_{\text {cart }} \geq 5\right|$ or $\left(\sigma_{1}+\sigma_{2}\right) \geq 0.5 \pi$.</p>
<p>The unknown model parameter for this problem is the center of mass of the lower pole, which has an unknown offset, $(\mu, 0.2 \mu)$, from the geometric center. To ensure that the control policy would need to apply different strategies to balance the pendulum when different model parameters are given, we allow the offset to vary across a wide range: $\mu \in[-0.6 m, 0.6 m]$. Note that the purpose of the vertical offset $(0.2 \mu)$ is to break the symmetry of the problem to further increase the difficulty of control.</p>
<p>At each training iteration of UP, we collect 150, 000 samples using the physics simulator. Figure 2(b) shows the normalized performance of the trained UP-OSI across different $\boldsymbol{\mu}$ values, comparing against UP-true (the informal upper bound). The performance of each $\boldsymbol{\mu}$ in Figure 2(b) is the normalized average accumulated reward of 20 rollouts starting from a randomly perturbed initial state. If the performance value is above 1.0 , the double inverted pendulum is able to balance. We also compare UP-OSI to a policy with conventional state input and control output but trained by data simulated from a range of model parameters (denoted as "regular" in Figure 2(b)). The purpose of this comparison is to show that providing the model parameters as input to UP results in a more powerful control policy under a range of dynamic models,</p>
<p>To demonstrate the learning process of OSI network, we plot the same reward-model parameter graph at each iteration of training. As shown in Figure 2(c), the performance of UPOSI improves over time and approaches the performance of UP-true. In Figure 2(d), we plot the mean and the standard deviation for the model parameter identified by the trained OSI for each ground truth $\mu$ on x-axis. This shows that OSI is indeed able to identify the model parameter in this task.</p>
<h2>B. Manipulator with unknown object mass</h2>
<p>In this example, we train a robot arm to grab a block and throw it to a certain height but not beyond. The arm is initially pointing down and the block is in the air near the gripper of the arm. Similar motor skill can be observed in the serving of a tennis ball. The state $\mathbf{x}$ includes the joint position $\mathbf{q}$, joint velocity $\dot{\mathbf{q}}$ of the robot arm, and the position of the block $\mathbf{p}_{\text {block }}$. The reward function is defined as:</p>
<p>$$
\begin{aligned}
&amp; r(\mathbf{x}, \mathbf{u})=-k_{1} r_{h}-k_{2}|\mathbf{u}|^{2}-k_{3}|\dot{q}|^{2}+35 \
&amp; r_{h}= \begin{cases}h_{\text {target }}-h_{\text {block }}, &amp; \text { if } h_{\text {block }} \leq h_{\text {target }} \
0, &amp; \text { otherwise }\end{cases}
\end{aligned}
$$</p>
<p>where $k_{1}=10, k_{2}=1 e-5, k_{3}=1 e-3, h_{\text {target }}=2 m$ and $h_{\text {block }}$ is the height of the block. We terminate the rollout when the box falls below -0.2 m or when the block is more than 0.8 m away horizontally. By giving zero reward beyond $h_{\text {target }}$, we encourage the robot arm to throw the block in a way that it has low velocity when it reaches $h_{\text {target }}$, such that it can stay in the high reward region as long as possible. The unknown model parameters is the mass of the block. The robot needs to infer the weight of the block and use the right amount of effort to throw it up to the right height.</p>
<p>During the training of UP, we collect 50,000 samples for each iteration. The performance of UP-OSI and UP-true is</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Fig. 2. Results for the Double Inverted Pendulum Task. (a) Illustration of the task. (b) Performance of UP-true, "Regular" Controller and UP-OSI. The horizontal axis is the model parameter (center of mass), and the vertical axis is the performance. (c) The evolution of optimizing UP-OSI. The reward across the training range of µ increases iteratively. (d) Mean and standard deviation of the predicted model parameter. The x-axis indicates the true model parameters while the y-axis indicates the predicted ones by OSI. The model parameters have been normalized to be in [−1, 1].</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Fig. 3. Results for the Robot Arm object throwing task. (a) Illustration of the Task. (b) Performance of UP-true and UP-OSI. The horizontal axis is the model parameter (mass of the object), and the vertical axis is the performance (maximum height of the object). (c) Mean and standard deviation of the predicted model parameter. The x-axis indicates the true model parameters while the y-axis indicates the predicted ones by OSI. The model parameters have been normalized to be in [−1, 1].</p>
<p>Plotted in Figure 3(b). We measure the performance by the highest point reached by the block. The closer to <em>h<sub>target</sub></em> = 2<em>m</em>, the better the performance. We also plot the mean and standard deviation of the predicted block mass throughout the test, as shown in Figure 3(c). We observe similar trends as in the double inverted pendulum task, which shows that OSI also learns to identify the model parameter for this task.</p>
<h3><em>C. Hopper with unknown friction coefficient</em></h3>
<p>Correctly identifying contact information is crucial to many locomotion tasks. In this example, we demonstrate that our method can be applied to identify the friction coefficient at the contact point in an online fashion. The task is to control a single leg robot in 2D, the Hopper, to hop forward as fast as possible without falling. The reward is defined as</p>
<p>$$r(\mathbf{x}, \mathbf{u}) = k_1\dot{\mathbf{x}} - k_2||\mathbf{u}||^2 + 3.0,$$</p>
<p>where <em>k<sub>1</sub></em> = 1, <em>k<sub>2</sub></em> = 0.002 for our experiments. The unknown model parameters is the friction coefficient with the range µ ∈ [0.3, 1.0]. We plot the maximum distance traveled by the hopper before the termination criteria is satisfied (the hopper falls or the maximum length of the rollout is reached) instead of the reward value to better visualize the performance of the hopper. The input to UP include the joint position of the hopper <strong>q</strong>, the joint velocity <strong>q̂</strong> and the friction coefficient µ between the foot and the ground. Note that we don't use position in the forward direction in the input state, because it is not directly related to the task.</p>
<p>We use 75,000 samples each iteration during the training of UP. Figure 4(b) shows the performance of UP-OSI compared to UP-true. Due to the difficulty of the task, UP can only perform well around µ = [0.6, 1.0]. However, being able to identify friction coefficients in this range, i.e. between the coefficient for wood-concrete contact and that for rubber-concrete contact, is sufficient for most practical applications. Figure 4(c) shows the mean and standard deviation of the predicted model parameter during the test at each µ.</p>
<h3><em>D. Cart-pole swing-up with unknown pole length and unknown attached mass</em></h3>
<p>To solve the classic cart-pole swing-up problem, the control policy needs to learn not only how to balance the pole, but also how to swing it up from a straight down position. Our experiment makes two modifications to increase the difficulty of the problem. First, we limit the force used by the cart to be within [−40<em>N</em>, 40<em>N</em>]. As such, the controller must swing the pole back and forth before it rises up. We also attach an additional mass to the tip of the pole to mimic the weight lifting task (Figure 5(a)).</p>
<p>We use a variant of the reward function suggested by [15]: <em>r<sub>σ</sub></em> = <em>wσ<sup>2</sup></em> + <em>v</em> log(<em>σ<sup>2</sup></em> + <em>a</em>), where σ is the angle of the pole. The first term encourages fast learning of swing-up motion and the second term encourages fast learning of balance. In our experiment, we set <em>w</em> = 1, <em>v</em> = 1, <em>a</em> = 0.1. Similar to the double inverted pendulum task, we also add a term to encourage the cart to stay at the center of the track, <em>r<sub>cart</sub></em> =</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Fig. 4. Results for the Hopper task. (a) Illustration of the task. (b) Performance of UP-true and UP-OSI. The horizontal axis is the model parameter (friction coefficient), and the vertical axis is the performance (maximum distance traveled in 1,000 simulation steps). (c) Mean and standard deviation of the predicted model parameter. The x-axis indicates the true model parameters while the y-axis indicates the predicted ones by OSI. The model parameters have been normalized to be in [−1, 1]. (d) Performance of varying contact friction test. We tested UP-true, UP-OSI and UP with input friction coefficient fixed at 0.9 for 2,000 simulation steps. (e) OSI-predicted and actual friction coefficient in varying contact friction test.</p>
<p><em>|p_{c}art|</em>. Together, our reward function is defined as:</p>
<p>$$r(\mathbf{x}) = -k_1 r_{\sigma} - k_2 r_{cart} + 10.0,$$</p>
<p>where <em>k</em><sub>1</sub> = 1.0, <em>k</em><sub>2</sub> = 0.2. In our setup, the pole has 0 position when it is upright. During the simulation, we randomly initialize the position of the pole to be either <em>π</em> or −<em>π</em> with a small noise drawn from <em>N</em>(0, 0.005). We terminate the rollout when the pole rotates more than 4<em>π</em> from the initial position, or when the cart is more than 2<em>m</em> from the center.</p>
<p>The unknown model parameters in this example include the additional mass attached to the top of the pole (<em>μ</em><sub>mass</sub> ∈ [0.1<em>kg</em>, 1.0<em>kg</em>]), and the length of the pole (<em>μ</em><sub>length</sub> ∈ [0.2<em>m</em>, 0.8<em>m</em>]). To closely compare with the cart-pole examples in [12], where they control an inverted pendulum with varying pole length using a RNN with the whole history trajectory as input, we train OSI to estimate the velocity of the system, instead of directly giving the true velocity to the policy as part of the state. As such, the space of model parameters for this example is ℝ<sup>4</sup>. At each iteration of UP training, we run 70,000 samples. We normalize the resulting reward such that if a policy achieves averaged accumulated reward more than one, then it usually can swing up and balance the cart-pole system. Figure 5(b) and (c) show that UP-OSI can achieve high reward for a range of unknown pole lengths, similar to the inverted pendulum result shown in [12], but UP-OSI only requires three time steps of history as input. In addition, the mass attached to the tip is also an unknown that needs to be simultaneously identified with the pole length.</p>
<h3><em>E. Generalization to varying model parameter</em></h3>
<p>We run the trained UP-OSI for Hopper on a track with varying friction coefficients to test its generalizability. We create a track with friction coefficient <em>μ</em><sub>const</sub> = 0.9 everywhere except for the region between 20<em>m</em> to 30<em>m</em>. We then vary the friction coefficient <em>μ</em><sub>vary</sub> in this region and plot the performance of the controller with regard to <em>μ</em><sub>vary</sub>. Figure 4(d) shows the performance of UP-OSI and the UP-true. Note that UP-true was given the ground truth friction coefficient at each time instance as if it has a perfect contact-friction sensor on the foot, where UP-OSI needs to identify this information based on the recent history of the motion. The results show that UP-OSI can achieve comparable and sometimes better performance than UP-true. We also test the performance of UP with fixed input <em>μ</em> = 0.9, i.e. the hopper isn't aware of the change in friction coefficient, which is shown as the blue curve in Figure 4(d). The worse performance shows that it is crucial to detect the varying friction coefficient in order to success in this task.</p>
<p>In addition, we plot the friction coefficient predicted by OSI over time for one specific <em>μ</em><sub>vary</sub> = 0.55, as is shown in Figure 4(e). We can see that OSI can identify the changes in model parameter during the task. Note that we did not provide any training examples with temporally-varying <em>μ</em> when training either UP-true or UP-OSI networks.</p>
<h3><em>F. Generalization beyond training range</em></h3>
<p>Another way to evaluate the generalizability of the policy is to test it with model parameters that were not seen during the training phase. We perform such test on the cart-pole swing up problem with a pole length range of [0.8<em>m</em>, 1.4<em>m</em>] and the</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Fig. 5. Results on the Cart-Pole Swing-Up task. (a) Illustration of the task. (b) Performance of UP-true visualized in the domain of pole length and weight mass. (c) Performance of UP-OSI visualized in the domain of pole length and weight mass. (d) Performance with model parameters exceeding the training range 100%.</p>
<p>attached mass range of [1.0kg, 1.9kg]. We linearly couple the two unknown parameters together, such that when pole length is 0.8m the attached mass has 1.0kg and when pole length is 1.4m the attached mass has 1.9kg. This is 100% beyond the original training range ([0.2m, 0.8m] and [0.1kg, 1.0kg]). We test both UP-true and UP-OSI with this extended range, which is shown in Figure 5(d). The result shows that UP-OSI can work for a large range of unknown pole length and attached mass with only position information as input. More interestingly, UP-OSI significantly outperforms UP-true in this range of μ unseen during training.</p>
<h2>V. DISCUSSION</h2>
<p>While UP-OSI has demonstrated a wide range of success, we recognize a few limitations that require further investigation. First, identifying high-dimensional model parameters remains an unsolved challenge. Although we demonstrated that OSI can perform well for model parameters in ℝ³ (the cart-pole example), more rigorous analysis is required to evaluate the sample-efficiency of UP-OSI for high-dimensional model parameter space. In all our experiments, we train OSI with five iterations and the resulting UP-OSI can achieve similar performance as the baseline. However, a theoretical upper bound and convergence conditions are not established in this work. Further, our current implementation assumes both the policy and the dynamic model are deterministic, but UP-OSI can easily be extended to a stochastic formulation.</p>
<p>This work primarily focuses on identifying model parameters unrelated to uncertainty in sensors and actuators partly because many of these issues have been addressed in the literature of robust control. One important source of uncertainty in a dynamic model is latency. The nature of latency might complicate the scheme of history queue used in OSI, but it is nevertheless an important and challenging problem to tackle.</p>
<p>An alternative approach to UP-OSI is to train an "end-to-end" control policy that takes as input a sequence of motion history and directly outputs the optimal control, rather than explicitly decoupling the process into system identification and control. Indeed, previous work [12] has shown that a recurrent network can learn to control a dynamic system with unknown model parameters. We chose to design a control policy that explicitly takes in the model parameters as input, because this additional information in the input allows the policy to specialize for each model parameter, which can potentially improve the performance. In addition, we conjecture that decoupling a large network trained by reinforcement learning into two moderate-sized networks, one of which is trained by supervised learning, might reduce the learning time and improve the sample-efficiency.</p>
<p>We demonstrated that UP-OSI can be extended to operate under the model parameters outside of the training range. The more surprising result is that, in these extrapolated situations, UP-OSI actually outperforms the baseline. While further investigation is needed, one possible explanation is that OSI learned how to modulate the model parameters over time, essentially switching between existing policies, to achieve unseen tasks. Since UP-OSI has the ability to handle μ outside of the training range, a follow-up question for future work is whether UP-OSI can handle variations in other model parameters outside of the space of μ.</p>
<p>For near future, we would like to train UP-OSI using one simulator but test it on a different one. If successful, our next step will be to test UP-OSI on real-world robotic platforms. One potential issue of our method is that the real-world dynamics cannot be well represented by the chosen parameterization of the dynamic models. However, UP-OSI allows the dynamic model to be time-varying, resulting in a more expressive parametric model to match the real-world dynamics. Essentially, the algorithm modifies its estimate of the dynamic model at every time instance based on recent real-world observations. This rapid adaptation of dynamic model allows the control policy to make prompt correction as it is also time-varying.</p>
<h2>VI. CONCLUSION</h2>
<p>We have introduced a new approach to creating motion policies that are formed by coupling a Universal Policy together with an On-line System Identification model. A key aspect of such policies is that they are robust under a wide variety of dynamic models, and indeed, they determine the</p>
<p>dynamic model parameters on-the-fly. This approach was created with the goal of developing control policies for realworld tasks by performing extensive off-line training using physical simulation and deep reinforcement learning. While we have yet to transfer such policies to real robots, their performance gives several promising indications. First, the UPOSI control policies give almost the same performance as the UP-true baseline, while having to deduce the unknown dynamic models on their own. Second, UP-OSI can perform better than the Universal Policy alone, in the case where the dynamic model is outside of the training range. Finally, by constantly estimating the dynamic model at every time-step, such control policies can adapt to a changing environment such as locomotion over a surface with varying friction.</p>
<h2>REFERENCES</h2>
<p>[1] DART: Dynamic Animation and Robotics Toolkit". URL http://dartsim.github.io/.
[2] Pydart2. URL https://github.com/sehoonha/pydart2.
[3] Pieter Abbeel and Andrew Y. Ng. Exploration and Apprenticeship Learning in Reinforcement Learning. In International Conference on Machine Learning, pages 18, 2005.
[4] Pieter Abbeel, Morgan Quigley, and Andrew Y. Ng. Using Inaccurate Models in Reinforcement Learning. In Proceedings of the 23rd International Conference on Machine Learning, ICML '06, pages 1-8, 2006.
[5] Josh C. Bongard and Hod Lipson. Nonlinear System Identification Using Coevolution of Models and Tests. IEEE Trans. Evolutionary Computation, 9(4):361384, 2005. URL http://dx.doi.org/10.1109/TEVC.2005. 850293.
[6] Paul Christiano, Zain Shah, Igor Mordatch, Jonas Schneider, Trevor Blackwell, Joshua Tobin, Pieter Abbeel, and Wojciech Zaremba. Transfer from Simulation to Real World through Learning Deep Inverse Dynamics Model. arXiv preprint arXiv:1610.03518, 2016.
[7] Bruno Da Silva, George Konidaris, and Andrew Barto. Learning parameterized skills. arXiv preprint arXiv:1206.6398, 2012.
[8] Marc Deisenroth and Carl E Rasmussen. PILCO: A model-based and data-efficient approach to policy search. In Proceedings of the 28th International Conference on machine learning (ICML-11), pages 465-472, 2011.
[9] Michel Gevers. System identification without lennart ljung: what would have been different? 2006.
[10] Shixiang Gu, Timothy Lillicrap, Zoubin Ghahramani, Richard E Turner, and Sergey Levine. Q-Prop: SampleEfficient Policy Gradient with An Off-Policy Critic. arXiv preprint arXiv:1611.02247, 2016.
[11] Sehoon Ha and Katsu Yamane. Reducing Hardware Experiments for Model Learning and Policy Optimization. IROS, 2015.
[12] Nicolas Heess, Jonathan J Hunt, Timothy P Lillicrap, and David Silver. Memory-based control with recurrent neural networks. arXiv preprint arXiv:1512.04455, 2015.
[13] Stephen James and Edward Johns. 3D Simulation for Robot Arm Control with Deep Q-Learning. arXiv preprint arXiv:1609.03759, 2016.
[14] Sylvain Koos, Jean-Baptiste Mouret, and Stéphane Doncieux. Crossing the reality gap in evolutionary robotics by promoting transferable controllers. In Genetic and Evolutionary Computation Conference. ACM, 2010. ISBN 978-1-4503-0072-8. URL http://doi.acm.org/10. 1145/1830483.1830505.
[15] Sergey Levine, Nolan Wagener, and Pieter Abbeel. Learning contact-rich manipulation skills with guided policy search. In Robotics and Automation (ICRA), 2015 IEEE International Conference on, pages 156-163. IEEE, 2015.
[16] Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-End Training of Deep Visuomotor Policies. Journal of Machine Learning Research, 17(39): $1-40,2016$.
[17] Sergey Levine, Peter Pastor, Alex Krizhevsky, and Deirdre Quillen. Learning Hand-Eye Coordination for Robotic Grasping with Deep Learning and Large-Scale Data Collection. CoRR, abs/1603.02199, 2016. URL http://arxiv.org/abs/1603.02199.
[18] Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015.
[19] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
[20] Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy P Lillicrap, Tim Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International Conference on Machine Learning, 2016.
[21] Igor Mordatch, Kendall Lowrey, and Emanuel Todorov. Ensemble-CIO: Full-body dynamic motion planning that transfers to physical humanoids. In IEEE/RSJ International Conference on Intelligent Robots and Systems, 2015.
[22] S. Nolfi and D. Floreano. Evolutionary Robotics: The Biology, Intelligence, and Technology. MIT Press (Cambridge, MA), 2000.
[23] Xue Bin Peng, Glen Berseth, and Michiel van de Panne. Terrain-Adaptive Locomotion Skills Using Deep Reinforcement Learning. ACM Transactions on Graphics, 35 (4), 2016.
[24] Lerrel Pinto and Abhinav Gupta. Supersizing selfsupervision: Learning to grasp from 50k tries and 700 robot hours. In IEEE International Conference on Robotics and Automation (ICRA), pages 3406-3413. IEEE, 2016.
[25] Ali Punjani and Pieter Abbeel. Deep learning helicopter dynamics models. In IEEE International Conference</p>
<p>on Robotics and Automation (ICRA), pages 3223-3230. IEEE, 2015.
[26] Aravind Rajeswaran, Sarvjeet Ghotra, Sergey Levine, and Balaraman Ravindran. EPOpt: Learning Robust Neural Network Policies Using Model Ensembles. arXiv preprint arXiv:1610.01283, 2016.
[27] Stephane Ross and J. Andrew Bagnell. Agnostic system identification for model-based reinforcement learning. In In ICML, 2012.
[28] Andrei A Rusu, Matej Vecerik, Thomas Rothörl, Nicolas Heess, Razvan Pascanu, and Raia Hadsell. Sim-to-real robot learning from pixels with progressive nets. arXiv preprint arXiv:1610.04286, 2016.
[29] John Schulman, Sergey Levine, Philipp Moritz, Michael I Jordan, and Pieter Abbeel. Trust region policy optimization. CoRR, abs/1502.05477, 2015.
[30] John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-dimensional continuous control using generalized advantage estimation. arXiv preprint arXiv:1506.02438, 2015.
[31] David Silver, Guy Lever, Nicolas Heess, Thomas Degris, Daan Wierstra, and Martin A. Riedmiller. Deterministic Policy Gradient Algorithms. In ICML, 2014.
[32] Freek Stulp, Gennaro Raiola, Antoine Hoarau, Serena Ivaldi, and Olivier Sigaud. Learning compact parameterized skills with a single regression. In Humanoid Robots (Humanoids), 2013 13th IEEE-RAS International Conference on, pages 417-422. IEEE, 2013.
[33] István Szita, Bálint Takács, and András Lörincz. $\varepsilon$ MDPs: Learning in varying environments. Journal of Machine Learning Research, 3(Aug):145-174, 2002.
[34] Juan Cristobal Zagal, Javier Ruiz-del-Solar, and Paul Vallejos. Back-to-Reality: Crossing the Reality Gap in Evolutionary Robotics. In IAV 2004: Proceedings 5th IFAC Symposium on Intelligent Autonomous Vehicles. Elsevier Science Publishers B.V., 2004. ISBN 008-044237-4.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ Supplementary video at https://youtu.be/dwyuScnPNME&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>