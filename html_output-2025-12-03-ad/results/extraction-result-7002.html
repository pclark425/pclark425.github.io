<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-7002 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-7002</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-7002</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-135.html">extraction-schema-135</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <p><strong>Paper ID:</strong> paper-210981845</p>
                <p><strong>Paper Title:</strong> <a href="https://www.aclweb.org/anthology/2020.tacl-1.2.pdf" target="_blank">AMR-To-Text Generation with Graph Transformer</a></p>
                <p><strong>Paper Abstract:</strong> Abstract meaning representation (AMR)-to-text generation is the challenging task of generating natural language texts from AMR graphs, where nodes represent concepts and edges denote relations. The current state-of-the-art methods use graph-to-sequence models; however, they still cannot significantly outperform the previous sequence-to-sequence models or statistical approaches. In this paper, we propose a novel graph-to-sequence model (Graph Transformer) to address this task. The model directly encodes the AMR graphs and learns the node representations. A pairwise interaction function is used for computing the semantic relations between the concepts. Moreover, attention mechanisms are used for aggregating the information from the incoming and outgoing neighbors, which help the model to capture the semantic information effectively. Our model outperforms the state-of-the-art neural approach by 1.5 BLEU points on LDC2015E86 and 4.8 BLEU points on LDC2017T10 and achieves new state-of-the-art performances.</p>
                <p><strong>Cost:</strong> 0.015</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e7002.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e7002.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Linearized AMR (Konstas)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Linearized Abstract Meaning Representation (as in Konstas et al., 2017)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A linear token sequence serialization of an AMR graph used as input to sequence-to-sequence models (RNN or Transformer); referenced and used as the baseline input representation in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural AMR: Sequence-to-sequence models for parsing and generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Konstas linearization (AMR → token sequence)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>An AMR graph is serialized into a single token sequence according to the linearization procedure of Konstas et al. (2017) and used as the input sequence to standard seq2seq or Transformer models; this linearized string encodes nodes, edges (labels), and nesting/structure via tokens in a sequence format.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>sequential / token‑based (lossy with respect to explicit graph adjacency unless kept via markers)</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Linearization as per Konstas et al. (2017) (the paper states it uses the same linearization but does not detail the full traversal algorithm)</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2015E86 and LDC2017T10 (and Gigaword-derived auto-labeled data when used as external data)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AMR‑to‑text generation (graph‑to‑text)</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Transformer (baseline using linearized AMR); also used by prior S2S models (S2S+Anon, S2S+Copy)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Original Transformer architecture (encoder‑decoder attention stacks) applied to the linearized AMR sequence as input for generation; compared with RNN-based seq2seq models reported in literature.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU (primary) and CHRF++ (reported elsewhere for some models)</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>Transformer (linearized input) reported in this paper: BLEU 17.7 (trained on gold LDC2015E86 only); with 2M Gigaword auto-labeled external data, Transformer (linearized) BLEU = 35.1 (Table 1). Comparable sequence models (from literature): S2S+Anon (gold) BLEU = 22.0; S2S+Anon (2M) = 32.3; S2S+Anon (20M) = 33.8.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>When training data are small, sequence models on linearized AMR (especially Transformer on long linearized inputs) underperform RNN-based S2S; with large automatically labeled external data, the Transformer on linearized AMR benefits strongly and performance improves substantially.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Potential loss of explicit graph structure (reentrancies/co‑references) and long linearized sequences that make self-attention harder to learn with limited data; can lead to omission of information and degraded fidelity to input semantics.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>Compared to direct graph encoders (Graph Transformer in this paper), linearized representations lose structural inductive biases and underperform on small gold datasets; however, with large amounts of external auto-labeled data, linearized Transformer models can approach or improve substantially (Transformer 35.1 with 2M vs Graph Transformer 36.4 with 2M).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7002.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e7002.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Anonymized linearization (S2S+Anon)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Anonymized linearized AMR representation (used by S2S+Anon)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A variant of linearized AMR where low-frequency items (named entities, rare tokens) are anonymized into placeholders before sequence modeling; commonly used to reduce data sparsity.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural AMR: Sequence-to-sequence models for parsing and generation</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Anonymized linearized AMR</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Apply anonymization to tokens in the linearized AMR sequence (replace names/rare tokens with placeholders) then serialize as a token sequence for input to seq2seq models; anonymized placeholders are typically recovered post-hoc.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>sequential / token‑based (lossy w.r.t. lexical surface forms but preserves structural tokens)</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Konstas-style linearization combined with anonymization of low-frequency tokens (per Konstas et al., 2017)</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2015E86 (gold) and Gigaword-derived auto-labeled data (2M, 20M variants in literature)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AMR‑to‑text generation</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>S2S+Anon (attention‑based BiLSTM seq2seq with anonymization)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>RNN-based encoder‑decoder with attention trained on anonymized linearized AMR input; anonymization reduces vocabulary sparsity for rare entities.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>S2S+Anon BLEU = 22.0 (gold); S2S+Anon (2M external) BLEU = 32.3; S2S+Anon (20M external) BLEU = 33.8 (reported from prior work and cited in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Anonymization helps handle low-frequency tokens and improves performance when combined with large external data; allows models to generalize over entity placeholders.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Requires post-processing to recover entity surface forms; anonymization can lose lexical specificity and relies on external alignment for de‑anonymization.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>Per the paper, S2S+Anon outperforms plain seq2seq baselines on gold-only training but is still outperformed by Graph Transformer on gold data; with large external data, anonymized S2S improves markedly but remains below Graph Transformer when both use the same external resources in reported experiments.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7002.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e7002.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Treeified AMR (reentrancy split)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Treeified AMR via splitting reentrancies (Tree2Str / t-GCNSEQ approach)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A technique that converts AMR graphs into trees by splitting reentrancies (duplicating nodes with multiple incoming edges) and then applies tree-to-string or tree-based encoders/linearizations for generation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Generation from abstract meaning representation using tree transducers</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Treeified AMR (reentrancy-splitting) → tree serialization</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Transform a directed AMR graph into a tree by splitting nodes with multiple incoming edges (reentrancies), then serialize or process with tree-to-string transducers or tree encoders; this yields a hierarchical tree-based sequence representation usable by tree transducers or stacked encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>hierarchical / sequential after tree conversion (lossy w.r.t. reentrancy semantics unless tracked separately)</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Split reentrancies to produce a tree, then apply tree‑to‑string transducer or serialize the tree for sequence models (method described in Flanigan et al. and used by t-GCNSEQ pipelines as cited).</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2015E86 (reported evaluations)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AMR‑to‑text generation</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Tree2Str (tree‑to‑string transducer), t-GCNSEQ (tree-encoded GCN+BiLSTM)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Tree2Str: grammar/tree-transducer-based statistical generation after tree conversion; t-GCNSEQ: structural encoder that stacks GCNs (on tree) then BiLSTM to capture sequence ordering.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>Tree2Str BLEU = 23.0 (Table 1); t-GCNSEQ reported BLEU ≈ 24.1 (on LDC2017T10 per Table 2 / cited works).</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Enables use of tree-specific generation machinery and structured statistical models; can be effective but requires handling duplicated nodes and alignment.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Splitting reentrancies loses the explicit graph reentrancy (co‑reference/control) structure unless extra bookkeeping is used; may introduce duplication and alignment errors; can complicate modeling of genuine graph phenomena.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>Per this paper, Graph Transformer (direct graph encoder) outperforms Tree2Str and other treeified approaches, suggesting direct graph encoders better preserve semantics especially when reentrancies matter.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7002.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e7002.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PBMT on linearized AMR</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Phrase-Based Machine Translation using linearized AMR input (Pourdamghani et al., 2016)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A phrase‑based statistical MT system that treats a linearized AMR graph as source text for translation into surface sentences, often augmented with an external language model trained on Gigaword.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Generating English from abstract meaning representations</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Linearized AMR for phrase-based MT</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>The AMR graph is serialized into a linear representation which is fed into a phrase‑based MT pipeline (PBMT) as the source side; a separate language model (often trained on Gigaword) is used to improve fluency.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>sequential / token‑based (lossy w.r.t. graph unless special tokens retained)</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Linearization of AMR graph (as used in Konstas and prior works); used as input text to phrase-based SMT.</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>LDC2014T12 / LDC2015E86 (PBMT trained on earlier corpus version as reported)</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AMR‑to‑text generation</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>PBMT (phrase-based statistical machine translation) with LM trained on Gigaword</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A phrase-based SMT system that learns phrase translations from linearized AMR source to target sentences; leverages an external Gigaword-trained language model for fluency.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>PBMT BLEU = 26.9 (Table 1) — note PBMT also used Gigaword LM whereas some neural runs did not.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Using linearized AMR as SMT source allows leveraging mature phrase-based pipelines and large external LMs, giving strong baseline performance especially with extra language-model data.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Relies on linearization and alignments between graph tokens and surface tokens; susceptible to error accumulation from automatic alignments; may not model graph structure as naturally as graph encoders.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>PBMT with external language modeling remains competitive with neural models on limited gold data; Graph Transformer outperforms PBMT in some configurations despite PBMT using extra LM data.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e7002.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e7002.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of graph-to-text representations used to convert graphs into textual sequences for language model training, including their description, encoding method, properties, datasets, models, evaluation metrics, performance outcomes, and any reported advantages or limitations.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Gigaword auto-labeled AMR (JAMR)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Gigaword corpus automatically parsed into AMR graphs by JAMR (used as external training data)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A large external English news corpus (Gigaword) parsed automatically with the JAMR AMR parser to produce additional AMR→sentence training pairs for pretraining and fine‑tuning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>representation_name</strong></td>
                            <td>Automatically parsed AMR from Gigaword (JAMR outputs) → linearized AMR sequences</td>
                        </tr>
                        <tr>
                            <td><strong>representation_description</strong></td>
                            <td>Gigaword sentences are parsed by an automatic AMR parser (JAMR) to produce AMR graphs; those graphs are then linearized (per Konstas or dataset pipeline) to produce large-scale training pairs for pretraining/fine-tuning generation models.</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>sequential / token‑based after linearization (noisy, automatically produced graphs)</td>
                        </tr>
                        <tr>
                            <td><strong>encoding_method</strong></td>
                            <td>Automatic AMR parsing (JAMR) of Gigaword sentences followed by the same linearization procedure used for gold AMR data</td>
                        </tr>
                        <tr>
                            <td><strong>canonicalization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>average_token_length</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>dataset_name</strong></td>
                            <td>Gigaword (2M and 20M subsets as cited), used together with LDC gold datasets</td>
                        </tr>
                        <tr>
                            <td><strong>task_name</strong></td>
                            <td>AMR‑to‑text generation pretraining / augmentation</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Used to pretrain sequence and graph models (e.g., S2S variants, Transformer, Graph Transformer)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Large-scale automatically labeled training set derived by parsing Gigaword with JAMR; used to pretrain or augment models to improve performance.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td>BLEU</td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td>Using 2M Gigaword auto-labeled instances: Graph Transformer BLEU = 36.4 (Table 1); Transformer (linearized, with 2M) BLEU = 35.1; S2S+Anon (2M) = 32.3; S2S+Anon (20M) = 33.8.</td>
                        </tr>
                        <tr>
                            <td><strong>impact_on_training</strong></td>
                            <td>Substantial positive effect — pretraining on large automatically-labeled Gigaword markedly improves BLEU for both linearized-sequence and graph-encoder models; Graph Transformer benefits and achieves state-of-the-art when combined with 2M Gigaword data.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations</strong></td>
                            <td>Automatically parsed AMRs are noisy and introduce labeling/parsing errors; quality depends on parser accuracy and can propagate noise into training.</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_with_other</strong></td>
                            <td>When both representation approaches (linearized seq and graph-encoder) use the same Gigaword auto-labeled data, the graph-encoder (Graph Transformer) still attains the best reported BLEU in this paper (36.4 with 2M) though linearized Transformer also gains large improvements.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural AMR: Sequence-to-sequence models for parsing and generation <em>(Rating: 2)</em></li>
                <li>Generation from abstract meaning representation using tree transducers <em>(Rating: 2)</em></li>
                <li>Generating English from abstract meaning representations <em>(Rating: 2)</em></li>
                <li>Graph-to-sequence learning using gated graph neural networks <em>(Rating: 1)</em></li>
                <li>Structural neural encoders for amr-to-text generation <em>(Rating: 1)</em></li>
                <li>A graph-to-sequence model for AMR-to-text generation <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-7002",
    "paper_id": "paper-210981845",
    "extraction_schema_id": "extraction-schema-135",
    "extracted_data": [
        {
            "name_short": "Linearized AMR (Konstas)",
            "name_full": "Linearized Abstract Meaning Representation (as in Konstas et al., 2017)",
            "brief_description": "A linear token sequence serialization of an AMR graph used as input to sequence-to-sequence models (RNN or Transformer); referenced and used as the baseline input representation in this paper.",
            "citation_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "mention_or_use": "use",
            "representation_name": "Konstas linearization (AMR → token sequence)",
            "representation_description": "An AMR graph is serialized into a single token sequence according to the linearization procedure of Konstas et al. (2017) and used as the input sequence to standard seq2seq or Transformer models; this linearized string encodes nodes, edges (labels), and nesting/structure via tokens in a sequence format.",
            "representation_type": "sequential / token‑based (lossy with respect to explicit graph adjacency unless kept via markers)",
            "encoding_method": "Linearization as per Konstas et al. (2017) (the paper states it uses the same linearization but does not detail the full traversal algorithm)",
            "canonicalization": null,
            "average_token_length": null,
            "dataset_name": "LDC2015E86 and LDC2017T10 (and Gigaword-derived auto-labeled data when used as external data)",
            "task_name": "AMR‑to‑text generation (graph‑to‑text)",
            "model_name": "Transformer (baseline using linearized AMR); also used by prior S2S models (S2S+Anon, S2S+Copy)",
            "model_description": "Original Transformer architecture (encoder‑decoder attention stacks) applied to the linearized AMR sequence as input for generation; compared with RNN-based seq2seq models reported in literature.",
            "performance_metric": "BLEU (primary) and CHRF++ (reported elsewhere for some models)",
            "performance_value": "Transformer (linearized input) reported in this paper: BLEU 17.7 (trained on gold LDC2015E86 only); with 2M Gigaword auto-labeled external data, Transformer (linearized) BLEU = 35.1 (Table 1). Comparable sequence models (from literature): S2S+Anon (gold) BLEU = 22.0; S2S+Anon (2M) = 32.3; S2S+Anon (20M) = 33.8.",
            "impact_on_training": "When training data are small, sequence models on linearized AMR (especially Transformer on long linearized inputs) underperform RNN-based S2S; with large automatically labeled external data, the Transformer on linearized AMR benefits strongly and performance improves substantially.",
            "limitations": "Potential loss of explicit graph structure (reentrancies/co‑references) and long linearized sequences that make self-attention harder to learn with limited data; can lead to omission of information and degraded fidelity to input semantics.",
            "comparison_with_other": "Compared to direct graph encoders (Graph Transformer in this paper), linearized representations lose structural inductive biases and underperform on small gold datasets; however, with large amounts of external auto-labeled data, linearized Transformer models can approach or improve substantially (Transformer 35.1 with 2M vs Graph Transformer 36.4 with 2M).",
            "uuid": "e7002.0"
        },
        {
            "name_short": "Anonymized linearization (S2S+Anon)",
            "name_full": "Anonymized linearized AMR representation (used by S2S+Anon)",
            "brief_description": "A variant of linearized AMR where low-frequency items (named entities, rare tokens) are anonymized into placeholders before sequence modeling; commonly used to reduce data sparsity.",
            "citation_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "mention_or_use": "mention",
            "representation_name": "Anonymized linearized AMR",
            "representation_description": "Apply anonymization to tokens in the linearized AMR sequence (replace names/rare tokens with placeholders) then serialize as a token sequence for input to seq2seq models; anonymized placeholders are typically recovered post-hoc.",
            "representation_type": "sequential / token‑based (lossy w.r.t. lexical surface forms but preserves structural tokens)",
            "encoding_method": "Konstas-style linearization combined with anonymization of low-frequency tokens (per Konstas et al., 2017)",
            "canonicalization": null,
            "average_token_length": null,
            "dataset_name": "LDC2015E86 (gold) and Gigaword-derived auto-labeled data (2M, 20M variants in literature)",
            "task_name": "AMR‑to‑text generation",
            "model_name": "S2S+Anon (attention‑based BiLSTM seq2seq with anonymization)",
            "model_description": "RNN-based encoder‑decoder with attention trained on anonymized linearized AMR input; anonymization reduces vocabulary sparsity for rare entities.",
            "performance_metric": "BLEU",
            "performance_value": "S2S+Anon BLEU = 22.0 (gold); S2S+Anon (2M external) BLEU = 32.3; S2S+Anon (20M external) BLEU = 33.8 (reported from prior work and cited in this paper).",
            "impact_on_training": "Anonymization helps handle low-frequency tokens and improves performance when combined with large external data; allows models to generalize over entity placeholders.",
            "limitations": "Requires post-processing to recover entity surface forms; anonymization can lose lexical specificity and relies on external alignment for de‑anonymization.",
            "comparison_with_other": "Per the paper, S2S+Anon outperforms plain seq2seq baselines on gold-only training but is still outperformed by Graph Transformer on gold data; with large external data, anonymized S2S improves markedly but remains below Graph Transformer when both use the same external resources in reported experiments.",
            "uuid": "e7002.1"
        },
        {
            "name_short": "Treeified AMR (reentrancy split)",
            "name_full": "Treeified AMR via splitting reentrancies (Tree2Str / t-GCNSEQ approach)",
            "brief_description": "A technique that converts AMR graphs into trees by splitting reentrancies (duplicating nodes with multiple incoming edges) and then applies tree-to-string or tree-based encoders/linearizations for generation.",
            "citation_title": "Generation from abstract meaning representation using tree transducers",
            "mention_or_use": "mention",
            "representation_name": "Treeified AMR (reentrancy-splitting) → tree serialization",
            "representation_description": "Transform a directed AMR graph into a tree by splitting nodes with multiple incoming edges (reentrancies), then serialize or process with tree-to-string transducers or tree encoders; this yields a hierarchical tree-based sequence representation usable by tree transducers or stacked encoders.",
            "representation_type": "hierarchical / sequential after tree conversion (lossy w.r.t. reentrancy semantics unless tracked separately)",
            "encoding_method": "Split reentrancies to produce a tree, then apply tree‑to‑string transducer or serialize the tree for sequence models (method described in Flanigan et al. and used by t-GCNSEQ pipelines as cited).",
            "canonicalization": null,
            "average_token_length": null,
            "dataset_name": "LDC2015E86 (reported evaluations)",
            "task_name": "AMR‑to‑text generation",
            "model_name": "Tree2Str (tree‑to‑string transducer), t-GCNSEQ (tree-encoded GCN+BiLSTM)",
            "model_description": "Tree2Str: grammar/tree-transducer-based statistical generation after tree conversion; t-GCNSEQ: structural encoder that stacks GCNs (on tree) then BiLSTM to capture sequence ordering.",
            "performance_metric": "BLEU",
            "performance_value": "Tree2Str BLEU = 23.0 (Table 1); t-GCNSEQ reported BLEU ≈ 24.1 (on LDC2017T10 per Table 2 / cited works).",
            "impact_on_training": "Enables use of tree-specific generation machinery and structured statistical models; can be effective but requires handling duplicated nodes and alignment.",
            "limitations": "Splitting reentrancies loses the explicit graph reentrancy (co‑reference/control) structure unless extra bookkeeping is used; may introduce duplication and alignment errors; can complicate modeling of genuine graph phenomena.",
            "comparison_with_other": "Per this paper, Graph Transformer (direct graph encoder) outperforms Tree2Str and other treeified approaches, suggesting direct graph encoders better preserve semantics especially when reentrancies matter.",
            "uuid": "e7002.2"
        },
        {
            "name_short": "PBMT on linearized AMR",
            "name_full": "Phrase-Based Machine Translation using linearized AMR input (Pourdamghani et al., 2016)",
            "brief_description": "A phrase‑based statistical MT system that treats a linearized AMR graph as source text for translation into surface sentences, often augmented with an external language model trained on Gigaword.",
            "citation_title": "Generating English from abstract meaning representations",
            "mention_or_use": "mention",
            "representation_name": "Linearized AMR for phrase-based MT",
            "representation_description": "The AMR graph is serialized into a linear representation which is fed into a phrase‑based MT pipeline (PBMT) as the source side; a separate language model (often trained on Gigaword) is used to improve fluency.",
            "representation_type": "sequential / token‑based (lossy w.r.t. graph unless special tokens retained)",
            "encoding_method": "Linearization of AMR graph (as used in Konstas and prior works); used as input text to phrase-based SMT.",
            "canonicalization": null,
            "average_token_length": null,
            "dataset_name": "LDC2014T12 / LDC2015E86 (PBMT trained on earlier corpus version as reported)",
            "task_name": "AMR‑to‑text generation",
            "model_name": "PBMT (phrase-based statistical machine translation) with LM trained on Gigaword",
            "model_description": "A phrase-based SMT system that learns phrase translations from linearized AMR source to target sentences; leverages an external Gigaword-trained language model for fluency.",
            "performance_metric": "BLEU",
            "performance_value": "PBMT BLEU = 26.9 (Table 1) — note PBMT also used Gigaword LM whereas some neural runs did not.",
            "impact_on_training": "Using linearized AMR as SMT source allows leveraging mature phrase-based pipelines and large external LMs, giving strong baseline performance especially with extra language-model data.",
            "limitations": "Relies on linearization and alignments between graph tokens and surface tokens; susceptible to error accumulation from automatic alignments; may not model graph structure as naturally as graph encoders.",
            "comparison_with_other": "PBMT with external language modeling remains competitive with neural models on limited gold data; Graph Transformer outperforms PBMT in some configurations despite PBMT using extra LM data.",
            "uuid": "e7002.3"
        },
        {
            "name_short": "Gigaword auto-labeled AMR (JAMR)",
            "name_full": "Gigaword corpus automatically parsed into AMR graphs by JAMR (used as external training data)",
            "brief_description": "A large external English news corpus (Gigaword) parsed automatically with the JAMR AMR parser to produce additional AMR→sentence training pairs for pretraining and fine‑tuning.",
            "citation_title": "",
            "mention_or_use": "use",
            "representation_name": "Automatically parsed AMR from Gigaword (JAMR outputs) → linearized AMR sequences",
            "representation_description": "Gigaword sentences are parsed by an automatic AMR parser (JAMR) to produce AMR graphs; those graphs are then linearized (per Konstas or dataset pipeline) to produce large-scale training pairs for pretraining/fine-tuning generation models.",
            "representation_type": "sequential / token‑based after linearization (noisy, automatically produced graphs)",
            "encoding_method": "Automatic AMR parsing (JAMR) of Gigaword sentences followed by the same linearization procedure used for gold AMR data",
            "canonicalization": null,
            "average_token_length": null,
            "dataset_name": "Gigaword (2M and 20M subsets as cited), used together with LDC gold datasets",
            "task_name": "AMR‑to‑text generation pretraining / augmentation",
            "model_name": "Used to pretrain sequence and graph models (e.g., S2S variants, Transformer, Graph Transformer)",
            "model_description": "Large-scale automatically labeled training set derived by parsing Gigaword with JAMR; used to pretrain or augment models to improve performance.",
            "performance_metric": "BLEU",
            "performance_value": "Using 2M Gigaword auto-labeled instances: Graph Transformer BLEU = 36.4 (Table 1); Transformer (linearized, with 2M) BLEU = 35.1; S2S+Anon (2M) = 32.3; S2S+Anon (20M) = 33.8.",
            "impact_on_training": "Substantial positive effect — pretraining on large automatically-labeled Gigaword markedly improves BLEU for both linearized-sequence and graph-encoder models; Graph Transformer benefits and achieves state-of-the-art when combined with 2M Gigaword data.",
            "limitations": "Automatically parsed AMRs are noisy and introduce labeling/parsing errors; quality depends on parser accuracy and can propagate noise into training.",
            "comparison_with_other": "When both representation approaches (linearized seq and graph-encoder) use the same Gigaword auto-labeled data, the graph-encoder (Graph Transformer) still attains the best reported BLEU in this paper (36.4 with 2M) though linearized Transformer also gains large improvements.",
            "uuid": "e7002.4"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural AMR: Sequence-to-sequence models for parsing and generation",
            "rating": 2,
            "sanitized_title": "neural_amr_sequencetosequence_models_for_parsing_and_generation"
        },
        {
            "paper_title": "Generation from abstract meaning representation using tree transducers",
            "rating": 2,
            "sanitized_title": "generation_from_abstract_meaning_representation_using_tree_transducers"
        },
        {
            "paper_title": "Generating English from abstract meaning representations",
            "rating": 2,
            "sanitized_title": "generating_english_from_abstract_meaning_representations"
        },
        {
            "paper_title": "Graph-to-sequence learning using gated graph neural networks",
            "rating": 1,
            "sanitized_title": "graphtosequence_learning_using_gated_graph_neural_networks"
        },
        {
            "paper_title": "Structural neural encoders for amr-to-text generation",
            "rating": 1,
            "sanitized_title": "structural_neural_encoders_for_amrtotext_generation"
        },
        {
            "paper_title": "A graph-to-sequence model for AMR-to-text generation",
            "rating": 1,
            "sanitized_title": "a_graphtosequence_model_for_amrtotext_generation"
        }
    ],
    "cost": 0.01511475,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>AMR-To-Text Generation with Graph Transformer</p>
<p>Tianming Wang wangtm@pku.edu.cn 
The MOE Key Laboratory of Computational Linguistics
Wangxuan Institute of Computer Technology
Peking University
Peking University</p>
<p>Xiaojun Wan wanxiaojun@pku.edu.cn 
The MOE Key Laboratory of Computational Linguistics
Wangxuan Institute of Computer Technology
Peking University
Peking University</p>
<p>Hanqi Jin jinhanqi@pku.edu.cn 
The MOE Key Laboratory of Computational Linguistics
Wangxuan Institute of Computer Technology
Peking University
Peking University</p>
<p>AMR-To-Text Generation with Graph Transformer
10.1162/tacl
meaning representation (AMR)-totext generation is the challenging task of generating natural language texts from AMR graphs, where nodes represent concepts and edges denote relations. The current state-of-the-art methods use graph-to-sequence models; however, they still cannot significantly outperform the previous sequence-to-sequence models or statistical approaches. In this paper, we propose a novel graph-to-sequence model (Graph Transformer) to address this task. The model directly encodes the AMR graphs and learns the node representations. A pairwise interaction function is used for computing the semantic relations between the concepts. Moreover, attention mechanisms are used for aggregating the information from the incoming and outgoing neighbors, which help the model to capture the semantic information effectively. Our model outperforms the state-of-the-art neural approach by 1.5 BLEU points on LDC2015E86 and 4.8 BLEU points on LDC2017T10 and achieves new state-of-the-art performances.</p>
<p>Introduction</p>
<p>Abstract meaning representation (AMR) is a semantic formalism that abstracts away from the syntactic realization of a sentence, and encodes its definition as a rooted, directed, and acyclic graph. In the graph, the nodes represent the concepts, and edges denote the relations between the concepts. The root of an AMR binds its contents to a single traversable graph and serves as a rudimentary representation of the overall focus. The existence of co-references and control structures results in nodes with multiple incoming edges, called reentrancies, and causes an AMR to possess a graph structure, instead of a tree structure. Numerous natural language processing (NLP) tasks can benefit from using AMR, such as machine translation (Jones et al., 2012;Song et al., 2019), question answering (Mitra and Baral, 2016), summarization (Liu et al., 2015;Takase et al., 2016), and event extraction (Huang et al., 2016).</p>
<p>AMR-to-text generation is the task of recovering a text representing the same definition as a given AMR graph. Because the function words and structures are abstracted away, the AMR graph can correspond to multiple realizations. Numerous important details are underspecified, including tense, number, and definiteness, which makes this task extremely challenging (Flanigan et al., 2016). Figure 1 shows an example AMR graph and its corresponding sentence.</p>
<p>Early works relied on grammar-based or statistical approaches (Flanigan et al., 2016;Pourdamghani et al., 2016;Lampouras and Vlachos, 2017;Gruzitis et al., 2017). Such approaches generally require alignments between the graph nodes and surface tokens, which are automatically generated and can lead to error accumulation. In recent research, the graphs are first transformed into linear sequences, and then the text is generated from the inputs (Konstas et al., 2017). Such a method may lose information from the graph structure. The current state-of-theart neural methods are graph-to-sequence models and hybrid variants (Beck et al., 2018;Song et al., 2018;Damonte and Cohen, 2019). These methods use a graph state long short-term memory (LSTM) network, gated graph neural network (GGNN), or graph convolution network (GCN) to encode AMR graphs directly, and they can explicitly utilize the information provided by the graph structure. However, these graph encoders still cannot significantly outperform sequence encoders. The AMR-to-text generation task can be regarded as a distinct translation task, and basing it on the concepts of off-the-shelf methods Figure 1: An example AMR graph and its corresponding sentence. The graph is rooted by ''expect-01'', which means the AMR is about the expecting. The node ''create'' is a reentrance and it plays two roles simultaneously (i.e., ''ARG1'' of ''accelerate'' and ''ARG1'' of ''slow-down'').</p>
<p>for neural machine translation can be helpful. The Transformer model (Vaswani et al., 2017) is a stacked attention architecture and has shown its effectiveness in translation tasks; however, applying it to AMR-to-text generation has a major problem: It can only deal with sequential inputs.</p>
<p>To address these issues, we propose a novel graph network (Graph Transformer) for AMRto-text generation. Graph Transformer is an adaptation of the Transformer model, and it has a stacked attention-based encoder-decoder architecture. The encoder considers the AMR graph as the input and learns the node representations from the node attributes by the aggregation of the neighborhood information. The global semantic information is captured by stacked graph attention layers, which allow a node to deal with the hidden states of the neighbor nodes and their corresponding relations. Multiple stacked graph attention layers enable the nodes to utilize the information of those nodes that are not directly adjacent, allowing the global information to propagate. We consider that the AMR graph is a directed graph in which the directions hold extremely important information. Therefore, for encoding the information from the incoming and outgoing edges, we use two individual graph attentions in each layer. Then we utilize a fusion layer to incorporate the information from the incoming and outgoing relations, followed by a feed-forward network. Residual connections are used for connecting adjacent layers. The final node representations are formed by concatenating the two individual representations encoded by multiple layers. The decoder is similar to the original decoder in Transformer, performing multi-head attentions and self-attentions over the representations of the nodes in the encoder and over the hidden states of the decoder, respectively. For the decoder stack, we adopt a copy mechanism to generate the texts, which can help copy low-frequency tokens, such as named entities and numbers.</p>
<p>We perform experiments on two benchmark datasets (LDC2015E86 and LDC2017T10). Our model significantly outperforms the prior methods and achieves a new state-of-the-art performance. Without external data, our model improves the BLEU scores of the state-of-the-art and a mostly recently proposed neural model (i.e., g-GCNSEQ [Damonte and Cohen, 2019]) by 1.5 points on LDC2015E86 and 4.8 points on LDC2017T10. When using the Gigaword corpus as the additional training data, which is automatically labeled by a pre-trained AMR parser, our model achieves a BLEU score of 36.4 on LDC2015E86, which is the highest result on the dataset. The experimental result also shows that the improved structural representation encoding by our proposed graph encoder is most useful when the amount of training data is small. The variations in our model are evaluated to verify its robustness as well as the importance of the proposed modules. In addition, we study the performances of our model and baselines under different structures of the input graphs.</p>
<p>Our contributions can be summarized as follows:</p>
<p>• For AMR-to-text generation, we propose Graph Transformer, a novel graph-tosequence model based on the attention mechanism. Our model uses a pairwise interaction function to compute the semantic relations and uses separate graph attentions on the incoming and outgoing neighbors, which help in enhanced capturing of the semantic information provided in the graph. The code is available at https://github. com/sodawater/GraphTransformer.</p>
<p>• The experimental results show that our model achieves a new state-of-the-art performance on benchmark datasets. 20</p>
<p>AMR-to-Text Generation</p>
<p>Early work on AMR-to-text generation focused on statistical methods. Flanigan et al. (2016) transformed AMR graphs to appropriate spanning trees and applied tree-to-string transducers to generate texts. Song et al. (2016) partitioned an AMR graph into small fragments and generated the translations for all the fragments, whose order was finally decided by solving an asymmetric generalized traveling salesman problem. Song et al. (2017) used synchronous node replacement grammar to parse AMR graphs and generate output sentences. Pourdamghani et al. (2016) adopted a phrase-based machine translation model on the input of a linearized graph. Recent works propose using neural networks for generation. Konstas et al. (2017) used a sequence-to-sequence model to generate texts, leveraging an LSTM for encoding a linearized AMR structure. Graph-to-sequence models outperform sequence-to-sequence models, including a graph state LSTM (Song et al., 2018) and GGNN (Beck et al., 2018). A most recently developed hybrid neural model achieved the stateof-the-art performance by applying a BiLSTM on the output of a graph encoder GCN, to utilize both structural and sequential information (Damonte and Cohen, 2019).</p>
<p>Neural Networks for Graphs</p>
<p>Neural network methods for processing the data represented in graph domains have been studied for several years. Graph neural networks (GNNs) have also been proposed, which are an extension of recursive neural networks and can be applied to most of the practically useful types of graphs (Gori et al., 2005;Scarselli et al., 2009). GCNs are the main alternatives for neural-based graph representations, and are widely used to address various problems (Bruna et al., 2014;Duvenaud et al., 2015;Kipf and Welling, 2017). Li et al. (2015) further extended a GNN and modified it to use gated recurrent units for processing the data represented in graphs; this method is known as a GGNN. Beck et al. (2018) followed their concept and applied a GGNN to string generation. Another neural architecture based on gated units is the graph state LSTM (Song et al., 2018), which uses an LSTM structure for encoding graph-level semantics. Our model is most similar to graph attention networks (GATs) (Velickovic et al., 2018); it incorporates the attention mechanism in the information aggregation.</p>
<p>Transformer Network</p>
<p>Recurrent neural networks (RNNs) and convolution neural networks (CNNs) have been widely used in NLP tasks because of their advantages of capturing long-term and local dependencies, respectively. Compared with these networks, models based solely on the attention mechanism show superiority in terms of the parallelism and flexibility in the modeling dependencies. </p>
<p>Graph Transformer</p>
<p>The overall architecture of Graph Transformer is shown in Figure 2, with an example AMR graph and its corresponding sentence. We begin by providing the formal definition of the AMRto-text generation and the notations we use, and then reviewing the Transformer model. Then we introduce the graph encoder and sentence decoder used in our model. Finally, we describe the training and decoding procedures.</p>
<p>Problem Formulation and Notations</p>
<p>Given an AMR graph, G, our goal is to generate a natural language sentence that represents the same definition as G. Our model is trained to maximize the probability, P (S|G), where S is the gold sentence.</p>
<p>In the following, we define the notations used in this study. We assume a directed graph, G = (V, E), where V is a set of N nodes, E is a set of M edges, and N and M are the numbers of nodes and edges, respectively. Each edge in E can be represented as (i, j, l), where i and j are the indices of the source and target nodes, respectively, and l is the edge label. We further denote the incoming neighborhoods (i.e., reached by an incoming edge) of node v i ∈ V Figure 2: Left: Graph attention mechanism. We take the node ''accelerate'' in Figure 1 as an example. Head representation is marked with yellow and tail representation is marked with blue. The node ''accelerate'' has one incoming relation and two outgoing relations to be attend respectively; Right: The overall architecture of our proposed Graph Transformer.</p>
<p>as N in i and outgoing neighborhoods (i.e., reached by an outgoing edge) as N out i . The corresponding sentence is S = {s 1 , s 2 , ..., s T }, where s i is the i-th token of the sentence and T is the number of the tokens.</p>
<p>Transformer</p>
<p>Our model is adapted from the Transformer model, and here, we briefly review this model. The original Transformer network uses an encoderdecoder architecture, with each layer consisting of a multi-head attention mechanism and a feedforward network. Both the components are described here.</p>
<p>The multi-head attention mechanism builds on scaled dot-product attention, which operates on a package of queries Q and keys K of dimension
d k and values V of dimension d v , Attention(Q, K, V ) = softmax( QK √ d k )V (1)
The multi-head attention linearly projects d model -dimensional queries, keys, and values d h times with different projections, and it performs scaled dot-product attention on each projected pair. The outputs of the attention are concatenated and again projected, resulting in the final output,
head x = Attention(QW x q , KW x k , V W x v ) MultiHead(Q, K, V ) = d h x=1 head x W o (2) where denotes the concatenation of the d h attention heads. Projection matrices W x q ∈ R d k ×d model , W x k ∈ R d k ×d model , W x v ∈ R d v ×d model , and W o ∈ R d h * d v ×d model . d k = d v = d model /d h .
The other component of each layer is a feed-forward network. It consists of two linear transformations, with a ReLU activation in between.
FFN(x) = max(0, xW 1 + b 1 )W 2 + b 2(3)
For constructing a deep network and regularization, a residual connection and layer normalization are used to connect adjacent layers.</p>
<p>Graph Encoder</p>
<p>Our model also has an encoder-decoder architecture. In our model, the graph encoder is composed of a stack of L 1 identical graph layers that use different parameters from layer to layer. Each layer has three sub-layers: a graph attention mechanism, fusion layer, and feed-forward network. The encoder takes the nodes as the input and learns the node representations by aggregating the neighborhood information. Considering that an AMR graph is a directed graph, our model learns two distinct representations for each node. The first is a head representation, which represents a node when it works as a head node (i.e., a source node) in a semantic relation and only aggregates the information from the outgoing edges and corresponding nodes. The second is a tail representation, which represents a node when it works as a tail node (i.e., a target node) and only aggregates the information from the outgoing edges and corresponding nodes. Specifically, we denote − → h t i and ← − h t i as the head representation and tail representation of each node v i at the t-th layer, respectively. The embedding of each node (i.e., the word embedding of the concept) is fed to the graph encoder as the initial hidden state of the node,
− → h 0 i = ← − h 0 i = e i W e + b e(4)
where e i is the embedding of node v i , W e ∈ R d emb ×d model and b e ∈ R d model are the parameters, and d emb is the dimension of the embedding. Different from previous methods, we propose using graph attention as the aggregator, instead of a gated unit or pooling layer. In an AMR graph, the semantic representation of a node is determined by its own concept definition and relations to other concepts. Graph attention is used for capturing such global semantic information in a graph. Specifically, it allows each node to deal with the triples that are composed of the embeddings of the neighbor nodes, embeddings of the corresponding edges, and its own embedding. We represent the triple of two adjacent nodes connected by edge (i, j, l) as
r t ij = − → h t−1 i e l ← − h t−1 j W r + b r (5) r t ij = − → h t−1 i e l ← − h t−1 j W r + b r , (6) where e l ∈ R d model is the embedding of edge label l and − → h t−1 i e l ← − h t−1 j
is the concatenation of these three representations. W r ∈ R 3d model ×d model and b r ∈ R d model are the parameters. r t ij is the representations of the triple, which will be deal with both source node v i and target node v j .</p>
<p>Using such a pairwise-interaction function to compute a relation has three advantages: 1) it does not encounter the parameter explosion problem (Beck et al., 2018) because the linear transformation for the triple is independent of the edge label, 2) the edge information is encoded by edge embedding so that there is no loss of information, and 3) the representation incorporates the context information of the nodes. Then we perform graph attentions over the incoming and outgoing relations (i.e., incoming and outgoing edges and the corresponding nodes). The multihead graph attentions for node v i are computed as
− → g t i = d h x=1 ⎛ ⎝ j∈N out i α x ij r t ij W x v ⎞ ⎠ W o α x ij = exp − → h t−1 i W x q ·(r t ij W x k ) √ d k z∈N out i exp − → h t−1 i W x q ·(r t iz W x k ) √ d k (7)
where − → g t i is the output of the graph attention on the outgoing relations for node v i . Similarly, ← − g t i is computed over all the incoming relations.</p>
<p>Following the graph attention sub-layer, we use a fusion layer to incorporate the information aggregated from the incoming and outgoing relations.
s t i = sigmoid − → g t i ← − g t i W s + b s g t i = s t i * − → g t i + (1 − s t i ) * ← − g t i (8) where W s ∈ R 2 * d model ×1 and b s ∈ R 1 are the parameters.
The last sub-layer is a fully connected feedforward network, which is applied to each node separately and identically. We use a GeLU activation function instead of the standard ReLU activation. The dimensions of the input, inner layer, and output are d model , 4 * d model , and 2 * d model , respectively. The output is divided into two parts to obtain the head and tail representations, respectively. In addition, a residual connection is used to connect adjacent layers.</p>
<p>− →
O t ← − O t = F F N(G t ) − → H t = LayerNorm( − → O t + − → H t−1 ) ← − H t = LayerNorm( ← − O t + ← − H t−1 ) (9) where G t i is the package of outputs g t i . − → H t and ← − H t are the packages of head representation − → h t i and tail representation ← − h t i , respectively.
LayerN orm is the layer normalization. Note that using a residual connection and layer normalization around each layer in the graph encoder is more effective than using them around each of the three sub-layers for our model.</p>
<p>The final node representation is obtained by concatenating the forward and backward representations. A linear transformation layer is also used for compressing the dimension. For convenience, we denote h i as the final representation of node v i ,
h i = − → h L 1 i ← − h L 1 i W h(10)
where W h ∈ R 2d model ×d emb is a parameter and L 1 is the number of layers of the encoder stack.</p>
<p>Sentence Decoder</p>
<p>In our model, the decoder has an architecture similar to that in the original Transformer model, which is composed of L 2 identical layers. Each layer has three sub-layers: a multi-head self-attention mechanism, multi-head attention mechanism over the output of the encoder stack, and position-wise feed-forward network. A residual connection is used for connecting adjacent sub-layers. The decoder generates the natural language sentence, and we denote the hidden state at position i of the t-th layer in the decoder stack asĥ t i . Different from the input representation of the encoder, the position information is added and the sum of the embedding and position encoding is fed as the input,
h 0 i = e i W e + b e + pe i(11)
where e i and pe i ∈ R d model are the embedding and positional encoding of the token at position i, respectively. The self-attention sub-layer is used for encoding the information of the decoded subsequences. We use masking to ensure that the attention and prediction for position i depend only on the known words at positions preceding i,
A t = MultiHead(Ĥ t−1 ,Ĥ t−1 ,Ĥ t−1 ) B t = LayerNorm(A t +Ĥ t−1 )(12)
whereĤ t−1 is the package of hidden statesĥ t−1 i in the decoder. Next, the output of the self-attention is further fed into the multi-head attention and feed-forward network, expressed as follows:
A t = MultiHead(B t , H, H) B t = LayerNorm(Â t + B t ) O t = FFN(B t ) H t = LayerNorm(Ô t +B t )(13)
where H is the package of final node representations h i encoded by the graph encoder.</p>
<p>For convenience, we denote the final hidden state of the decoder at position i asĥ i . Considering that numerous low-frequency open-class tokens such as named entities and numbers in an AMR graph appear in the corresponding sentence, we adopt the copy mechanism (Gu et al., 2016) to solve the problem. A gate is used over the decoder stack for controlling the generation of words from the vocabulary or directly copying them from the graph, expressed as
θ i = σ(ĥ i W θ + b θ )(14)
where W θ ∈ R d model ×1 and b θ ∈ R 1 are the parameters. Probability distribution p g i of the words to be directly generated at time-step i is computed as
p g i = softmax(ĥ i W g + b g )(15)
where W g ∈ R d model ×d vocab and b g ∈ R d vocab are the parameters and d vocab is the vocabulary size. Probability distribution p c i of the words to be copied at time-step i is computed as
p c i = N i * =1 exp ĥ i · h i * N j * =1 exp ĥ i · h j * z i *(16)
where z i * is the one-hot vector of node v i * . The final probability distribution of the words at time-step i is the interpolation of two probabilities,
p i = θ i * p g i + (1 − θ i ) * p c i(17)</p>
<p>Training and Decoding</p>
<p>For the training, we aim to maximize the likelihood of each gold-standard output sequence, S, given the graph, G.
l(S|G) = T i=1 log P (s i |s i−1 , ..., s 1 , G, θ) (18)
whereθis the model parameter. P (s i |s i−1 , ..., s 1 , G, θ) corresponds to the probability score of word s i in p i computed by Eq. (16). We use the beam search to generate the target sentence during the decoding stage.</p>
<p>Comparison to Prior Graph Encoders</p>
<p>In this section, we compare our proposed graph encoders with the existing ones presented in prior works.</p>
<p>Most models, including a GCN (Damonte and Cohen, 2019), GGNN (Beck et al., 2018), and GraphLSTM (Song et al., 2018), use a nonpairwise interaction function to represent the information to be aggregated from the neighborhoods. Specifically, they ignore the receiver node (i.e., the node to be updated), operating only on the sender node (i.e., the neighbor node) and the edge attribute (Battaglia et al., 2018). They add a self-loop edge for each node so that its own information can be considered. In our model, we compute the pairwise interactions using Eq. (5); hence, no self-loop edge is required.</p>
<p>In our model, the graph attention mechanism is similar to GAT (Velickovic et al., 2018). The main differences are that GAT is designed for undirected graphs and neither directions nor labels of edges are considered. We propose using two distinct representations (i.e., head representation and tail representation) for each node and utilizing graph attentions on the incoming and outgoing relations. Accordingly, the model can consider the differences in the incoming and outgoing relations, and the results presented in the next section verify the effectiveness of this proposed modification. In addition, GAT adopts additive attention and uses averages of the outputs of the multi-head attention in the final layer. In our model, we use a scaled dot-product attention for all the attention layers.</p>
<p>Experiment</p>
<p>Data and Preprocessing</p>
<p>We used two standard AMR corpora (LDC2015E86 and LDC2017T10) as our experiment datasets. The LDC2015E86 dataset contains 16,833 instances for the training, 1,368 for the development, and 1,371 for the test. The LDC2017T10 dataset is the latest AMR corpus release, which contains 36,521 instances for the training and the same instances for the development and test as in LDC2015E86. Most prior works evaluate their models on the former dataset. Because prior approaches during the same period achieve the state-of-the-art performances on LDC2015E86 and LDC2017T10, respectively, we performed experiments on both the datasets.</p>
<p>Following Konstas et al. (2017), we supplemented the gold data with large-scale external data. We used the Gigaword corpus 1 released by Song et al. (2018) as the external data, which was automatically parsed by the JAMR. For the training on both the gold data and automatically labeled data, the same training strategy as that of Konstas et al. (2017) was adopted, which was fine-tuning the model on the gold data after each epoch of the pre-training on the Gigaword data.</p>
<p>Parameter Settings and Training Details</p>
<p>We set our model parameters based on preliminary experiments on the development set. d model is set to 256 and d emb is set to 300. The head number of attention is set to 2. The numbers (L 1 and L 2 ) of layers of the encoder and decoder are set to 8 and 6, respectively. The batch size is set to 64. We extract a vocabulary from the training set, which is shared by both the encoder and the decoder. The word embeddings are initialized from GloVe word embeddings (Pennington et al., 2014). We use the Adam optimizer (Kingma and Ba, 2015) with lr = 0.0002, β 1 = 0.9, β 2 = 0.98, and = 10 −9 . Learning rate is halved every time perplexity on the development set does not improve for two epochs. We apply dropout to the output of each attention sub-layer and the input embeddings, and use a rate of P drop = 0.3. Beam search with beam size to 6 is used for decoding. During training, we filter out instances with more than 100 nodes in graph or 100 words in sentence for speeding up. Note that d model is set to 512, the head number is set to 4, and the learning rate is set to 0.0001 when training on both gold data and automatically labeled data.</p>
<p>Metrics and Baselines</p>
<p>Following existing works, we evaluate the results with the BLEU metric (Papineni et al., 2002). We also report the results using CHRF++ (Popović, 2017), similar to Beck et al. (2018).</p>
<p>Our direct baseline is the original Transformer, which takes a linearized graph as the input. We use the same linearization as that by Konstas et al. (2017). We also compare our model with prior statistical approaches (PBMT, Tree2Str, and TSP), sequence-to-sequence approaches (S2S+Anon and S2S+Copy), the current state-of-the-art Methods BLEU PBMT (Pourdamghani et al., 2016) 26.9 Tree2Str (Flanigan et al., 2016) 23.0 TSP (Song et al., 2016) 22.4 S2S+Anon (Konstas et al., 2017) 22.0 GraphLSTM (Song et al., 2018) 23.3 t-GCNSEQ (Damonte and Cohen, 2019) 23.9 g-GCNSEQ (Damonte and Cohen, 2019) 24.4 Transformer 17.7 Graph Transformer 25.9 S2S+Anon (2M) (Konstas et al., 2017) 32.3 S2S+Anon (20M) (Konstas et al., 2017) 33.8 S2S+Copy (2M) (Song et al., 2018) 31.7 GraphLSTM (2M) (Song et al., 2018) 33.6 Transformer (2M) 35.1 Graph Transformer (2M) 36.4 Table 1: Test results of models. ''(2M)'' / ''(20M)'' denotes using the corresponding number of automatically labeled Gigaword data instances as additional training data.</p>
<p>graph-to-sequence approaches (GraphLSTM and GGNN), and hybrid approaches (t-GCNSEQ and g-GCNSEQ). PBMT (Pourdamghani et al., 2016) adopts a phrased-based machine translation model with the input of a linearized AMR graph. Tree2Str (Flanigan et al., 2016) converts AMR graphs into trees by splitting the reentrants and applies a treeto-string transducer to generate text. TSP (Song et al., 2016) solves the generation problem as a traveling salesman problem. S2S+Anon (Konstas et al., 2017) is a multi-layer attention-based bidirectional LSTM model, which is trained with anonymized data. S2S+Copy (Song et al., 2018) is also an attention-based LSTM model, but it instead uses the copy mechanism. GGNN (Beck et al., 2018) uses a gated graph neural network to encode the AMR graph and an RNN-based decoder to generate the text. GraphLSTM (Song et al., 2018) utilizes a graph state LSTM as the graph encoder and uses the copy mechanism instead of anonymization. T-GCNSEQ (Damonte and Cohen, 2019) also splits the reentrancies and applies stacking of the encoders to encode the tree, in which BiLSTM networks are used on top of the GCN for utilizing both the structure and sequential information. G-GCNSEQ has the same architecture as t-GCNSEQ, but it directly encodes the graph rather than the tree. Tree2Str, TSP, S2S+Anon, S2S+Copy, and GraphLSTM have been trained on LDC2015E86. PBMT has been trained on a previous release of the corpus (LDC2014T12). 2 Note that PBMT, Tree2Str, and TSP also train and use a language model based on an additional Gigaword corpus. GGNN has been trained on LDC2017T10. T-GCNSEQ and g-GCNSEQ have been trained on both LDC2015E86 and LDC2017T10. Table 1 summarizes the results of the models using LDC2015E86 as the gold training data. When trained only on the gold training data, our model achieves the best BLEU score of 25.9 among all the neural models and outperforms S2S+Anon by 3.9 BLEU points. Compared with the graph-tosequence model, GraphLSTM, our model is 2.6 BLEU points higher, which shows the superiority of our proposed architecture. Our model also outperforms hybrid models t-GCNSEQ and g-GCNSEQ by 2.0 points and 1.5 points, respectively. Comparing the two sequence-to-sequence neural models, Transformer underperforms the RNN-based model (S2S+Anon). This is in plain contrast to their performances in machine translation. The reason is attributed to the possible extreme length of the linearized AMR graph and difficulty in performing self-attention to obtain a good context representation of each token with a small training data. Our proposed Graph Transformer does not encounter this problem, which is significantly better than Transformer, and improves the BLEU score by more than 8 points. It also shows that our proposed deep architecture is even effective with a small training data. The results of statistical approaches PBMT, Tree2Str, and TSP are not strictly comparable because they use an additional Gigaword corpus to train the language model. Our model still outperforms the Tree2Str and TSP and performs close to the PBMT. Following the approach of Konstas et al. (2017), we also evaluate our model using automatically labeled Gigaword data as additional training data. When using external data, the performance of our model is improved significantly. Utilizing 2M gigaword data, the performance of our model improves by 10.5. With the 2M additional data, our model achieves the new state-of-the-art BLEU score of 36.4 points, which is 4.7 and 2.8 points</p>
<p>Comparison Results</p>
<p>Methods</p>
<p>BLEU CHRF++</p>
<p>GGNN (Beck et al., 2018) 23.3 50.4 GGNN(ensemble) (Beck et al., 2018) 27.5 53.5 t-GCNSEQ (Damonte and Cohen, 2019) 24.1 − g-GCNSEQ (Damonte and Cohen, 2019) 24.5 −  higher than those of S2S+Copy and GraphLSTM using the same training data, respectively. Transformer achieves a BLEU score of 35.1, which is much higher compared with that achieved with the one trained on the gold data. This verifies the effectiveness of a deep neural model when the training dataset is sufficiently big. With 20M external data, the S2S+Anon obtains a BLEU score of 33.8, which is much worse than our model score. We speculate the performance can be further improved with a relatively larger number of external data; however, we do not attempt this owing to hardware limitations. Note that the CHRF++ score is not reported for these approaches in previous works; therefore, we do not compare it in this experiment. Table 2 lists the results of the models trained on LDC2017T10. Our model strongly outperforms GGNN, and improves the BLEU score by 6.0 points and the CHRF++ score by 8.6 points. Hybrid models t-GCNSEQ and g-GCNSEQ achieve BLEU scores of 24.1 and 24.5, which are 5.2 and 4.8 points lower than those of our model, respectively. Compared with the same model with smaller gold training data in Table 1, the BLEU score of our model is also improved by 3.4 points and the scores of t-GCNSEQ and g-GCNSEQ are improved by only 0.2 and 0.1 points, respectively. This indicates that the performance of our model can easily benefit from more gold training data. Beck et al. (2018) also reported the scores of GGNN ensemble, which achieves a BLEU score of 27.5 and a CHRF++ score of 53.5; these scores are even much worse than those of our single model.</p>
<p>Model Variations</p>
<p>To evaluate the importance of the different components of our proposed Graph Transformer, we vary our model and perform both hyper-parameter and ablation studies. We train the models on both LDC2015E86 and LDC2017T10 and measure the performance changes on the development set, and the results are listed in Table 3.</p>
<p>Hyper-Parameter Tuning</p>
<p>In Table 3 (A), we vary the number of transition steps (i.e., number of layers), L 1 , in the graph encoder. As we can see, the performance of our model increases as L 1 increases; however, it starts decreasing gradually when L 1 becomes larger than 8. Our model achieves the best performance when L 1 equals 8. This shows that incorporating the information from the nodes with a long distance can help improve capture of the global semantic information. The reason for this performance drop when L 1 is larger than 8 may be attributed to the over-fitting because the amount of training data is not large. In addition, we also compare the BLEU scores of our model and GraphLSTM with the same number of transition steps. These models are only trained on LDC2015E86. Results on the development set are shown in Figure 3. Compared with the performance of the GraphLSTM, our model performs consistently and significantly better when L 1 , which varies from 1 to 10. This indicates that our proposed graph encoder has a stronger ability of utilizing both local and global semantic information.</p>
<p>In Table 3 (B), we vary the number of layers in the decoder, L 2 . Our model achieves the best performance when L 2 equals 6, and its performance drops significantly when L 2 decreases. With few layers, the decoder might not be able to utilize the information provided by the graph encoder and generate fluent sentences. An extremely large  L 2 also adversely affects the performance, particularly when training on the smaller dataset.</p>
<p>In Table 3 (C), we observe that larger models do not lead to better performance. We attribute the reason to the number of training pairs being quite small. In Table 3 (D), we observe that the models, trained on a small dataset, are extremely sensitive to the number of heads, d h . The singlehead attention is 1.9 BLEU points worse than the best setting. The performance also deceases with too many heads. Using more training data, our model becomes more stable and insensitive to d h . In Table 3 (E), we can see that a suitable rate of dropout is extremely helpful for avoiding over-fitting.</p>
<p>Ablation Study</p>
<p>We further perform an ablation study on two datasets to investigate the influence of the modules in the graph encoder. We fix the sentence decoder of our model because it is similar to the original one in Transformer. The modules in the graph encoder are tested by two methods: using a single representation for each node (i.e., the head representation and tail representation are updated with shared parameters), and using a single representation and performing the inseparate graph attention over the incoming and outgoing relations simultaneously (i.e., the output of the attention in Eq. (7) 
is g t i = d h x=1 ( j∈N in i N out i α x ij r t ij W x v )
W o and the fusion layer is discarded). These modifications test the effectiveness of the separate graph attentions.</p>
<p>The results are presented in Table 3 (F). We can see that using a single representation for each node results in a loss of 0.4 and 0.5 BLEU points on the two datasets, respectively. It indicates that learning the head representation and tail representation for each node is helpful. We further observe that without separated graph attentions (i.e., in inseparate graphattention), the performance of our model drops, suffering a loss of 2.4 BLEU points on the LDC2015E86 dataset and 1.2 on LDC2017T10. We consider that the relations represented by the incoming edges and outgoing edges are different. Moreover, projecting them into the same space for the graph attentions might cause confusion, particularly when the number of training data is small. Separate graph attentions can help the model better capture the semantics.</p>
<p>Compared with the prior methods, there are two changes in our model: the graph encoder and the Transformer decoder. To study the influences of the different encoders and decoders, we implement three encoders (RNN encoder, Transformer   encoder, and our graph encoder) and two decoders (RNN decoder and Transformer decoder). We also perform a study of their combinations. Table 4 presents the results. We find an interesting phenomenon that simply mixing Transformer-based networks with RNNs can lead to a large decrease in the performance. Irrespective of replacing the RNN decoder with the Transformer decoder in S2S or replacing the Transformer decoder with the RNN decoder in Transformer and Graph Transformer, the replaced models perform much worse than the original ones. This indicates that there is a mismatch in using an RNN (or Transformer) to decode a sentence from the representations encoded by Transformer-based networks (or RNNs). The superior performance of our model is owing to the interplay of the Transformer-based graph encoder and the Transformer decoder.</p>
<p>Performance Against Size and Structure of AMR Graph</p>
<p>To study the advantages of our proposed model against prior sequence-to-sequence models and   graph models further, we compare the results of the models on different sizes and structures of the AMR graphs. All the models are trained on LDC2015E86. We consider the size and structure of a graph in three approaches: depth, number of edges, and number of reentrancies. The depth of an AMR graph is defined as the longest distance between the AMR node and its root. The deeper the graph, the longer the dependency. Table 5 lists the counts of the AMR graphs with different depths for the test split and the results of different models on these graphs. We can see that the graph models outperform the sequence-to-sequence model, but the gap narrows when the depth increases. GraphLSTM outperforms the S2S by 3.9 points when the depth is less than 6, and the gap is only 0.7 points when the depth is larger than 10. Compared with GraphLSTM, Graph Transformer returns better performance on deeper graphs, which shows that our model is more powerful for capturing long-term dependencies.</p>
<p>The edges in an AMR graph represent the semantic relations of the concepts. The more the edges in the graph, the more semantic information is represented and usually the larger the graph. Table 6 lists the counts of the AMR graphs with different number of edges for the test split and  the corresponding BLEU scores of the different models. We observe that all the models have much better performances on small graphs than on large ones. Similar to the phenomena based on Table 4, our model shows a stronger ability in dealing with more semantic relations than GraphLSTM.</p>
<p>Following Damonte and Cohen (2019), we also study the influence of the reentrancies in the graph. Reentrancies represent the co-references and control structures in AMR and make it a graph rather than a tree. A graph with more reentrancies is typically more complex. From Table 7, we can see that the performance of all the models drop significantly when the number of reentrancies increases. With more reentrancies, the lead of the graph-to-sequence models over the sequenceto-sequence model also narrows. We consider that this is because the reentrancies increase the complexity of the graph structure and make the graph models difficult to learn the semantic representation. Our model exhibits an extremely strong performance when the input degrades into a tree. This is because we use two graph attentions over the incoming and outgoing edges, respectively, and only one incoming edge makes the model easy to learn and train. In addition, our model outperforms S2S by 2.9 points when the input graphs have more than 3 reentrancies. In comparison, GraphLSTM achieves nearly an identical result to that of S2S, which indicates that our proposed encoder is also better in dealing with complex graphs than GraphLSTM.</p>
<p>Case Study</p>
<p>We perform case studies to provide a better understanding of the model performance. We compare the outputs of S2S, GraphLSTM, and our Graph Transformer trained on the gold data of LDC2015E86. We observe that there are several common error types in the outputs of these systems: 1) generating unnatural language or unreadable sentences; 2) missing information from the input graph; 3) generating words or tokens inconsistent with the given semantic representation (i.e., mistranslation of the nodes in the graph); 4) mixing the semantic relations between the entities (i.e., mistranslation of the edges in the graph).</p>
<p>To exhibit how systematic these errors are explicitly, we manually evaluate 50 randomly sampled outputs from each compared system, and count the ratio of the outputs with each error type. Note that these four types of errors are not mutually exclusive. Table 8 lists the results. We can clearly see that these four types of errors occur in all the three systems, and Graph Transformer performs the best by comparison. Compared with S2S and GraphLSTM, our model Graph Transformer significantly covers more information from the input graph. All the models make more mistakes on the fluency aspect than on other three aspects. This is because both the missing information from the input graph and the mistranslation of the nodes and edges can cause a generated sentence to be unnatural or unreadable.</p>
<p>In addition, we present several example outputs in Table 9. AMR denotes the input graph and Ref denotes the reference output sentence.</p>
<p>In the first case, we can see that S2S fails to generate a fluent sentence. It also omits the concept, work, and therefore, adversely affects the semantic relation between you and hard. GraphLSTM omits the adverb hard and generates an adverb really for verb work, which is only supposed to modify verb want. Graph Transformer generates a basically correct answer.</p>
<p>In the second case, the AMR graph is more complex. S2S mistranslates the concept, stand, as take away and omits adjective passive. The verb, plant, is also omitted, which might be caused by the long distance between plant and pressure in the linearized input. Moreover, the entire sentence is unreadable owing to numerous grammar mistakes. GraphLSTM also omits the concept, passive, and fails to generate the clause headed by stand. In addition, it makes a mistake at the conjunction between the pressure and Table 9: Example outputs of different systems are compared, including S2S, GraphLSTM, and Graph Transformer.</p>
<p>f armers. Our model does not omit any concept in the graph, but the generated sentence is not highly fluent. It treats the stand and pressure as predicates and fails to generate take and put because they are explicitly given in the graph.</p>
<p>In the last case, all three models fail to capture the concept, employ, and disturbs the relations between person, employ, and company. S2S omits the adjective, oil, and mistranslates the concept, participate, as part of. GraphLSTM is completely confused in this case and even fails to generate the word, June, from the relation, :month 6. Our Graph Transformer correctly generates the sentence constituents other than the subject.</p>
<p>Specifically, the four types of errors occur in all the three models, particularly when the input graph is complex. Compared with S2S and GraphLSTM, our model is less likely to miss the information from the input, and it can generate sentences with high quality, in terms of the fluency and fidelity to the input semantics.</p>
<p>Conclusion</p>
<p>In this study, we present a novel graph network (Graph Transformer) for AMR-to-text generation. Our model is solely based on the attention mechanism. Our proposed graph attentions over the neighbor nodes, and the corresponding edges are used for learning the representations of the nodes and capturing global information. The experimental results shows that our model significantly outperforms the prior neural models and achieves a new state-of-the-art performance on benchmark datasets.</p>
<p>In future work, we will incorporate BERT embeddings and multi-task learnings to improve the performance further. We will also apply Graph Transformer to other related text generation tasks like MRS-to-text generation, data-to-text generation, and image captioning.</p>
<p>Recently, RNN/CNN-free networks have attracted increasing interests. Vaswani et al. (2017) proposed a stacked attention architecture, the Transformer model, for neural machine translation. Gu et al. (2018) introduced a non-autoregressive translation model based on the transformer. Zhang et al. (2018) integrated the paraphrase rules and the Transformer model, for sentence simplification. Devlin et al. (2018) proposed a language representation model called BERT, which achieved new state-of-the-art results on 11 NLP tasks.</p>
<p>Figure 3 :
3Development results of Graph Transformer and GraphLSTM against transition steps in the graph encoder.</p>
<p>Table 2 :
2Test results of models trained on LDC2017T10.</p>
<p>Table 3 :
3Development results of the variations on Graph Transformer. Unlisted values are 
identical to those of the base model. Both models trained on LDC2015E86 and LDC2017T10 
are evaluated. </p>
<p>Table 4 :
4Development results of models with three 
different encoders and two different decoders. 
A+B represents the model with A encoder and 
B decoder. RNN encoder and decoder are abbre-
viated to RNN, Transformer encoder and decoder 
are abbreviated to TFM and our Graph encoder are 
abbreviated to Graph. </p>
<p>Model 
Depth 
1−5 6−10 11− </p>
<h1>count</h1>
<p>278 
828 
265 </p>
<p>S2S 
37.2 21.2 19.3 
GraphLSTM 
+3.9 +2.1 +0.7 
Graph Transformer +6.0 +4.5 +3.7 </p>
<p>Table 5 :
5Counts of AMR graphs with different depth for the test split and the BLEU scores of different models on these graphs.</p>
<p>Table 6 :
6Counts of AMR graphs with different number of edges for the test split and the BLEU scores of different models on these graphs.Model 
Number of reentrancies 
0 
1−3 
4− </p>
<h1>count</h1>
<p>624 566 
181 
S2S 
26.6 21.2 
15.3 
GraphLSTM 
+2.9 +2.4 
+0.1 
Graph Transformer +7.1 +4.0 
+2.9 </p>
<p>Table 7 :
7Counts of AMR graphs with different number of reentrancies for the test split and the BLEU scores of different models on these graphs.</p>
<p>Table 8 :
8The ratio of outputs with each error type for each compared system. Lower percentage is better.
https://www.cs.rochester.edu/∼lsong10/ downloads/2m.json.gz.
The LDC2014T12 dataset contains 10,313 instances for the training and the same instances for the development and test as in case of LDC2015E86.
AcknowledgmentsThis work was supported by National Natural Science Foundation of China (61772036) and Key Laboratory of Science, Technology and Standard in Press Industry (Key Laboratory of Intelligent Press Media Technology). We thank the anonymous reviewers for their helpful comments. Xiaojun Wan is the corresponding author.AMR:(h / have-condition-91:ARG1 (w / work-01 :ARG0 (y / you) :ARG1-of (h2 / hard-02)) :ARG2 (w2 / want-01 :ARG0 y :ARG2 (o / out) :mod (r / really))) :mod (t2 / this))) :op2 (p2 / pressure-01 :ARG0 c :ARG1 (p5 / person :mod (c3 / country :wiki ''Afghanistan'' :name (n2 / name :op1 ''Afghanistan'')) :ARG0-of (f / farm-01)) :ARG2 (p3 / plant-01 :ARG0 p5 :ARG1 (p4 / poppy :mod (o / opium))) :degree (l / less))) Ref:The Taliban this year are taking a passive stance toward cultivation and putting less pressure on Afghan farmers to plant opium poppy. S2S: the Taliban will take away with cultivation of cultivate this year and pressure on Afghan farmers less with opium poppy in them. GraphLSTM: The Taliban has been standing in the cultivation this year and less pressure from the Afghan farmers to plant opium poppies. Graph Transformer: The Taliban has stood passive in cultivation this year and has less pressured Afghan farmers to plant opium poppies.
Peter Battaglia, Jessica B Hamrick, Victor Bapst, Alvaro Sanchezgonzalez, Mateusz Vinicius Flores Zambaldi, Andrea Malinowski, David Tacchetti, Adam Raposo, Ryan Santoro, Faulkner, arXiv preprint: 1806.01261Relational inductive biases, deep learning, and graph networks. and othersPeter Battaglia, Jessica B. Hamrick, Victor Bapst, Alvaro Sanchezgonzalez, Vinicius Flores Zambaldi, Mateusz Malinowski, Andrea Tacchetti, David Raposo, Adam Santoro, Ryan Faulkner, and others. 2018. Relational induc- tive biases, deep learning, and graph networks. arXiv preprint: 1806.01261.</p>
<p>Graph-to-sequence learning using gated graph neural networks. Daniel Beck, Gholamreza Haffari, Trevor Cohn, Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics. the 56th Annual Meeting of the Association for Computational Linguistics1Daniel Beck, Gholamreza Haffari, and Trevor Cohn. 2018. Graph-to-sequence learning using gated graph neural networks. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 273-283.</p>
<p>Joan Bruna, Wojciech Zaremba, Arthur Szlam, Yann Lecun, Spectral networks and locally connected networks on graphs. International Conference on Learning Representations. Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann Lecun. 2014. Spectral networks and locally connected networks on graphs. International Conference on Learning Repre- sentations.</p>
<p>Marco Damonte, Shay B Cohen, arXiv:1903.11410v1Structural neural encoders for amr-to-text generation. arXiv preprintMarco Damonte and Shay B. Cohen. 2019. Struc- tural neural encoders for amr-to-text generation. arXiv preprint arXiv:1903.11410v1.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, Kristina Toutanova, arXiv:1810.04805Bert: Pretraining of deep bidirectional transformers for language understanding. arXiv preprintJacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre- training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.</p>
<p>Convolutional networks on graphs for learning molecular fingerprints. David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, Alán Aspuru-Guzik, Ryan P Adams, Advances in Neural Information Processing Systems. David K. Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, Alán Aspuru-Guzik, and Ryan P. Adams. 2015. Convolutional networks on graphs for learning molecular fingerprints. In Advances in Neural Information Processing Systems, pages 2224-2232.</p>
<p>Generation from abstract meaning representation using tree transducers. Jeffrey Flanigan, Chris Dyer, Noah A Smith, Jaime Carbonell, Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language TechnologiesJeffrey Flanigan, Chris Dyer, Noah A. Smith, and Jaime Carbonell. 2016. Generation from abstract meaning representation using tree transducers. In Proceedings of the 2016 Con- ference of the North American Chapter of the Association for Computational Linguistics: Hu- man Language Technologies, pages 731-739.</p>
<p>A new model for learning in graph domains. Marco Gori, Gabriele Monfardini, Franco Scarselli, Proceedings. 2005 IEEE International Joint Conference on Neural Networks. 2005 IEEE International Joint Conference on Neural NetworksIEEE2Marco Gori, Gabriele Monfardini, and Franco Scarselli. 2005. A new model for learning in graph domains. In Proceedings. 2005 IEEE International Joint Conference on Neural Networks, 2005., volume 2, pages 729-734. IEEE.</p>
<p>Rigotrio at SemEval-2017 task 9: combining machine learning and grammar engineering for amr parsing and generation. Normunds Gruzitis, Didzis Gosko, Guntis Barzdins, Proceedings of the 11th International Workshop on Semantic Evaluation. the 11th International Workshop on Semantic EvaluationAssociation for Computational LinguisticsNormunds Gruzitis, Didzis Gosko, and Guntis Barzdins. 2017. Rigotrio at SemEval-2017 task 9: combining machine learning and grammar engineering for amr parsing and generation. In Proceedings of the 11th International Work- shop on Semantic Evaluation (SemEval-2017). Association for Computational Linguistics.</p>
<p>Jiatao Gu, James Bradbury, Caiming Xiong, O K Victor, Richard Li, Socher, Non-autoregressive neural machine translation. International Conference on Learning Representations. Jiatao Gu, James Bradbury, Caiming Xiong, Victor O. K. Li, and Richard Socher. 2018. Non-autoregressive neural machine transla- tion. International Conference on Learning Representations.</p>
<p>Incorporating copying mechanism in sequence-to-sequence learning. Jiatao Gu, Zhengdong Lu, Hang Li, O K Victor, Li, arXiv:1603.06393arXiv preprintJiatao Gu, Zhengdong Lu, Hang Li, and Victor O. K. Li. 2016. Incorporating copying mechanism in sequence-to-sequence learning. arXiv preprint arXiv:1603.06393.</p>
<p>Liberal event extraction and event schema induction. Lifu Huang, Taylor Cassidy, Xiaocheng Feng, Heng Ji, Clare R Voss, Jiawei Han, Avirup Sil, Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics. the 54th Annual Meeting of the Association for Computational Linguistics1Lifu Huang, Taylor Cassidy, Xiaocheng Feng, Heng Ji, Clare R. Voss, Jiawei Han, and Avirup Sil. 2016. Liberal event extraction and event schema induction. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 258-268.</p>
<p>Semantics-based machine translation with hyperedge replacement grammars. Bevan Jones, Jacob Andreas, Daniel Bauer, Karl Moritz Hermann, Kevin Knight, Proceedings of COLING 2012. COLING 2012Bevan Jones, Jacob Andreas, Daniel Bauer, Karl Moritz Hermann, and Kevin Knight. 2012. Semantics-based machine translation with hyperedge replacement grammars. Proceedings of COLING 2012, pages 1359-1376.</p>
<p>Adam: A method for stochastic optimization. P Diederik, Jimmy Kingma, Ba, International Conference on Learning Representations. Diederik P. Kingma and Jimmy Ba. 2015. Adam: A method for stochastic optimization. Interna- tional Conference on Learning Representations.</p>
<p>Semisupervised classification with graph convolutional networks. N Thomas, Max Kipf, Welling, International Conference on Learning Representations. Thomas N. Kipf and Max Welling. 2017. Semi- supervised classification with graph convolu- tional networks. International Conference on Learning Representations.</p>
<p>Neural amr: Sequence-to-sequence models for parsing and generation. Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, Luke Zettlemoyer, Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics. the 55th Annual Meeting of the Association for Computational Linguistics1Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin Choi, and Luke Zettlemoyer. 2017. Neural amr: Sequence-to-sequence models for parsing and generation. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 146-157.</p>
<p>Sheffield at SemEval-2017 task 9: Transition-based language generation from AMR. Gerasimos Lampouras, Andreas Vlachos, Proceedings of the 11th International Workshop on Semantic Evaluation. the 11th International Workshop on Semantic EvaluationGerasimos Lampouras and Andreas Vlachos. 2017. Sheffield at SemEval-2017 task 9: Transition-based language generation from AMR. In Proceedings of the 11th International Workshop on Semantic Evaluation (SemEval- 2017), pages 586-591.</p>
<p>Yujia Li, Daniel Tarlow, Marc Brockschmidt, Richard Zemel, arXiv:1511.05493Gated graph sequence neural networks. arXiv preprintYujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard Zemel. 2015. Gated graph sequence neural networks. arXiv preprint arXiv:1511.05493.</p>
<p>Toward abstractive summarization using semantic representations. Fei Liu, Jeffrey Flanigan, Sam Thomson, Norman M Sadeh, Noah A Smith, North American Chapter of the Association for Computational Linguistics. Fei Liu, Jeffrey Flanigan, Sam Thomson, Norman M. Sadeh, and Noah A. Smith. 2015. Toward abstractive summarization using se- mantic representations. North American Chapter of the Association for Computational Lin- guistics, pages 1077-1086.</p>
<p>Addressing a question answering challenge by combining statistical methods with inductive rule learning and reasoning. Arindam Mitra, Chitta Baral, Thirtieth AAAI Conference on Artificial Intelligence. Arindam Mitra and Chitta Baral. 2016. Addressing a question answering challenge by combining statistical methods with inductive rule learning and reasoning. In Thirtieth AAAI Conference on Artificial Intelligence.</p>
<p>BLEU: A method for automatic evaluation of machine translation. Kishore Papineni, Salim Roukos, Todd Ward, Wei-Jing Zhu, Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics. the 40th Annual Meeting of the Association for Computational LinguisticsAssociation for Computational LinguisticsKishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. 2002. BLEU: A method for automatic evaluation of machine translation. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics, pages 311-318. Association for Computational Linguistics.</p>
<p>GloVe: Global vectors for word representation. Jeffrey Pennington, Richard Socher, Christopher Manning, Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP). the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)Jeffrey Pennington, Richard Socher, and Christopher Manning. 2014. GloVe: Global vectors for word representation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1532-1543.</p>
<p>CHRF++: Words helping character n-grams. Maja Popović, Proceedings of the Second Conference on Machine Translation. the Second Conference on Machine TranslationMaja Popović. 2017. CHRF++: Words helping character n-grams. In Proceedings of the Second Conference on Machine Translation, pages 612-618.</p>
<p>Generating English from abstract meaning representations. Nima Pourdamghani, Kevin Knight, Ulf Hermjakob, Proceedings of the 9th International Natural Language Generation Conference. the 9th International Natural Language Generation ConferenceNima Pourdamghani, Kevin Knight, and Ulf Hermjakob. 2016. Generating English from abstract meaning representations. In Proceed- ings of the 9th International Natural Language Generation Conference, pages 21-25.</p>
<p>The graph neural network model. Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, Gabriele Monfardini, IEEE Transactions on Neural Networks. 201Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini. 2009. The graph neural network model. IEEE Transactions on Neural Networks, 20(1):61-80.</p>
<p>Semantic neural machine translation using AMR. Linfeng Song, Daniel Gildea, Yue Zhang, Zhiguo Wang, Jinsong Su, Transactions of the Association for Computational Linguistics. 7Linfeng Song, Daniel Gildea, Yue Zhang, Zhiguo Wang, and Jinsong Su. 2019. Semantic neural machine translation using AMR. Transactions of the Association for Compu- tational Linguistics, 7:19-31.</p>
<p>AMR-to-text generation with synchronous node replacement grammar. Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo Wang, Daniel Gildea, Meeting of the Association for Computational Linguistics. 2Linfeng Song, Xiaochang Peng, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2017. AMR-to-text generation with synchronous node replacement grammar. Meeting of the Association for Computational Linguistics, 2:7-13.</p>
<p>Amrto-text generation as a traveling salesman problem. Linfeng Song, Yue Zhang, Xiaochang Peng, Zhiguo Wang, Daniel Gildea, Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. the 2016 Conference on Empirical Methods in Natural Language ProcessingLinfeng Song, Yue Zhang, Xiaochang Peng, Zhiguo Wang, and Daniel Gildea. 2016. Amr- to-text generation as a traveling salesman problem. In Proceedings of the 2016 Confer- ence on Empirical Methods in Natural Lan- guage Processing, pages 2084-2089.</p>
<p>A graph-to-sequence model for AMR-to-text generation. Linfeng Song, Yue Zhang, Zhiguo Wang, Daniel Gildea, Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics. the 56th Annual Meeting of the Association for Computational Linguistics1Linfeng Song, Yue Zhang, Zhiguo Wang, and Daniel Gildea. 2018. A graph-to-sequence model for AMR-to-text generation. In Proceed- ings of the 56th Annual Meeting of the Asso- ciation for Computational Linguistics (Volume 1: Long Papers), volume 1, pages 1616-1626.</p>
<p>Neural headline generation on abstract meaning representation. Jun Sho Takase, Naoaki Suzuki, Tsutomu Okazaki, Masaaki Hirao, Nagata, Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. the 2016 Conference on Empirical Methods in Natural Language ProcessingSho Takase, Jun Suzuki, Naoaki Okazaki, Tsutomu Hirao, and Masaaki Nagata. 2016. Neural headline generation on abstract meaning representation. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 1054-1059.</p>
<p>Attention is all you need. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, Illia Polosukhin, Advances in Neural Information Processing Systems. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information Processing Systems, pages 5998-6008.</p>
<p>Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, Yoshua Bengio, Graph attention networks. International Conference on Learning Representations. Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua Bengio. 2018. Graph attention net- works. International Conference on Learn- ing Representations.</p>
<p>Improving the transformer translation model with document-level context. Jiacheng Zhang, Huanbo Luan, Maosong Sun, Feifei Zhai, Jingfang Xu, Min Zhang, Yang Liu, Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing. the 2018 Conference on Empirical Methods in Natural Language ProcessingJiacheng Zhang, Huanbo Luan, Maosong Sun, Feifei Zhai, Jingfang Xu, Min Zhang, and Yang Liu. 2018. Improving the transformer translation model with document-level context. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 533-542.</p>            </div>
        </div>

    </div>
</body>
</html>