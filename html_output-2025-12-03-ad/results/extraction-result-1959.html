<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1959 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1959</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1959</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-43.html">extraction-schema-43</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experiments or studies that measure bloat, diversity, and executability (or related metrics like validity, correctness, or fitness) in genetic programming or evolutionary computation systems, particularly focusing on how these metrics interact and trade off against each other.</div>
                <p><strong>Paper ID:</strong> paper-277741307</p>
                <p><strong>Paper Title:</strong> <a href="https://export.arxiv.org/pdf/2504.08310v1.pdf" target="_blank">DeQompile: quantum circuit decompilation using genetic programming for explainable quantum architecture search</a></p>
                <p><strong>Paper Abstract:</strong> Demonstrating quantum advantage using conventional quantum algorithms remains challenging on current noisy gate-based quantum computers. Automated quantum circuit synthesis via quantum machine learning has emerged as a promising solution, employing trainable parametric quantum circuits to alleviate this. The circuit ansatz in these solutions is often designed through reinforcement learning-based quantum architecture search when the domain knowledge of the problem and hardware are not effective. However, the interpretability of these synthesized circuits remains a significant bottleneck, limiting their scalability and applicability across diverse problem domains. This work addresses the challenge of explainability in quantum architecture search (QAS) by introducing a novel genetic programming-based decompiler framework for reverse-engineering high-level quantum algorithms from low-level circuit representations. The proposed approach, implemented in the open-source tool DeQompile, employs program synthesis techniques, including symbolic regression and abstract syntax tree manipulation, to distill interpretable Qiskit algorithms from quantum assembly language. Validation of benchmark algorithms demonstrates the efficacy of our tool. By integrating the decompiler with online learning frameworks, this research potentiates explainable QAS by fostering the development of generalizable and provable quantum algorithms.</p>
                <p><strong>Cost:</strong> 0.014</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1959.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1959.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of experiments or studies that measure bloat, diversity, and executability (or related metrics like validity, correctness, or fitness) in genetic programming or evolutionary computation systems, particularly focusing on how these metrics interact and trade off against each other.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DeQompile</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DeQompile: quantum circuit decompilation using genetic programming</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A tree-based genetic programming decompiler that evolves Python ASTs (Qiskit programs) to reproduce sets of QASM quantum circuits using multi-objective fitness combining syntactic similarity metrics and a parsimony (node-count) penalty; demonstrated on simple ansatzes, GHZ, QFT and QPE.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>DeQompile (GP decompiler)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Tree-based genetic programming over Python abstract syntax trees (ASTs) where individuals are functions returning Qiskit QuantumCircuit objects parameterized by problem size n; fitness is multi-objective combining syntactic similarity (Levenshtein gate-sequence similarity, gate-frequency cosine similarity, longest-common-subsequence over QASM lines) and a parsimony pressure S_KC computed from AST node count; genetic operators include outermost-level crossover (to preserve syntactic validity), mutation by inserting/modifying AST subtrees (deletion disallowed), elitism, random individual injection, and an annealed mutation-rate schedule.</td>
                        </tr>
                        <tr>
                            <td><strong>bloat_metric</strong></td>
                            <td>S_KC parsimony pressure: estimated by counting the number of nodes in the AST representation (node count used as a parsimony penalty). Authors also apply symbolic simplification (SymPy) to expressions to reduce algebraic complexity before counting.</td>
                        </tr>
                        <tr>
                            <td><strong>bloat_measurements</strong></td>
                            <td>No explicit quantitative time-series of bloat (node counts) are reported. The paper states that code bloat is a known GP issue and that S_KC (AST node count) is included in the fitness as parsimony pressure; deletion is disabled (to ensure syntactic validity) which the authors note may exacerbate bloat but no numeric growth (nodes/gen) is given.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td>No explicit numeric diversity metric (e.g., genotypic uniqueness, behavioral distance) is reported. Diversity is operationally maintained via: (a) injecting a fraction of newly randomized individuals each generation (new_gen_rate), (b) multiple selection operators implemented (tournament, roulette, rank, weighted roulette), and (c) annealed mutation-rate scheduling. The paper does not define or compute a formal diversity statistic.</td>
                        </tr>
                        <tr>
                            <td><strong>diversity_measurements</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Syntactic validity and functional fitness as proxied by combined syntactic similarity score S_total (geometric-mean of S_seq (Levenshtein-based gate-sequence similarity), S_freq (cosine similarity of gate-frequency vectors), and S_LCS (longest common subsequence over QASM lines)) plus S_KC; additionally programs that produce syntactic/runtime errors (e.g., invalid multi-qubit indices, divide-by-zero in angles) are assigned fitness 0. Process (unitary) fidelity is mentioned as a semantic metric but is only used for small circuits due to exponential cost.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_measurements</strong></td>
                            <td>Reported experiment outcomes (these are fitness / functional-reconstruction measures; syntactic-validity is enforced): 1-qubit simple ansatz datasets reached combined fitness 1.0 within ~30 generations (3 trials). R_y undecomposed circuits reached perfect fitness within ~40 generations; decomposed R_y circuits converged slower and to lower scores (H-Rx decomposition performed better than Rx-Rz decomposition). QFT: small circuits (2–5 qubits) achieved fitness >0.9 within ~100 generations; larger QFT circuits (6–10 qubits) plateaued around ~0.85 after ~150 generations. GHZ decompilation achieved the best results among tested conventional algorithms; QPE was hardest. The paper does not report explicit percentages of syntactically-valid individuals over time, only that invalid individuals get fitness=0 when encountered.</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_rate</strong></td>
                            <td>0.3 (experiment values reported in figure captions; Table 2 default also lists 0.3)</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_rate</strong></td>
                            <td>0.3 in several experiment runs (Figure captions) ; default mutation_rate listed as 0.1 in Table 2; an additional annealed mutation parameter (mutation_rate_2) is used with decay (examples: mutation_rate_2 initial 0.99, or 0.5 in some runs).</td>
                        </tr>
                        <tr>
                            <td><strong>selection_method</strong></td>
                            <td>Tournament selection (algorithm/pseudocode and figure captions use tournament); paper notes other selection options are implemented (roulette wheel, rank-based, weighted roulette) but experiments use tournament.</td>
                        </tr>
                        <tr>
                            <td><strong>population_size</strong></td>
                            <td>40 in several experiments (Figure 4); default/popular setting in Table 2 is 50. Reported experiment captions use pop_size=40 or pop_size=50 depending on the figure.</td>
                        </tr>
                        <tr>
                            <td><strong>special_operators</strong></td>
                            <td>Parsimony pressure via S_KC (AST node count) and symbolic simplification (SymPy); crossover constrained to outermost indent level to preserve syntactic correctness; mutation forbids deletion (only insertion/modification) to maintain syntactic validity; periodic injection of new random individuals (new_gen_rate) to promote diversity; annealed mutation rate to balance exploration/exploitation.</td>
                        </tr>
                        <tr>
                            <td><strong>observed_tradeoffs</strong></td>
                            <td>Explicit: an explainability-efficiency tradeoff in gate-set transpilation — undecomposed (readable) R_y circuits are easier to decompile (higher/faster-achieved fitness) while decomposed (hardware-efficient) circuits are harder to decompile and converge to lower fitness, indicating a tradeoff between hardware-efficiency (decomposition) and human-explainability / recoverability by the GP. Implicit tradeoffs: authors apply parsimony pressure to reduce bloat but note that forbidding deletion (to ensure syntactic validity) can conflict with size reduction; injection of random individuals and higher mutation early aids diversity/exploration but may slow convergence/executability. The paper does not provide a quantified three-way tradeoff table (bloat vs diversity vs executability) but discusses mechanisms creating tradeoffs.</td>
                        </tr>
                        <tr>
                            <td><strong>temporal_dynamics</strong></td>
                            <td>Reported dynamics for fitness (executable/functional measure): 1-qubit simple patterns -> perfect (S_total=1.0) by ~30 generations; nested loops showed fitness jumps around generation ~50; R_y undecomposed -> perfect within ~40 generations while decomposed variants converged slower; QFT (2–5 qubits) >0.9 by ~100 generations, QFT (6–10 qubits) plateaued ~0.85 by ~150 generations; authors also use an annealed mutation rate (decaying per generation) and inject new random individuals each generation to maintain diversity. No time-series numeric data for bloat (node-count) or formal diversity measures are reported.</td>
                        </tr>
                        <tr>
                            <td><strong>supports_triangle_constraint</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>counterexample_to_triangle</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_explanation</strong></td>
                            <td>Mechanisms described: (1) Parsimony pressure (S_KC node-count) and symbolic simplification reduce bloat by penalizing large ASTs and simplifying algebraic expressions; (2) constraining crossover to outermost indent and disabling deletion preserves syntactic validity/executability at the cost of potentially increasing bloat; (3) injecting randomly-initialized individuals and using higher mutation early increases genotypic exploration/diversity but may slow convergence to high-fitness (executable) solutions; (4) decomposition of gates (to native gate sets) increases parameter/structural complexity and so reduces the syntactic similarity measures the decompiler optimizes for, producing the observed explainability-efficiency tradeoff.</td>
                        </tr>
                        <tr>
                            <td><strong>domain_type</strong></td>
                            <td>Program synthesis / quantum circuit decompilation (quantum circuit program synthesis)</td>
                        </tr>
                        <tr>
                            <td><strong>representation_type</strong></td>
                            <td>Tree-based GP over Python AST (abstract syntax tree of Qiskit code)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Genetic Programming: On the Programming of Computers by Means of Natural Selection <em>(Rating: 2)</em></li>
                <li>Balancing accuracy and parsimony in genetic programming <em>(Rating: 2)</em></li>
                <li>Automatic Quantum Computer Programming: a genetic programming approach <em>(Rating: 2)</em></li>
                <li>Evolutionary quantum architecture search for parametrized quantum circuits <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1959",
    "paper_id": "paper-277741307",
    "extraction_schema_id": "extraction-schema-43",
    "extracted_data": [
        {
            "name_short": "DeQompile",
            "name_full": "DeQompile: quantum circuit decompilation using genetic programming",
            "brief_description": "A tree-based genetic programming decompiler that evolves Python ASTs (Qiskit programs) to reproduce sets of QASM quantum circuits using multi-objective fitness combining syntactic similarity metrics and a parsimony (node-count) penalty; demonstrated on simple ansatzes, GHZ, QFT and QPE.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "DeQompile (GP decompiler)",
            "system_description": "Tree-based genetic programming over Python abstract syntax trees (ASTs) where individuals are functions returning Qiskit QuantumCircuit objects parameterized by problem size n; fitness is multi-objective combining syntactic similarity (Levenshtein gate-sequence similarity, gate-frequency cosine similarity, longest-common-subsequence over QASM lines) and a parsimony pressure S_KC computed from AST node count; genetic operators include outermost-level crossover (to preserve syntactic validity), mutation by inserting/modifying AST subtrees (deletion disallowed), elitism, random individual injection, and an annealed mutation-rate schedule.",
            "bloat_metric": "S_KC parsimony pressure: estimated by counting the number of nodes in the AST representation (node count used as a parsimony penalty). Authors also apply symbolic simplification (SymPy) to expressions to reduce algebraic complexity before counting.",
            "bloat_measurements": "No explicit quantitative time-series of bloat (node counts) are reported. The paper states that code bloat is a known GP issue and that S_KC (AST node count) is included in the fitness as parsimony pressure; deletion is disabled (to ensure syntactic validity) which the authors note may exacerbate bloat but no numeric growth (nodes/gen) is given.",
            "diversity_metric": "No explicit numeric diversity metric (e.g., genotypic uniqueness, behavioral distance) is reported. Diversity is operationally maintained via: (a) injecting a fraction of newly randomized individuals each generation (new_gen_rate), (b) multiple selection operators implemented (tournament, roulette, rank, weighted roulette), and (c) annealed mutation-rate scheduling. The paper does not define or compute a formal diversity statistic.",
            "diversity_measurements": null,
            "executability_metric": "Syntactic validity and functional fitness as proxied by combined syntactic similarity score S_total (geometric-mean of S_seq (Levenshtein-based gate-sequence similarity), S_freq (cosine similarity of gate-frequency vectors), and S_LCS (longest common subsequence over QASM lines)) plus S_KC; additionally programs that produce syntactic/runtime errors (e.g., invalid multi-qubit indices, divide-by-zero in angles) are assigned fitness 0. Process (unitary) fidelity is mentioned as a semantic metric but is only used for small circuits due to exponential cost.",
            "executability_measurements": "Reported experiment outcomes (these are fitness / functional-reconstruction measures; syntactic-validity is enforced): 1-qubit simple ansatz datasets reached combined fitness 1.0 within ~30 generations (3 trials). R_y undecomposed circuits reached perfect fitness within ~40 generations; decomposed R_y circuits converged slower and to lower scores (H-Rx decomposition performed better than Rx-Rz decomposition). QFT: small circuits (2–5 qubits) achieved fitness &gt;0.9 within ~100 generations; larger QFT circuits (6–10 qubits) plateaued around ~0.85 after ~150 generations. GHZ decompilation achieved the best results among tested conventional algorithms; QPE was hardest. The paper does not report explicit percentages of syntactically-valid individuals over time, only that invalid individuals get fitness=0 when encountered.",
            "crossover_rate": "0.3 (experiment values reported in figure captions; Table 2 default also lists 0.3)",
            "mutation_rate": "0.3 in several experiment runs (Figure captions) ; default mutation_rate listed as 0.1 in Table 2; an additional annealed mutation parameter (mutation_rate_2) is used with decay (examples: mutation_rate_2 initial 0.99, or 0.5 in some runs).",
            "selection_method": "Tournament selection (algorithm/pseudocode and figure captions use tournament); paper notes other selection options are implemented (roulette wheel, rank-based, weighted roulette) but experiments use tournament.",
            "population_size": "40 in several experiments (Figure 4); default/popular setting in Table 2 is 50. Reported experiment captions use pop_size=40 or pop_size=50 depending on the figure.",
            "special_operators": "Parsimony pressure via S_KC (AST node count) and symbolic simplification (SymPy); crossover constrained to outermost indent level to preserve syntactic correctness; mutation forbids deletion (only insertion/modification) to maintain syntactic validity; periodic injection of new random individuals (new_gen_rate) to promote diversity; annealed mutation rate to balance exploration/exploitation.",
            "observed_tradeoffs": "Explicit: an explainability-efficiency tradeoff in gate-set transpilation — undecomposed (readable) R_y circuits are easier to decompile (higher/faster-achieved fitness) while decomposed (hardware-efficient) circuits are harder to decompile and converge to lower fitness, indicating a tradeoff between hardware-efficiency (decomposition) and human-explainability / recoverability by the GP. Implicit tradeoffs: authors apply parsimony pressure to reduce bloat but note that forbidding deletion (to ensure syntactic validity) can conflict with size reduction; injection of random individuals and higher mutation early aids diversity/exploration but may slow convergence/executability. The paper does not provide a quantified three-way tradeoff table (bloat vs diversity vs executability) but discusses mechanisms creating tradeoffs.",
            "temporal_dynamics": "Reported dynamics for fitness (executable/functional measure): 1-qubit simple patterns -&gt; perfect (S_total=1.0) by ~30 generations; nested loops showed fitness jumps around generation ~50; R_y undecomposed -&gt; perfect within ~40 generations while decomposed variants converged slower; QFT (2–5 qubits) &gt;0.9 by ~100 generations, QFT (6–10 qubits) plateaued ~0.85 by ~150 generations; authors also use an annealed mutation rate (decaying per generation) and inject new random individuals each generation to maintain diversity. No time-series numeric data for bloat (node-count) or formal diversity measures are reported.",
            "supports_triangle_constraint": null,
            "counterexample_to_triangle": null,
            "mechanism_explanation": "Mechanisms described: (1) Parsimony pressure (S_KC node-count) and symbolic simplification reduce bloat by penalizing large ASTs and simplifying algebraic expressions; (2) constraining crossover to outermost indent and disabling deletion preserves syntactic validity/executability at the cost of potentially increasing bloat; (3) injecting randomly-initialized individuals and using higher mutation early increases genotypic exploration/diversity but may slow convergence to high-fitness (executable) solutions; (4) decomposition of gates (to native gate sets) increases parameter/structural complexity and so reduces the syntactic similarity measures the decompiler optimizes for, producing the observed explainability-efficiency tradeoff.",
            "domain_type": "Program synthesis / quantum circuit decompilation (quantum circuit program synthesis)",
            "representation_type": "Tree-based GP over Python AST (abstract syntax tree of Qiskit code)",
            "uuid": "e1959.0"
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Genetic Programming: On the Programming of Computers by Means of Natural Selection",
            "rating": 2
        },
        {
            "paper_title": "Balancing accuracy and parsimony in genetic programming",
            "rating": 2
        },
        {
            "paper_title": "Automatic Quantum Computer Programming: a genetic programming approach",
            "rating": 2
        },
        {
            "paper_title": "Evolutionary quantum architecture search for parametrized quantum circuits",
            "rating": 1
        }
    ],
    "cost": 0.013662,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>DeQompile: quantum circuit decompilation using genetic programming for explainable quantum architecture search
11 Apr 2025</p>
<p>Shubing Xie 
Instituut-Lorentz
Leiden University
The Netherlands</p>
<p>Quantum Machine Learning research group
Quantum Computing division
QuTechThe Netherlands</p>
<p>Aritra Sarkar 
Quantum Machine Learning research group
Quantum Computing division
QuTechThe Netherlands</p>
<p>Department of Quantum &amp; Computer Engineering
Delft University of Technology
The Netherlands</p>
<p>Sebastian Feld s.feld@tudelft.nl 
Quantum Machine Learning research group
Quantum Computing division
QuTechThe Netherlands</p>
<p>Department of Quantum &amp; Computer Engineering
Delft University of Technology
The Netherlands</p>
<p>DeQompile: quantum circuit decompilation using genetic programming for explainable quantum architecture search
11 Apr 2025BEFD4956ECDB78B9282AA865C0B61412arXiv:2504.08310v1[quant-ph]
Demonstrating quantum advantage using conventional quantum algorithms remains challenging on current noisy gate-based quantum computers.Automated quantum circuit synthesis via quantum machine learning has emerged as a promising solution, employing trainable parametric quantum circuits to alleviate this.The circuit ansatz in these solutions is often designed through reinforcement learning-based quantum architecture search when the domain knowledge of the problem and hardware are not effective.However, the interpretability of these synthesized circuits remains a significant bottleneck, limiting their scalability and applicability across diverse problem domains.This work addresses the challenge of explainability in quantum architecture search (QAS) by introducing a novel genetic programming-based decompiler framework for reverse-engineering high-level quantum algorithms from low-level circuit representations.The proposed approach, implemented in the open-source tool DeQompile, employs program synthesis techniques, including symbolic regression and abstract syntax tree manipulation, to distill interpretable Qiskit algorithms from quantum assembly language.Validation of benchmark algorithms demonstrates the efficacy of our tool.By integrating the decompiler with online learning frameworks, this research potentiates explainable QAS by fostering the development of generalizable and provable quantum algorithms.</p>
<p>Introduction</p>
<p>Quantum computing (QC) represents a paradigm shift in information processing, utilizing the principles of quantum mechanics to solve problems that are intractable for classical computers.In recent years, significant advances have been made in engineering gate-based quantum computing, which relies on quantum bits (qubits) and quantum gates to manipulate quantum states and process data in a superposition of states [1].The current state of the art in quantum computing is exemplified by breakthroughs from quantum processor manufacturers in qubits with better fidelity, scalability, real-time control, and error-correction [2,3,4].Conventional quantum algorithms like integer factorization [5] and search [6] ensure provable resource complexity advantages over their classical counterparts.However, demonstrating the classical-to-quantum advantage crossover for applications via these algorithms requires considerable improvements in the fidelity and multiplicity of qubits.The current noisy intermediate-scale quantum computing (NISQ) [7,8,9,10] devices have motivated the automated synthesis of quantum circuits while accounting for the device constraints [11,12].</p>
<p>The quantum circuit synthesis methods are often referred to using the broader umbrella term of quantum machine learning (QML).Similar to classical neural networks, these methods typically consider a parametric quantum circuit (PQC) [13,14].The structure/ansatz of the circuit can either be based on the problem structure or the hardware constraints or automatically constructed via quantum architecture search (QAS) [15,16,17].The parameters, in turn, are iteratively adjusted by the variational principle mediated by a classical optimizer in the loop.QAS is typically mediated by neural-network-based reinforcement learning (RL-QAS) [18,19] or population-based evolutionary algorithms [20,21].</p>
<p>QAS-based PQC shares both the strengths and limitations of classical machine learning (ML) based neural architecture search (NAS).A major challenge in deep neural networks has been the issue of explainability [22] of both the architecture and the learned model.Various model explainability techniques have been developed in ML and subsequently in QML [23,24,25,26,27].Interpretable NAS techniques [28,29] have also been employed for post-doc understanding of the architecture based on empirical performance.Similarly to NAS, while QAS-based solutions have been shown to perform against hardware constraints [30], the trained ansatz is not human-interpretable.This restricts the generalizability of these solutions to larger problem sizes and a deeper understanding of the underlying governing symmetries that led the QAS to converge on the solution.</p>
<p>Recently, explainable QAS has been attempted variously via quantum information theoretic approach [31], interpretable learning models [32], and online learning of a gadget library (GRL-QAS) [33].In this work, we develop a complementary approach toward explaining a family of quantum circuits via a genetic programmingbased decompiler.We demonstrate our framework using examples from conventional quantum algorithms and suggest their integration within a GRL-QAS framework to augment their capability beyond simple gadgets.</p>
<p>Program synthesis provides a promising avenue for addressing the explainability problem in quantum algorithm design automation [34].It aims to distill a family of circuits into a high-level, interpretable algorithm, often by using methods like genetic programming or neural networks.Symbolic regression, for example, can be used to find mathematical expressions that describe the behavior of quantum circuits [35].For more holistic and expressive descriptions, high-level program synthesis and concept learning [36,37] can be employed.Decompilation closely resembles inductive inference in the human brain, such as when we deduce the next item in a sequence by identifying underlying patterns.In the context of quantum computing, such methods would facilitate the understanding and generalization of quantum algorithms across different quantum hardware and related problem instances.For quantum circuits, if the circuits are known at a limited scale and we wish to extend the corresponding design, we must identify the shared structures and recognize the patterns of these circuits.Inspired by quantum techniques for Solomonoff's induction [38,39,40,41], in this research, the rules or patterns of these circuits are represented by finding the underlying code that can generate them.With that background, in this article, we address this research question of reverse-engineering high-level quantum algorithms (in Qiskit) from their low-level representations (QASM) using genetic programming (GP) on the abstract syntax tree (AST) representation.We develop a framework to tackle this question, including a method to initialize syntactically valid Qiskit ASTs, a multi-objective fitness function, the genetic operators, and strategies to improve the convergence of the GP.We validate the decompiler's performance on common variational ansatz and quantum algorithms like GHZ state preparation, quantum Fourier Transform, and quantum phase estimation.Further, we investigate the increased difficulty in decompiling circuits that have been transpiled to the constraints of underlying quantum hardware.The software implementation of our technique, called DeQompile, is available as open-source software for further research and development.</p>
<p>Background</p>
<p>This section introduces the necessary concepts of decompilation, genetic programming, and abstract syntax tree representation.</p>
<p>Decompilation</p>
<p>Decompilation is the process of translating compiled code (e.g., low-level assembly code) back into a more readable form of source code (e.g., a high-level language) or a close approximation of it without having access to the original source code.This process is crucial for understanding, analyzing, and optimizing software systems, especially when the original source code is obfuscated or unavailable.In classical computing, decompilation has numerous applications, including software reverse engineering, explainable AI (XAI), and programming by example.For instance, in software reverse engineering, decompiling a program's binary allows for vulnerability assessment, malware analysis, and system optimization.Decompilation plays an important role in programming by example, such as Excel's Flash Fill, where it is used to automate string processing tasks based on inputoutput examples, significantly reducing the need for manual coding [42,43,44].In the realm of XAI, decompiling machine learning models [45,46] help enhance interpretability and transparency, which is vital for ensuring the trustworthiness of AI systems.</p>
<p>Decompilation, however, is inherently a difficult task due to several challenges.Fundamentally, the undecidability of the halting problem implies that it is not always possible to determine whether a synthesized program will terminate with the intended effect or run indefinitely.Additionally, the program space is nondifferentiable, which prevents the direct application of traditional gradient-based optimization methods.The semantic variable names are typically absent in low-level codes, making it difficult to understand the decompiled code.Despite these difficulties, various techniques have been developed to address the challenges of decompilation.For instance, genetic programming [47], a technique rooted in evolutionary algorithms, has been popularly used for program synthesis and software reverse engineering.Neural networks [48] have also been applied to decompilation tasks, where deep learning models can learn mappings between machine code and high-level languages, thus automating and enhancing the decompilation process.</p>
<p>Despite the similarities with classical decompilation, quantum circuit decompilation has not yet been explored for quantum algorithm reverse engineering from learned quantum circuits.Quantum decompilation faces unique challenges that differentiate it from classical decompilation.Quantum phenomena like superposition, entanglement, non-stabilizer magic, and interference do not have phenomenological analogs in human daily experience (or in propositional logic), thus requiring a certain degree of commitment to mathematical models in their interpretability.It is also preferable to evaluate the decompiler purely syntactically instead of testing by executing the decompiler artifact to circumvent the exponential computational cost of classical simulation of quantum programs.Besides this, quantum transformations have an added continuous yet non-measurable degree of freedom in their global phase, which makes it difficult to generalize across circuits where the pattern gets obscured by this phase factor.</p>
<p>Decompiling quantum circuits could uncover the underlying principles of quantum architecture and algorithm design, ultimately enabling the discovery of more interpretable, scalable, and provable quantum algorithms.This would allow us to transition from QAS-based PQC solutions in the NISQ era to conventional quantum algorithms in the fault-tolerant quantum computing (FTQC) era.</p>
<p>Genetic programming</p>
<p>The basic idea behind evolutionary techniques such as genetic algorithms (GA), genetic programming (GP), and genetic expression programming (GEP) is to evolve solutions to problems by iteratively modifying a population of candidate solutions.These candidates are typically represented as tree structures, which can be subjected to operations like selection, crossover, and mutation to explore the solution space.GP [47] allows computer programs to evolve to solve a variety of complex problems, including symbolic regression, classification, and optimization.In GP, the nodes of the tree represent functions or operations, and the leaves represent variables or constants.The fitness function evaluates the performance of the individuals (programs) and guides the evolution process.Quantum genetic programming (QGP) [49,50] extends the concept of classical GP into the realm of quantum program synthesis.</p>
<p>The steps of initialization, evaluation, selection, crossover, and mutation characterize the GP methodology.The following algorithm outlines the baseline genetic programming process.</p>
<p>Algorithm 1 Baseline Genetic Programming Algorithm</p>
<p>1: Initialize population P with random individuals (programs in chosen representation) 2: for each generation g do 3:</p>
<p>Evaluate the fitness of each program in P based on a fitness function</p>
<p>4:</p>
<p>Select the fittest individuals from P to form a mating pool Apply crossover to pairs of individuals in the mating pool to create offspring</p>
<p>6:</p>
<p>Apply mutation to the offspring with a certain probability 7:</p>
<p>Replace the least fit individuals in P with the new offspring 8: end for 9: Return the best individual from the final population A critical challenge in both classical and quantum GP is the encoding of the candidate solutions to allow efficient manipulation and evolution during the search process.This is where abstract syntax trees (AST) come into play and will be discussed in more detail subsequently.</p>
<p>Abstract syntax tree</p>
<p>Abstract syntax trees are a hierarchical, tree-like representation of the syntactic structure of source code or expressions, abstracted from the details of the underlying syntax.Unlike the raw code or textual representation, the AST focuses on the logical structure and relationships within the code, omitting unnecessary syntactic details like punctuation and formatting.Each node in the tree corresponds to a construct or operation in the source code, such as a variable, function, operator, or control flow structure.</p>
<p>ASTs are widely used in compilers, interpreters, and program analysis tools for efficient parsing, optimization, and transformation of code.AST's hierarchical and structured representation of quantum circuits or programs makes them ideal for encoding in evolutionary algorithms.By using ASTs, we can effectively manipulate the structure of quantum programs and optimize them during the evolutionary process, facilitating the exploration of the quantum program space.</p>
<p>Quantum circuit decompilation</p>
<p>In this section, we explain the decompilation process for QASM circuits.A population of Qiskit programs is initialized in the AST representation.The fitness for each corresponding Qiskit code for each AST is evaluated by comparing the generated QASM from the code and the training corpus (i.e., the list of QASM to be decompiled).The GP guides the evolution towards fitter individuals that can decompile the corpus.</p>
<p>Problem formulation</p>
<p>We study two primary objectives.Firstly, we select a quantum algorithm A of choice, such as simple ansatzes, GHZ state preparation, quantum Fourier transform, quantum phase estimation, etc.Quantum circuits for A are generated for different problem sizes, ranging from 2 to 30 qubits, using a Python program P A (n) using the Qiskit package [51].The resulting circuits,
C 2 A , C 3 A , . . . , C30
A , is represented in OpenQASM [52].This set of circuits C n A serves as the training data set.Given this set as input, the designed decompiler evolves an optimal program P ′ A (n) that closely approximates P A (n).The closeness metrics can be either the process distance between the synthesized unitaries or the difference between the generated QASMs, as discussed later.
P ′ A (n) can then be used to generate C ′ 31 A , C ′ 32
A , . ... The data set can also be divided into training and test sets to validate the generalization capability.</p>
<p>Secondly, we explore the limits of the tool through empirical analysis of decompiling a highly optimized code with a lesser algorithmic structure.We take circuits C</p>
<p>AST representation</p>
<p>In this project, we use the ast module of Python to generate a population of individuals for the GP.The parse and unparse functions in the ast package allow the conversion between the AST and code string representation.Each AST in the population represents a Python function that takes as an argument a circuit size n and returns a Qiskit quantum circuit object of n qubits.The operations in the quantum circuit are (potentially) conditioned on n as a proxy for the problem instance size.Each node in the AST represents a fundamental construct in the source code, such as quantum gate operations, assignments, and control flow.</p>
<p>The nodes of the AST include:</p>
<p>• Module: Represents the entire quantum program, containing all quantum operations and gates.</p>
<p>• FunctionDef: Represents a function definition, such as a quantum circuit initializer.</p>
<p>• Assign and Constant: Represent assignments, including qubit initializations and gate parameters.</p>
<p>• Expr and BinOp: Represent mathematical expressions and quantum gate operations.</p>
<p>• Control Flow: Represent loops (for loops), crucial for parameterized quantum operations.An example of a simple AST in Qiskit is as follows.Consider the function rx c that initializes a quantum circuit, and applies a series of rx rotations on each of the i ∈ n qubits with angle scaling by a factor of π/i for i ∈ [1, n], and returns the constructed circuit.-Assign: Assignment and storing of the circuit object qc = QuantumCircuit(n).</p>
<p>-Assign: Assignment of the initial angle angle = math.pi.</p>
<p>-For: A loop iterating over qubits.</p>
<p>-AugAssign: Augmented assignment angle /= 2.</p>
<p>-Call: Expression qc.rx(angle, i).-Load: The return statement return qc. Figure 2 shows the AST for the rx c function, illustrating how the AST captures the quantum circuit structure and operations.</p>
<p>Initialization of the population</p>
<p>By leveraging ASTs, we programmatically generate the initial population for evolution.In each generation, a preset percentage of the individuals are also culled and regenerated.Below are the key functions that contribute to this process.</p>
<p>Qubit index expressions</p>
<p>The random expr function generates random expressions for qubit indices using arithmetic operations, modulus, and simple variables.Parameters include:</p>
<p>• depth: Number of loop variables.</p>
<p>• max expr operators: Number of binary operations in expression.</p>
<p>• var depth: Number of additional variables.For example,</p>
<p>• random expr(0, 1, 2) could be a simple operation like n − n − n, where n is a variable or index.</p>
<p>• random expr(1, 2, 3) might generate a more complex expression such as i0 − n + 3 + 2, involving loop variables (i0), constants (3, 2), and operations.</p>
<p>Loop structures</p>
<p>Loops are essential for repeated quantum gate operations.The loop index function helps generate dynamic loop structures for complex quantum algorithms enabling the iterative application of quantum gates.</p>
<p>Below is an example illustrating nested loops in a quantum circuit:
for i0 in range ( n ) :
for i1 in range ( abs ( i0 -n ) ) :</p>
<p>for i2 in range ( abs ( i0 + i1 + i1 + 1) ) :
qc . crx ( pi * (1 / (2 ** ( i1 + n ) + i1 ) ) , ( n + 1) % n )
Listing 2: Nested loops in quantum circuit generation</p>
<p>• First loop: The index i0 iterates from 0 to n, setting the basic framework for subsequent nested loops.</p>
<p>• Second loop: Dependence on i0 and i1 ranges dynamically, increasing the complexity of operations performed in this layer.• Third loop: The deepest layer uses both i0 and i1 in determining its range, illustrating an advanced level of dependency and complexity in a loop structure.</p>
<p>Angle expressions for rotation gates</p>
<p>The random phase expr function generates phase expressions for gates such as rx, ry, and rz.This function creates an expression of the form:
expr phase = (π ⋅ 1 2 a + b + c ) (1)
where a is the expression related to the number of qubits n, b is the expression of the loop index i j , 0 &lt; j &lt; d, and c are random numbers from a Gaussian distribution
X ∼ N (µ, σ 2 ) .µ = 0, σ = 1
The function's only input is the depth of the current loop location, which is used to decide which symbols can be included in the expression.As an example, random phase expr(2) can generate the expression pi * (1 / (2 ** (n + 0 + n -0) + (i0 + 0 + 0 -n + 0))).</p>
<p>Quantum gate calls</p>
<p>The generate gate call function constructs calls to quantum gates, accommodating single, multi-qubit, and rotational gates.It uses randomly generated expressions for qubit indices and phases to define the gates' applications.Some examples of the function generate gate call(depth: Any, gate: Any) are given as Table 1.It takes the current loop depth and a specific gate type as inputs:</p>
<p>Function call</p>
<p>Generated quantum gate operation The random qiskit ast generator function in DeQompile assembles all these components together, constructing a complete quantum circuit.It takes as arguments a list of allowed operations, the maximum number of nodes, and the maximum cyclometric complexity (i.e., the levels of loop nesting).The function iterates through AST nodes, adding gate operations and returning the final circuit.This approach allows for the generation of random quantum circuits with arbitrary complexity.
generate gate call(2, 'h') qc.h((i1 -0 -n) % n) generate gate call(1, 'rx') qc.rx(pi * (1 / (2 ** (i0 + 0 -n) + (i0 -n + n + 0))), (n -0) % n) generate gate call(1, 'cx') qc.cx((n -0 + n) % n, (i0 + n -0) % n) generate gate call(1, 'cp') qc.cp(-(pi * (1 / (2 ** (n -0 -n) + (n -n + n + 2)))), (i0 + 0) % n, (n -0 -n) % n)</p>
<p>Evolution operations</p>
<p>The main goal is to evolve Qiskit programs (in AST representation) that can reproduce the set of QASM circuits based on the input while optimizing for resources like gate counts, node counts, etc.The GP workflow in each generation of DeQompile after the population initialization is described in this section.</p>
<p>Fitness evaluation</p>
<p>The fitness of each candidate quantum circuit is evaluated by comparing it to the target circuit using a set of custom evaluation metrics inspired by natural language processing (NLP).Similarity can broadly be classified as semantic or syntactic.Semantic similarity can be estimated by the process fidelity between the unitary of the circuit generated via the induced program and that of the QASM target.While semantic similarity allows generalization over syntactic differences (e.g., global phase), constructing the unitary scales exponentially with the problem size becoming restrictive beyond a few small samples.Instead, we introduce methods that compare the syntactic structure and operational similarities between circuits.We use a combination of three metrics to measure the fitness of each QASM pair.</p>
<p>• Gate sequence similarity: Compares the sequences of quantum gates in the candidate and target circuits using the Levenshtein distance [53].This metric calculates the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one sequence to the other.The similarity score S seq is defined as:
S seq = 1 − √ D(A, B) max(|A|, |B|)
where D(A, B) is the Levenshtein distance between the sequences A and B, and |A| and |B| are their lengths.The square root emphasizes differences in larger sequences.</p>
<p>• Gate frequency similarity: Assesses how similar the usage frequency of each gate type is between the candidate and target circuits.By creating frequency vectors for each circuit and calculating the cosine similarity between them, we obtain the score S freq :
S freq = f 1 ⋅ f 2 ∥f 1 ∥∥f 2 ∥
where f 1 and f 2 are the frequency vectors of the candidate and target circuits, respectively.</p>
<p>• Longest common subsequence: By finding the longest common subsequence (LCS) of lines in the QASM representations of the candidate and target circuits, we evaluate the structural similarity.The LCS score S LCS is calculated as:
S LCS =</p>
<p>Length of LCS Total lines in target QASM</p>
<p>A dynamic programming approach is used to efficiently compute the LCS.</p>
<p>The overall fitness score S total for a candidate circuit is the geometric mean of the individual similarity scores.This combined score ensures that a low similarity in any one metric significantly affects overall fitness, promoting well-rounded candidate solutions.The total fitness of the individual includes the average S total for all problem sizes, and an additional quantum description complexity [54] score S KC as a parsimony pressure [55] estimated by counting the number of nodes in the AST representation of the individual:
S total = S KC + ∑ n (S seq × S freq × S LCS ) 1/3
These evaluation metrics focus on the structural and operational similarities between circuits, guiding the evolutionary process toward candidates that closely resemble the target circuit regarding gate sequence, usage, and overall structure with an inductive bias toward succinct representation.</p>
<p>Genetic operations</p>
<p>Genetic programming employs genetic operations such as selection, crossover, and mutation to evolve candidate Qiskit codes over successive generations.</p>
<p>Selection involves choosing individuals with better fitness scores for reproduction, allowing the propagation of superior solutions.DeQompile implements popular selection algorithms like roulette wheel, tournament, rank-based, random, and weighted roulette wheel.We refer the readers to [56] for a pedantic coverage of these methods.</p>
<p>Crossover combines parts of two parents' codes to explore new potential solutions.An example is shown in Figure 3. Crossover is always done at the outmost indent level (i.e., not within a loop) to preserve the syntactic validity of the children.</p>
<p>The mutation operator alters parts of a single code to introduce diversity and avoid converging to suboptimal solutions.DeQompile selects a node in the AST to mutate.It allows either inserting a new AST by extending the body of the node or modifying the body of the node to the new AST.Deletion is not allowed to maintain syntactic validity.
1 # Parent 1 2 qc . h (( n -1) % n ) 3 ----------------split 4 for i0 in range ( n ) : 5 qc . h (( n -1 -i0 ) % n ) 6 qc . h (( i0 -1) % n ) 1 # Parent 2 2 qc . h (( n -0) % n ) 3 -----------------split 4 for i0 in range ( n ) : 5 qc . x (( i0 + n + 1) % n ) 6 qc . x (( i0 -n ) % n ) 1 # Child 1 2 qc . h (( n -0) % n ) 3 *</p>
<p>Improvement strategies</p>
<p>To enhance the performance of the genetic decompiler, we introduced three key strategies:</p>
<p>Random initialization of new individuals</p>
<p>At each generation, a portion of the population is replaced with randomly initialized individuals to increase exploration and avoid local optima.The updated population for generation g + 1 is given by:
P g+1 = E g ∪ N g
where E g represents elite individuals and N g represents newly generated individuals, ensuring both diversity and retention of high-quality solutions.</p>
<p>Annealed mutation rate</p>
<p>An annealing mechanism is applied to the mutation rate, which decreases over generations to balance exploration and exploitation:
m r 2(g) = max(m r 2 0 ⋅ d g , m r 2 min )
where m r 2 0 is the initial mutation rate, d is the decay factor (0 &lt; d &lt; 1), and m r 2 min is the minimum allowable rate.This ensures broad exploration early on and refined optimization in later stages.These strategies improve the decompiler's ability to explore complex search spaces and converge to highquality solutions efficiently.</p>
<p>Simplification of expressions</p>
<p>Code bloat is a known GP issue that affects the decompilation process.To tackle this, we introduce the parsimony pressure as described in the previous section.However, to effectively calculate this value, it is required to simplify the expressions.This is done by using the symbolic simplification method in the SymPy package [57] for every generated expression (for qubits, angles, and loop limits).Algebraic simplification [58] also maintains the intelligibility of the expressions in the decompiled code.</p>
<p>Workflow</p>
<p>The workflow of the DeQompile software is summarized in the pseudocode presented in Algorithm 2.</p>
<p>Algorithm 2 Genetic Programming Algorithm for Quantum Circuit Optimization for i = 1 to crossover count do 8:</p>
<p>Select parents (P 1 , P 2 ) using tournament selection for i = 1 to mutation count do Introduce new random individuals to maintain diversity selection method 'tournament' The method used to select parents for crossover.operations ['h', 'x', 'cx'] The list of quantum gate operations that can be used in the circuits.</p>
<p>Challenges</p>
<p>The following challenges were critical in the implementation of the DeQompile software.</p>
<p>Syntactic correctness</p>
<p>Syntactic correctness is a critical aspect of the quantum circuit generation process, particularly in the context of quantum genetic programming.Ensuring the correct syntax of quantum gates and operations is essential for both the execution of the generated circuits for fitness calculation and the final decompilation result.</p>
<p>Decompile-time handling of runtime constraints</p>
<p>At decompile time, the focus is on generating quantum circuits that adhere to the syntax of quantum programming languages, such as QASM.This includes ensuring that the qubit indices, gate types, and angles are well-formed according to the quantum circuit model.However, runtime execution introduces additional constraints, including hardware-specific requirements such as qubit connectivity and gate fidelity.While syntactic correctness ensures that the generated quantum circuit can be parsed and compiled into executable code, runtime correctness requires that the quantum circuit also adheres to the physical limitations of the underlying quantum processor, which are not satisfied by the decompilation.</p>
<p>Qubit argument for multi-qubit gates</p>
<p>A common issue encountered during the generation of quantum circuits is ensuring that the qubit indices fall within valid bounds of n. .To avoid syntax errors, such as an index exceeding the number of qubits, we apply a modulo operation to the expression.
expr qubit = expr qubit mod n(2)
This approach works well for local operations (single-qubit gates).However, when dealing with non-local operators like the CNOT gate for two qubits or the Toffoli gate for three qubits, two/three arbitrary expressions need to be evaluated to distinct values.If the generated indices for both the control and target qubits are the same (i.e., CX(i, i)), the operation becomes invalid.This problem often arises when the randomly generated expressions for qubit indices do not properly account for the total number of qubits in the circuit.Since the evaluation of an expression is unknown at decompile time, such syntactic errors could not be prevented.During fitness calculation, if such errors are encountered, the fitness for the comparison is set to 0.</p>
<p>Divide-by-zero error for rotation angle expressions</p>
<p>A common challenge in maintaining syntactic correctness during quantum gate parameter calculations is the risk of divide-by-zero errors, particularly in gates like R y where parameters involve division.When the denominator approaches zero, this can lead to undefined behavior and runtime failures.To address this, one approach is to label such cases as invalid expressions and redo the sampling, ensuring that only valid parameter sets are used.This helps maintain the integrity of decompiled circuits and prevents execution issues.</p>
<p>Convergence</p>
<p>Convergence in evolutionary algorithms is a key factor, particularly when using genetic programming techniques to approximate a target quantum circuit.Achieving convergence in quantum circuit generation is challenging due to the high dimensionality of the parameter space and the complexity of quantum operations.</p>
<p>Convergence in parameter space</p>
<p>The parameter space of quantum circuits is typically large, as each quantum gate may involve several parameters (e.g., rotation angles for single-qubit gates).The complexity of the parameter space increases with the number of qubits and gates, making it difficult for the genetic algorithm to converge on an optimal solution.Convergence depends on the ability of the algorithm to effectively explore this high-dimensional space, which often requires fine-tuning the crossover and mutation operations to direct the search toward more promising regions of the solution space.Achieving convergence in such a complex space is non-trivial and often requires careful balance between exploration (searching new areas of the space) and exploitation (refining known good solutions) via hyperparameter tuning.</p>
<p>Distribution of gates and expression operators</p>
<p>Another challenge in achieving convergence lies in the distribution of gates and operators in the generated quantum circuits.The population of circuits evolved by the genetic algorithm may be biased toward certain types of gates, especially if those gates are overrepresented in the initial population or in the fitness evaluation function.For instance, an overabundance of single-qubit gates like the U 3 gate may lead to premature convergence, where the algorithm favors these gates without exploring more diverse or complex solutions.To mitigate this bias and encourage the exploration of a wider variety of circuits, the distribution of gates and operators must be managed to ensure a more balanced search across the solution space.This can be achieved by modifying the genetic algorithm to include mechanisms that prevent over-representation of specific gates or by introducing diversity-promoting techniques such as niching or speciation.</p>
<p>Experiments with DeQompile</p>
<p>To evaluate the performance of the genetic decompiler implementation, DeQompile, we conducted a series of experiments on quantum circuit datasets, ranging from simple patterns to more complex quantum algorithms.This section presents the results for each dataset, along with fitness score trends and key observations.</p>
<p>1-qubit ansatz</p>
<p>The first set of experiments focuses on one-qubit patterns to validate the decompiler's ability to reconstruct and optimize simple circuits.These include single loops, multiple operations in loops, and nested loops.These examples are motivated by common ansatz in variational algorithms like quantum alternating operator ansatz (QAOA) [59], the generalization of the quantum approximate optimization algorithm (of the same acronym, QAOA).Many common algorithms like quantum (inverse) Fourier transformation also include similar patterns.</p>
<p>Single loop:</p>
<p>We tested circuits applying a single gate iteratively to a qubit.For example:</p>
<p>• Applying multiple Hadamard gate (h 0(n)) to first qubit.
qc = n−1 ∏ i=0 H 0 • Applying the Hadamard gate (h c(n)) sequentially to all qubits. qc = n−1 ∏ i=0 H i
• Rotational gate R x applied to each qubit with exponentially decreasing angles (rx c(n)).
qc = n−1 ∏ i=0 R x ( π 2 i ) i
The decompiler achieved a perfect fitness score of 1.0 within 30 generations, demonstrating its effectiveness in reconstructing these simple patterns.The results of combined score over 3 trials are shown in Figure 4.As the figure shows, all three simple datasets get perfectly decompiled by our decompiler, the Highest scores of duplicate experiments for each quantum circuit all achieve a combined score 1, which means all individual metrics also reach score 1, we can also confirm it by checking the final qiskit code generated by our decompiler, which matches the certain pattern of these quantum circuits.Nested loops: Nested loops were also evaluated, involving interdependent operations such as combining R x gates on one qubit and H gates on another.Fitness scores displayed evolutionary jumps around 50 generations, indicating the decompiler's exploration and refinement capabilities.</p>
<p>Explainability-efficiency tradeoff in gate set transpilation</p>
<p>Native gates are the fundamental operations that a quantum processor can perform directly without needing further decomposition.Based on IBM's quantum systems [60], we consider the native gates R z , X, and √ X (the square root of X), along with CN OT as a common two-qubit gate.These gates form the basis of quantum circuit design on these platforms and directly influence the implementation and efficiency [61,62] of quantum algorithms.</p>
<p>In contrast to R z and X, the R y gate (rotation around the y-axis) is not commonly included as a native gate.To utilize R y operations, they must be constructed through the synthesis of available native gates, predominantly R z and X.We tested both undecomposed and decomposed versions of R y circuits to evaluate the decompiler's handling of circuit structure and decomposition.Specifically, we compared the following two scenarios as a proof of concept.</p>
<p>Undecomposed R y : R y (θ) gates applied directly to all qubits.</p>
<p>Decomposed R y : Circuits where R y gates are expressed using R x , R z , and H gates.The R y gate can be decomposed using RX and RZ gates, which are also native gates for some quantum hardware.
R y (θ) = R z ( π 2 ) ⋅ RX(θ) ⋅ R z (− π 2 )
As an alternate common decomposition, we consider using H and RX gates
R y (θ) = H ⋅ RX(θ) ⋅ H
The results in Figure 6 show that:</p>
<p>• Undecomposed circuits achieved perfect fitness scores within 40 generations.</p>
<p>• Decomposed circuits exhibited lower scores, with H-R x decompositions achieving better results than R x -R z decompositions, which requires multiple-parameter convergence.This experiment indicates that while decomposition improves hardware efficiency, it reduces readability, making the circuits harder to decompile.Further aspects of explainability-efficiency tradeoff can be explored via DeQompile, especially in the context of variational algorithms [63].</p>
<p>Conventional quantum algorithms</p>
<p>After conducting our decompiling experiments on simple quantum circuits, we extend the approach to more complex and commonly used quantum algorithms.Specifically, we selected GHZ state preparation circuits, quantum Fourier transform (QFT), and quantum phase estimation (QPE) as these exhibit a gradual increase in hierarchical and compositional complexity.In this section, we provide a brief review of the circuit structure before presenting the decompilation results.</p>
<p>GHZ state preparation: Greenberger-Horne-Zeilinger (GHZ) [64] state is an entangled quantum state involving multiple qubits.It is used in quantum communication, quantum error correction, and tests of quantum mechanics.The circuit is shown in Figure 7.     † ): Apply the inverse QFT on the first register to convert the quantum phase information into a readable binary format.The results of the decompiling on these algorithms is shown in Figure 10.The Qiskit code generated by the decompiler for the best individual from last generation is available in [56].The plot illustrates that the GHZ circuit achieves the best decompilation result, while the QFT is easier to decompile than the QPE.This matches the intuition of the complexity ordering among these examples.
0 H |0⟩ 1 X |0⟩ 2 X ⋮ |0⟩ n−2 |0⟩ n−1 XFigureH R z ( π 2 ) R z ( π 4 ) R z ( π 2 n−2 ) R z ( π 2 n−1 ) |0⟩ 1 H R z ( π 2 ) R z ( π 2 n−3 ) R z ( π 2 n−2 ) |0⟩ 2 ⋮ |0⟩ n−2 |0⟩ n−1 . . . . . . . . . . . . . . . . . . . . . . . . |0⟩ 0 |0⟩ 1 |0⟩ 2 H R z ( π 2 n−4 ) R z ( π 2 n−3 ) ⋮ |0⟩ n−2|0⟩ 0 H QF T † |0⟩ 1 H |0⟩ 2 H ⋮ |0⟩ n−2 H |0⟩ n−1 H |ψ⟩ ⊗m U 2 0 U 2 1 U 2 2 U 2 n−2 U 2 n−1
QFT convergence was further inspected in the range of 2 − 10 qubits to assess scalability.Smaller QFT circuits (2 − 5 qubits) achieved fitness scores above 0.9 within 100 generations, while larger QFT circuits (6 − 10 qubits) converged more slowly, plateauing at scores around 0.85 after 150 generations.This indicates the decompiler's effectiveness for smaller patterns, while larger circuits present additional challenges due to the exponential growth in gate sequences.</p>
<p>Conclusion</p>
<p>In the current era of ubiquitous software automation, this research champions the need to distill higher-level abstractions that are both understandable to human experts and amenable to formal analysis.Understanding the underlying algorithm behind a family of quantum circuits motivates us to develop DeQompile, a QASM to Qiskit decompiler.Genetic programming is employed to evolve a candidate solution over generations, using the abstract syntax tree representation of Qiskit's Python code.We designed a software framework consisting of strategies to generate syntactically valid and expressive individuals, evolution operations, and hyperparameter tuning.We defined a set of metrics like gate sequence frequency, gate sequence similarity, and line-by-line comparison to evaluate the fitness of the decompilation.The open-sourced DeQompile tool was demonstrated on a series of examples with increasing complexity, from common ansatz patterns to popular quantum algorithms.We also demonstrate the explainability-efficiency tradeoff in quantum algorithms during native gate transpilation.This research provides a novel explainability framework in quantum information processing.</p>
<p>We infer some promising future directions based on the experiments conducted.The DeQompile tool can be extended to include measurements and control flow structures that are essential for protocols like error correction.Our current approach to fitness calculation is based on comparing the textual QASM syntax, which fails to capture semantic similarities (e.g., commuting gates).However, assessing semantic similarity while avoiding the manipulation of exponential-sized unitary matrices remains an open question.It was evident that genetic programming, while being successful for symbolic regression fails to decompile or synthesize complex structures.While further investigation into hyper-parameter tuning is imperative, it is also worthwhile to explore alternate program synthesis methods based on neural networks.It is important to realize that while the neural network itself is not necessarily explainable (equivalent to the random mutation in our case), the overall architecture adheres to the neuro-symbolic paradigm [67] with its distinct opportunities.Advancements in foundational models [45,46,68] can augment quantum decompilation capabilities in the future.Additionally, prior knowledge can be used to guide the convergence of the decompilation.This can be incorporated via hierarchical reinforcement learning of a concept library [37,69,33].Such an augmented framework would be equipped to decompile a suite of conventional or generated quantum circuits [70,71,72,73].Finally, as an alternate use case, the DeQompile can also be used to compress quantum circuits [74,39,38] and estimate the algorithmic information content [75,39,38] with multiple theoretical and practical implications.</p>
<p>nAFigure 1 :
1
Figure 1: Software architecture of DeQompile</p>
<p>def rx_c ( n ) : qc = Quan tumCircu it ( n ) angle = pi for i in range ( n ) : qc .rx ( angle , i ) angle /= 2 return qc Listing 1: Qiskit example for a rx c module The corresponding AST structure includes: -Module: The root node representing the quantum program.-FunctionDef: Defines the function rx c with arguments.</p>
<p>Figure 2 :
2
Figure 2: AST structure for a simple Qiskit function</p>
<p>Figure 3 :
3
Figure 3: An example of the effect of AST crossover on Qiskit codes</p>
<p>9 :Add C 1 , C 2 to P new 11
9111
Generate offspring (C 1 , C 2 ) via crossover 10:</p>
<p>Figure 4 :
4
Figure 4: DeQompile performance for 1-qubit ansatz.The mean best score and maximum score across generations demonstrate steady improvement.The parameters used for generating the plot are: mutation rate=0.3,pop size=40, generations=100, rep=3, total qubit=20, max length=10, perform crossover=True, crossover rate=0.3,new gen rate=0.2,max loop depth=2, mutation rate 2=0.5</p>
<p>(a) Best code for h c (b) Best code for h 0 (c) Best code for rx c</p>
<p>Figure 5 :
5
Figure 5: Best decompiled codes for 1-qubit ansatz</p>
<p>Figure 6 :
6
Figure6: Fitness evolution for RY circuits for various native gate availability.Undecomposed circuits converge faster and achieve higher scores compared to decomposed versions.Here ry decomposed means the decomposition of r x and h for the ry c circuit, and ry rx rz means the decomposition of r y and r z for the r c circuit.The hyperparameter settings for the R y gate experiments are as follows: mutation rate=0.3,new gen rate=0.3,crossover rate=0.2,mutation rate 2=0.99, max length=4, max loop depth=3, qubit limit=10, pop size=50, generations=400, rep=3.</p>
<p>|0⟩</p>
<p>Figure 9 :
9
Figure 9: Quantum circuit for quantum phase estimation.QF T † refers to the inverted circuit of Figure 8.</p>
<p>Figure 10 :
10
Figure 10: Genetic decompilation performance over generations.The plot shows the mean best score and the maximum score across generations for different algorithms: QFT decomposition (qft decom), QPE decomposition (qpe dec), and GHZ state preparation (ghz state).The mean best score represents the average score of the best individual across all experiments for each generation, while the max score indicates the highest score achieved among all repetitions for each generation.The hyperparameter settings are as follows: mutation rate=0.3,new gen rate=0.3,crossover rate=0.2,mutation rate 2=0.99, max length=4, max loop depth=3, qubit limit=10, pop size=40, generations=500, rep=3.</p>
<p>Table 1 :
1
Examples of generating quantum gate calls using generate gate call function.</p>
<p>1 :
1
Initialize: Population P ← generate initial population(pop size) 2: for generation = 1 to generations do Select best individual I best with fitness f best Initialize new population P new ← {I best } ▷ Elitism
3:Evaluate fitness F for each individual in P4:Sort P by F in descending order5:6:7:</p>
<p>16 :
16
Update P ← P new 17: end for 18: return best individual I best The hyperparameter of DeQompile is listed in</p>
<p>Table 2 Table 2 :
22
Hyperparameters for DeQompile
Hyperparameter Default value Descriptionalgorithm nameN/AThe name of the quantum algorithm to be decompiled.qubit limit20The maximum number of qubits in the generated quantumcircuits.generations100The number of generations the genetic algorithm will run.pop size50The size of the population in each generation.max length10The maximum number of operations in the generated quantumcircuits.crossover rate0.3The rate at which crossover operations occur.new gen rate0.2The rate at which new random individuals are introduced tothe population.mutation rate0.1The rate at which mutation operations occur.compare method'l by l'The method used to compare the generated QASM files withthe target QASM files.max loop depth2The maximum depth of nested loops in the generated qiskitcodes.</p>
<p>[65]OT gates: Apply CNOT gates between consecutive qubits (or, alternatively, from the first qubit to other qubits) to entangle them, creating the GHZ state.Quantum Fourier transform: The quantum Fourier transform is a linear transformation on quantum bits, analogous to the discrete Fourier transform in classical computation[65].It is a crucial component in many quantum algorithms, including Shor's algorithm for factoring.The key steps for QFT are:1.Superposition: Apply Hadamard gates to put the qubits into a state of superposition, encoding the input in quantum parallelism.2. Phase rotation: Apply a series of controlled phase rotation gates to entangle the qubits and encode the Fourier transform coefficients.Each subsequent Z-rotation involves a smaller angle by a factor of 2, i.e.,
π 2 , π 4 , etc.|0⟩ 0. . .. . .. . .. . .. . .. . .. . .. . .. . .. . .. . .. . .. . .. . .. . .
7: Quantum circuit for GHZ state preparationThe key steps for constructing a GHZ state preparation circuit are: 1. Hadamard gate: Apply a Hadamard gate to the first qubit to create a superposition state. 2</p>
<p>[66]tum phase estimation[66]is a fundamental algorithm used to estimate the phase (eigenvalue) introduced by a unitary operator.It has applications in various fields, including factoring, cryptography, and quantum chemistry.The key steps for QPE are:1.State preparation: Initialize two registers: the first with qubits in superposition to act as controls, and the second with an eigenstate of the unitary operator.2. Controlled unitary operations: Apply controlled unitary operations that evolve the second register based on the state of the first register.3. Inverse quantum Fourier transform (QFT
. . .. . .. . .. . .. . .. . .⋮. . .HR z ( π 2 ). . .|0⟩ n−1. . .. . .
H Figure 8: Quantum circuit for quantum Fourier transform (little endian) Quantum phase estimation:</p>
<p>AcknowledgementsA didactic introduction and additional details of the implementation presented in this article can be found in the corresponding master thesis[56].We thank Vedran Dunjko for insightful discussions during the project planning and evaluation.AS acknowledges funding from the Dutch Research Council (NWO) through the project "QuTech Part III Application-based research" (project no.601.QT.001Part III-C-NISQ).Software availabilityThe open-sourced code for the project, configuration files, output data, and plotting codes for the experiments presented in this article are available at: https://github.com/Advanced-Research-Centre/DeQompile/.Author contributionsConceptualization, A.S.; Methodology, A.S., S.F. and S.X.; Software, S.X. and A.S.; Validation, S.X. and A.S.; Writing -Original Draft Preparation, S.X. and A.S.; Writing -Review &amp; Editing, A.S. and S.F.; Visualization, S.X., S.F. and A.S.; Supervision, A.S. and S.F.; Project Administration, S.F. and A.S.;
Michael A Nielsen, Isaac L Chuang, Quantum Computation and Quantum Information. Cambridge University Press2010</p>
<p>Quantum error correction below the surface code threshold. Rajeev Acharya, Laleh Aghababaie-Beni, Igor Aleiner, Markus Trond I Andersen, Frank Ansmann, Kunal Arute, Abraham Arya, Nikita Asfaw, Juan Astrakhantsev, Atalaya, arXiv:2408.136872024arXiv preprint</p>
<p>Evidence for the utility of quantum computing before fault tolerance. Youngseok Kim, Andrew Eddins, Sajant Anand, Ken , Xuan Wei, Ewout Van Den, Sami Berg, Hasan Rosenblatt, Yantao Nayfeh, Michael Wu, Kristan Zaletel, Temme, Nature. 61879652023</p>
<p>Partially fault-tolerant quantum computing architecture with error-corrected clifford gates and space-time efficient analog rotations. Yutaro Akahoshi, Kazunori Maruyama, Hirotaka Oshima, Shintaro Sato, Keisuke Fujii, PRX Quantum. 51103372024</p>
<p>Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer. Peter W Shor, SIAM journal on computing. 2651999</p>
<p>A fast quantum mechanical algorithm for database search. K Lov, Grover, Proceedings of the twenty-eighth annual ACM symposium on Theory of computing. the twenty-eighth annual ACM symposium on Theory of computing1996</p>
<p>Quantum computing in the nisq era and beyond. John Preskill, 2018279</p>
<p>The bitter truth about gate-based quantum algorithms in the nisq era. Frank Leymann, Johanna Barzen, Quantum Science and Technology. 54440072020</p>
<p>The quantum house of cards. Xavier Waintal, Proceedings of the National Academy of Sciences. 1211e23132691202024</p>
<p>Olivier Ezratty, arXiv:2305.09518Where are we heading with nisq?. 2023arXiv preprint</p>
<p>Closing the gap between quantum algorithms and machines with hardware-software co-design. Fred Chong, Proceedings of the Great Lakes Symposium on VLSI 2023. the Great Lakes Symposium on VLSI 20232023</p>
<p>Myths around quantum computation before full fault tolerance: What no-go theorems rule out and what they don't. Zoltán Zimborás, Bálint Koczor, Zoë Holmes, Elsi-Mari Borrelli, András Gilyén, Hsin-Yuan Huang, Zhenyu Cai, Antonio Acín, Leandro Aolita, Leonardo Banchi, arXiv:2501.056942025arXiv preprint</p>
<p>The theory of variational hybrid quantum-classical algorithms. Jonathan Jarrod R Mcclean, Ryan Romero, Alán Babbush, Aspuru-Guzik, New Journal of Physics. 182230232016</p>
<p>Variational quantum algorithms. Marco Cerezo, Andrew Arrasmith, Ryan Babbush, Suguru Simon C Benjamin, Keisuke Endo, Jarrod R Fujii, Kosuke Mcclean, Xiao Mitarai, Lukasz Yuan, Cincio, Nature Reviews Physics. 392021</p>
<p>Quantum circuit architecture search for variational quantum algorithms. Yuxuan Du, Tao Huang, Shan You, Min-Hsiu Hsieh, Dacheng Tao, 2022npj Quantum Information862</p>
<p>A brief survey of quantum architecture search. Weiwei Zhu, Jiangtao Pi, Qiuyuan Peng, Proceedings of the 6th International Conference on Algorithms, Computing and Systems. the 6th International Conference on Algorithms, Computing and Systems2022</p>
<p>Quantum architecture search: A survey. Darya Martyniuk, Johannes Jung, Adrian Paschke, arXiv:2406.062102024arXiv preprint</p>
<p>Reinforcement learning for optimization of variational quantum circuit architectures. Mateusz Ostaszewski, Lea M Trenkwalder, Wojciech Masarczyk, Eleanor Scerri, Vedran Dunjko, Advances in Neural Information Processing Systems. 202134</p>
<p>Reinforcement learning-assisted quantum architecture search for variational quantum algorithms. Akash Kundu, arXiv:2402.137542024arXiv preprint</p>
<p>Evolutionary quantum architecture search for parametrized quantum circuits. Li Ding, Lee Spector, Proceedings of the Genetic and Evolutionary Computation Conference Companion. the Genetic and Evolutionary Computation Conference Companion2022</p>
<p>Evolutionary-based searching method for quantum circuit architecture. Anqi Zhang, Shengmei Zhao, Quantum Information Processing. 202322283</p>
<p>Explaining explanations: An overview of interpretability of machine learning. L H Gilpin, R Caruana, J Gehrke, P Koch, D H Chau, Proceedings of the 2018 ICML Workshop on Human Interpretability in Machine Learning. the 2018 ICML Workshop on Human Interpretability in Machine Learning2018</p>
<p>Explaining quantum circuits with shapley values: Towards explainable quantum machine learning. Raoul Heese, Thore Gerlach, Sascha Mücke, Sabine Müller, Matthias Jakobs, Nico Piatkowski, arXiv:2301.091382023arXiv preprint</p>
<p>Opportunities and limitations of explaining quantum machine learning. Elies Gil-Fuster, Jonas R Naujoks, Grégoire Montavon, Thomas Wiegand, Wojciech Samek, Jens Eisert, arXiv:2412.147532024arXiv preprint</p>
<p>On the interpretability of quantum neural networks. Lirandë Pira, Chris Ferrie, Quantum Machine Intelligence. 62522024</p>
<p>Feature importance and explainability in quantum machine learning. Luke Power, Krishnendu Guha, arXiv:2405.089172024arXiv preprint</p>
<p>Quantum gradient class activation map for model interpretability. Hsin-Yi Lin, Huan-Hsin Tseng, Samuel , Yen-Chi Chen, Shinjae Yoo, 2024 IEEE Workshop on Signal Processing Systems (SiPS). IEEE2024</p>
<p>Interpretable quantum architecture search using weisfeiler-lehman kernels. npj Quantum Information. Shuxiang Ru, Xin Tan, Yifan Zhang, 20206</p>
<p>Neural architecture search with interpretable meta-features and fast predictors. Iury Ba Gean T Pereira, Luís Pf Santos, Thierry Garcia, Muriel Urruty, André Cplf De Visani, Carvalho, Information Sciences. 6491196422023</p>
<p>Curriculum reinforcement learning for quantum architecture search under hardware errors. J Yash, Akash Patel, Mateusz Kundu, Xavier Ostaszewski, Vedran Bonet-Monroig, Onur Dunjko, Danaci, The Twelfth International Conference on Learning Representations. 2024</p>
<p>A quantum information theoretic analysis of reinforcement learning-assisted quantum architecture search. Abhishek Sadhu, Aritra Sarkar, Akash Kundu, Quantum Machine Intelligence. 62492024</p>
<p>Kanqas: Kolmogorov-arnold network for quantum architecture search. Akash Kundu, Aritra Sarkar, Abhishek Sadhu, EPJ Quantum Technology. 111762024</p>
<p>From easy to hard: Tackling quantum problems with learned gadgets for real hardware. Akash Kundu, Leopoldo Sarra, arXiv:2411.002302024arXiv preprint</p>
<p>Automated quantum software engineering. Aritra Sarkar, Automated Software Engineering. 3112024</p>
<p>Distilling free-form mathematical expressions from experimental data. Michael Schmidt, Hod Lipson, Science. 32459232009</p>
<p>Top-down synthesis for library learning. Matthew Bowers, Theo X Olausson, Lionel Wong, Gabriel Grand, Joshua B Tenenbaum, Kevin Ellis, Armando Solar-Lezama, Proceedings of the ACM on Programming Languages. 72023</p>
<p>Andrea López Lea M Trenkwalder, Hendrik Incera, Fulvio Poulsen Nautrup, Hans J Flamini, Briegel, arXiv:2212.12743Automated gadget discovery in science. 2022arXiv preprint</p>
<p>Applications of Quantum Computation and Algorithmic Information: for Causal Modeling in Genomics and Reinforcement Learning. Aritra Sarkar, 2022Delft University of TechnologyPhD thesis</p>
<p>Qksa: Quantum knowledge seeking agent. Aritra Sarkar, Zaid Al-Ars, Koen Bertels, International Conference on Artificial General Intelligence. Springer2022</p>
<p>Quantum circuit design for universal distribution using a superposition of classical automata. Aritra Sarkar, Zaid Al-Ars, Koen Bertels, arXiv:2006.009872020arXiv preprint</p>
<p>Estimating algorithmic information using quantum computing for genomics applications. Aritra Sarkar, Zaid Al-Ars, Koen Bertels, Applied Sciences. 11626962021</p>
<p>Flash fill: A programming by example tool for spreadsheets. Andrew Gauthier, Nathan Cho, Vidhya Narayanan, Joseph Smith, ACM Conference on Human Factors in Computing Systems. 2015</p>
<p>A survey on automated dynamic malware analysis techniques and tools. Manuel Egele, Thorsten Holz, Engin Kirda, Christopher Kruegel, Giovanni Vigna, ACM Computing Surveys (CSUR). 4422008</p>
<p>Polyunpack: Automated packing analysis for malicious code. Pat Royal, Michael Hovis, Jared Reaves, Tim Goodwin, Timothy Hines, Shane Packard, Proceedings of the 2006 IEEE Symposium on Security and Privacy. the 2006 IEEE Symposium on Security and Privacy2006</p>
<p>Degpt: Optimizing decompiler output with llm. Peiwei Hu, Ruigang Liang, Kai Chen, Proceedings 2024 Network and Distributed System Security Symposium. 2024 Network and Distributed System Security Symposium2024. 2024267622140</p>
<p>Automated discovery of algorithms from data. J Paul, Kesavan Blazek, Milo M Venkatesh, Lin, Nature Computational Science. 422024</p>
<p>Genetic Programming: On the Programming of Computers by Means of Natural Selection. John R Koza, 1992MIT PressCambridge, MA</p>
<p>A survey on neural decompilation: From machine code to high-level programs. Riccardo Baldoni, Andrea De Benedictis, Emanuele Marchiori, ACM Computing Surveys (CSUR). 5142018</p>
<p>Automatic Quantum Computer Programming: a genetic programming approach. Lee Spector, 2004Springer Science &amp; Business Media7</p>
<p>A brief introduction to quantum genetic programming. Lee Spector, Genetic Programming and Evolvable Machines. 20034</p>
<p>Ali Javadi-Abhari, Matthew Treinish, Kevin Krsulich, Christopher J Wood, Jake Lishman, Julien Gacon, Simon Martiel, Lev S Paul D Nation, Andrew W Bishop, Cross, arXiv:2405.08810Quantum computing with qiskit. 2024arXiv preprint</p>
<p>Openqasm 3: A broader and deeper quantum assembly language. Andrew Cross, Ali Javadi-Abhari, Thomas Alexander, Niel De Beaudrap, Lev S Bishop, Steven Heidel, Prasahnt Colm A Ryan, John Sivarajah, Jay M Smolin, Gambetta, ACM Transactions on Quantum Computing. 332022</p>
<p>A normalized levenshtein distance metric. Li Yujian, Liu Bo, IEEE transactions on pattern analysis and machine intelligence. 200729</p>
<p>Three approaches to the quantitative definition of information in an individual pure quantum state. Paul Vitanyi, quant-ph/99070352000arXiv preprint</p>
<p>Balancing accuracy and parsimony in genetic programming. Byoung-Tak Zhang, Heinz Mühlenbein, Evolutionary Computation. 311995</p>
<p>Quantum circuit decompiler: Pattern recognition of quantum circuits by genetic algorithm. Shubing Xie, 82024Leiden UniversityMaster's thesis</p>
<p>Sympy: symbolic computing in python. Aaron Meurer, Christopher P Smith, Mateusz Paprocki, Ondřej Čertík, B Sergey, Matthew Kirpichev, Amit Rocklin, Sergiu Kumar, Jason K Ivanov, Sartaj Moore, Singh, PeerJ Computer Science. 3e1032017</p>
<p>Algebraic simplification a guide for the perplexed. Joel Moses, Proceedings of the second ACM symposium on Symbolic and algebraic manipulation. the second ACM symposium on Symbolic and algebraic manipulation1971</p>
<p>From the quantum approximate optimization algorithm to a quantum alternating operator ansatz. Stuart Hadfield, Zhihui Wang, Eleanor G Bryan O'gorman, Davide Rieffel, Rupak Venturelli, Biswas, Algorithms. 122342019</p>
<p>Ibm quantum guides. 2024IBM</p>
<p>Yaqq: Yet another quantum quantizer-design space exploration of quantum gate sets using novelty search. Aritra Sarkar, Akash Kundu, Matthew Steinberg, Sibasish Mishra, Sebastiaan Fauquenot, Tamal Acharya, Jaros Miszczak, Sebastian Feld, arXiv:2406.176102024arXiv preprint</p>
<p>Visualizing quantum circuit probability: estimating quantum state complexity for quantum program synthesis. Gia Bao, Akash Bach, Kundu, Entropy. 2557632023Tamal Acharya, and Aritra Sarkar</p>
<p>Variational learning of grover's quantum search algorithm. Timur Mauro Es Morales, Jacob Tlyachev, Biamonte, Physical Review A. 986623332018</p>
<p>Going beyond bell's theorem. In Bell's theorem, quantum theory and conceptions of the universe. Michael A Daniel M Greenberger, Anton Horne, Zeilinger, 1989Springer</p>
<p>Shor's algorithm and the quantum fourier transform. Fang Xi, Lin , 2014McGill University</p>
<p>Quantum measurements and the abelian stabilizer problem. Kitaev Yu, 1995arXiv preprint quant-ph/9511026</p>
<p>Jennifer J Sun, Megan Tjandrasuwita, Atharva Sehgal, Armando Solar-Lezama, Swarat Chaudhuri, Yisong Yue, Omar Costilla-Reyes, arXiv:2210.05050Neurosymbolic programming for science. 2022arXiv preprint</p>
<p>Explainable neural networks that simulate reasoning. J Paul, Milo M Blazek, Lin, Nature Computational Science. 192021</p>
<p>Discovering quantum circuit components with program synthesis. Leopoldo Sarra, Kevin Ellis, Florian Marquardt, arXiv:2305.017072023arXiv preprint</p>
<p>MQT Bench: Benchmarking software and design automation tools for quantum computing. Nils Quetschlich, Lukas Burgholzer, Robert Wille, Quantum, 2023. MQT Bench is. </p>
<p>Ketgpt-dataset augmentation of quantum circuits using transformers. Boran Apak, Medina Bandic, Aritra Sarkar, Sebastian Feld, International Conference on Computational Science. Springer2024</p>
<p>Quantum circuit distillation and compression. Shunsuke Daimon, Kakeru Tsunekawa, Ryoto Takeuchi, Takahiro Sagawa, Naoki Yamamoto, Eiji Saitoh, Japanese Journal of Applied Physics. 633320032024</p>
<p>Quantum circuit optimization using machine learning algorithms. Natividad Ruiz, Kevin Ochoa, David Iglesias, Daniel Martinez, Masashi Eguchi, Quantum Engineering. 2024</p>
<p>Concept discovery of energy-optimized quantum instruction sets based on algorithmic complexity. Sibasish Mishra, Aritra Sarkar, 2024</p>
<p>Matthew Steinberg, Medina Bandić, Sacha Szkudlarek, Carmen G Almudever, Aritra Sarkar, Sebastian Feld, Lightcone bounds for quantum circuit mapping via uncomplexity. npj Quantum Information. 202410113</p>            </div>
        </div>

    </div>
</body>
</html>