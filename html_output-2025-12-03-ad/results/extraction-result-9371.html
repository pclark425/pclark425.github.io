<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-9371 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-9371</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-9371</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-162.html">extraction-schema-162</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of using language models for detecting anomalies in lists, sequences, or tabular data, including details of the models, data types, methods, results, comparisons, and limitations.</div>
                <p><strong>Paper ID:</strong> paper-15e46987e753a7f01f3d0f3b23e5a948366f94e8</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/15e46987e753a7f01f3d0f3b23e5a948366f94e8" target="_blank">Outlier Detection for Text Data</a></p>
                <p><strong>Paper Venue:</strong> SDM</p>
                <p><strong>Paper TL;DR:</strong> This paper presents a matrix factorization method, which is naturally able to distinguish the anomalies with the use of low rank approximations of the underlying data, and has significant advantages over traditional methods for text outlier detection.</p>
                <p><strong>Paper Abstract:</strong> The problem of outlier detection is extremely challenging in many domains such as text, in which the attribute values are typically non-negative, and most values are zero. In such cases, it often becomes difficult to separate the outliers from the natural variations in the patterns in the underlying data. In this paper, we present a matrix factorization method, which is naturally able to distinguish the anomalies with the use of low rank approximations of the underlying data. Our iterative algorithm TONMF is based on block coordinate descent (BCD) framework. We define blocks over the term-document matrix such that the function becomes solvable. Given most recently updated values of other matrix blocks, we always update one block at a time to its optimal. Our approach has significant advantages over traditional methods for text outlier detection. Finally, we present experimental results illustrating the effectiveness of our method over competing methods.</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-9371",
    "paper_id": "paper-15e46987e753a7f01f3d0f3b23e5a948366f94e8",
    "extraction_schema_id": "extraction-schema-162",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.0054375,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Outlier Detection for Text Data : An Extended Version</h1>
<p>Ramakrishnan Kannan<br>Oak Ridge National<br>Laboratory<br>Oak Ridge, TN, USA<br>kannanr@ornl.gov</p>
<p>Hyenkyun Woo<br>Korea University of<br>Technology and Education<br>Republic of Korea<br>hyenkyun@koreatech.ac.kr<br>Charu C. Aggarwal<br>IBM T. J. Watson Research<br>Center<br>Yorktown Heights, NY, USA<br>charu@us.ibm.com<br>Haesun Park<br>Georgia Institute of<br>Technology<br>Atlanta, GA, USA<br>hpark@cc.gatech.edu</p>
<h2>ABSTRACT</h2>
<p>The problem of outlier detection is extremely challenging in many domains such as text, in which the attribute values are typically non-negative, and most values are zero. In such cases, it often becomes difficult to separate the outliers from the natural variations in the patterns in the underlying data. In this paper, we present a matrix factorization method, which is naturally able to distinguish the anomalies with the use of low rank approximations of the underlying data. Our iterative algorithm TONMF is based on block coordinate descent (BCD) framework. We define blocks over the term-document matrix such that the function becomes solvable. Given most recently updated values of other matrix blocks, we always update one block at a time to its optimal. Our approach has significant advantages over traditional methods for text outlier detection. Finally, we present experimental results illustrating the effectiveness of our method over competing methods.</p>
<h2>1 Introduction</h2>
<p>The problem of outlier detection is that of finding data points which are unusually different from the rest of the data set. Such outliers are also variously referred to as anomalies, deviants, discordants or abnormalities in the data. Since outliers correspond to unusual observations, they are often of interest to the analyst in finding interesting anomalies in the underlying generating process. The problem of</p>
<p>This manuscript has been authored by UT-Battelle, LLC under Contract No. DE-AC05-00OR22725 with the U.S. Department of Energy. The United States Government retains and the publisher, by accepting the article for publication, acknowledges that the United States Government retains a nonexclusive, paid-up, irrevocable, worldwide license to publish or reproduce the published form of this manuscript, or allow others to do so, for United States Government purposes. The Department of Energy will provide public access to these results of federally sponsored research in accordance with the DOE Public Access Plan (http://energy.gov/downloads/doe-public-access-plan). This research used resources of the Oak Ridge Leadership Computing Facility, which is a DOE Office of Science User Facility supported under Contract DE-AC05-00OR22725
outlier analysis is applicable to a wide variety of domains such as machine monitoring, financial markets, environmental modeling and social network analysis. Correspondingly, the problem has been studied in the context of different data types which arise in these domains, such as multidimensional data, spatial data, and discrete sequences. Numerous books and surveys have been written on the problem of outlier detection $[1,7,8,16]$.</p>
<p>In this paper, we will study the problem of text outlier analysis. The problem of text outlier analysis has become increasingly important because of the greater prevalence of web-centric and social media applications, which are rich in text data. Some important applications of text outlier analysis are as follows:</p>
<ul>
<li>Web Site Management: An unusual page from a set of articles in a web site may be flagged as an outlier. The knowledge of such outliers may be used for web site management.</li>
<li>Sparse High Dimensional Data: While the methods discussed in this paper have text applications in mind, they can be used for other sparse high dimensional domains. For example, such methods can be used for market basket data sets. Unusual transactions may sometimes provide an idea of fraudulent behaviour.</li>
<li>News Article Management: It is often desirable to determine unusual news article from a collection of news documents. An unusual news from a group of articles may be flagged as an interesting outlier.</li>
</ul>
<p>While text is an extremely important domain from the perspective of outlier analysis, there are surprisingly few methods which are specifically focused on this domain, even though many generic methods such as distance-based methods can be easily adapted to this domain [21, 29], and are often used for text outlier analysis. Domains such as text are particularly challenging for the problem of outlier analysis, because of their sparse high dimensional nature, in which only a small fraction of the words take on non-zero values. Furthermore, many words in a document may be topically irrelevant to the context of the document and add to the noise in the distance computations. For example, the word "Jaguar" may correspond to a car, or a cat depending on the context of the document. In particular, the significance of a word can</p>
<p>be interpreted only in terms of the structure of the data within the context of a particular data locality. As a result, document-to-document similarity measures often lose their robustness. Thus, commonly used outlier analysis methods for multidimensional data, such as distance-based methods, are not particularly effective for text data. Our experiments also validate this observation.</p>
<p>In this paper, we will use non-negative matrix factorization (NMF) methods to address the aforementioned challenges in text anomaly detection. One advantage of matrix factorization methods is that they decompose the termdocument structure of the underlying corpus into a set of semantic term clusters and document clusters. The semantic nature of this decomposition provides the context in which a document may be interpreted for outlier analysis. Thus, documents can be decomposed into word clusters, and words are decomposed into document clusters with a low-rank ${ }^{1}$ approximation. Outliers are therefore defined as data points which cannot be naturally expressed in terms of this decomposition. By using carefully chosen model formulations, one can further sharpen the matrix-factorization method to reveal document-centric outliers. One challenge in this case, is that the design of a matrix factorization approach, which is optimized to anomaly detection, results in a non-standard formulation. Therefore, we will design an optimization solution for this model. The NMF model also has the advantage of providing better interpretability, and it can also provide insights into why a document should be considered an outlier. We present extensive experimental results on many data sets, and compare against a variety of baseline methods. We show significant improvements achieved by the approach over a variety of other methods.</p>
<p>This paper is organized as follows. The remainder of this section discusses the related work. Section 2 introduces the model for outlier analysis. The algorithm to solve this model is provided in section 3. Section 4 provides the experimental results. The conclusions and summary are contained in section 5. Our code can be downloaded from https://github.com/ramkikannan/outliernmf and tried with any text dataset.</p>
<h3>1.1 Related Work</h3>
<p>The outlier analysis problem has been studied extensively in the literature $[1,7,16]$. Numerous algorithms have been proposed in the literature for outlier detection of conventional multidimensional data [2, 5, 21, 29]. The key methods, which are used frequently for outlier analysis include distance-based methods [21, 29], density-based methods [5], and subspace methods [2, 18, 24, 28, 23]. In distance-based methods, data points are declared outliers, when they are situated far away from the dense regions in the underlying data. Typically, indexing or other summarization schemes may be used in order to improve the efficiency of the approach. In density-based methods [5], data points with low local density with respect to the remaining points are declared outliers. In addition, a number of subspace methods [2, 18, 24, 28, 23] have been proposed recently, in which outliers are defined on the basis of subspace behavior of the underlying data.</p>
<p>Most of the traditional multidimensional methods [7, 1]
$9^{1}$ In this paper, we use the terms "low rank approximation" and "matrix factorization" interchangeably. Similarly, we used the terms "anomalies" and "outliers" interchangeably.
can also be extended to text data, though they are not particularly suited to the latter. Some methods have been designed for outlier detection with matrix factorization in network data sets [31], that are not applicable to text data. Text data is uniquely difficult because of its sparse and high dimensional nature. As a result, many of the outliers detected using conventional methods may simply correspond to noisy text segments. Therefore, careful modeling is required with the use of matrix factorization methods.</p>
<p>Over the last decade, Non-negative Matrix Factorization (NMF) has emerged as another important low rank approximation technique, where the low-rank factor matrices are constrained to have only non-negative elements. Lee and Seung [25] introduced a multiplicative update based low rank approximation with non-negative factors to overcome the challenges of truncated SVD. Subsequent to this work, NMF has received enormous attention and has been successfully applied to a broad range of important problems in areas including computer vision, community detection in social networks, visualization, recommender systems bioinformatics, etc. In spite of broad range of applications, NMF's literature in text domain is scarce. Xu et. al. [34] experimented with NMF for document clustering instead of SVD based Latent Semantic Indexing (LSI). Other than applications of NMF in the text domain, Gaussier and Goutte [14] established the equivalence between NMF and pLSA. Similarly, Ding et. al. [11] explained the equivalence between NMF and pLSI.</p>
<p>In this paper, we use an NMF approach for concise modelling of the patterns, the background, and the anomalies in the underlying data. It should be pointed out that NMF is similar to the generative models of text such as pLSI and LDA [14] [11] [30], though NMF often provides better interpretability. Our important challenge is to model the outliers along with the low rank space of the input matrix. We identified $\ell_{1,2}$-norm as an appropriate approach for factorization in outlier analysis. Recently, the researchers have used $\ell_{2,1^{-}}$ norm in their models to solve various problems, though the corresponding solution techniques are not easily generalizable to the $\ell_{1,2}$-norm. Yang et.al., [35], under the assumption that the class label of input data can be predicted by a linear classifier, incorporate discriminative analysis and $\ell_{2,1^{-}}$ norm minimization into a joint framework for unsupervised feature selection problem. Similarly, Liu et al [27], solve $\ell_{2,1^{-}}$ norm regularized regression model for joint feature selection from multiple tasks. They also propose to use Nesterov's method to solve the optimization problem with non-smooth $\ell_{2,1}$-norm regularization. Also, Kong et al [22] propose a robust formulation of NMF using $\ell_{2,1}$-norm loss function for data with noises.</p>
<h3>1.2 Our Contributions</h3>
<p>Text data is uniquely challenging to outlier detection both because of its sparsity and high dimensional nature. Given the relevant literature for NMF and text outliers, we propose the first approach to detect outliers in text data using nonnegative matrix factorization. We extend the fact that NMF is similar to pLSI and LDA generative models and model the outliers using the $\ell_{1,2}$-norm. This particular formulation of NMF is non-standard, and requires careful design of optimization methods to solve the problem. We solve the resulting optimization problem using block coordinate descent technique. We also present extensive experimental</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Notation</th>
<th style="text-align: left;">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$\mathbf{A}=\left|\mathbf{a}<em n="n">{1} \cdots \mathbf{a}</em>$}\right| \in \mathbb{R}_{+}^{m \times n</td>
<td style="text-align: left;">Document-word matrix</td>
</tr>
<tr>
<td style="text-align: left;">$m$</td>
<td style="text-align: left;">Vocabulary size</td>
</tr>
<tr>
<td style="text-align: left;">$n$</td>
<td style="text-align: left;">Number of documents</td>
</tr>
<tr>
<td style="text-align: left;">$\mathbf{Z} \in \mathbb{R}^{m \times n}$</td>
<td style="text-align: left;">Outlier matrix</td>
</tr>
<tr>
<td style="text-align: left;">$r&lt;\operatorname{rank}(\mathbf{A})$</td>
<td style="text-align: left;">Rank</td>
</tr>
<tr>
<td style="text-align: left;">$\mathbf{W} \in \mathbb{R}_{+}^{m \times r}$</td>
<td style="text-align: left;">Term-Topic matrix</td>
</tr>
<tr>
<td style="text-align: left;">$\mathbf{H} \in \mathbb{R}_{+}^{r \times n}$</td>
<td style="text-align: left;">Topic-Document matrix</td>
</tr>
<tr>
<td style="text-align: left;">$\mathbf{A}^{(i)}$</td>
<td style="text-align: left;">Matrix $\mathbf{A}$ from the $i^{t h}$ iteration</td>
</tr>
<tr>
<td style="text-align: left;">$|\mathbf{A}|_{1,2}$</td>
<td style="text-align: left;">$\sum_{i=1}^{n}\left|\mathbf{a}<em _ell__2="\ell_{2">{i}\right|</em>$-Norm where,}} \ell_{12</td>
</tr>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">$\mathbf{a}_{i} \in \mathbb{R}^{m}$ is the $i$-th column of $\mathbf{A}$</td>
</tr>
</tbody>
</table>
<p>Table 1: Notations used in the paper
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Text Outliers Using NMF
results both on text and other kinds of market basket data sets. We show significant improvements achieved by the approach over other baseline methods.</p>
<h2>2 Matrix Factorization Model</h2>
<p>This section will present the matrix factorization model which is used for outlier detection. Before discussing the model in detail, we present the notations and definitions. We represent the corpus of text documents as a bag of words matrix. A lowercase or uppercase letter such as $x$ or $X$, is used to denote a scalar. A boldface lowercase letter, such as $\mathbf{x}$, is used to denote a vector, and a boldface uppercase letter, such as $\mathbf{X}$, is used to denote a matrix. This is consistent with what is commonly used in much of the data mining literature. Indices typically start from 1, unless otherwise mentioned. For a $\mathbf{X}, \mathbf{x}<em j="j">{i}$ denotes its $i^{t h}$ column, $\mathbf{y}</em>$ element.}^{\dagger}$ denotes its $j^{t h}$ row and $x_{i j}$ or $X(i, j)$ or $(X)_{i j}$ denote its $(i, j)^{t h</p>
<p>For greater expressibility, we have also borrowed certain notations from matrix manipulation scripts such as Matlab and Octave. For example, the notation $\max (\mathbf{x})$ returns the maximal element $x \in \mathbf{x}$ and $\max (\mathbf{X})$ returns a vector of maximal elements from each column $\mathbf{x} \in \mathbf{X}$. Similarly, $\mathbf{X}(i$, : ) denotes the $i$-th row of the matrix and $\mathbf{X}(:, i)$ for $i$-th column. For the reader's convenience, the notations used in the paper are summarized in Table 1.</p>
<p>Let $\mathbf{A}$ be the matrix representing the underlying data. In the context of a text collection, this corresponds to a termdocument matrix, where terms correspond to rows and documents correspond to columns. In other words, $a_{i j}$ denotes the number of times the term $i$ appears in document $j$. Generally, we can write $\mathbf{A}$ as follows:</p>
<p>$$
\mathbf{A}=\mathbf{L}<em _mathbf_0="\mathbf{0">{\mathbf{0}}+\mathbf{Z}</em>
$$}</p>
<p>Here, $\mathbf{L}<em _mathbf_0="\mathbf{0">{\mathbf{0}}$ is a low rank matrix and $\mathbf{Z}</em>}}$ represents the matrix of outlier entries. Typically, the matrix $\mathbf{L<em _mathbf_0="\mathbf{0">{\mathbf{0}}$ represents the documents created by a lower rank generative process (such as that modeled by pLSI), and the parts of the documents that do not correspond to the generative process are represented as part of the matrix $\mathbf{Z}</em>}}$. In real world scenarios, the outlier matrix $\mathbf{Z<em 0="0">{\mathbf{0}}$ contains entries which are very close to zero, and only a small number of entries have significantly non-zero values. These significantly nonzero entries are often present in only a small fraction of the columns. Columns which are fully representable in terms of factors are consistent with the low rank behavior of the data, and therefore not outliers. The rank of $\mathbf{L}</em>$ is not known in advance, and it can be expressed in terms of its underlying factors.</p>
<p>$$
\mathbf{L}<em 0="0">{0} \approx \mathbf{W}</em>
$$} \mathbf{H}_{0</p>
<p>Here, the two matrices have dimensions $\mathbf{W}<em _="+">{0} \in \mathbb{R}</em>}^{m \times r}, \mathbf{H<em _="+">{0} \in$ $\mathbb{R}</em>}^{r \times n}$, and $r \leq \operatorname{rank}\left(\mathbf{L<em 0="0">{0}\right)$. The matrices $\mathbf{W}</em>}$ and $\mathbf{H<em _mathbf_0="\mathbf{0">{0}$ are non-negative, and this provides interpretability in terms of being able to express a document as a non-negative linear combination of the relevant basis vectors, each of which in itself can be considered a frequency-annotated bag of words (topics) because of its non-negativity. Specifically, $\mathbf{H}</em>}}$ corresponds to the coefficients for the basis matrix $\mathbf{W<em i="i">{\mathbf{0}}$. Intuitively, this corresponds to the case that every document $\mathbf{a}</em>$ matrix. In real scenarios, the entries in this matrix are often extremely skewed, and the small number of non-zero entries very obviously expose the outliers. The decomposition of the matrix into different component is pictorially illustrated in Figure 1.}$, is represented as the linear combination of the $r$ topics. In cases, where this is not true, the document is an outlier, and those unrepresentable sections of the matrix are captured by the non-zero entries in the $\mathbf{Z}_{\mathbf{0}</p>
<p>In order to determine the best low rank factorization, one must try to optimize the aggregate values of the residuals in the matrix. This can of course be done in a variety of ways, depending upon the goals of the underlying factorization process. We model the determination of the matrices $\mathbf{W}, \mathbf{H}$, and $\mathbf{Z}$, as the following optimization problem:</p>
<p>$$
\left(\mathbf{W}<em 0="0">{0}, \mathbf{H}</em>} ; \mathbf{Z<em F="F">{0}\right)=\underset{\mathbf{W} \geq 0, \mathbf{H} \geq 0}{\arg \min } \frac{1}{2}|\mathbf{A}-\mathbf{W H}-\mathbf{Z}|</em>
$$}^{2}+\alpha|\mathbf{Z}|_{1,2</p>
<p>The specific location of outliers in each column does not have a closed form solution, since the $\ell_{1,2}$-norm penalty is applied to $\mathbf{Z}$. The logic for applying the $\ell_{1,2}$-norm in the context of the outlier detection problem is as follows. Each entry in the $\mathbf{Z}$ corresponds to a term in a document, whereas we are interested in the outlier behavior of entire document. This aggregate outlier behavior of the document $x$ can be modeled with the $\ell_{2}$ norm score of a particular column $\mathbf{z}<em _mathbf_0="\mathbf{0">{x}$. In a real scenario, if a large segment of a document $x$ is not representable as the linear combination of the $r$ topics through $\mathbf{L}</em>}}$, the corresponding column $\mathbf{z<em 2="2">{x}$ in the matrix $\mathbf{Z}$ will be compensated by having more entries in its column. In other words, we will have a higher $\ell</em>}$ value for the corresponding column $\mathbf{z<em 1_2="1,2">{x}$, and this corresponds to a higher outlier score. Furthermore, the $\ell</em>$ norm outlier scores over all the documents. Therefore, the optimization problem essentially tries to find the best model, an important component of which is to minimize the sum of the outlier scores over all documents. While a variety of different (and more commonly used) penalties such}$-norm penalty on $\mathbf{Z}$ defines the sum of the $\ell_{2</p>
<p>as the Frobenius norm are available for matrix factorization models, we have chosen the $\ell_{1,2}$-norm penalty because of its intuitive significance in the context of the outlier detection problem, and its tendency to create skewed outlier scores across the columns of the matrix. As we will see in the next section, this comes at the expense of a formulation which is more difficult to solve algorithmically.</p>
<p>For high dimensional data, sparse coefficients are desirable for obtaining an interpretable low rank matrix $\mathbf{W H}$. For this purpose, we add the $\ell_{1}$-penalty on $\mathbf{H}$ :</p>
<p>$$
\min <em F="F">{\mathbf{W} \geq 0, \mathbf{H} \geq 0, \mathbf{Z}} \frac{1}{2}|\mathbf{A}-\mathbf{W H}-\mathbf{Z}|</em>|}^{2}+\alpha|\mathbf{Z<em 1="1">{1,2}+\beta|\mathbf{H}|</em>
$$</p>
<p>The constant $\alpha$ defines the weight for the outlier matrix $\mathbf{Z}$ over the recovery of the low rank space $\mathbf{L}$ and the sparsity term. In the case of outlier detection in text documents, we give more weight for the outlier matrix over the low rank representation $\mathbf{L}$. This problem does not have a closed form solution, and therefore we cannot directly recover the low rank matrix $\mathbf{W H}$ in closed form. However, we can recover the column space. Without non-negativity constraints, this property is also known as the rotational invariant property $[12,33]$. This particular formulation of the matrix factorization model is a bit different from the commonly used formulations, and off-the-shelf solutions do not directly exist for this scenario. Therefore, in a later section, we will carefully design an algorithm with the use of block coordinate descent for this problem.</p>
<p>In order to understand the modeling of the outliers better, we present the readers with a toy example from a real world data set, to show how skewed the typical values of the corresponding column $\mathbf{z}(x)$ may be in real scenarios. In this case, we used the $B B C$ dataset ${ }^{2}$. This dataset consists of documents from BBC news website corresponding to stories in area business, entertainment, politics, sport, tech from 2004-2005 . We took all the documents from business and politics and 50 documents from tech labeled as outliers. We randomly permuted the columns to shuffle the outliers in the matrix to avoid any spatial bias. We computed the $\mathbf{Z}$ matrix and generated the $\ell_{2}$ scores of the columns of outlier matrix $\mathbf{Z}$. Figure 2 shows the outlier $\left(\ell_{2}\right)$ scores of the documents. The $X$-axis illustrates the index of the document, and the $Y$ axis illustrates the outlier score. It is evident that the scores for some columns are so close to zero, that they cannot even be seen on the diagram drawn to scale. These columns also happened to be the non-outlier/regular documents of the collection. Such documents $\mathbf{a}<em x="x">{x} \in \mathbb{R}^{m}$ correspond to the low rank space, and are approximately representable as a product of the basis matrix $\mathbf{W}$ with the corresponding column vector of coefficients $\mathbf{h}</em>$. However, the documents that are not representable in such a low rank space have a large outlier score. From the distribution of the outlier score, we can also observe that the scores of outlier documents against non-outliers are clearly separable, by using a simple statistical mean and standard deviation analysis. Therefore, while we use the scores to rank the documents in terms of their outlier behavior, the skew in the entries ensures that it is often easy to choose a cut-off in order to distinguish the outliers from the non-outliers.} \in \mathbb{R}^{r}$ drawn from $\mathbf{H</p>
<p>In the following sections, we will analyze the property and performance of this model (3) for outlier detection prob-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: $\ell_{2}$ norm of columns of $\mathbf{Z}$ outlier matrix
lems.</p>
<h2>3 Algorithmic Solution</h2>
<p>As discussed earlier our technique is based on NMF, and this particular formulation (3), which is suited to outlier analysis, is relatively uncommon, and does not have a closed form solution. In order to address this issue we use a Block Coordinate Descent (BCD) framework and its application to solve the optimization problem (3). The BCD framework is a popular choice not only because of the ease in implementation, but also because it is scalable. First, we will lay the foundation for the basic BCD technique, as it generally applies to non-linear optimization problems. We will then relate it to our non-negative matrix factorization problem, and explain our algorithm Text Outliers using Nonnegative Matrix Factorization(TONMF) in detail.</p>
<h3>3.1 Block coordinate Descent</h3>
<p>In this section, we will see relevant foundation for using this framework. Consider a constrained non-linear optimization problem as follows:</p>
<p>$$
\min f(x) \text { subject to } x \in \mathcal{X}
$$</p>
<p>Here, $\mathcal{X}$ is a closed convex subset of $\mathbb{R}^{n}$. An important assumption to be exploited in the BCD method is that the set $\mathcal{X}$ is represented by a Cartesian product:</p>
<p>$$
\mathcal{X}=\mathcal{X}<em m="m">{1} \times \cdots \times \mathcal{X}</em>
$$</p>
<p>where $\mathcal{X}<em j="j">{j}, j=1, \cdots, m$, is a closed convex subset of $\mathbb{R}^{N</em>}}$, satisfying $n=\sum_{j=1}^{m} N_{j}$. Accordingly, the vector $\mathbf{x}$ is partitioned as $\mathbf{x}=\left(\mathbf{x<em m="m">{1}, \cdots, \mathbf{x}</em>}\right)$ so that $\mathbf{x<em j="j">{j} \in \mathcal{X}</em>}$ for $j=1, \cdots, m$. The BCD method solves for $\mathbf{x<em 1="1">{j}$ by fixing all other subvectors of $\mathbf{x}$ in a cyclic manner. That is, if $\mathbf{x}^{(i)}=\left(\mathbf{x}</em>}^{(i)}, \cdots, \mathbf{x<em 1="1">{m}^{(i)}\right)$ is given as the current iterate at the $i^{t h}$ step, the algorithm generates the next iterate $\mathbf{x}^{(i+1)}=\left(\mathbf{x}</em>\right)$ block by block, according to the solution of the following subproblem:}^{(i+1)}, \cdots, \mathbf{x}_{m}^{(i+1)</p>
<p>$$
\mathbf{x}<em j="j">{j}^{(k+1)} \leftarrow \underset{\xi \in \mathcal{X}</em>}}{\operatorname{argmin}} f\left(\mathbf{x<em j-1="j-1">{1}^{(k+1)}, \cdots, \mathbf{x}</em>}^{(k+1)}, \xi, \mathbf{x<em m="m">{j+1}^{(k)}, \cdots, \mathbf{x}</em>\right)
$$}^{(k)</p>
<p>Also known as a non-linear Gauss-Seidel method [3], this algorithm updates one block each time, always using the</p>
<p>most recently updated values of other blocks $\mathbf{x}_{\tilde{j}}, \tilde{j} \neq j$. This is important since it ensures that after each update, the objective function value does not increase. For a sequence $\left{\mathbf{x}^{(i)}\right}$ where each $\mathbf{x}^{(i)}$ is generated by the BCD method, the following property holds.</p>
<p>Theorem 1: Suppose $f$ is continuously differentiable in $\mathcal{X}=\mathcal{X}<em m="m">{1} \times \cdots \times \mathcal{X}</em>, j=1, \cdots, m$, are closed convex sets. Furthermore, suppose that for all $j$ and $i$, the minimum of}$, where $\mathcal{X}_{j</p>
<p>$$
\min <em j="j">{\xi \in \mathcal{X}</em>}} f\left(\mathbf{x<em j-1="j-1">{i}^{(k+1)}, \cdots, \mathbf{x}</em>}^{(k+1)}, \xi, \mathbf{x<em m="m">{j+1}^{(k)}, \cdots, \mathbf{x}</em>\right)
$$}^{(k)</p>
<p>is uniquely attained. Let $\left{\mathbf{x}^{(i)}\right}$ be the sequence generated by the block coordinate descent method as in Eq. (6). Then, every limit point of $\left{\mathbf{x}^{(i)}\right}$ is a stationary point. The uniqueness of the minimum is not required for the case when $m=2$ $[15]$.</p>
<p>The proof of this theorem for an arbitrary number of blocks is shown in Bertsekas [3]. For a non-convex optimization problem, most algorithms only guarantee the stationarity of a limit point [26].</p>
<p>When applying the BCD method to a constrained nonlinear programming problem, it is critical to wisely choose a partition of $\mathcal{X}$, whose Cartesian product constitutes $\mathcal{X}$. An important criterion is whether the sub-problems in Eq. (6) are efficiently solvable. For example, if the solutions of subproblems appear in a closed form, each update can be computed fast. In addition, it is worth checking how the solutions of sub-problems depend on each other. The BCD method requires that the most recent values be used for each sub-problem in Eq. (6). When the solutions of subproblems depend on each other, they have to be computed sequentially to make use of the most recent values. If solutions for some blocks are independent of each other, they can be computed simultaneously. We discuss how different choices of partitions lead to different NMF algorithms. The partitioning can be achieved in several ways, by using either matrix blocks, vector blocks or scalar blocks.</p>
<h3>3.1.1 BCD with Two Matrix Blocks - ANLS Method</h3>
<p>The most natural partitioning of the variables is to have two big blocks, $\mathbf{W}$ and $\mathbf{H}$. In this case, following the BCD method in Eq. (6), we take turns solving the following:</p>
<p>$$
\left{\begin{array}{l}
\mathbf{W}^{(k+1)} \leftarrow \arg \min <em _mathbf_H="\mathbf{H">{\mathbf{W} \geq 0} f\left(\mathbf{W}, \mathbf{H}^{(k)}\right) \
\mathbf{H}^{(k+1)} \leftarrow \arg \min </em>\right)
\end{array}\right.
$$} \geq 0} f\left(\mathbf{W}^{(k+1)}, \mathbf{H</p>
<p>Since the sub-problems are non-negativity constrained least squares (NLS) problems, the two-block BCD method has been called the alternating non-negative least square (ANLS) framework $[26,19,20]$.</p>
<h3>3.1.2 BCD with $2 k$ Vector Blocks - HALS/RRI Method</h3>
<p>We partition the unknowns into 2 k blocks in which each block is a column/row of $\mathbf{W}$ or $\mathbf{H}$. In this case, it is easier to consider the objective function in the following form:</p>
<p>$$
f\left(\mathbf{w}<em r="r">{1}, \cdots, \mathbf{w}</em>}, \mathbf{h<em r="r">{1}^{\intercal}, \cdots, \mathbf{h}</em>}^{\intercal}\right)=\left|\mathbf{A}-\sum_{j=1}^{r} \mathbf{w<em j="j">{j} \mathbf{h}</em>
$$}^{T}\right|_{F}^{2</p>
<p>where $\mathbf{W}=\left[\mathbf{w}<em r="r">{1}, \cdots \mathbf{w}</em>}\right] \in \mathbb{R<em 1="1">{+}^{m \times r}$ and $\mathbf{H}=\left[\mathbf{h}</em>}, \cdots, \mathbf{h<em _="+">{r}\right]^{\intercal} \in$ $\mathbb{R}</em>$ can be approximated by the sum of $r$ rank-one matrices.}^{r \times n}$. The form in Eq. (8) represents the fact that $\mathbf{A</p>
<p>Following the BCD scheme, we can minimize $f$ by iteratively solving the following:</p>
<p>$$
\mathbf{w}<em i="i">{i} \leftarrow \underset{\mathbf{w}</em>} \geq 0}{\arg \min } f\left(\mathbf{w<em r="r">{1}, \cdots, \mathbf{w}</em>}, \mathbf{h<em r="r">{1}^{\intercal}, \cdots, \mathbf{h}</em>\right)
$$}^{\intercal</p>
<p>for $i=1, \cdots, r$, and</p>
<p>$$
\mathbf{h}<em i="i">{i}^{\intercal} \leftarrow \underset{\mathbf{h}</em>}^{\intercal} \geq 0}{\arg \min } f\left(\mathbf{w<em r="r">{1}, \cdots, \mathbf{w}</em>}, \mathbf{h<em r="r">{1}^{\intercal}, \cdots, \mathbf{h}</em>\right)
$$}^{\intercal</p>
<p>for $i=1, \cdots, r$.
The 2 K -block BCD algorithm has been studied as Hierarchical Alternating Least Squares (HALS) proposed by Cichocki et al. $[10,9]$ and independently by Ho et al. [17] as rank-one residue iteration (RRI).</p>
<h3>3.1.3 BCD with $k(n+m)$ Scalar Blocks</h3>
<p>We can also partition the variables with the smallest $k(n+$ $m$ ) element blocks of scalars, where every element of $\mathbf{W}$ and $\mathbf{H}$ is considered as a block in the context of Theorem 1. To this end, it helps to write the objective function as a quadratic function of scalar $w_{i j}$ or $h_{i j}$ assuming all other elements in $\mathbf{W}$ and $\mathbf{H}$ are fixed:</p>
<p>$$
\begin{aligned}
&amp; f\left(w_{i j}\right)=\left|\left(\mathbf{a}<em _bar_k="\bar{k">{i}^{\intercal}-\sum</em>} \neq j} w_{i \bar{k}} \mathbf{q<em i="i" j="j">{\bar{k}}^{\intercal}\right)-w</em>} \mathbf{h<em 2="2">{j}^{\intercal}\right|</em> \
&amp; f\left(h_{i j}\right)=\left|\left(\mathbf{a}}^{2}+\text { const <em _bar_k="\bar{k">{j}-\sum</em>} \neq i} \mathbf{w<em _bar_k="\bar{k">{\bar{k}} h</em>} j}\right)-\mathbf{w<em i="i" j="j">{i} h</em>
\end{aligned}
$$}\right|_{2}^{2}+\text { const </p>
<p>where $\mathbf{a}<em j="j">{i}^{\intercal}$ and $\mathbf{a}</em>$ column of A, respectively.}$ denote the $i^{t h}$ row and the $j^{t h</p>
<p>In this paper for solving the optimization problem (3), we partition the matrices $\mathbf{Z}, \mathbf{W}, \mathbf{H}$ into vector blocks such as $\mathbf{z}<em _mathbf_n="\mathbf{n">{1}, \cdots, \mathbf{z}</em>}}, \mathbf{w<em _mathbf_r="\mathbf{r">{1}, \cdots, \mathbf{w}</em>}}, \mathbf{h<em _mathbf_r="\mathbf{r">{1}, \cdots, \mathbf{h}</em>$. The reasoning behind this partitioning is explained in the next section.}</p>
<h3>3.2 Text Outliers using Nonnegative Matrix Factorization(TONMF)</h3>
<p>In this section, we propose an efficient algorithm for the outlier detection model (3).</p>
<p>To determine the $\mathbf{Z}, \mathbf{W}, \mathbf{H}$ for the aforementioned optimization problem (3), we use the block coordinate descent method. In other words, by fixing $\mathbf{W}, \mathbf{H}$, we determine the optimal $\mathbf{Z}$ as vector blocks $\mathbf{z}<em _mathbf_n="\mathbf{n">{1}, \cdots, \mathbf{z}</em>$-norm, this optimization corresponds to the two block non-smooth BCD framework.}}$ and vice versa. Due to $\ell_{1,2</p>
<p>$$
\begin{aligned}
\mathbf{Z}^{(k+1)} \leftarrow \underset{\mathbf{Z}}{\arg \min } \frac{1}{2}\left|\mathbf{A}-\mathbf{Z}-\mathbf{W}^{(k)} \mathbf{H}^{(k)}\right|<em 1_2="1,2">{F}^{2} \
+\alpha|\mathbf{Z}|</em> \
\left(\mathbf{W}^{(k+1)}, \mathbf{H}^{(k+1)}\right) \leftarrow \underset{\mathbf{W} \geq \mathbf{0}, \mathbf{H} \geq \mathbf{0}}{\arg \min } \frac{1}{2}\left|\mathbf{A}-\mathbf{W H}-\mathbf{Z}^{(k+1)}\right| \
+\beta|\mathbf{H}|_{1}
\end{aligned}
$$</p>
<p>Regarding $\mathbf{Z}=\left[\mathbf{z}<em n="n">{1}, \ldots, \mathbf{z}</em>\right]$, the minimization problem in (10) has a separable structure:</p>
<p>$$
\mathbf{Z}^{(k+1)}=\underset{\mathbf{Z}}{\arg \min } \sum_{i} \frac{1}{2}\left|\overline{\mathbf{a}}<em i="i">{i}-\mathbf{z}</em>\right|<em i="i">{2}^{2}+\alpha\left|\mathbf{z}</em>
$$}\right|_{2</p>
<p>where $\overline{\mathbf{a}}<em i="i">{i}=\mathbf{a}</em>$. Therefore, we only need to}-\left(\mathbf{W}^{(k)} \mathbf{H}^{(k)}\right)_{i</p>
<p>define a solution with respect to one variable $\mathbf{z}<em i="i">{i}$. Thus, we partition the matrix $\mathbf{Z}$ into vector blocks $\mathbf{z}</em>}$ and construct $\mathbf{Z}$ as a set of vectors $\mathbf{z<em i="i">{i}$. Also, the blocks $\mathbf{z}</em>}$ is independent of $\mathbf{z<em i="i">{j}, \forall i \neq j$. That is, the closed form solution of $\mathbf{z}</em>}$ is dependent only on $\overline{\mathbf{a}<em 1="1">{i}$. When all other blocks of $\mathbf{w}</em>}, \cdots, \mathbf{w<em 1="1">{\mathbf{r}}, \mathbf{h}</em>}, \cdots, \mathbf{h<em i="i">{\mathbf{r}}$, are fixed, every vector $\mathbf{z}</em>$, to optimal, when all the other blocks are fixed.} \in \mathbf{Z}$, can be solved to optimal in parallel. Thus, we adhere to DCD framework of solving the vector blocks of $\mathbf{z}_{i</p>
<p>Theorem 2: The solution of the following minimization problem</p>
<p>$$
\mathbf{z}<em i="i">{i}^{*}=\underset{\mathbf{z}</em>}}{\arg \min } f\left(\mathbf{z<em i="i">{i}\right)=\frac{\gamma}{2}\left|\mathbf{z}</em>}-\mathbf{a<em 2="2">{i}\right|</em>}^{2}+\alpha\left|\mathbf{z<em 2="2">{i}\right|</em>
$$</p>
<p>is the generalized shrinkage operator:</p>
<p>$$
\mathbf{z}<em i="i">{i}^{*}=\operatorname{shrink}\left(\mathbf{a}</em>\right)
$$}, \frac{\alpha}{\gamma</p>
<p>$\stackrel{\text { PROOF }}{\text { s }}$ generalized shrinkage operator is defined as:</p>
<p>$$
\frac{\partial f\left(\mathbf{z}<em i="i">{i}\right)}{\operatorname{shrink}(\text { ( } \mathbf{a}</em>} C)}=\gamma\left(\mathbf{z<em i="i">{i}\left\lceil|\mathbf{a}</em>|<em i="i">{| 2}+\alpha \frac{\mathbf{z}</em>|}}{|\mathbf{a<em i="i">{| 2}}\right.\right. \mathbf{a}</em>\right.
$$} \mathbf{a}_{i</p>
<p>When $\left|\mathbf{a}<em 2="2">{i}\right|</em>$,} \leq \frac{\alpha}{\gamma</p>
<p>$$
f\left(\mathbf{z}<em i="i">{i}\right) \geq \frac{\gamma}{2}\left(\left|\mathbf{z}</em>\right|<em i="i">{2}^{2}+\left|\mathbf{a}</em>\right|<em i="i">{2}^{2}\right)+\left(\alpha-\gamma\left|\mathbf{a}</em>\right|<em i="i">{2}\right)\left|\mathbf{z}</em>
$$}\right|_{2</p>
<p>Therefore we have:</p>
<p>$$
\underset{\mathbf{z}<em i="i">{i}}{\arg \min } f\left(\mathbf{z}</em>\right)=0
$$</p>
<p>When $\left|\mathbf{a}<em 2="2">{i}\right|</em>} \geq \frac{\alpha}{\gamma}$, let $\mathbf{z<em i="i">{i}=c \mathbf{a}</em>$ then</p>
<p>$$
\frac{\partial f\left(\mathbf{z}<em i="i">{i}\right)}{\partial \mathbf{z}</em>}}=\gamma\left(\mathbf{z<em i="i">{i}-\mathbf{a}</em>}\right)+\alpha \frac{\mathbf{z<em i="i">{i}}{\left|\mathbf{z}</em>\right|<em i="i">{2}}=\left[\gamma(c-1)+\frac{\alpha}{\left|\mathbf{a}</em>\right|<em i="i">{2}}\right] \mathbf{a}</em>=0
$$</p>
<p>where</p>
<p>$$
c=1-\frac{\alpha}{\gamma} \frac{1}{\left|\mathbf{a}<em 2="2">{i}\right|</em>
$$}</p>
<p>Therefore, we get</p>
<p>$$
\mathbf{z}<em i="i">{i}=\left(\left|\mathbf{a}</em>\right|<em i="i">{2}-\frac{\alpha}{\gamma}\right) \frac{\mathbf{a}</em>}}{\left|\mathbf{a<em 2="2">{i}\right|</em>
$$}</p>
<p>Now, utilizing the generalized shrinkage operator as defined in $[13][32]$,</p>
<p>$$
\mathbf{z}<em i="i">{i}^{*}=\operatorname{shrink}\left(\mathbf{a}</em>}, C\right)=\max \left(\left|\mathbf{a<em 2="2">{i}\right|</em>}-C, 0\right) \frac{\mathbf{a<em i="i">{i}}{\left|\mathbf{a}</em>
$$}\right|_{2}</p>
<p>where $C=\alpha / \gamma$.
Now, we need to solve the following NMF model with sparsity constraints on $\mathbf{H}$ :</p>
<p>$$
\left(\mathbf{W}^{(k+1)}, \mathbf{H}^{(k+1)}\right)=\underset{\mathbf{W} \geq 0, \mathbf{H} \geq 0}{\arg \min }|\overline{\mathbf{A}}-\mathbf{W} \mathbf{H}|<em 1="1">{F}^{2}+\beta|\mathbf{H}|</em>
$$</p>
<p>where $\overline{\mathbf{A}}=\mathbf{A}-\mathbf{Z}^{(k+1)}$. Let</p>
<p>$$
\mathcal{F}\left(\mathbf{w}<em r="r">{1}, \ldots, \mathbf{w}</em>} ; \mathbf{h<em r="r">{1}, \ldots, \mathbf{h}</em>}\right)=\left|\overline{\mathbf{A}}-\sum_{i=1}^{r} \mathbf{w<em i="i">{i} \mathbf{h}</em>\right|<em 1="1">{F}^{2}+g\left(\mathbf{h}</em>\right)
$$}, \ldots, \mathbf{h}_{r</p>
<p>where $\mathbf{W}=\left[\mathbf{w}<em 2="2">{1}, \mathbf{w}</em>}, \ldots, \mathbf{w<em 1="1">{r}\right]$ and $\mathbf{H}=\left[\mathbf{h}</em>}, \mathbf{h<em r="r">{2}, \ldots, \mathbf{h}</em>$. For any $j \in{1, \ldots, r},(11)$ can be rewritten as}\right]^{T</p>
<p>$$
\left|\overline{\mathbf{A}}-\sum_{i=1}^{r} \mathbf{w}<em i="i">{i} \mathbf{h}</em>\right|}^{T<em _neq="\neq" i="i" j="j">{F}^{2}=\left|\overline{\mathbf{A}}-\sum</em>}^{r} \mathbf{w<em i="i">{i} \mathbf{h}</em>}^{T}-\mathbf{w<em j="j">{j} \mathbf{h}</em>
$$}^{T}\right|_{F}^{2</p>
<p>The following is the framework of the block coordinate descent method with a separable regularizer such as the Frobenius norm. We iteratively minimize $\mathcal{F}(\mathbf{W}, \mathbf{H})$ with respect to each column of $\mathbf{W}$ and $\mathbf{H}$ :</p>
<p>$$
\left{\begin{array}{l}
\text { for } j=1 \ldots r \
\mathbf{h}<em j="j">{j}^{(k+1)}=\underset{\mathbf{h}</em>} \geq 0}{\arg \min } \frac{\alpha}{2}\left|\mathbf{w<em j="j">{j}^{(k)} \mathbf{h}</em>}^{T}-\left(\overline{\mathbf{A}}-\overline{\mathbf{W}<em F="F">{j}^{(k)}\right)\right|</em> \
+g\left(\mathbf{h}}^{2<em j="j">{1}^{(k+1)}, \ldots, \mathbf{h}</em>}, \ldots, \mathbf{h<em j="j">{r}^{(k)}\right) \
\text { end } \
\text { for } j=1 \ldots r \
\mathbf{w}</em>}^{(k+1)}=\underset{\mathbf{w<em j="j">{j} \geq 0}{\arg \min }\left|\mathbf{w}</em>}\left(\mathbf{h<em j="j">{j}^{(k+1)}\right)^{T}-\left(\overline{\mathbf{A}}-\overline{\mathbf{H}}</em> \
\text { end }
\end{array}\right.
$$}^{(k+1)}\right)\right|_{F}^{2</p>
<p>where</p>
<p>$$
\overline{\mathbf{W}}<em i="1">{j}^{(k)}=\sum</em>}^{j-1} \mathbf{w<em i="i">{i}^{(k)}\left(\mathbf{h}</em>}^{(k+1)}\right)^{T}+\sum_{i=j+1}^{r} \mathbf{w<em i="i">{i}^{(k)}\left(\mathbf{h}</em>
$$}^{(k)}\right)^{T</p>
<p>and</p>
<p>$$
\overline{\mathbf{H}}<em i="1">{j}^{(k+1)}=\sum</em>}^{j-1} \mathbf{w<em i="i">{i}^{(k+1)}\left(\mathbf{h}</em>}^{(k+1)}\right)^{T}+\sum_{i=j+1}^{r} \mathbf{w<em i="i">{j}^{(k)}\left(\mathbf{h}</em>
$$}^{(k+1)}\right)^{T</p>
<p>According to Theorem 2, the solution of $\mathbf{z}<em j="j">{i}$ is independent of $\mathbf{z}</em>$ from (13). The Algorithm 1, gives the outline of the TONMFand its complete implementation can be obtained from https://github.com/ramkikannan/outliernmf to try with any real world text dataset.}, \forall i \neq j$, and it enables us to solve the solution in parallel. This is very useful when computing for very large input matrices. Similarly, the vector blocks of $\mathbf{W}, \mathbf{H}$ can also be updated in parallel. Now, we have all the building blocks for the Text Outliers using Nonnegative Matrix Factorization algorithm. We will be using Theorem 2 and the update for $\mathbf{W}, \mathbf{H</p>
<div class="codehilite"><pre><span></span><code><span class="nt">Algorithm</span><span class="w"> </span><span class="nt">1</span><span class="o">:</span><span class="w"> </span><span class="nt">Text</span><span class="w"> </span><span class="nt">Outliers</span><span class="w"> </span><span class="nt">using</span><span class="w"> </span><span class="nt">Nonnegative</span><span class="w"> </span><span class="nt">Matrix</span>
<span class="nt">Factorization</span><span class="w"> </span><span class="o">(</span><span class="nt">TONMF</span><span class="o">)</span>
<span class="w">    </span><span class="nt">input</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">Matrix</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">A</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbb</span><span class="p">{</span><span class="err">R</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">+</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">m</span><span class="w"> </span><span class="err">\times</span><span class="w"> </span><span class="err">n</span><span class="p">}</span><span class="err">\</span><span class="o">),</span><span class="w"> </span><span class="nt">reduced</span><span class="w"> </span><span class="nt">rank</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">r</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">alpha</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">beta</span><span class="err">\</span><span class="o">)</span>
<span class="w">    </span><span class="nt">output</span><span class="o">:</span><span class="w"> </span><span class="nt">Matrix</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">W</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbb</span><span class="p">{</span><span class="err">R</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">+</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">m</span><span class="w"> </span><span class="err">\times</span><span class="w"> </span><span class="err">r</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">H</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbb</span><span class="p">{</span><span class="err">R</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">+</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">r</span><span class="w"> </span><span class="err">\times</span><span class="w"> </span><span class="err">n</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">Z</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">in</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbb</span><span class="p">{</span><span class="err">R</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">m</span><span class="w"> </span><span class="err">\times</span><span class="w"> </span><span class="err">n</span><span class="p">}</span><span class="err">\</span><span class="o">)</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="nt">Rand</span><span class="w"> </span><span class="nt">initialization</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathrm</span><span class="p">{</span><span class="err">W</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathrm</span><span class="p">{</span><span class="err">H</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathrm</span><span class="p">{</span><span class="err">Z</span><span class="p">}</span><span class="err">\</span><span class="o">)</span>
<span class="w">    </span><span class="nt">1</span><span class="w"> </span><span class="nt">Initialize</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">boldsymbol</span><span class="p">{</span><span class="err">W</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">boldsymbol</span><span class="p">{</span><span class="err">H</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">boldsymbol</span><span class="p">{</span><span class="err">Z</span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">as</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">nonnegative</span><span class="w"> </span><span class="nt">random</span><span class="w"> </span><span class="nt">matrix</span><span class="w"> </span><span class="o">;</span>
<span class="w">    </span><span class="nt">while</span><span class="w"> </span><span class="nt">stopping</span><span class="w"> </span><span class="nt">criteria</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathfrak</span><span class="p">{</span><span class="err">C</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">1</span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">not</span><span class="w"> </span><span class="nt">met</span><span class="w"> </span><span class="nt">do</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nt">Compute</span><span class="w"> </span><span class="nt">Z</span><span class="w"> </span><span class="nt">for</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">given</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">A</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">W</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">H</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">alpha</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">beta</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">based</span>
<span class="w">            </span><span class="nt">on</span><span class="w"> </span><span class="nt">Theorem</span><span class="w"> </span><span class="nt">2</span>
<span class="w">        </span><span class="nt">for</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">i</span><span class="w"> </span><span class="err">\</span><span class="nt">leftarrow</span><span class="w"> </span><span class="nt">1</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">n</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">do</span>
<span class="w">            </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">z</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">1</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">leftarrow</span><span class="w"> </span><span class="err">\</span><span class="nt">max</span><span class="w"> </span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">a</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">i</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="err">\</span><span class="o">|</span><span class="nt">_</span><span class="p">{</span><span class="err">2</span><span class="p">}</span><span class="nt">-</span><span class="err">\</span><span class="nt">frac</span><span class="p">{</span><span class="err">\alpha</span><span class="p">}{</span><span class="err">\gamma</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="nt">0</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="w"> </span><span class="err">\</span><span class="nt">frac</span><span class="p">{</span><span class="err">\mathbf{a</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">i</span><span class="p">}</span><span class="err">}</span><span class="p">{</span><span class="err">\left\|\mathbf{a</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">i</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="err">\</span><span class="o">|</span><span class="nt">_</span><span class="p">{</span><span class="err">2</span><span class="p">}</span><span class="err">}\</span><span class="o">)</span>
<span class="w">    </span><span class="nt">while</span><span class="w"> </span><span class="nt">stopping</span><span class="w"> </span><span class="nt">criteria</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathfrak</span><span class="p">{</span><span class="err">C</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">2</span><span class="p">}</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">not</span><span class="w"> </span><span class="nt">met</span><span class="w"> </span><span class="nt">do</span>
<span class="w">            </span><span class="nt">for</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">j</span><span class="w"> </span><span class="err">\</span><span class="nt">leftarrow</span><span class="w"> </span><span class="nt">1</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">r</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">do</span>
<span class="w">            </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k+1)</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="nt">underset</span><span class="p">{</span><span class="err">\mathbf{h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">geq</span><span class="w"> </span><span class="nt">0</span><span class="err">}</span><span class="p">{</span><span class="err">\arg</span><span class="w"> </span><span class="err">\min</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">frac</span><span class="p">{</span><span class="err">\alpha</span><span class="p">}{</span><span class="err">2</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">w</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k)</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">T</span><span class="p">}</span><span class="nt">-</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">overline</span><span class="p">{</span><span class="err">\mathbf{A</span><span class="p">}</span><span class="err">}</span><span class="nt">-</span><span class="err">\</span><span class="nt">right</span><span class="o">.</span><span class="err">\</span><span class="nt">right</span><span class="o">.</span><span class="err">\</span><span class="o">)</span>
<span class="w">            </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">left</span><span class="o">.</span><span class="err">\</span><span class="nt">overline</span><span class="p">{</span><span class="err">\mathbf{W</span><span class="p">}</span><span class="err">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k)</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="nt">left</span><span class="err">\</span><span class="o">|</span><span class="nt">_</span><span class="p">{</span><span class="err">F</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">2</span><span class="p">}</span><span class="o">+</span><span class="nt">g</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">1</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k+1)</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">cdots</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">cdots</span><span class="o">,</span><span class="w"> </span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">r</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k)</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="nt">right</span><span class="o">.</span><span class="err">\</span><span class="o">)</span>
<span class="w">            </span><span class="nt">for</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">j</span><span class="w"> </span><span class="err">\</span><span class="nt">leftarrow</span><span class="w"> </span><span class="nt">1</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="err">\</span><span class="o">(</span><span class="nt">r</span><span class="err">\</span><span class="o">)</span><span class="w"> </span><span class="nt">do</span>
<span class="w">            </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">w</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k+1)</span><span class="p">}</span><span class="o">=</span><span class="err">\</span><span class="o">)</span>
<span class="w">            </span><span class="err">\</span><span class="o">(</span><span class="err">\</span><span class="nt">underset</span><span class="p">{</span><span class="err">\mathbf{w</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="w"> </span><span class="err">\</span><span class="nt">geq</span><span class="w"> </span><span class="nt">0</span><span class="err">}</span><span class="p">{</span><span class="err">\arg</span><span class="w"> </span><span class="err">\min</span><span class="w"> </span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">w</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">mathbf</span><span class="p">{</span><span class="err">h</span><span class="p">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k+1)</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)^</span><span class="p">{</span><span class="err">T</span><span class="p">}</span><span class="nt">-</span><span class="err">\</span><span class="nt">left</span><span class="o">(</span><span class="err">\</span><span class="nt">overline</span><span class="p">{</span><span class="err">\mathbf{A</span><span class="p">}</span><span class="err">}</span><span class="nt">-</span><span class="err">\</span><span class="nt">overline</span><span class="p">{</span><span class="err">\mathbf{H</span><span class="p">}</span><span class="err">}</span><span class="nt">_</span><span class="p">{</span><span class="err">j</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">(k+1)</span><span class="p">}</span><span class="err">\</span><span class="nt">right</span><span class="o">)</span><span class="err">\</span><span class="nt">right</span><span class="err">\</span><span class="o">|</span><span class="nt">_</span><span class="p">{</span><span class="err">F</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="err">2</span><span class="p">}</span><span class="w"> </span><span class="o">;</span><span class="err">\</span><span class="o">)</span>
</code></pre></div>

<h2>4 Experimental Results</h2>
<p>In this section, we present the experiments on text outlier analysis using matrix factorization. We used both real and synthetic data sets to test our algorithm. The real data sets correspond to the well known RCV20, Reuters and Wiki People data, whereas the synthetic data set was created using a well known market basket generator described later. It should be pointed out that these data sets were not originally designed for outlier analysis, and they have no ground truth information available. Therefore, some additional preprocessing needed to be applied to the real data sets, in order to isolate ground truth classes, and use them effectively for the outlier analysis problem. In this section, we will describe the data sets, their preparation, the performance criteria and the results obtained by our algorithm. At the end of this section, we will also present a discussion that provides interesting insights about the effectiveness of algorithm TONMF .</p>
<h3>4.1 Data Sets</h3>
<p>The experiments were conducted with both labelled real and synthetic data sets. These are described below:
RCV20 Data Set: The RCV20 data set ${ }^{3}$ is a collection of approximately 20,000 newsgroup documents, partitioned (nearly) evenly across 20 different newsgroups. We took all data points from two randomly chosen classes, which in this case corresponded to the IBM and Mac Hardware classes. In addition, 50 data points were chosen from one randomly chosen class, which corresponds to the Windows Operating System (OS) class. As it turns out, this is a rather hard problem for our algorithm because of some level of relationship between one of the rare classes and the base data. Specifically, Windows Operating System and IBM Hardware are both computer related subjects, and the former is often used with the latter. Therefore, some vocabulary is shared between the regular class and the rare class, and this makes the detection of outlier harder. We randomly permuted the position of the outliers and regular data points.
Reuters-21578 Data Set: The documents in the Reuters21578 collection ${ }^{4}$ appeared on the Reuters newswire in 1987. It contains 21578 documents in 135 categories. Every document belongs to one or more categories. We selected those documents that belong to only one category. We chose totally 5768 documents that belong to the category earn and acq. The outliers were 100 documents from category interest. The vocabulary size of all the documents from these categories put together were 18933 . We randomly permuted the position of the outliers and regular data points.
Wiki People Dataset: This is a subset of the dataset collected by Blasiak et.al., [4]. The dataset is constructed by crawling Wikipedia starting from http://en.wikipedia.org/wiki/Category:List#/o/ (with a $1000 \mathrm{~mm} / \mathrm{p}$ or $[\mathrm{D}-G]$ to a depth of four. Pages describing people were extracted from the list of all crawled pages. Text from the body paragraphs of the pages were extracted, and section headings were used as labels for blocks of text. Text blocks were assumed to begin with $&lt;\mathrm{p}&gt;$ and end with $&lt;/ \mathrm{p}&gt;$. Only text in section headings that occurred 10 times or more was retained. Words were stemmed, stopwords were removed, and words of length at least 3 and at most 15 were considered. The words need to occur at least 4 times in at least 2 doc-
uments to be considered important enough to be retained. From the collected data, the sections Career and Life were chosen as non-outlier and whereas the small section section Death was chosen as outlier. The constructed dataset has a vocabulary size of 18834 and total of 9593 documents. A total of 100 documents that belong to section Death were labeled as outlier.
Market Basket Data Generator: We also wanted to understand the performance of our algorithm in some large sparse matrices that is similar to the bag of words matrix. Towards this end, we used the standard IBM Synthetic Data Generation Code for Associations and Sequential Patterns -market-basket data generator, that is packaged as part of Rlimine ${ }^{5}$ software. We set the average length of the transaction to be 300 and number of different items to be 50,000 . Note that this generator uses a random seed, and by changing the seed, it is possible to completely change the transaction distribution, even if all other parameters remain the same. We generated 10,000 data points as a group of four different sets of 2500 data points with randomly chosen seed values. In addition, the rare class contained 250 data points from a single seed value. In addition, we randomly permuted the positions of the outliers and regular data points in the matrix representation, to avoid any unforeseen bias in the algorithm.</p>
<h3>4.2 Performance Metrics</h3>
<p>The effectiveness was measured in terms of the ROC curve drawn on the outlier scores. We use the area under the Receiver Operating Characteristics(ROC) curve - the defacto metric for evaluation in outlier analysis. The idea of this curve is to evaluate a ranking of outlier scores, by examining the tradeoff between the true positives and false positives, as the threshold on the outlier score is varied in a range. By using different thresholds, it is possible to obtain a relatively larger or smaller number of true positives with respect to the false positives.</p>
<p>Let $S(t)$ be the set of outliers determined by using a threshold $t$ on the outlier scores. In this case, the True Positive Rate is graphed against the False Positive Rate. The true positive rate $T P R(t)$ is defined in the same way as the metric of recall is defined in the IR literature. The false positive rate $F P R(t)$ is the percentage of the falsely reported positives out of the ground-truth negatives. Therefore, for a data set $D$ with ground truth positives $G$, these definitions are as follows:</p>
<p>$$
\operatorname{TPR}(t)=\operatorname{Recall}(t)=100 * \frac{|S(t) \cap G|}{|G|}
$$</p>
<p>Note that the end points of the ROC curve are always at $(0,0)$ and $(100,100)$, and a random method is expected to exhibit performance along the diagonal line connecting these points. The lift obtained above this diagonal line provides an idea of the accuracy of the approach. The area under the ROC curve provides a measure of the accuracy. A random algorithm would have an area of 0.5 under the ROC curve. The ROC curve was used to provide detailed insights into the tradeoffs associated with the method, whereas the</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>area under the ROC curve was used in order to provide a summary of the performance of the method.</p>
<h3>4.3 Baseline Algorithms</h3>
<p>The baselines used by our approach were as follows:
Distance-based Algorithm: The first algorithm which was used was the $k$-nearest neighbour algorithm, which is a classical distance-based algorithm frequently used for outlier detection [21, 29]. The outliers were ranked based on distances in order to create an ROC curve, rather than using a specific threshold as in [21]. In addition, we gave the $k$-nearest neighbour algorithm an advantage by picking a value of $k$ optimally based on area under ROC curve by sweeping $k$ from 1 to 50 . Note that such an advantage would not be available to the baseline under real scenarios, since the ground-truth outliers in the data are unknown, and therefore the ROC curve cannot be optimized.
Simplified Low Rank Approximation: We used a low rank approximation based on Singular Value Decomposition $(S V D)$. For a given matrix $\mathbf{A}$, a best $r$-rank approximation $\hat{\mathbf{A}}<em r="r">{r} \quad$ is given by $\quad \mathbf{A}</em>}=\mathbf{U S<em r="r">{r} \mathbf{V}^{\mathrm{T}}$, where $\mathbf{S}</em>$ can be used a score to determine the outliers. In the graphs, we use $S V D$ as the legend to represent this baseline. For the $S V D$ approach, we used the same low rank as our algorithm.}=\operatorname{diag}\left(\sigma_{1}, \cdots, \sigma_{r}, 0, \cdots, 0\right)$. That is, the trailing $\operatorname{rank}(\mathbf{A})$ $r$ in the descending ordered singular values are set to 0 . It is natural to understand that the outlier documents require linear combination of many basis vectors. Thus the $\ell_{2}$ norm on the $\sqrt{S_{r}} V^{\mathrm{T}</p>
<p>Robust Principal Component Analysis(RPCA) : Recently Candes et.al.,[6], proposed a new technique called Robust PCA that is insensitive to noises and outliers. It is important to note that both PCA and NMF are different forms of low rank approximation. Hence, we wanted to leverage the output of RPCA and recover the outliers. RPCA yields two matrices (1) a low rank matrix - $\mathbb{L}$ and (2) a sparse matrix $\mathbb{S}$ such that $\mathbb{A} \approx \mathbb{L}+\mathbb{S}$, where $\mathbb{A}$ is the given input matrix. The main disadvantage of RPCA is its larger memory requirements. Retaining $\mathbb{L}, \mathbb{S}$ for large matrices require significant memory. We used the $\ell_{2}$ norm on the $\mathbb{S}$ as an outlier score for every document. In the graphs, we use $R P C A$ as the legend to represent this baseline.</p>
<h3>4.4 Effectiveness Results</h3>
<p>We first present the ROC curves for the different data sets. The ROC curve for the Reuters dataset is illustrated in Figure 3. In this case, our algorithm shows a drastic improvement over both the baseline algorithms. This is evident from the rather large lift in the chart. Our algorithm TONMF had an area of 0.9340 under ROC. The $k$-NN approach performed quite poorly, and had an area under the ROC curve of 0.5370 . This is slightly better than random performance. The area under ROC for the $S V D$ method was 0.5816 and $R P C A$ was 0.6120 , which is better than the $k$-NN method, but still significantly less than the proposed algorithm.</p>
<p>The comparison of our algorithm with baselines for the $R C V 20$ data set is shown in Figure 5. As discussed in the data generation section, this is a particularly challenging data set, because of the similarity in the vocabulary distribution between the rare class, and the regular class. It is evident that our algorithm TONMF performed better than the $S V D, R P C A$ and the $k$-NN method. However, the lift in the ROC curve for all the methods is not particularly sig-
nificant, because of the inherently challenging nature of the data set. The $k$-NN method performed particularly poorly in this case. In a later section, we will provide some insights about the fact that some of this "poor" performance is because of the noise in the data set itself, where some of the points in the regular class should really be considered outliers. We generated a datasets in RCV20 where we just changed the outlier class to christian religion. We received a best ROC of 0.9732 and it is not shown in Figure 5.</p>
<p>Figure 9 shows the comparison of our algorithm TONMF against the baselines for the Wiki People data set. The area under the ROC for $k$-NN was 0.5395 , which is rather poor. All the other methods performed better than $k$-NN with area under the ROC for $S V D$ being 0.5670 and $R P C A$ being 0.5471 . Our algorithm TONMF performed significantly better than all the methods with an AUC of 0.8552 . Clearly, this is a significant qualitative difference between the methods. The above three were experiments on real life dataset and we chose market basket for synthetic dataset.</p>
<p>The ROC comparison for the synthetic market basket data is illustrated in Figure 7. In this case, the improvement of the algorithm TONMF over the baseline methods was quite significant. Specifically, the algorithm TONMF had an area under the ROC curve of 0.7598 , which is a significant lift. This significantly outperformed the $S V D$ and $R P C A$ method, which had an area under the ROC curve of 0.5731 and 0.5758 respectively. As in the case of the other data sets, the $k$-NN algorithm performed very poorly with an area under the ROC curve of 0.5431 . The consistently poor performance of the $k$-NN approach over all algorithms is quite striking, and suggests that straightforward generalizations of outlier analysis techniques from other data domains are often not well suited to the text domain.</p>
<p>Based on our conducted experiments on real world and synthetic datasets, we observed that $T O N M F$ outperformed every other baseline. Furthermore, the rank of the methods from best to worst is $T O N M F, R P C A, S V D$ and $N N$. Clearly, conventional distance-based methods do not seem to work very well for text data.</p>
<h3>4.5 Parameter Sensitivity</h3>
<p>From (3) in Section 2, we can see that the parameters for our algorithm are $\alpha, \beta$ and the low rank $r$. We tested the algorithm for different variations in the parameters, and found that our algorithm was insensitive to changes in $\beta$. In other words, for a given low rank $r$ and $\alpha$, the changes in the value of $\beta$ did not result in significant change in the area under ROC. Hence, in this paper, we provide the charts of the ROC area variation with the parameters $\alpha$ and $r$ on the data sets.</p>
<p>The sensitivity results for the Reuters data set are illustrated in Figure 4. The value of $\alpha$ is illustrated on the $X$-axis, and different values of the low rank $r$ are graphed by different curves in the plot. It is evident in this case, that the area under the ROC increased with increase in low rank $r$ and $\alpha$. However the improvement started diminishing and changed very marginally at higher ranks $r$.</p>
<p>The results for the RCV20 and Wiki People datasets are illustrated in Figure 6 and Figure 10 respectively. As in the previous case, the value of $\alpha$ is illustrated on the $X$-axis, and different values of the low rank $r$ are represented by different curves. In this case, the area under the ROC curve was relatively insensitive to the parameters. This implies</p>
<p>ROC
<img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Reuters</p>
<p>ROC
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 5: RCV20</p>
<p>ROC
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 7: Market Basket</p>
<p>ROC
<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 9: Wiki People</p>
<p>Parameter Sensitivity
<img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 4: Reuters</p>
<p>Parameter Sensitivity
<img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Figure 6: RCV20</p>
<p>Parameter Sensitivity
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Figure 8: Market Basket</p>
<p>Parameter Sensitivity
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Figure 10: Wiki People</p>
<p>that the algorithm can be used over a wide range of parameters, without affecting the performance too much. Finally, the results for the market basket data set are illustrated in Figure 8. In this case, the area under the ROC curve decreases with increase in low rank $r$ and $\alpha$. This is because the market-basket data has inherently very low (implicit) dimensionality, and therefore, it is best to use a relatively low rank in order to mine the outliers.</p>
<p>From the parameter sensitivity graphs for real world datasets, we observe that for a given $\alpha$, the approach is relatively insensitive to the rank of the approximation. It needs to be kept in mind that it is generally faster to determine approximations with lower rank. This implies that, for very large matrices, the algorithm can be made computationally faster by choosing approximations with lower rank without compromising on the performance. According to the model explained in equation (3), the parameters $\alpha$ and $\beta$ balance the importance given to outliers against the matrix sparsity criterion during regularization. By picking $\alpha&gt;&gt;\beta$, the importance of the outlier portion of the regularization increases. From the parameter sensitivity graph, it is evident that for most low ranks $K$, the increase in the value of $\alpha$ does not improve the performance of the outlier detection. This is because, beyond a particular limit, the weights given to the outlier criterion do not supersede the optimization problem's main objective of extracting the low-rank patterns from the underlying data.</p>
<h3>4.6 Further Insights</h3>
<p>In order to illustrate the inner workings of the matrix factorization approach, we provide some further insights about the statistics buried deep in the algorithm. We also present some interesting observations when outliers share the same vocabulary distribution as regular data points, as is the case for the $R C V 20$ data set. One observation is that the method of data generation implicitly assumes that all the documents within a "regular" class in a real data set are not outliers. This is of course not true in practice, since some of the documents within these classes will also be outliers, for reasons other than topical affinity. Our algorithm TONMF was also able to detect such distinct documents, much better than the other baseline algorithms. We isolated those false positives of our algorithm TONMF that were not detected in the baselines in the case of the $R C V 20$ data set. It was observed that while these outliers officially belonged to one of the regular classes, they did show different kinds of distinctive characteristics. For example, while the average number of words in regular documents was 195, the "false positive" outliers chosen by our algorithm were typically either very lengthy with over 400 words, or were unusually short will less than 150 words. This behaviour was also generally reflected in the number of distinct words per document. Another observation is that these outlier documents typically had a significant vocabulary repetition over a small number of distinct words. Thus, the algorithm was also able to identify those natural outliers, which ought to have been considered outliers for reasons of statistical word distribution, as opposed to their topical behaviour.</p>
<h2>5 Conclusion</h2>
<p>This paper presents a matrix factorization based approach to text outlier analysis. The approach is designed to adjust well to the widely varying structures in different localities of the
data, and therefore provides more robust methods than competing models. The approach has the potential to be applied to other domains with similar structure, and as a specific example, we provide experiments on market basket data. We also presented extensive experimental results, which illustrate the superiority of the approach. Our code can be downloaded from https://github.com/ramkikannan/outliernmf and tried with any text dataset.</p>
<p>In this paper, we had a parallel implementation using the Matlab's parallel computing toolbox to run in multicore environments. In the future, we would like to explore a scalable implementation of our algorithm. The solution is embarrassingly parallelizable, and would like to experiment in web scale data. One of the potential extension is incorporating temporal and spatial aspects into the model. Such an extension, make the solution applicable to emerging applications such as topic detection and streaming data. We experimented the solution primarily on text data and market basket data. In future work, we will extend this broader approach to other domains such as video data.</p>
<h2>6 Acknowledgements</h2>
<p>This manuscript has been co-authored by UT-Battelle, LLC under Contract No. DE-AC05-00OR22725 with the U.S. Department of Energy. This project was partially funded by the Laboratory Director's Research and Development fund and also sponsored by the Army Research Laboratory (ARL) and was accomplished under Cooperative Agreement Number W911NF-09-2-0053. Also, H. Woo is supported by NRF-2015R101A1A01061261.</p>
<p>The United States Government retains and the publisher, by accepting the article for publication, acknowledges that the United States Government retains a non-exclusive, paidup, irrevocable, world-wide license to publish or reproduce the published form of this manuscript, or allow others to do so, for United States Government purposes. The Department of Energy will provide public access to these results of federally sponsored research in accordance with the DOE Public Access Plan (http://energy.gov/downloads/doepublic-access-paedus/doepublic_access_plan).</p>
<p>Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the USDOE, NSF or ARL.</p>
<h2>7 References</h2>
<p>[1] C. Aggarwal. Outlier analysis. Springer, 2013.
[2] C. C. Aggarwal and P. S. Yu. Outlier detection for high dimensional data. In SIGMOD Conference, pages $37-46,2001$.
[3] D. P. Bertsekas. Nonlinear Programming. Athena Scientific, Belmont, MA, 1999.
[4] S. J. Blasiak, H. Rangwala, and S. Sudarsan. Joint segmentation and clustering in text corpuses. In SIAM Data Mining(SDM), pages 485-493, 2013.
[5] M. M. Breunig, H.-P. Kriegel, R. T. Ng, and J. Sander. Lof: Identifying density-based local outliers. In SIGMOD Conference, pages 93-104, 2000.
[6] E. J. Cands, X. Li, Y. Ma, and J. Wright. Robust principal component analysis. Journal of the ACM (JACM), 58(3):11, 2011.
[7] V. Chandola, A. Banerjee, and V. Kumar. Anomaly detection: A survey. ACM Comput. Surv., 41(3), 2009.</p>
<p>[8] V. Chandola, A. Banerjee, and V. Kumar. Anomaly detection for discrete sequences: A survey. Knowledge and Data Engineering, IEEE Transactions on, 24(5):823-839, 2012.
[9] A. Cichocki and A.-H. Phan. Fast local algorithms for large scale nonnegative matrix and tensor factorizations. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E92-A:708-721, 2009.
[10] A. Cichocki, R. Zdunek, and S. Amari. Hierarchical als algorithms for nonnegative matrix and 3d tensor factorization. LNCS, 4666:169-176, 2007.
[11] C. Ding, T. Li, and W. Peng. Nmf and plsi: equivalence and a hybrid algorithm. In Proceedings of the 29th annual international ACM SIGIR conference on Research and development in information retrieval, SIGIR '06, pages 641-642, 2006.
[12] C. Ding, D. Zhou, X. He, and H. Zha. $r_{1}$-pca: Rotational invariant $l_{1}$-norm principal component analysis for robust subspace factorization. In Proceedings of the 23rd international conference on Machine learning(ICML), pages 281-288, 2006.
[13] E. Esser, X. Zhang, and T. Chan. A general framework for a class of first-order primal-dual algorithm for convex optimization in imaging science. SIAM J. Imag. Sci., 3(4):1015-1046, 2010.
[14] E. Gaussier and C. Goutte. Relation between plsa and nmf and implications. In Proceedings of the 28th annual international ACM SIGIR conference on Research and development in information retrieval, pages 601-602, 2005.
[15] L. Grippo and M. Sciandrone. On the convergence of the block nonlinear gauss-seidel method under convex constraints. Oper. Res. Lett., 26(3):127-136, 2000.
[16] D. M. Hawkins. Identification of outliers, volume 11. Chapman and Hall London, 1980.
[17] N.-D. Ho, P. V. Dooren, and V. D. Blondel. Descent methods for nonnegative matrix factorization. CoRR, abs/0801.3199, 2008.
[18] F. Keller, E. Muller, and K. Bohm. Hics: high contrast subspaces for density-based outlier ranking. In 2012 IEEE 28th International Conference on Data Engineering(ICDE), pages 1037-1048, 2012.
[19] H. Kim and H. Park. Nonnegative matrix factorization based on alternating nonnegativity constrained least squares and active set method. SIAM Journal on Matrix Analysis and Applications, 30(2):713-730, 2008.
[20] J. Kim and H. Park. Fast nonnegative matrix factorization: An active-set-like method and comparisons. SIAM Journal on Scientific Computing, 33(6):3261-3281, 2011.
[21] E. M. Knorr and R. T. Ng. Algorithms for mining distance-based outliers in large datasets. In Proceedings of the International Conference on Very Large Data Bases, pages 392-403, 1998.
[22] D. Kong, C. Ding, and H. Huang. Robust nonnegative matrix factorization using l21-norm. In Proceedings of the 20th ACM international conference on Information and knowledge management(CIKM), pages 673-682, 2011.
[23] H.-P. Kriegel, P. Kroger, E. Schubert, and A. Zimek.</p>
<p>Outlier detection in arbitrarily oriented subspaces. In 2012 IEEE 12th International Conference on Data Mining(ICDM), pages 379-388, 2012.
[24] A. Lazarevic and V. Kumar. Feature bagging for outlier detection. In Proceedings of the eleventh ACM SIGKDD international conference on Knowledge discovery in data mining(KDD), pages 157-166, 2005.
[25] D. D. Lee and H. S. Seung. Learning the parts of objects by non-negative matrix factorization. Nature, 401(6755):788-791, 1999.
[26] C. J. Lin. Projected Gradient Methods for Nonnegative Matrix Factorization. Neural Comput., 19(10):2756-2779, 2007.
[27] J. Liu, S. Ji, and J. Ye. Multi-task feature learning via efficient $\mathrm{l}<em 2_1="2,1">{2,1}$-norm minimization. In $U A I$, pages $339-348,2009$.
[28] E. Muller, I. Assent, P. Iglesias, Y. Mulle, and K. Bohm. Outlier ranking via subspace analysis in multiple views of the data. In 2012 IEEE 12th International Conference on Data Mining(ICDM), pages 529-538, 2012.
[29] S. Ramaswamy, R. Rastogi, and K. Shim. Efficient algorithms for mining outliers from large data sets. In SIGMOD Conference, pages 427-438, 2000.
[30] A. P. Singh and G. J. Gordon. A unified view of matrix factorization models. In Joint European Conference on Machine Learning and Knowledge Discovery in Databases, pages 358-373, 2008.
[31] H. Tong and C.-Y. Lin. Non-negative residual matrix factorization with application to graph anomaly detection. In SIAM Data Mining(SDM), pages $143-153,2011$.
[32] Y. Wang, J. Yang, W. Yin, and Y. Zhang. A new alternating minimization algorithm for total variation image reconstruction. SIAM J. Imag. Sci., 1(3):248-272, 2008.
[33] H. Xu, C. Caramanis, and S. Sanghavi. Robust pca via outlier pursuit. IEEE Trans. on Information Theory, 58(5):3047-3064, 2012.
[34] W. Xu, X. Liu, and Y. Gong. Document clustering based on non-negative matrix factorization. In Proceedings of the 26th annual international ACM SIGIR conference on Research and development in informaion retrieval, pages 267-273, 2003.
[35] Y. Yang, H. T. Shen, Z. Ma, Z. Huang, and X. Zhou. $\mathrm{l}</em>$-norm regularized discriminative feature selection for unsupervised learning. In IJCAI
Proceedings-International Joint Conference on Artificial Intelligence, pages 1589-1594, 2011.</p>
<p><img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1>TRUE POSITIVE RATE (RECALL)</h1>
<table>
<thead>
<tr>
<th>100</th>
<th>100</th>
</tr>
</thead>
<tbody>
<tr>
<td>90</td>
<td>90</td>
</tr>
<tr>
<td>80</td>
<td>80</td>
</tr>
<tr>
<td>70</td>
<td>70</td>
</tr>
<tr>
<td>60</td>
<td>60</td>
</tr>
<tr>
<td>50</td>
<td>50</td>
</tr>
<tr>
<td>40</td>
<td>40</td>
</tr>
<tr>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>40</td>
<td>40</td>
</tr>
<tr>
<td>60</td>
<td>60</td>
</tr>
<tr>
<td>80</td>
<td>80</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
</tr>
</tbody>
</table>
<h1>FALSE POSITIVE RATE</h1>
<p><img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>W
<img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>H
<img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>A</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>$9^{3}$ http://qwone.com/ jason/20Newsgroups/
$9^{4}$ http://archive.ics.uci.edu/ml/datasets/Reuters-21578+TW2htCpt#gst1zm1soneSo#lact\&amp;dn/&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>