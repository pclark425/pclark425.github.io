<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1771 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1771</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1771</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-32.html">extraction-schema-32</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of sim-to-real transfer for robotic agents, scientific discovery agents, or laboratory automation systems, including details about simulation fidelity, transfer success, and the conditions that enable or hinder skill transfer from virtual to real environments.</div>
                <p><strong>Paper ID:</strong> paper-366ca45102a6111dbb256a908aa3f2bdb6a707dc</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/366ca45102a6111dbb256a908aa3f2bdb6a707dc" target="_blank">Factory: Fast Contact for Robotic Assembly</a></p>
                <p><strong>Paper Venue:</strong> Robotics: Science and Systems</p>
                <p><strong>Paper TL;DR:</strong> This work presents Factory, a set of physics simulation methods and robot learning tools for robotic assembly, and achieves real-time or faster simulation of a wide range of contact-rich scenes, including simultaneous simulation of 1000 nut-and-bolt interactions.</p>
                <p><strong>Paper Abstract:</strong> Robotic assembly is one of the oldest and most challenging applications of robotics. In other areas of robotics, such as perception and grasping, simulation has rapidly accelerated research progress, particularly when combined with modern deep learning. However, accurately, efficiently, and robustly simulating the range of contact-rich interactions in assembly remains a longstanding challenge. In this work, we present Factory, a set of physics simulation methods and robot learning tools for such applications. We achieve real-time or faster simulation of a wide range of contact-rich scenes, including simultaneous simulation of 1000 nut-and-bolt interactions. We provide $60$ carefully-designed part models, 3 robotic assembly environments, and 7 robot controllers for training and testing virtual robots. Finally, we train and evaluate proof-of-concept reinforcement learning policies for nut-and-bolt assembly. We aim for Factory to open the doors to using simulation for robotic assembly, as well as many other contact-rich applications in robotics. Please see https://sites.google.com/nvidia.com/factory for supplementary content, including videos.</p>
                <p><strong>Cost:</strong> 0.016</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1771.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1771.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of sim-to-real transfer for robotic agents, scientific discovery agents, or laboratory automation systems, including details about simulation fidelity, transfer success, and the conditions that enable or hinder skill transfer from virtual to real environments.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Factory</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Factory: Fast Contact for Robotic Assembly</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A physics simulation module and robot-learning toolset (PhysX + Isaac Gym integration) that implements SDF-based collisions, GPU contact-reduction, and a Gauss–Seidel solver to enable large-scale, real-time simulation of contact-rich robotic assembly (e.g., 1024 nut-and-bolt interactions) and to train RL policies for assembly tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Factory: Fast Contact for Robotic Assembly</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>agent_system_name</strong></td>
                            <td>Simulated Franka robot (Franka Panda) with parallel-jaw gripper</td>
                        </tr>
                        <tr>
                            <td><strong>agent_system_description</strong></td>
                            <td>A 7-DOF Franka manipulator model integrated in Isaac Gym with 7 classical controllers (joint-space IK/ID, task-space impedance, OSC, open/closed-loop force, hybrid force-motion) and a parallel-jaw gripper; used to learn subpolicies (Pick, Place, Screw) for nut-and-bolt assembly in simulation.</td>
                        </tr>
                        <tr>
                            <td><strong>domain</strong></td>
                            <td>general robotics manipulation / robotic assembly</td>
                        </tr>
                        <tr>
                            <td><strong>virtual_environment_name</strong></td>
                            <td>PhysX (custom SDF/contact module) running inside Isaac Gym (NVIDIA GPU-based simulation); visualization via Omniverse/Isaac Gym</td>
                        </tr>
                        <tr>
                            <td><strong>virtual_environment_description</strong></td>
                            <td>High-performance GPU-accelerated rigid-body physics simulation using PhysX extended with voxel SDF collision queries, contact-patch reduction, and a Gauss–Seidel constraint solver; simulates rigid-body dynamics, contact generation and resolution, frictional contacts, controllers, and can produce rendered images (path-tracing/real-time).</td>
                        </tr>
                        <tr>
                            <td><strong>simulation_fidelity_level</strong></td>
                            <td>High-fidelity rigid-body contact physics for contact-rich interactions (geometry-accurate collision handling and force computation); not a deformable/FEM simulation for elastic effects.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_aspects_modeled</strong></td>
                            <td>High-fidelity geometric representation via voxel SDFs (resolutions up to 256^3+), accurate contact detection and normals, multi-surface frictional contact dynamics, contact force computation, realistic part geometries and ISO-standard clearances (nuts/bolts, pegs, gears), robot dynamics and controllers, large-scale parallel simulation performance.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_aspects_simplified</strong></td>
                            <td>No full FEM/deformation modeling (pre-tension, elastic thread deformation) for bolted joints; thread roots not modeled; thin-shell collisions and low-tessellation mesh issues noted as limitations; sensor noise, actuator delay/latency, and tactile sensing were not simulated in the presented transfer experiments (though tactile sim is planned); some evaluation scenes used artificially-reduced friction or tiny clearance adjustments for profiling.</td>
                        </tr>
                        <tr>
                            <td><strong>real_environment_description</strong></td>
                            <td>No real robot experiments were executed in this paper; only a quantitative comparison of simulated contact forces (finger/bolt forces) to an existing real-world human dataset (Daily Interactive Manipulation) collected with a wrench instrumented by a force-torque sensor. The paper reports that simulated joint torques and fingertip contact forces fall within realistic human ranges but does not run the learned policies on a physical Franka robot.</td>
                        </tr>
                        <tr>
                            <td><strong>task_or_skill_transferred</strong></td>
                            <td>No policies were transferred to real hardware in this work. Tasks trained in simulation: Pick (grasp nut), Place (align nut over bolt), Screw (engage and tighten nut on bolt); sequential chaining of subpolicies evaluated in simulation.</td>
                        </tr>
                        <tr>
                            <td><strong>training_method</strong></td>
                            <td>On-policy reinforcement learning (PPO) in Isaac Gym using the simulated Franka environments; policies trained as subpolicies (Pick, Place, Screw) with controller-target action spaces and environment/pose randomization.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success_metric</strong></td>
                            <td>Not applicable as no sim-to-real policy transfer was performed. For assessing simulation realism the authors compared contact-force distributions between simulation and the real-world Daily Interactive Manipulation (DIM) dataset using Maximum Mean Discrepancy (MMD) (reported MMD = 0.01269 for fingertip contact forces vs DIM wrench forces).</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance_sim</strong></td>
                            <td>Pick: 100% success (within training randomization bounds); Place: 98.4% success; Screw (best config): 85.6% success over 1024 episodes; End-to-end Pick+Place+Screw: 74.2% success. Training times: typical batches (4 policies) required ~1-1.5 hours for 1024 policy updates on an RTX3090 for these on-policy experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_performance_real</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>transfer_success</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_used</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>domain_randomization_details</strong></td>
                            <td>During RL training the authors randomized initial poses, object types/locations, robot joint states and small pose offsets (e.g., nut-in-gripper perturbations, bolt XY perturbations) to promote robustness. They did not report systematic domain randomization of dynamics (mass, friction coefficients, sensor noise) specifically intended for sim-to-real transfer in this paper, but plan to use such randomization in future work.</td>
                        </tr>
                        <tr>
                            <td><strong>sim_to_real_gap_factors</strong></td>
                            <td>Identified gap factors include: absence of deformable/FEM modeling (pretension and elastic contact effects), limitations in handling thin-shell or low-tessellation meshes, lack of simulated tactile sensing and occluded camera observations during contact, unmodeled sensor noise and actuator latency, possible mismatches in friction/contact parameters, and the tendency for RL agents to exploit simulator inaccuracies.</td>
                        </tr>
                        <tr>
                            <td><strong>transfer_enabling_conditions</strong></td>
                            <td>Paper argues that enabling conditions for future successful sim-to-real include: high-fidelity contact modeling (SDF collisions, accurate geometry and ISO-standard clearances), contact-reduced but accurate constraints, realistic contact force magnitudes, appropriate controller abstractions that match real robot controllers (OSC/impedance), parallelized training to permit on-policy learning, and algorithmic approaches for bridging sim-to-real such as domain randomization, teacher-student distillation (privileged-state teacher -> vision-based student), critics with privileged information, adding observation noise, and integrating tactile sensing on the real system.</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_requirements_identified</strong></td>
                            <td>The paper emphasizes that accurate contact dynamics and precise geometric fidelity (real-world clearances conforming to ISO standards) are critical for assembly tasks; successful simulation of nut-and-bolt kinematics requires collision between threads (i.e., geometry-accurate contact). They also note missing capabilities that are important for transfer (e.g., FEM for stiff deformable features, robust thin-shell handling), but do not provide a single numeric fidelity threshold (no percent error bound is given).</td>
                        </tr>
                        <tr>
                            <td><strong>fine_tuning_in_real_world</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>fine_tuning_details</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>comparison_across_fidelity_levels</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>fidelity_comparison_results</strong></td>
                            <td>The paper compares geometric/collision representations (convex hulls, convex decomposition, triangle meshes, voxel SDFs) and solver approaches: convex decompositions caused spatial artifacts and instabilities; trimeshes were accurate but required tiny timesteps and were slow; SDFs enabled accurate and efficient collision queries allowing real-time large-scale simulation (e.g., 1024 M16 nut-and-bolt assemblies) when combined with contact reduction and Gauss–Seidel solver. They did not compare sim-to-real transfer outcomes across fidelity levels.</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>While the authors do not perform sim-to-real policy transfer, they demonstrate that: (1) combining voxel SDF collisions, GPU contact-reduction, and a Gauss–Seidel solver enables large-scale, real-time, stable simulation of highly contact-rich assembly tasks (e.g., 1024 nut-and-bolt interactions); (2) RL policies for complex assembly phases (Pick, Place, Screw) can be trained efficiently in this simulator with high in-sim success rates (Screw up to ~85.6%); (3) simulated contact-force magnitudes are quantitatively similar to real-world human wrench data (low MMD), suggesting physical realism of raw contact quantities; (4) direct sim-to-real transfer was not demonstrated, and bridging the sim-to-real gap will likely require domain randomization, privileged-information distillation, noise modeling, tactile sensing, and possibly FEM/deformable modeling for certain phenomena.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Factory: Fast Contact for Robotic Assembly', 'publication_date_yy_mm': '2022-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Transferring dexterous manipulation from GPU simulation to a remote real-world TriFinger <em>(Rating: 2)</em></li>
                <li>Learning dexterous in-hand manipulation <em>(Rating: 2)</em></li>
                <li>Sim-to-real for robotic tactile sensing via physics-based simulation and learned latent projections <em>(Rating: 2)</em></li>
                <li>Sim-to-real transfer of bolting tasks with tight tolerance <em>(Rating: 2)</em></li>
                <li>Closing the sim-to-real loop: Adapting simulation randomization with real world experience <em>(Rating: 2)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1771",
    "paper_id": "paper-366ca45102a6111dbb256a908aa3f2bdb6a707dc",
    "extraction_schema_id": "extraction-schema-32",
    "extracted_data": [
        {
            "name_short": "Factory",
            "name_full": "Factory: Fast Contact for Robotic Assembly",
            "brief_description": "A physics simulation module and robot-learning toolset (PhysX + Isaac Gym integration) that implements SDF-based collisions, GPU contact-reduction, and a Gauss–Seidel solver to enable large-scale, real-time simulation of contact-rich robotic assembly (e.g., 1024 nut-and-bolt interactions) and to train RL policies for assembly tasks.",
            "citation_title": "Factory: Fast Contact for Robotic Assembly",
            "mention_or_use": "use",
            "agent_system_name": "Simulated Franka robot (Franka Panda) with parallel-jaw gripper",
            "agent_system_description": "A 7-DOF Franka manipulator model integrated in Isaac Gym with 7 classical controllers (joint-space IK/ID, task-space impedance, OSC, open/closed-loop force, hybrid force-motion) and a parallel-jaw gripper; used to learn subpolicies (Pick, Place, Screw) for nut-and-bolt assembly in simulation.",
            "domain": "general robotics manipulation / robotic assembly",
            "virtual_environment_name": "PhysX (custom SDF/contact module) running inside Isaac Gym (NVIDIA GPU-based simulation); visualization via Omniverse/Isaac Gym",
            "virtual_environment_description": "High-performance GPU-accelerated rigid-body physics simulation using PhysX extended with voxel SDF collision queries, contact-patch reduction, and a Gauss–Seidel constraint solver; simulates rigid-body dynamics, contact generation and resolution, frictional contacts, controllers, and can produce rendered images (path-tracing/real-time).",
            "simulation_fidelity_level": "High-fidelity rigid-body contact physics for contact-rich interactions (geometry-accurate collision handling and force computation); not a deformable/FEM simulation for elastic effects.",
            "fidelity_aspects_modeled": "High-fidelity geometric representation via voxel SDFs (resolutions up to 256^3+), accurate contact detection and normals, multi-surface frictional contact dynamics, contact force computation, realistic part geometries and ISO-standard clearances (nuts/bolts, pegs, gears), robot dynamics and controllers, large-scale parallel simulation performance.",
            "fidelity_aspects_simplified": "No full FEM/deformation modeling (pre-tension, elastic thread deformation) for bolted joints; thread roots not modeled; thin-shell collisions and low-tessellation mesh issues noted as limitations; sensor noise, actuator delay/latency, and tactile sensing were not simulated in the presented transfer experiments (though tactile sim is planned); some evaluation scenes used artificially-reduced friction or tiny clearance adjustments for profiling.",
            "real_environment_description": "No real robot experiments were executed in this paper; only a quantitative comparison of simulated contact forces (finger/bolt forces) to an existing real-world human dataset (Daily Interactive Manipulation) collected with a wrench instrumented by a force-torque sensor. The paper reports that simulated joint torques and fingertip contact forces fall within realistic human ranges but does not run the learned policies on a physical Franka robot.",
            "task_or_skill_transferred": "No policies were transferred to real hardware in this work. Tasks trained in simulation: Pick (grasp nut), Place (align nut over bolt), Screw (engage and tighten nut on bolt); sequential chaining of subpolicies evaluated in simulation.",
            "training_method": "On-policy reinforcement learning (PPO) in Isaac Gym using the simulated Franka environments; policies trained as subpolicies (Pick, Place, Screw) with controller-target action spaces and environment/pose randomization.",
            "transfer_success_metric": "Not applicable as no sim-to-real policy transfer was performed. For assessing simulation realism the authors compared contact-force distributions between simulation and the real-world Daily Interactive Manipulation (DIM) dataset using Maximum Mean Discrepancy (MMD) (reported MMD = 0.01269 for fingertip contact forces vs DIM wrench forces).",
            "transfer_performance_sim": "Pick: 100% success (within training randomization bounds); Place: 98.4% success; Screw (best config): 85.6% success over 1024 episodes; End-to-end Pick+Place+Screw: 74.2% success. Training times: typical batches (4 policies) required ~1-1.5 hours for 1024 policy updates on an RTX3090 for these on-policy experiments.",
            "transfer_performance_real": null,
            "transfer_success": null,
            "domain_randomization_used": false,
            "domain_randomization_details": "During RL training the authors randomized initial poses, object types/locations, robot joint states and small pose offsets (e.g., nut-in-gripper perturbations, bolt XY perturbations) to promote robustness. They did not report systematic domain randomization of dynamics (mass, friction coefficients, sensor noise) specifically intended for sim-to-real transfer in this paper, but plan to use such randomization in future work.",
            "sim_to_real_gap_factors": "Identified gap factors include: absence of deformable/FEM modeling (pretension and elastic contact effects), limitations in handling thin-shell or low-tessellation meshes, lack of simulated tactile sensing and occluded camera observations during contact, unmodeled sensor noise and actuator latency, possible mismatches in friction/contact parameters, and the tendency for RL agents to exploit simulator inaccuracies.",
            "transfer_enabling_conditions": "Paper argues that enabling conditions for future successful sim-to-real include: high-fidelity contact modeling (SDF collisions, accurate geometry and ISO-standard clearances), contact-reduced but accurate constraints, realistic contact force magnitudes, appropriate controller abstractions that match real robot controllers (OSC/impedance), parallelized training to permit on-policy learning, and algorithmic approaches for bridging sim-to-real such as domain randomization, teacher-student distillation (privileged-state teacher -&gt; vision-based student), critics with privileged information, adding observation noise, and integrating tactile sensing on the real system.",
            "fidelity_requirements_identified": "The paper emphasizes that accurate contact dynamics and precise geometric fidelity (real-world clearances conforming to ISO standards) are critical for assembly tasks; successful simulation of nut-and-bolt kinematics requires collision between threads (i.e., geometry-accurate contact). They also note missing capabilities that are important for transfer (e.g., FEM for stiff deformable features, robust thin-shell handling), but do not provide a single numeric fidelity threshold (no percent error bound is given).",
            "fine_tuning_in_real_world": null,
            "fine_tuning_details": null,
            "comparison_across_fidelity_levels": false,
            "fidelity_comparison_results": "The paper compares geometric/collision representations (convex hulls, convex decomposition, triangle meshes, voxel SDFs) and solver approaches: convex decompositions caused spatial artifacts and instabilities; trimeshes were accurate but required tiny timesteps and were slow; SDFs enabled accurate and efficient collision queries allowing real-time large-scale simulation (e.g., 1024 M16 nut-and-bolt assemblies) when combined with contact reduction and Gauss–Seidel solver. They did not compare sim-to-real transfer outcomes across fidelity levels.",
            "key_findings": "While the authors do not perform sim-to-real policy transfer, they demonstrate that: (1) combining voxel SDF collisions, GPU contact-reduction, and a Gauss–Seidel solver enables large-scale, real-time, stable simulation of highly contact-rich assembly tasks (e.g., 1024 nut-and-bolt interactions); (2) RL policies for complex assembly phases (Pick, Place, Screw) can be trained efficiently in this simulator with high in-sim success rates (Screw up to ~85.6%); (3) simulated contact-force magnitudes are quantitatively similar to real-world human wrench data (low MMD), suggesting physical realism of raw contact quantities; (4) direct sim-to-real transfer was not demonstrated, and bridging the sim-to-real gap will likely require domain randomization, privileged-information distillation, noise modeling, tactile sensing, and possibly FEM/deformable modeling for certain phenomena.",
            "uuid": "e1771.0",
            "source_info": {
                "paper_title": "Factory: Fast Contact for Robotic Assembly",
                "publication_date_yy_mm": "2022-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Transferring dexterous manipulation from GPU simulation to a remote real-world TriFinger",
            "rating": 2
        },
        {
            "paper_title": "Learning dexterous in-hand manipulation",
            "rating": 2
        },
        {
            "paper_title": "Sim-to-real for robotic tactile sensing via physics-based simulation and learned latent projections",
            "rating": 2
        },
        {
            "paper_title": "Sim-to-real transfer of bolting tasks with tight tolerance",
            "rating": 2
        },
        {
            "paper_title": "Closing the sim-to-real loop: Adapting simulation randomization with real world experience",
            "rating": 2
        }
    ],
    "cost": 0.01577325,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Factory: Fast Contact for Robotic Assembly</h1>
<p>Yashraj Narang1, Kier Storey1, Iretiayo Akinola1, Miles Macklin1, Philipp Reist1, Lukasz Wawrzyniak1, Yunrong Guo1, Adam Moravanszky1, Gavriel State1, Michelle Lu1, Ankur Handa1, Dieter Fox12
1NVIDIA Corporation, Santa Clara, USA
2Paul G. Allen School of Computer Science &amp; Engineering, University of Washington, Seattle, USA</p>
<h6>Abstract</h6>
<p>Robotic assembly is one of the oldest and most challenging applications of robotics. In other areas of robotics, such as perception and grasping, simulation has rapidly accelerated research progress, particularly when combined with modern deep learning. However, accurately, efficiently, and robustly simulating the range of contact-rich interactions in assembly remains a longstanding challenge. In this work, we present Factory, a set of physics simulation methods and robot learning tools for such applications. We achieve real-time or faster simulation of a wide range of contact-rich scenes, including simultaneous simulation of 1000 nut-and-bolt interactions. We provide 60 carefully-designed part models, 3 robotic assembly environments, and 7 robot controllers for training and testing virtual robots. Finally, we train and evaluate proof-of-concept reinforcement learning policies for nut-and-bolt assembly. We aim for Factory to open the doors to using simulation for robotic assembly, as well as many other contact-rich applications in robotics. Please see our website for supplementary content, including videos. ${ }^{1}$</p>
<h2>I. INTRODUCTION</h2>
<p>Assembly is an essential, but highly challenging area of manufacturing. It includes a diverse range of operations, from peg insertion, electrical connector insertion, and threaded fastener mating (e.g., tightening nuts and bolts), to wire processing, cable routing, and soldering [9, 42]. These operations are ubiquitous across the automotive, aerospace, electronics, and medical industries [9]. However, assembly has been exceptionally difficult to automate due to physical complexity, part variability, and strict reliability requirements [42].</p>
<p>In industry, robotic assembly methods may achieve high precision, accuracy, and reliability [9, 52, 98]. However, these methods can be highly restrictive. They often use expensive equipment, require custom fixtures, have high setup times (e.g., tooling design, waypoint definition, parameter tuning) and cycle times, and are sensitive to variation (e.g., part appearance, location). Custom tooling and part-specific engineering are also cost-prohibitive for high-mix, low-volume settings [42]. In research, methods for robotic assembly often use lessexpensive equipment, require fewer custom fixtures, achieve increased robustness to variation, and may recover from failure [35, 56, 90]. Nevertheless, these methods often have lower reliability, higher setup times (e.g., demo collection, real-world training, parameter tuning), and/or higher cycle times.</p>
<p>Meanwhile, physics simulation has become a powerful tool for robotics development. Simulators have primarily been used to verify and validate robot designs and algorithms [1]. Recent</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Fig. 1. Rendering of Franka robots interacting with nut-and-bolt assemblies in Isaac Gym using methods from Factory. The simulation contains 128 parallel environments and is executing in real-time on a single GPU.
research has demonstrated a host of other applications: creating training environments for virtual robots [20, 50, 91, 105], generating large-scale grasping datasets [21, 33], inferring real-world material parameters [70, 71], simulating tactile sensors [73, 84, 100], and training reinforcement learning (RL) agents for manipulation and locomotion [13, 78]. Compelling works have now shown that RL policies trained in simulation can be transferred to the real world [2, 4, 12, 27, 62, 81, 103].</p>
<p>Nevertheless, the power of physics simulation has not substantially impacted robotic assembly. For assembly, a simulator must accurately and efficiently simulate contact-rich interactions, a longstanding challenge in robotics [14, 31, 53, 109], particularly for geometrically-complex, tight-clearance bodies. For instance, consider the canonical nut-and-bolt assembly task. Real-world nuts and bolts have finite clearances between their threads, thus experiencing 6-DOF relative motion rather than pure helical motion. To simulate real-world motion phases (e.g., initial mating, rundown) and associated pathologies (e.g., cross-threading, jamming) [36], collisions between the threads must be simulated. However, high-quality surface meshes for a nut-and-bolt may consist of $10 k-50 k$ triangles; a naive collision scheme may easily exceed memory and compute limits. Moreover, for RL training, a numerical solver may need to satisfy non-penetration constraints for 1000 environments in real-time (i.e., at the same rate as the underlying physical dynamics). Despite the omnipresence of threaded fasteners in the world, no existing simulator achieves this performance.</p>
<p>In this work, we present Factory, a set of physics simulation methods and robot learning tools for such interactions (Fig. 1). Specifically, we contribute the following:</p>
<ul>
<li>A physics simulation module for fast, accurate simulations of contact-rich interactions through a novel synthesis of signed distance function (SDF)-based collisions, contact reduction, and a Gauss-Seidel solver. The module is accessible within the PhysX physics engine [75] and Isaac Gym [64]. We demonstrate simulator performance on a wide range of challenging scenes. As an example, we simulate 1000 simultaneous nut-and-bolt assemblies in real-time on a single GPU, whereas the prior state-of-the-art was a single nut-and-bolt assembly at $\frac{1}{20}$ real-time.</li>
<li>A robot learning suite consisting of a Franka robot and all rigid-body assemblies from the NIST Assembly Task Board 1 [42], the established benchmark for robotic assembly [98]. The suite includes 60 carefully-designed assets, 3 robotic assembly environments, and 7 classical robot controllers. The suite is accessible within Isaac Gym. User-defined assets, environments, and controllers can be added and simulated as desired.</li>
<li>Proof-of-concept RL policies for a simulated Franka robot to solve the most contact-rich task on the NIST board, nut-and-bolt assembly. The policies are trained and tested in Isaac Gym. The contact forces generated during policy execution are compared to literature values from the real world and show strong consistency.</li>
</ul>
<p>We aim for Factory to greatly accelerate research and development in robotic assembly, as well as serve as a powerful tool for contact-rich simulation of any kind.</p>
<h2>II. Related Work</h2>
<h2>A. Contact-Rich Simulation</h2>
<p>A longstanding challenge in contact-rich simulation is fast, accurate, and robust contact generation, as well as solution of non-penetration constraints. We have found that achieving such performance requires careful consideration of 1) geometric representations, 2) contact reduction schemes, and 3) numerical solvers. Here we review primary options for each, as well as prior results on a challenging benchmark.</p>
<p>1) Geometric Representations: There are 5 major geometric representations in physics simulation for graphics: convex hulls, convex decompositions, triangular meshes (trimeshes), tetrahedral meshes (tetmeshes), and SDFs (Fig. S10).</p>
<p>Convex hulls cannot accurately approximate complex object geometries, such as threaded fasteners with concavities. Convex decompositions address this issue by approximating the input shape using multiple convex hulls, generated with algorithms such as V-HACD [65]. While an improvement on single convex hulls, these decompositions can produce spatial artifacts on complex geometries (Fig. S11). Even for perfect decompositions, the number of collision pairs to test during contact generation scales as $\mathcal{O}\left(n^{2}\right)$ (where $n$ is the number of convex shapes), impacting memory and performance. Since contacts are generated between convex shapes, undesirable contact normals can be generated, and snagging may occur.</p>
<p>Trimeshes can provide a near-exact approximation of complex geometries. However, the number of collision pairs for contact generation scales as $\mathcal{O}\left(n^{2}\right)$ (where $n$ is the number of triangles), again impacting memory and performance. In addition, since triangles have zero volume, penetrations can be difficult to resolve, motivating techniques such as boundarylayer expanded meshes [28]. Tetmeshes can mitigate such penetration issues, but high quality tetrahedral meshing is challenging. Tetrahedra may have extreme aspect ratios in high-detail areas, leading to inaccurate collision checks.</p>
<p>SDFs, which map points to distance-to-a-surface, can provide accurate implicit representations of complex geometries. They enable fast lookups of distances, as well as efficient computation of gradients to define contact normals. However, using SDFs for collisions requires precomputing SDFs offline from a mesh, which can be time- and memory-intensive. Moreover, collision schemes typically test the vertices of a trimesh against the SDF to generate contacts. For sharp objects, simply sampling vertices can cause penetration to occur, motivating iterative per-triangle contact generation [61].</p>
<p>We use discrete, voxel-based SDFs as our geometric representation and demonstrate that they provide efficient, robust collision detection for challenging assets in robotic assembly.
2) Contact Reduction: Contact reduction is a powerful technique from game physics for reducing the total number of contacts without compromising simulation accuracy. A naive contact generation scheme between a nut and bolt may generate $\sim 1$e6 contacts; a careful one may generate $\sim 1$e4. Excessive contacts can impact both memory and stability, and per-contact memory requirements cannot easily be reduced. Since the rigid-body mechanics principle of equivalent systems dictates that a set of distributed forces can be replaced by a smaller set of forces (constrained to produce the same net force and moment), accurate dynamics can be preserved.</p>
<p>Specifically, contact reduction consists of methods for preprocessing, clustering, and maintaining temporal persistence of contacts. We pay particular attention to contact clustering, which generates bins for contacts, reduces the bins, and reduces the contacts within each bin using heuristics. The two most common heuristics are normal similarity and penetration depth [72]. Normal similarity assigns contacts with similar surface normals to the same bin, culls similar bins, and culls similar contacts, and is often implemented with $k$-means or cube map algorithms [76, 80, 26]. Penetration depth culls bins and contacts with negligible penetration, as these often have minimal impact on dynamics. Data-driven methods train networks to perform the reduction [41], but require a separate data collection and learning phase to be effective.</p>
<p>We combine normal similarity, penetration depth, and an area-based metric to reduce contacts and demonstrate the resulting dynamics across numerous evaluation scenes.
3) Solvers: There are 4 major options for solvers in physics simulation: direct, conjugate gradient/conjugate residual (CG/CR), Jacobi, and Gauss-Seidel. We briefly review these solution methods below; see [3] for a detailed treatment.</p>
<p>Direct solvers, which may rely on matrix pivoting, do not scale well to large sets of contact constraints, such as the $\sim 1$e4 constraints between a nut and bolt mesh. CG/CR methods can</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Fig. 2. Cross-sectional view of an aligned M16 nut-and-bolt assembly. Nuts and bolts have finite clearances between their threads, thus experiencing 6-DOF kinematics with multi-surface frictional contact, rather than pure helical motion. As follows, a nut can roll and pitch on a bolt, and may experience pathologies such as cross-threading and jamming [36]. Left: a loose model, where the clearances between threads are at their maximum allowable value (ISO 965). Right: zoom view. Thread roots are not modeled.</p>
<p>handle larger sets of constraints, but are still unable to achieve real-time performance for complex scenarios. Gauss-Seidel solvers are robust and converge quickly for well-conditioned problems, but perform serial operations that do not scale well to large sets of constraints. Jacobi solvers perform parallel operations that can leverage GPU acceleration, but converge slower than the aforementioned techniques.</p>
<p>A naive implementation of Jacobi can outperform Gauss-Seidel for simulating numerous contact-rich interactions. However, we show that contact reduction can greatly accelerate Gauss-Seidel, achieving better performance than Jacobi.</p>
<p>4) Benchmark Problem: We pay special attention to the problem of accurately and efficiently simulating a nut-and-bolt assembly (Fig. 2). In the simulation community, this problem has emerged as a canonical challenge in contact-rich simulation. Moreover, in robotic assembly, tightening nuts onto bolts is critically important, as ≈ 40% of all mechanical assembly operations involve screws and bolts [67].</p>
<p>The 3D finite element method (FEM) is the gold standard for accurate simulation of nut-and-bolt models, capturing deformation phenomena such as pretension ([40]). However, FEM simulation of a single nut-bolt pair may take ∼1-10 min to execute on CPU. As our aim is real-time (or faster) simulation to enable learning methods such as RL, we focus on rigid-body simulation prevalent in graphics and robotics.</p>
<p>In [106], rigid-body contact was simulated using semi-implicit integration, symbolic Gaussian elimination, analytical contact gradients, and an SVD solver. A dynamic scene was simulated of screwing a hex bolt into a threaded hole at 1/460 real-time (6.0 h for 47 s). The proposed method was compared against Bullet (2012) [17], and a 7e4× speed-up was measured for a stable quasi-static version of the scene. In [25], rigid-body contact was simulated using a smoothed particle hydrodynamics solver that samples rigid surfaces with particles, models contacts as density deviations, and computes pressure-based contact forces implicitly. A quasi-static nut-and-bolt scene was simulated at 1/20 real-time (81 s for 4 s). The proposed method was also compared against Bullet (2018), and a 9.5× speed-up was measured for a stable scene.</p>
<p>In [23], rigid-body contact was simulated using an extension of incremental potential contact (IPC) [51] and continuous collision detection (CCD) for curved trajectories. A dynamic, frictionless nut-and-bolt scene was simulated at 1/350 real-time (3.5 s for ∆t = 0.01 s). The proposed method was compared against Bullet (2019), MuJoCo [95], Chrono [92], and Houdini RBD [86]. Instabilities were observed with Bullet and MuJoCo, and interpenetrations were observed with Chrono and Houdini. In [87], rigid-body contact was simulated using a configuration-space contact model. A single large M48 (48 mm diameter) nut-and-bolt was simulated at 4× real-time; however, data and evaluations were limited. Informally, an industry group simulated a dynamic nut-and-bolt scene at ≈1/20 real-time with variational integrators [10, 45].</p>
<p>From the previous works, we define the established state-of-the-art for a general-purpose physics simulator that can simulate a nut-and-bolt assembly to be 1/20 real-time for a single nut-bolt pair. Although fast, such speeds are not optimal for applications such as RL, which benefit from simulation of ∼1e2–1e3 contact-rich interactions in real-time. In this work, we demonstrate real-time simulation of 1000 nuts-and-bolts, as well as exceptional speeds on other challenging scenes.</p>
<h3>B. Robotic Assembly Simulation</h3>
<p>Here we review previous efforts to simulate robotic assembly, as well as efforts to use these simulators and/or real-world training for RL. For another recent review, see [89].</p>
<p>1) Simulation: Research efforts such as [106, 25, 23] have demonstrated advances in contact-rich simulation, often in comparison to physics engines used in robotics. However, the majority of robotics studies use PyBullet, MuJoCo, or Isaac Gym, as they provide robot importers, simulated sensors, parallel simulation, and learning-friendly APIs. Consequently, existing work in simulation for robotic assembly is largely limited to the performance of these simulators.</p>
<p>Efforts using MuJoCo or the robosuite extension [112] include [19, 22, 29, 37, 38, 48, 82, 88, 96, 97, 99, 108, 110, 111]. Simulated rigid-body assembly tasks are limited to peg-in-hole insertion of large pegs with round, triangular, square, and prismatic cross-sections, lap-joint mating, and one non-convex insertion [29]. Furthermore, clearances between rigid parts are typically 0.5-10 mm, substantially greater than real-world clearances. Efforts using PyBullet include [5, 57, 83, 107]. Simulated tasks are again limited to large peg-in-hole insertion and lap-joint mating, with clearances of ∼1 mm. A handful of research efforts have used other off-the-shelf simulators [7, 32, 47, 104, 111] and custom simulators [16, 58, 87]. Only [87] simulated a nut-and-bolt, which was exceptionally large (48 mm diameter) with inherently-larger clearances.</p>
<p>From the previous works, we conclude that there have been few successful efforts to simulate assembly tasks with realistic scales, realistic clearances (e.g., ∼0.1 mm diametral clearance for a 4 mm peg), and complex geometries (e.g., nuts-and-bolts, electrical connectors) within a robotics simulator. In</p>
<p>this work, we build a module for PhysX and Isaac Gym that can successfully simulate all rigid components on NIST Task Board 1 <em>[42]</em> with accurate models and real-world clearances.
2) Reinforcement Learning: The studies in the previous subsection, as well as a small number of studies that trained RL for robotic assembly purely in the real world, can be categorized according to their choice of RL algorithm.</p>
<p>Several earlier works used model-based RL algorithms or proposed variants, which explicitly predict environment response during policy learning and/or execution. These efforts leveraged guided policy search <em>[54, 93]</em> and iterative LQG <em>[55]</em>. Such algorithms are sample-efficient, but difficult to apply to contact-rich tasks due to highly discontinuous and nonlinear dynamics and unknown material parameters <em>[88]</em>.</p>
<p>Most recent works have used model-free, off-policy RL algorithms or variants, which do not predict environment response, and update an action-value function independently of the current policy (e.g., using a replay buffer). These studies have applied Q-learning <em>[35]</em>, deep-Q networks <em>[110]</em>, deep deterministic policy gradients (DDPG) <em>[5, 58, 56, 97]</em>, softactor critic <em>[7]</em>, probabilistic embeddings <em>[82]</em>, and hierarchical RL <em>[32]</em>. These algorithms are typically chosen for sample efficiency, but are often brittle and slow/unable to converge.</p>
<p>Several other studies use or develop off-policy RL algorithms that leverage human demonstrations, as well as motion planners and trajectory optimizers. These efforts have used residual learning from demonstration <em>[19]</em>, guided DDPG <em>[22]</em>, DDPG from demonstration (DDPGfD) <em>[56, 57, 96]</em>, and inverse RL <em>[104]</em>. Notably, <em>[56]</em> used DDPGfD to achieve state-of-the-art performance in the real world for 3 insertion tasks from NIST Task Board 1. They used human demonstrations, real-world training, and human on-policy corrections, achieving a $99.8\%$ success rate over $13k$ trials. Of course, these methods also require demonstration collection or effective planners/optimizers, and are typically limited to the performance of these structured priors.</p>
<p>Finally, a handful of research efforts have successfully used on-policy algorithms or variants. These studies have applied proximal policy optimization (PPO) <em>[29, 87, 99]</em>, trust region policy optimization <em>[47]</em>, asynchronous advantage actor-critic <em>[83]</em>, and additional algorithms <em>[38]</em>. These algorithms are typically stable, easy-to-use, and achieve high return, but are highly sample-inefficient and require long wall-clock time.</p>
<p>We take inspiration from the performance of <em>[56]</em>, but aim to achieve such performance in a fundamentally different way. We build a module for contact-rich simulation that can help enable roboticists to perform more complicated tasks (e.g., nut-and-bolt assembly) with tight clearances; leverage performant and stable on-policy RL algorithms with high parallelization; avoid tedious human demonstrations and corrections; and mitigate the need for time-consuming (e.g., $\sim 50$ hours of data in <em>[56]</em>), costly, and dangerous real-world RL training.</p>
<h2>III Contact-Rich Simulation Methods</h2>
<p>In this work, we first build a module for PhysX <em>[75]</em> for efficient and robust contact-rich simulation. Specifically, we uniquely combine SDF collisions <em>[61]</em>, contact reduction <em>[72]</em>, and a Gauss-Seidel solver <em>[60]</em>, allowing us to simulate interactions of highly-detailed models substantially faster than previous efforts. We describe methods and results below.</p>
<h3>III-A SDF Collisions</h3>
<p>An SDF is a function $\phi(\boldsymbol{x}):\mathbb{R}^{3}\rightarrow\mathbb{R}$ that maps a point $\boldsymbol{x}$ in Cartesian space to its Euclidean distance to a surface. The surface is implicitly defined by $\phi(\boldsymbol{x})=0$, and the sign indicates whether $\boldsymbol{x}$ is inside or outside the surface. The gradient $\nabla\phi(\boldsymbol{x})$ provides the normal at a point $\boldsymbol{x}$ on the surface. Collectively, the SDF value and gradient define a vector to push a colliding object out of the surface.</p>
<p>We generate the SDF for an object via sampling and compute gradients via finite-differencing. Specifically, given a triangle mesh representing the boundaries of the object, we generate an SDF for the mesh at initialization time and store it as a 3D texture, which enables GPU-accelerated texture fetching with trilinear filtering and extremely fast $\mathcal{O}(1)$ lookups. Since our shapes contain many small features, we typically use SDF resolutions of $256^{3}$ or greater.</p>
<p>To generate an initial set of contacts, we use the method of <em>[61]</em>, which generates one contact per triangle-mesh face. The contact position on each face is determined by performing iterative local minimization to find the closest point on the face to the opposing shape, using projected gradient descent with adaptive stepping. As an example, detailed M4 nut-and-bolt meshes generate $16k$ contacts; with the above method, these contacts can be generated in $&lt;1~{}{ms}$, orders of magnitude faster than typical approaches for convex or mesh collision.</p>
<h3>III-B Contact Reduction and Solver Selection</h3>
<p>To motivate our contact reduction methods, we begin with a brief discussion and first-order analysis of the tight coupling between contact generation and solver execution.</p>
<p>In a typical contact generation scheme, each contact only requires approximately 7 floats (point, normal vector, and distance) and 2 integers (rigid body indices), for a total of 36 bytes. However, the memory required to store constraints associated with these contacts is substantially greater; in our implementation, storing a contact and its constraints requires approximately 160 bytes. Thus, simulating an M4 nut-bolt pair with $16k$ contacts requires approx. $2.5~{}{MB}$ per timestep.</p>
<p>For a Jacobi solver with $\Delta t=\frac{1}{60}{s}$, we require 8 substeps and 64 iterations for stable simulation. Thus, memory bandwidth requirements for $16k$ contacts are approximately $1.28~{}{GB}$ per frame and $76.8~{}{GB}$ per second. Using a state-of-the-art GPU, we can only simulate 20 nut-and-bolt assemblies in parallel (Table V). Unfortunately, although a Gauss-Seidel solver converges faster (i.e., requires fewer substeps and iterations), it would be unreasonably slow for so many contacts due to its inherently serial nature. As reducing per-contact memory can be challenging, contact reduction becomes a compelling strategy for reducing memory and increasing parallelization.</p>
<p>If we can reduce the number of contacts to $2\%$ (i.e., from $16k$ to $300$), the simulation now requires approximately $48~{}{kB}$</p>
<p>per timestep. The Jacobi solver now only requires 24 $M B$ per frame and 1.44 $G B$ per second. We can now hypothetically simulate a maximum of 1100 nut-and-bolt assemblies in real-time. Solving contact constraints is no longer a performance bottleneck, and we can achieve a level of parallelization suitable for training on-policy RL algorithms.</p>
<p>In addition, given the far fewer contacts, it is now feasible to use a Gauss-Seidel solver. With $\Delta t=\frac{1}{60}$s, we require only 1 substep and 16 iterations for stable simulation. Thus, we can now comfortably simulate $&gt;1000$ nut-and-bolt assemblies in real-time. We demonstrate exactly such performance later.</p>
<h3>V-C Implementation of Contact Reduction</h3>
<p>To implement contact reduction, we use the concept of contact patches, which are sets of contacts that are proximal and share a normal. We generate contact patches in 3 phases (Algorithm 1). First, we Generate candidate contacts using SDF collisions for a batch of triangles (size 1024). Second, we Assign candidates to existing patches in the shape pair based on normal similarity. Third, for unassigned candidates, we FindDeepest (i.e., find the one with deepest penetration), create a new patch, BinReduce (i.e., assign remaining candidates to this patch based on normal similarity), and AddPatch to our list of patches. We repeat until no candidates remain. When performing AddPatch, we also check if a patch with a similar normal exists. We either add both patches or replace the existing patch, using a measure that maximizes patch surface area, prioritizes contacts with high penetration depth, and restricts the number of patches to $N$ (where $128 \leq N \leq 256$ ).</p>
<p>The preceding contact reduction process is performed exclusively in GPU shared memory. Notably, contact reduction does not make contact generation slower; to the contrary, it makes generation faster, as the contact generation kernel does not need to write extensive amounts of data to global memory.</p>
<p>Applying the above procedure to the M4 nut-and-bolt interactions, we reduce the number of contacts from $16 k$ to 300 (Fig. S13), allowing us to simulate 1024 assemblies in realtime on an NVIDIA A5000 GPU. Generating and reducing contacts takes 11 ms , and solving contact constraints takes an additional 3 ms . A number of additional evaluations follow.</p>
<h3>V-D Performance Evaluations</h3>
<p>We test our collision detection, contact generation, contact reduction, and solution pipeline on 8 contact-rich scenes. These scenes were designed to represent a broad range of challenging real-world scenarios, including complex geometries, robot-object interactions, tight clearances, 100s of interacting bodies, and multi-part mechanisms. The scenes are as follows:</p>
<ul>
<li>1024 parallel 4-mm peg-in-hole assemblies from the NIST board with ISO-standard clearances ( 0.104 mm ).</li>
<li>1024 parallel M16 nut-and-bolt assemblies with ISOstandard clearances (Fig 3). For ease of contact profiling, the coefficient of friction is reduced to 0.05 , allowing the nuts to rotate on the bolts under gravity.</li>
<li>1024 parallel VGA-style D-subminiature (D-sub) connectors from the NIST board (Fig S14). For ease of</li>
</ul>
<p>Algorithm 1: Collision Detection: An overview of our collision detection pipeline. The input is two potentially contacting shapes $(a, b)$. The output is a list of patches (i.e., sets of contacts) for each shape pair.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">foreach</span><span class="w"> </span><span class="nv">shape</span><span class="w"> </span><span class="nv">pair</span><span class="w"> </span>\<span class="ss">((</span><span class="nv">a</span>,<span class="w"> </span><span class="nv">b</span><span class="ss">)</span>\<span class="ss">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="nv">patches</span><span class="w"> </span>\<span class="ss">(</span><span class="o">=</span>\<span class="nv">emptyset</span>\<span class="ss">)</span>
<span class="w">    </span><span class="nv">foreach</span><span class="w"> </span><span class="nv">batch</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">triangles</span><span class="w"> </span>\<span class="ss">((</span><span class="nv">a</span>,<span class="w"> </span><span class="nv">b</span><span class="ss">)</span>\<span class="ss">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">        </span><span class="nv">candidates</span><span class="w"> </span>\<span class="ss">(</span>\<span class="nv">leftarrow</span>\<span class="ss">)</span><span class="w"> </span><span class="nv">GenerateContacts</span><span class="w"> </span><span class="ss">(</span><span class="nv">batch</span><span class="ss">)</span>
<span class="w">        </span><span class="nv">patches</span><span class="w"> </span>\<span class="ss">(</span>\<span class="nv">leftarrow</span>\<span class="ss">)</span><span class="w"> </span><span class="nv">Assign</span><span class="ss">(</span><span class="nv">candidates</span>,<span class="w"> </span><span class="nv">patches</span><span class="ss">)</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="nv">candidates</span><span class="w"> </span>\<span class="ss">(</span>\<span class="nv">neq</span><span class="w"> </span>\<span class="nv">emptyset</span>\<span class="ss">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">            </span><span class="nv">best</span><span class="w"> </span>\<span class="ss">(</span>\<span class="nv">leftarrow</span>\<span class="ss">)</span><span class="w"> </span><span class="nv">FindDeepest</span><span class="ss">(</span><span class="nv">candidates</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">patch</span><span class="w"> </span>\<span class="ss">(</span>\<span class="nv">leftarrow</span>\<span class="ss">)</span><span class="w"> </span><span class="nv">BinReduce</span><span class="ss">(</span><span class="nv">candidates</span>,<span class="w"> </span><span class="nv">best</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">patches</span><span class="w"> </span>\<span class="ss">(</span>\<span class="nv">leftarrow</span>\<span class="ss">)</span><span class="w"> </span><span class="nv">AddPatch</span><span class="ss">(</span><span class="nv">patch</span>,<span class="w"> </span><span class="nv">patches</span><span class="ss">)</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</code></pre></div>

<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Fig. 3. Rendering of the M16 nut-and-bolt assemblies scene, consisting of 1024 parallel nut-and-bolt interactions executing in real-time.
contact profiling, a $2 \mathrm{e}-6 \mathrm{~m}$ clearance is introduced, allowing the plug-and-socket to mate under gravity.</p>
<ul>
<li>1024 parallel 2-stage gear assemblies from the NIST board (Fig S14). An external torque is applied to the intermediate gear to rotate the adjacent gears.</li>
<li>1024 M16 nuts, falling into a pile in one environment (Fig. S15).</li>
<li>1024 bowls (akin to [106]), falling into a pile in one environment. To enable larger timesteps while maintaining accuracy, a tiny $1 \mathrm{e}-6 \mathrm{~m}$ negative clearance is added.</li>
<li>1024 toruses, falling into a pile in one environment.</li>
<li>128 parallel Franka robot + M16 nut-and-bolt assemblies. A vibratory feeder mechanism feeds an aggregate of nuts into a channel. The robot grasps the nut from the channel and tightens it onto the bolt using an inverse kinematics (IK) controller (Fig. 4, App. C2).
Table VI describes the geometric representations used in each of the scenes, including SDF resolution and number of triangles. Table I provides statistics on contacts before and after contact reduction, as well as timing for reduction and solution. Finally, Table II provides simulation performance statistics, including comparisons to real-time. We also qualitatively demonstrate an additional test scene: a Franka robot</li>
</ul>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Fig. 4. Rendering of the Franka robot + M16 nut-and-bolt assemblies scene, consisting of 128 parallel Franka robots retrieving nuts from a vibratory feeder mechanism (left) and tightening them onto a bolt (right).</p>
<h2>+ M16 nuts + flange assembly scene (App. C2).</h2>
<p>Although we defer to the tables for complete performance assessments, key observations include the following:</p>
<ul>
<li>Contact reduction can reduce contact counts by over 2 orders-of-magnitude compared to naive methods.</li>
<li>Contact handling time (<em>i.e.</em>, pair finding, generation, reduction) is typically dominant compared to solution time.</li>
<li>Parallelization achieves a 3-orders-of-magnitude speed-up over real-time single-threaded computation.</li>
</ul>
<h2>IV. ROBOT LEARNING TOOLS</h2>
<p>We have thus far evaluated our physics simulation module over a diverse array of contact-rich scenes. However, the module is an extension of PhysX [75]. For convenient use in robot learning, we have integrated our module into Isaac Gym [64], which can use PhysX as its physics engine. To use our contact methods for arbitrary assets, the user simply has to include an <em><sdf></em> tag in URDF descriptions (Listing 1).</p>
<p>For applications to robotic assembly, assets, and scenes related to NIST Task Board 1 may be particularly useful. Thus, we provide 1) 60 assets from the NIST board, 2) 3 robotic assembly scenes for RL training in Isaac Gym, and 3) 7 classical robot controllers in Isaac Gym to accelerate learning. Here we describe our assets, environments, and controllers.</p>
<h3>A. Assets</h3>
<p>The NIST Task Board 1 consists of 38 unique parts. However, the CAD models publicly provided for these parts are not suitable for high-accuracy physics simulation. In particular, the models for the nuts, bolts, pegs, and gear assembly do not conform to real-world tolerances and clearances; in assembly, mating parts together with tight clearances is precisely the most significant challenge. Furthermore, the models for the electrical connectors were sourced from public repositories rather than manufacturers (<em>e.g.</em>, the D-sub plug and socket), were geometrically incompatible (<em>e.g.</em>, the RJ45 plug and socket, which interpenetrate), were incomplete (<em>e.g.</em>, the USB socket, which lacks mating features), and/or were designed using hand measurements (<em>e.g.</em>, the Waterproof plug and socket). Regardless of simulator accuracy, inaccurate geometries (esp. interpenetration) will lead to unstable or inaccurate dynamics.</p>
<p><img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Fig. 5. Rendering of a simulated NIST Task Board 1, demonstrating the provided assets. We provide simulation and RL training environments for all rigid components of the board. Compare to the real board in Fig. S16.</p>
<p>We provide 60 high-quality, simulation-ready part models, each with an Onshape CAD model, one or more OBJ meshes, a URDF description, and estimated material properties (Table VII and Table VIII). These models include all the parts on the NIST Task Board 1, as well as dimensional variations. The assets for the nuts, bolts, pegs, and gearshafts conform to ISO 724, ISO 965, and ISO 286 standards and contain <em>loose</em> and <em>tight</em> configurations that correspond to the extremes of the tolerance band. The CAD models for the electrical connectors were sourced from manufacturer-provided models. Each part of each connector contains a <em>visual mesh</em>, directly exported from the CAD models, and a <em>collision mesh</em>, carefully redesigned to simplify external geometry while faithfully preserving mating features (<em>e.g.</em>, pins and holes).</p>
<h3>B. Scenes</h3>
<p>We provide 3 robotic assembly scenes for Isaac Gym that can be used for developing planning and control algorithms, collecting simulated sensor data for supervised learning, and training RL agents. Each scene contains a Franka robot and disassembled assemblies from NIST Task Board 1. All scenes have been tested with up to 128 simultaneous environments on an NVIDIA RTX 3090 GPU. The scenes are as follows:</p>
<ul>
<li>FrankaNutBoltEnv, which contains a Franka robot and nut-and-bolt assemblies of the user's choice (M4, M8, M12, M16, and/or M20). The nuts and bolts can be randomized in type and location across all environments. The default goal is to pick up a nut from a work surface and tighten it to the bottom of its corresponding bolt. Our own RL training results on this environment will be discussed in detail in the next section.</li>
<li>FrankaInsertionEnv, which contains a Franka robot and insertion assemblies of the user's choice (round and/or rectangular pegs-and-holes; BNC, D-sub, and/or USB plugs-and-sockets) (Fig. 6). The assets can be randomized in type and location across all environments. The default goal is to pick up a peg or plug and insert it into its corresponding hole or socket.</li>
<li>FrankaGearsEnv, which contains a Franka robot and a 4-part gear assembly (Fig. 7). The assets can be randomized in location across all environments. The default goal</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Contact Stats (Before)</th>
<th></th>
<th>Contact Handling</th>
<th>Contact Stats (After)</th>
<th>Contact Solution</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Scene</td>
<td>Contacts</td>
<td>Per Pair (avg)</td>
<td>Per Pair (max)</td>
<td>Time</td>
<td>Per Pair (avg)</td>
<td>Patches</td>
<td>Time</td>
</tr>
<tr>
<td>Peg-in-hole</td>
<td>5.89e5</td>
<td>576</td>
<td>576</td>
<td>2 ms</td>
<td>46</td>
<td>11</td>
<td>1 ms</td>
</tr>
<tr>
<td>Nut-and-bolt</td>
<td>1.73e7</td>
<td>16930</td>
<td>16930</td>
<td>11 ms</td>
<td>195</td>
<td>53</td>
<td>3 ms</td>
</tr>
<tr>
<td>D-sub connector</td>
<td>1.20e7</td>
<td>11746</td>
<td>11746</td>
<td>12.5 ms</td>
<td>175</td>
<td>36</td>
<td>1.5 ms</td>
</tr>
<tr>
<td>Gear assembly</td>
<td>7.26e7</td>
<td>14172</td>
<td>31568</td>
<td>39 ms</td>
<td>83</td>
<td>26</td>
<td>3 ms</td>
</tr>
<tr>
<td>Nuts</td>
<td>1.81e6</td>
<td>2516</td>
<td>8304</td>
<td>10 ms</td>
<td>99</td>
<td>46</td>
<td>2.1 ms</td>
</tr>
<tr>
<td>Bowls</td>
<td>5.23e5</td>
<td>731</td>
<td>1160</td>
<td>2 ms</td>
<td>66</td>
<td>18</td>
<td>4.3 ms</td>
</tr>
<tr>
<td>Toruses</td>
<td>4.00e5</td>
<td>185</td>
<td>864</td>
<td>4.6 ms</td>
<td>44</td>
<td>20</td>
<td>2.8 ms</td>
</tr>
<tr>
<td>Franka + nut-and-bolt</td>
<td>4.64e5</td>
<td>9285</td>
<td>10031</td>
<td>1.7 ms</td>
<td>147</td>
<td>40</td>
<td>2.7 ms</td>
</tr>
</tbody>
</table>
<p>TABLE I: CONTACT STATISTICS. Contacts IS THE TOTAL NUMBER OF CONTACTS IN THE SCENE. Contact Handling INCLUDES PAIR FINDING, CONTACT GENERATION, AND CONTACT REDUCTION. Contact Solution INCLUDES CONTACT CONSTRAINT PREPARATION, ITERATIVE CONSTRAINT SOLUTION, AND NUMERICAL INTEGRATION.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Timestepping</th>
<th></th>
<th>Simulation Stats</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Scene</td>
<td>Substeps</td>
<td>Pos Iterations</td>
<td>Vel Iterations</td>
<td>Time</td>
<td>Real-time</td>
<td></td>
</tr>
<tr>
<td>Peg-in-hole</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>3 ms</td>
<td>5689x</td>
<td></td>
</tr>
<tr>
<td>Nut-and-bolt</td>
<td>1</td>
<td>20</td>
<td>1</td>
<td>14 ms</td>
<td>1219x</td>
<td></td>
</tr>
<tr>
<td>D-sub connector</td>
<td>4</td>
<td>4</td>
<td>1</td>
<td>14 ms</td>
<td>305x</td>
<td></td>
</tr>
<tr>
<td>Gear assembly</td>
<td>4</td>
<td>4</td>
<td>1</td>
<td>42 ms</td>
<td>102x</td>
<td></td>
</tr>
<tr>
<td>Nuts</td>
<td>1</td>
<td>16</td>
<td>1</td>
<td>12 ms</td>
<td>1.39x</td>
<td></td>
</tr>
<tr>
<td>Bowls</td>
<td>2</td>
<td>50</td>
<td>1</td>
<td>6.3 ms</td>
<td>1.32x</td>
<td></td>
</tr>
<tr>
<td>Toruses</td>
<td>1</td>
<td>16</td>
<td>1</td>
<td>7.4 ms</td>
<td>2.25x</td>
<td></td>
</tr>
<tr>
<td>Franka + nut-and-bolt</td>
<td>4</td>
<td>16</td>
<td>1</td>
<td>4.4 ms</td>
<td>121x</td>
<td></td>
</tr>
</tbody>
</table>
<p>TABLE II: PERFORMANCE STATISTICS. THE BASELINE TIMESTEP SIZE (BEFORE SUBSTEPPING) IS $\frac{1}{60}$ s. Pos Iterations AND Vel Iterations DENOTE THE NUMBER OF POSITION AND VELOCITY ITERATIONS IN THE GAUSS SEIDEL SOLVER. Time DENOTES TOTAL SIMULATION TIME PER FRAME, WHICH IS THE SUM OF Contact Handling AND Contact Solution FROM TABLE I. Real-time DENOTES STABLE TIMESTEP SIZE (AFTER SUBSTEPPING) RELATIVE TO SIMULATION TIME, SCALED BY THE NUMBER OF PARALLEL ENVIRONMENTS.</p>
<p><img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Fig. 6. Visualization of FrankaInsertionEnv. Each environment consists of a Franka robot and an insertion assembly from NIST Task Board 1. Left: The default initial state, where the positions of the parts are randomized on the work surface. Right: The default goal state, where all parts are inserted. is to pick up each gear, insert it onto its corresponding gear shaft, and align it with any other gears.</p>
<h3>C. Controllers</h3>
<p>Research efforts in reinforcement learning for robotic manipulation have traditionally used an action space consisting of low-level position, velocity, or torque commands. On the other hand, classical PD- or PID-style robot controllers have been used to solve contact-rich tasks in robotic assembly for several decades [69, 101]. In recent years, there has been substantial interest in using an RL action space consisting of targets to such controllers, with promising results in both sample efficiency and asymptotic performance [68, 77].</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Fig. 7. Visualization of FrankaGearsEnv. Each environment consists of a Franka robot and the gear assembly from NIST Task Board 1. Left: The default initial state, where the positions of the gears are randomized on the work surface. Right: The default goal state, where all gears are aligned.</p>
<p>Akin to [112] in MuJoCo, we provide a series of robot controllers based on those that researchers and engineers commonly use in the real world. The actions of the controllers are executed using an explicit integrator to avoid undesired damping. The controllers are as follows:</p>
<ul>
<li>Joint-space inverse differential kinematics (IK) motion controller, which converts task-space errors into jointspace errors and applies PD gains to generate joint torques. The IK controller can use either the geometric or analytic Jacobian [85] and generate torques with the Jacobian pseudoinverse, Jacobian transpose, damped leastsquares (Levenberg-Marquardt), or adaptive SVD [11].</li>
</ul>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>Fig. 8. Rendering of achieved goal states of our trained subpolicies for FrankaNutBoltEnv. Left: Pick. Middle: Place. Right: Screw.</p>
<ul>
<li>Joint-space inverse dynamics (ID) controller, which uses the joint-space inertia matrix and gravity compensation to generate joint torques, achieving desired springdamper behavior in joint-space [79].</li>
<li>Task-space impedance controller, which applies PD gains to task-space errors to generate joint torques. This controller is immediately available on the real-world Franka robot via the libfranka library [24].</li>
<li>Operational-space (OSC) motion controller, which uses the task-space inertia matrix and gravity compensation to generate joint torques, achieving desired springdamper behavior in task-space (akin to [102]).</li>
<li>Open-loop force controller, which converts a task-space force target into joint torques.</li>
<li>Closed-loop P force controller, which stacks an open-loop force controller with a closed-loop controller that applies P gains to task-space force errors.</li>
<li>Hybrid force-motion controller, which stacks a task-space impedance or OSC motion controller with an open- or closed-loop force controller. Selection matrices can specify which axes use motion and/or force control.</li>
</ul>
<p>Mathematical formulations are provided in App. D4.</p>
<h2>V. REINFORCEMENT LEARNING</h2>
<p>The robotics community has demonstrated that RL can effectively solve simulated or real-world assembly tasks. However, these efforts are often limited to off-policy algorithms, require extensive training time or human demonstrations/corrections, and/or only address simple tasks. With our contact simulation methods, we use on-policy RL to solve the most contact-rich task on NIST Task Board 1: assembling a nut onto a bolt. Like many assembly tasks, such a procedure is long-horizon and challenging to learn end-to-end. We divide the task into 3 phases and learn an subpolicy for each:</p>
<ul>
<li>Pick: The robot grasps the nut with a parallel-jaw gripper from a random location on a work surface.</li>
<li>Place: The robot transports the nut to the top of a bolt fixed to the surface.</li>
<li>Screw: The robot brings the nut into contact with the bolt, engages the mating threads, and tightens the nut until it contacts the base of the bolt head.</li>
</ul>
<p>RL is neither the only means to solve the 3 phases of this task, nor the most efficient: Pick and Place can be solved with classical grasping and motion controllers, and although challenging, Screw may be solved using a nut-driver and a compliance and/or suction mechanism [43]. We investigate this task as a proof-of-concept that our simulation methods can enable efficient policy learning for tasks of such complexity. Moreover, it is a common experience of simulation developers that model-free RL agents reveal and exploit any inaccuracies or instabilities in the simulator to maximize their reward; we view successfully training RL agents in contact-rich tasks as important qualitative evidence of simulator robustness.</p>
<p>We describe each subpolicy below; detailed evaluations will focus on Screw, the most contact-rich of the phases. We then address sequential execution and examine contact forces.</p>
<h3>A. Shared Framework</h3>
<p>The Pick, Place, and Screw subpolicies were all trained in Isaac Gym using our simulation methods and FrankaNutBoltEnv environment. The PPO implementation from [63] was used with a shared set of hyperparameters (Table IX). Typically, a batch of 3-4 policies were trained simultaneously on a single NVIDIA RTX 3090 GPU, with each policy using 128 parallel simulation environments. Each batch required a total of 1-1.5 hours for 1024 policy updates.</p>
<p>We defined our action space as targets for our implemented controllers. Unless otherwise specified, the targets for the joint-space IK controller, joint-space ID controller, task-space impedance controller, and OSC motion controller were all 6-DOF transformations relative to the current state, with the rotation expressed as axis-angle. The targets for the open-loop and closed-loop force controller were 3-dimensional force vectors. The targets for the hybrid force-motion controller were the 9-dimensional union of the previous 2 action spaces.</p>
<p>We now discuss our randomization, observations, rewards, success criterion, and success rate for each subpolicy.</p>
<h3>B. Subpolicy: Pick</h3>
<p>At the start of each Pick episode, the 6-DOF Franka hand pose and 2-DOF nut pose (constrained by the work surface) were randomized over a large spatial range (Table III).</p>
<p>The observation space for Pick was the pose (position and quaternion) of the hand and nut, as well as the linear and angular velocity of the hand. In the real world, the pose and velocity of the hand can be determined to reasonable accuracy (&lt; 1 cm) through a forward kinematic model and proprioception of joint positions and velocities, whereas the pregrasp pose of the nut (a known model, as typical in industrial settings) can be accurately estimated through pose estimation frameworks [44]. The action space for Pick consisted of joint-space IK controller targets with damped least-squares.</p>
<p>A dense reward was formulated as the distance between the fingertips and the nut. Initial experiments defined this distance as ||x||+α||q||, where x and q are the translation and quaternion errors, and α is a scalar hyperparameter. However, this approach was sensitive to α. Inspired by [2], we reformulated</p>
<p>| Pick | | Place | | Screw | |
| Parameter | Range | Parameter | Range | Parameter | Range |
| --- | --- | --- | --- | --- | --- |
| Hand X-axis | [-0.2, 0.2] m | Hand XY-axes | [-0.2, 0.2] m | Hand angle | [-90, 90] deg |
| Hand Y-axis | [-0.4, 0.0] m | Hand Z-axis | [0.5, 0.7] m | Fingertip X-axis | [-3, 3] mm |
| Hand Z-axis | [0.5, 0.7] m | Hand roll, pitch | [-17, 17] deg | Fingertip Y-axis | [-3, 3] mm |
| Hand roll, pitch | [-17, 17] deg | Hand yaw | [-57, 57] deg | Fingertip Z-axis | [0, 3] mm |
| Hand yaw | [-57, 57] deg | Nut-in-gripper XY-axes | [-2, 2] mm | Nut-in-gripper X-axis | [-3.5, 3.5] mm |
| Nut X-axis | [-0.1, 0.1] m | Nut-in-gripper Z-axis | [-5, 5] mm | Nut-in-gripper Z-axis | [-6.5, 1.0] mm |
| Nut Y-axis | [-0.4, 0.2] m | Nut-in-gripper yaw | [-180, 180] mm | Nut-in-gripper yaw | [-15, 15] deg |
| | | Bolt XY-axes | [-10, 10] mm | | |</p>
<p>TABLE III: RANGES FOR INITIAL RANDOMIZATION OF POSE PARAMETERS. PARAMETER VALUES WERE UNIFORMLY SAMPLED FROM THE RANGES.
the distance as $\left|\mathbf{k}<em _mathbf_f="\mathbf{f">{\mathbf{n}}-\mathbf{k}</em>$ are both tensors of $2-4$ keypoints distributed along the nut central axis and endeffector approach axis, respectively. Intuitively, this method computes distance on a single manifold, obviating tuning. The collinearity of each keypoint set also allows equivariance to rotation of the hand (i.e., yaw) about the nut central axis.}}\right|$, where $k_{n}$ and $k_{f</p>
<p>After executing the Pick subpolicy for a prescribed (constant) number of timesteps, a manually-specified grasp-and-lift action was executed. Policy success was defined as whether the nut remained in the grasp after lifting. If successful, a success bonus was added to the episodic return.</p>
<p>With the above approach, the Pick policy was able to achieve a $100 \%$ success rate within the randomization bounds. Qualitatively, the agent learned to execute a fast straight-line path towards the nut, followed by a slow pose refinement. Due to the collinearity of the keypoints, the final pose distribution of the hand was highly multimodal in yaw.</p>
<h2>C. Subpolicy: Place</h2>
<p>At the start of each Place episode, the Franka hand and nut were reset to a known stable grasp pose. The nut-in-gripper position/rotation and the bolt position were randomized. The hand-and-nut were moved to a random pose using the jointspace IK controller (Table III). Training was then initiated.</p>
<p>The observation space for Place was identical to that for Pick, but also included the pose (position and quaternion) of the bolt. When grasped, the nut pose may be challenging to determine in the real world; however, recent research has demonstrated that visuotactile sensing with known object models can enable high-accuracy pose estimates [6].</p>
<p>The action space was identical to that for Pick. A dense reward was again formulated as a keypoint distance, now between the bolt and nut central axes. The keypoints were defined such that, when perfectly aligned, the base of the nut was located 1 mm above the top of the bolt. Success was defined as when the average keypoint distance was $&lt;0.8 \mathrm{~mm}$</p>
<p>With the above approach, the Place policy was able to achieve a $98.4 \%$ success rate within the randomization bounds. A common initial failure case during training was collision between the gripper and the bolt, dislodging the nut. The robot learned trajectories that remained above the top plane of the bolt, with a slow pose refinement phase when close.</p>
<p>Although having negligible effect on steady-state error, an effective strategy for smoothing the Place trajectory was
applying an action gradient penalty at each timestep. The penalty was equal to $\beta\left|\mathbf{a}<em _mathbf_t="\mathbf{t">{\mathbf{t}}-\mathbf{a}</em>$ is the 6 dimensional action vector and $\beta$ is a hyperparameter (0.1).}-1}\right|$, where $\mathbf{a</p>
<h2>D. Subpolicy: Screw</h2>
<p>At the start of each Screw episode, the Franka hand and nut were reset to a stable grasp pose, randomized relative to the top of the bolt (Table III); these stable poses were generated using the FrankaCalibrate script described in App. D3. The nut-in-gripper position was also randomized as before.</p>
<p>Among the subpolicies, Screw was by far the most contactrich, and as follows, challenging to train. The robot was required to bring the nut into contact with the bolt, engage the respective threads, generate precise torques along the 7 arm joints to allow the high-inertia robot links to admit the rigid bolt constraint, and maintain appropriate posture of the gripper with respect to the nut during tightening. As a simplifying assumption, the joint limit of the end-effector was removed, allowing the Franka to avoid regrasping (akin to the Kinova Gen3). Nevertheless, training was replete with a diverse range of pathologies, including high-energy collision with the bolt shank, roll-pitch misalignment of the nut when first engaging the bolt threads, jamming of the nut during tightening, and precession of the gripper around the bolt during tightening, which induced slip between the gripper and nut.</p>
<p>To overcome the preceding issues, a systematic exploration of controllers/gains, observation/action spaces, and baseline rewards was executed. First, policies for 3 task-space controllers were evaluated over a wide range of gains, and the controllergain configuration with the highest success rate was chosen (Table X). Then, 4 observation spaces were evaluated, and the space with the highest success rate was selected (Table IV). The procedure continued with 2 action spaces (Table XI) and 3 baseline rewards (Table XII). Success was defined as when the nut was less than 1 thread away from the base of the bolt.</p>
<p>To encourage stable robot posture, a dense reward was formulated that consisted of the sum of the keypoint distance [between nut and base of bolt] and [between end-effector and nut]. To prioritize both task completion and efficient training, early termination was applied on success and failure, and a maximum of 1024 gradient updates was allowed. Future work will investigate asymptotic performance with more updates.</p>
<p>Notably, collisions between the complex geometries of the nut and bolt remained stable during exploration by the RL</p>
<p>agent. However, the majority of experimental groups failed due to the pathologies described earlier. The highest performing agents consistently used an OSC motion controller with low proportional gains, an observation space consisting of pose and velocity of the gripper and nut, a 2-DOF action space (Z-translation and yaw), and a linear baseline reward. As expected, the relatively low number of epochs biased towards lower-dimensional observations and actions.</p>
<p>Using the above configuration, a final Screw policy was trained over 4096 gradient updates and achieved an 85.6$\%$ success rate over 1024 episodes.</p>
<h2>E. Sequential Policy Execution</h2>
<p>Although not our primary focus, a natural question arose on whether the subpolicies could be chained. Policy chaining can be challenging, as errors in each subpolicy can accumulate into poor overall performance; as a simple example, 3 perfectly-coupled subpolicies with 90$\%$ success rates can produce a combined policy with a 72.9$\%$ success rate.</p>
<p>In this work, we used a simple strategy to connect the learned Pick, Place, and Screw subpolicies end-to-end. Specifically, when training a given subpolicy, the initial states were randomized to span the distribution of the final states of the preceding trained subpolicy. For example, we defined the initial states of the Screw subpolicy (Table III) to span the maximum observed error of the Place subpolicy. For a small number of subpolicies, this strategy may be effective; however, the approach does not scale to long sequences, as Policy $N$ must be trained and Sequence $0 \ldots N$ must be evaluated before training Policy $N+1$. To facilitate smoothness, an exponential moving average was applied on Place actions.</p>
<p>With this strategy, we achieved an end-to-end Pick, Place, and Screw success rate of 74.2$\%$. More sophisticated techniques can be explored for improvements [15, 49].</p>
<h2>F. Contact Forces</h2>
<p>Quantitatively and through numerous visual comparisons, our physics simulation module enabled accurate, efficient, and robust simulation of contact-rich interactions of assets with real-world geometries and material properties. Furthermore, our module was built on PhysX, which has been evaluated under challenging sim-to-real conditions [2, 18, 81].</p>
<p>Nevertheless, it is also important to consider the contact forces generated during such interactions. We executed our Screw subpolicy and recorded joint torque norms, as well as contact force norms at the gripper fingers and bolt (Fig. S17). The joint torques are well within the range of lightweight collaborative robots (e.g., UR3). Furthermore, the contact force norms at the fingertips were compared to analogous real-world forces from the Daily Interactive Manipulation dataset [34], in which human subjects tightened or loosened nuts with a wrench outfitted with a force-torque sensor (Fig. 9).</p>
<p>Although the reward functions for the RL agents never involved contact forces, the robots learned policies that generated forces in the middle of human ranges; the much higher variance of human forces was likely due to more diverse</p>
<p><img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>Fig. 9. Comparison of simulated contact forces during Screw subpolicy execution with analogous real-world contact forces from the Daily Interactive Manipulation (DIM) dataset [34]. In this DIM task, humans tightened nuts using a wrench outfitted with a force-torque sensor. Extreme outliers were rejected for visualization. Maximum mean discrepancy (MMD) was 0.01269. (MMD values were $\sim 0.1-1.0$ for less-related tasks.)
strategies adopted by humans. Combined with our visual comparisons, these results do not guarantee sim-to-real policy transfer, but demonstrate that raw quantities computed by simulation are highly comparable to the real world.</p>
<h2>VI. DISCUSSION</h2>
<p>We have presented Factory, a set of physics simulation methods and robot learning tools for contact-rich interactions in robotics. We provide a physics simulation module for PhysX and Isaac Gym that enables 100s to 1000s of contact-rich interactions to be simulated in real-time on a single GPU, as tested on a diverse array of scenes. As one example, 1000 nuts-and-bolts were simulated in real-time, whereas the established benchmark was a single nut-and-bolt at $\frac{1}{20}$ real-time.</p>
<p>We also provide 60 carefully-designed, ISO-standard or manufacturer-based assets from the NIST Assembly Task Board 1, suitable for high-accuracy simulation; 3 robotic assembly scenes in Isaac Gym where a robot can interact with these assets across a diverse range of assembly operations (fastener tightening, insertion, gear meshing); and 7 classical robot controllers that can achieve pose, force, or hybrid targets. We intend for our assets, environments, and controllers to grow over time with contributions from the community.</p>
<p>Finally, we train proof-of-concept RL policies in Isaac Gym for the most contact-rich interaction on the board, nut-andbolt assembly. We show that we can achieve stable simulator behavior, efficient training (1-1.5 hours to simultaneously train 4 policies on 1 GPU), high success rates, and realistic forces/torques. Although Factory was developed with robotic assembly as a motivating application, there are no limitations on using our methods for entirely different tasks within robotics, such as grasping of complex non-convex shapes in home environments, locomotion on uneven outdoor terrain, and non-prehensile manipulation of aggregates of objects.</p>
<table>
<thead>
<tr>
<th>Observations</th>
<th>Success Rate</th>
<th>Env Steps to Success</th>
<th>Reward</th>
<th>Joint Torque (Nm)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pose</td>
<td>0.7708</td>
<td>2318</td>
<td>-0.1019</td>
<td>1.7319</td>
</tr>
<tr>
<td>Pose, velocity</td>
<td>0.7760</td>
<td>3015</td>
<td>-0.0941</td>
<td>1.7330</td>
</tr>
<tr>
<td>Pose, velocity, force</td>
<td>0.5026</td>
<td>3849</td>
<td>-0.0784</td>
<td>1.2186</td>
</tr>
<tr>
<td>Pose, velocity, force, action</td>
<td>0.3307</td>
<td>3791</td>
<td>-0.0521</td>
<td>1.2257</td>
</tr>
</tbody>
</table>
<p>TABLE IV: Comparison of observation spaces on performance of Screw Task. Success Rate Specifies the fraction of episodes that were successful. Time to Success Specifies the mean number of timesteps required to achieve success. Reward Specifies the mean reward during each episode. Joint Torque Specifies the mean joint torque norm (Nm) during each episode. Each cell is computed from the average of 3 seeds. Pose was quickest; Pose, velocity exhibited highest success rate; and Pose, velocity, force, action achieved lowest mean reward, but did not consistently complete the task.</p>
<h2>VII. LIMITATIONS</h2>
<p>We plan to address several limitations of this work. Within simulation, we plan to make 3 improvements to our SDF collision scheme: 1) the ability to robustly handle collisions of thin-shell meshes (e.g., thin-walled bottles and boxes), 2) improved handling of low-tessellation meshes, as currently, 1 contact is generated per-triangle, allowing penetration on large flat surfaces, 3) using sparse SDF representations to reduce the SDF memory footprint (Table VI). Furthermore, we are adding support for FEM-based simulation of stiff deformable features, such as the flexible tab on an RJ45 connector.</p>
<p>Within our assets, environments, and controllers, we plan to add assets for additional industrial and home subassemblies (e.g., USB-C, power plugs, key-in-lock), scenes for additional assembly tasks (e.g., chain-and-sprocket assembly), and controllers found in industrial settings (e.g., admittance). Within policy training, we plan to extend our policy for FrankaNutBoltEnv to learn regrasp behavior. In addition, we aim to develop a unified proof-of-concept policy for all insertion tasks within FrankaInsertionEnv, as well as a policy for gear meshing within FrankaGearsEnv, further evaluating training efficiency and simulator robustness. However, we encourage the broader RL community to test and develop state-of-the-art RL algorithms around these complex tasks.</p>
<h3>VII-A Future Work</h3>
<p>Upon making the aforementioned improvements, our future work will focus primarily on sim-to-real transfer. As described earlier, there has been compelling evidence sim-to-real is possible for industrial insertion tasks; we aim to demonstrate this for more complex bolt-tightening and gear-meshing tasks, as well as full $3D$ assembly operations in both industrial and home settings. For perception, we may train image-based policies using real-time ray-tracing and/or post-simulation path-tracing [8, 74] combined with domain randomization [94], However, we find distillation approaches to be particularly compelling. Specifically, we can</p>
<p>1) Train RL teacher policies, which take privileged information (e.g., 6-DOF states) as input; and then use imitation learning to learn student policies, which take images as input and replicate the teacher’s actions [13, 46], or
2) Train RL policies with the actor accessing images, but the critic accessing privileged information [4].</p>
<p>Adding noise on both low-dimensional and high-dimensional observations may be valuable. Furthermore, given that camera observations will be occluded during contact, we anticipate that integrating tactile sensing into our real-world system will be exceptionally critical for object-gripper pose estimation and slip detection.</p>
<p>Algorithmically, we are interested in obviating human demonstrations or corrections during policy learning. Nevertheless, our physics simulation module is also suitable for simulation-based demonstration collection for use in imitation learning [16, 66] or DDPGfD-style policy learning.</p>
<h2>VIII. CONCLUSION</h2>
<p>We aim for Factory to establish the state-of-the-art in contact-rich simulation, as well as serve as an existence proof that highly efficient simulation and learning of contact-rich interactions is possible in robotics. Our experience has shown that high-quality assets and accurate, efficient simulation methods drastically reduce the inductive bias and algorithmic burden required to solve contact-rich tasks. We invite the community to establish benchmarks for solving the provided scenes, as well as extend and use Factory for their own contact-rich applications both within and outside of RL. We also hope that this work inspires researchers to execute contact-rich simulations of tasks beyond what we show in this paper to enable further solutions to complex problems.</p>
<h2>AUTHOR CONTRIBUTIONS</h2>
<p>YN led the research project.
MM initially developed SDF collisions for FleX.
MM and YN conducted proof-of-concept demonstrations of SDF collisions for robotic assembly in FleX.
KS, ML, PR, and AM developed SDF collisions and contact reduction for PhysX.
PR, KS, AM, and YN developed evaluation and demonstration scenes for PhysX.
LW, YG, and GS integrated the PhysX developments into Isaac Gym.
YN, IA, and PR developed the assets, environments, and controllers for Isaac Gym.
YN, IA, and AH developed the RL policies within Isaac Gym.
DF, AH, MM, ML, GS, and AM advised the project.
YN, MM, AH, and IA wrote the paper.</p>
<h2>ACKNOWLEDGMENTS</h2>
<p>We thank Joe Falco for assistance with the original NIST assets, John Ratcliff for generating the convex decomposition for the bolt (Fig. S11), Karl Van Wyk and Lucas Manuelli for helpful discussions on controllers, Viktor Makoviychuk for assistance with the rl-games [63] library, and the RSS reviewers for their insightful comments and questions.</p>
<h2>REFERENCES</h2>
<p>[1] Afsoon Afzal, Deborah S. Katz, Claire Le Goues, and Christopher S. Timperley. A study on the challenges of using robotics simulators for testing. arXiv:2004.07368 [cs], 2020.
[2] Arthur Allshire, Mayank Mittal, Varun Lodaya, Viktor Makoviychuk, Denys Makoviichuk, Felix Widmaier, Manuel Wüthrich, Stefan Bauer, Ankur Handa, and Animesh Garg. Transferring dexterous manipulation from GPU simulation to a remote real-world TriFinger. arXiv:2108.09779 [cs], 2021.
[3] Sheldon Andrews and Kenny Erleben. Contact and friction simulation for computer graphics. In ACM SIGGRAPH Courses, 2021.
[4] Marcin Andrychowicz, Bowen Baker, Maciek Chociej, Rafal Józefowicz, Bob McGrew, Jakub Pachocki, Arthur Petron, Matthias Plappert, Glenn Powell, Alex Ray, Jonas Schneider, Szymon Sidor, Josh Tobin, Peter Welinder, Lilian Weng, and Wojciech Zaremba. Learning dexterous in-hand manipulation. Int. J. Rob. Res., 2020.
[5] Aleksandra Anna Apolinarska, Matteo Pacher, Hui Li, Nicholas Cote, Rafael Pastrana, Fabio Gramazio, and Matthias Kohler. Robotic assembly of timber joints using reinforcement learning. Autom. Constr., 2021.
[6] Maria Bauza, Eric Valls, Bryan Lim, Theo Sechopoulos, and Alberto Rodriguez. Tactile object pose estimation from the first touch with geometric contact rendering. In Conference on Robot Learning (CoRL), 2020.
[7] Cristian C. Beltran-Hernandez, Damien Petit, Ixchel G. Ramirez-Alpizar, and Kensuke Harada. Variable compliance control for robotic peg-in-hole assembly: A deep-reinforcement-learning approach. Appl. Sci., 2020.
[8] Blender Foundation. Blender: A 3d modelling and rendering package. http://www.blender.org, 2018.
[9] BNP Media. Assembly Magazine. https://www. assemblymag.com/, 2022. [Online; accessed 1-January2022].
[10] Kenneth Bodin. https://twitter.com/kennethbodin/status/ 1252973291217850368, 2021. [Online; accessed 1-January-2022].
[11] Samuel R. Buss. Introduction to inverse kinematics with Jacobian transpose, pseudoinverse and damped least squares methods. 2009.
[12] Yevgen Chebotar, Ankur Handa, Viktor Makoviychuk, Miles Macklin, Jan Issac, Nathan Ratliff, and Dieter Fox. Closing the sim-to-real loop: Adapting simulation randomization with real world experience. In IEEE</p>
<p>International Conference on Robotics and Automation (ICRA), 2019.
[13] Tao Chen, Jie Xu, and Pulkit Agrawal. A system for general in-hand object re-orientation. In Conference on Robot Learning (CoRL), 2021.
[14] HeeSun Choi, Cindy Crump, Christian Duriez, Asher Elmquist, Gregory Hager, David Han, Frank Hearl, Jessica Hodgins, Abhinandan Jain, Frederick Leve, Chen Li, Franziska Meier, Dan Negrut, Ludovic Righetti, Alberto Rodriguez, Jie Tan, and Jeff Trinkle. On the use of simulation in robotics: Opportunities, challenges, and suggestions for moving forward. Proc. Natl. Acad. Sci. USA, 2021.
[15] Alexander Clegg, Wenhao Yu, Jie Tan, C Karen Liu, and Greg Turk. Learning to dress: Synthesizing human dressing motion via deep reinforcement learning. ACM Transactions on Graphics (TOG), 2018.
[16] Henry M. Clever, Ankur Handa, Hammad Mazhar, Kevin Parker, Omer Shapira, Qian Wan, Yashraj Narang, Iretiayo Akinola, Maya Cakmak, and Dieter Fox. Assistive Tele-op: Leveraging transformers to collect robotic task demonstrations. arXiv:2112.05129 [cs], 2021.
[17] Erwin Coumans. Bullet real-time physics simulation. https://pybullet.org/wordpress/, 2022. [Online; accessed 1-January-2022].
[18] Xingye Da, Zhaoming Xie, David Hoeller, Byron Boots, Animashree Anandkumar, Yuke Zhu, Buck Babich, and Animesh Garg. Learning a contact-adaptive controller for robust, efficient legged locomotion. In Conference on Robot Learning (CoRL), 2020.
[19] Todor Davchev, Kevin Sebastian Luck, Michael Burke, Franziska Meier, Stefan Schaal, and Subramanian Ramamoorthy. Residual learning from demonstration: Adapting DMPs for contact-rich manipulation. arXiv:2008.07682 [cs], 2021.
[20] Kiana Ehsani, Winson Han, Alvaro Herrasti, Eli VanderBilt, Luca Weihs, Eric Kolve, Aniruddha Kembhavi, and Roozbeh Mottaghi. ManipulaTHOR: A framework for visual object manipulation. In IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2021.
[21] Clemens Eppner, Arsalan Mousavian, and Dieter Fox. ACRONYM: A large-scale grasp dataset based on simulation. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[22] Yongxiang Fan, Jieliang Luo, and Masayoshi Tomizuka. A learning framework for high precision industrial assembly. In International Conference on Robotics and Automation (ICRA), 2019.
[23] Zachary Ferguson, Minchen Li, Teseo Schneider, Francisca Gil-Ureta, Timothy Langlois, Chenfanfu Jiang, Denis Zorin, Danny M Kaufman, and Daniele Panozzo. Intersection-free rigid body dynamics. ACM Trans. Graph., 2021.
[24] Franka Emika. libfranka examples. 2017.</p>
<p>[25] Christoph Gissler, Andreas Peer, Stefan Band, Jan Bender, and Matthias Teschner. Interlinked SPH pressure solvers for strong fluid-rigid coupling. ACM Trans. Graph., 2019.
[26] Loeiz Glondu, Sara C. Schvartzman, Maud Marchal, Georges Dumont, and Miguel A. Otaduy. Efficient collision detection for brittle fracture. In Proc. of the ACM SIGGRAPH / Eurographics Symposium on Computer Animation, 2012.
[27] Huy Ha and Shuran Song. FlingBot: The unreasonable effectiveness of dynamic manipulation for cloth unfolding. In Conference on Robot Learning (CoRL), 2021.
[28] Kris Hauser. Robust contact generation for robot simulation with unstructured meshes. In Robotics Research. Springer International Publishing, 2016.
[29] Marius Hebecker, Jens Lambrecht, and Markus Schmitz. Towards real-world force-sensitive robotic assembly through deep reinforcement learning in simulations. In IEEE/ASME International Conference on Advanced Intelligent Mechatronics (AIM), 2021.
[30] Neville Hogan and Stephen Buerger. Impedance and Interaction Control. In Robotics and Automation Handbook. CRC Press, 2004.
[31] Peter C. Horak and Jeff C. Trinkle. On the similarities and differences among contact models in robot simulation. IEEE Robot. Autom. Lett., 2019.
[32] Zhimin Hou, Jiajun Fei, Yuelin Deng, and Jing Xu. Data-efficient hierarchical reinforcement learning for robotic assembly control applications. IEEE Trans. Ind. Electron., 2021.
[33] Isabella Huang, Yashraj Narang, Clemens Eppner, Balakumar Sundaralingam, Miles Macklin, Tucker Hermans, and Dieter Fox. DefGraspSim: Physics-based simulation of grasp outcomes for 3D deformable objects. IEEE Robotics and Automation Letters, 2022.
[34] Yongqiang Huang and Yu Sun. A dataset of daily interactive manipulation. The International Journal of Robotics Research, 2019.
[35] Tadanobu Inoue, Giovanni De Magistris, Asim Munawar, Tsuyoshi Yokoya, and Ryuki Tachibana. Deep reinforcement learning for high precision assembly tasks. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2017.
[36] Zhenzhong Jia, Ankit Bhatia, Reuben M. Aronson, David Bourne, and Matthew T. Mason. A survey of automated threaded fastening. IEEE Trans. Automat. Sci. Eng., 2019.
[37] Shiyu Jin, Diego Romeres, Arvind Ragunathan, Devesh K. Jha, and Masayoshi Tomizuka. Trajectory optimization for manipulation of deformable objects: Assembly of belt drive units. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[38] Shahbaz Abdul Khader, Hang Yin, Pietro Falco, and Danica Kragic. Stability-guaranteed reinforcement learning for contact-rich manipulation. IEEE Robot. Autom. Lett., 2021.
[39] Oussama Khatib. A unified approach for motion and force control of robot manipulators: The operational space formulation. IEEE J. Robot. Automat., 1987.
[40] Jeong Kim, Joo-Cheol Yoon, and Beom-Soo Kang. Finite element analysis and modeling of structure with bolted joints. Applied Mathematical Modelling, 2007.
[41] Myungsin Kim, Jaemin Yoon, Dongwon Son, and Dongjun Lee. Data-driven contact clustering for robot simulation. In IEEE International Conference on Robotics and Automation (ICRA), 2019.
[42] Kenneth Kimble, Karl Van Wyk, Joe Falco, Elena Messina, Yu Sun, Mizuho Shibata, Wataru Uemura, and Yasuyoshi Yokokohji. Benchmarking protocols for evaluating small parts robotic assembly systems. IEEE Robot. Autom. Lett., 2020.
[43] KUKA. Fast \&amp; reliable micro screw fastening. https://www.youtube.com/watch?v=BOY3oZ8SkZU, 2016. [Online; accessed 1-January-2022].
[44] Y. Labbe, J. Carpentier, M. Aubry, and J. Sivic. CosyPose: Consistent multi-view multi-object 6D pose estimation. In Proceedings of the European Conference on Computer Vision (ECCV), 2020.
[45] Claude Lacoursiere. Ghosts and machines: regularized variational methods for interactive simulations of multibodies with dry frictional contacts. PhD thesis, Umeå University, 2007.
[46] Joonho Lee, Jemin Hwangbo, Lorenz Wellhausen, Vladlen Koltun, and Marco Hutter. Learning quadrupedal locomotion over challenging terrain. Science Robotics, 2020.
[47] Michelle A. Lee, Yuke Zhu, Peter Zachares, Matthew Tan, Krishnan Srinivasan, Silvio Savarese, Li Fei-Fei, Animesh Garg, and Jeannette Bohg. Making sense of vision and touch: Learning multimodal representations for contact-rich tasks. IEEE Trans. Robot., 2020.
[48] Youngwoon Lee, Edward S. Hu, and Joseph J. Lim. IKEA furniture assembly environment for long-horizon complex manipulation tasks. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[49] Youngwoon Lee, Joseph J Lim, Anima Anandkumar, and Yuke Zhu. Adversarial skill chaining for longhorizon robot manipulation via terminal state regularization. In Conference on Robot Learning (CoRL), 2021.
[50] Chengshu Li, Fei Xia, Roberto Martín-Martín, Michael Lingelbach, Sanjana Srivastava, Bokui Shen, Kent Vainio, Cem Gokmen, Gokul Dharan, Tanish Jain, Andrey Kurenkov, C. Karen Liu, Hyowon Gweon, Jiajun Wu, Li Fei-Fei, and Silvio Savarese. iGibson 2.0: Object-centric simulation for robot learning of everyday household tasks. arXiv:2108.03272 [cs], 2021.
[51] Minchen Li, Zachary Ferguson, Teseo Schneider, Timothy Langlois, Denis Zorin, Daniele Panozzo, Chenfanfu Jiang, and Danny M. Kaufman. Incremental potential contact: intersection-and inversion-free, largedeformation dynamics. ACM Trans. Graph., 2020.
[52] Wenzhao Lian, Tim Kelch, Dirk Holz, Adam Norton,</p>
<p>and Stefan Schaal. Benchmarking off-the-shelf solutions to robotic assembly tasks. arXiv:2103.05140 [cs], 2021.
[53] C. Karen Liu and Dan Negrut. The role of physicsbased simulators in robotics. Annu. Rev. Control Robot. Auton. Syst., 2021.
[54] Jianlan Luo, Eugen Solowjow, Chengtao Wen, Juan Aparicio Ojea, and Alice M. Agogino. Deep reinforcement learning for robotic assembly of mixed deformable and rigid objects. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2018.
[55] Jianlan Luo, Eugen Solowjow, Chengtao Wen, Juan Aparicio Ojea, Alice M. Agogino, Aviv Tamar, and Pieter Abbeel. Reinforcement learning on variable impedance controller for high-precision robotic assembly. In IEEE International Conference on Robotics and Automation (ICRA), 2019.
[56] Jianlan Luo, Oleg Sushkov, Rugile Pevceviciute, Wenzhao Lian, Chang Su, Mel Vecerik, Ning Ye, Stefan Schaal, and Jon Scholz. Robust multi-modal policies for industrial assembly via reinforcement learning and demonstrations: A large-scale study. arXiv:2103.11512 [cs], 2021.
[57] Jieliang Luo and Hui Li. Dynamic experience replay. In Conference on Robot Learning (CoRL), 2019.
[58] Jieliang Luo and Hui Li. A learning approach to robot-agnostic force-guided high precision assembly. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2021.
[59] Kevin M. Lynch and Frank C. Park. Modern Robotics: Mechanics, Planning, and Control. Cambridge University Press, 2017.
[60] Miles Macklin, Kier Storey, Michelle Lu, Pierre Terdiman, Nuttapong Chentanez, Stefan Jeschke, and Matthias Müller. Small steps in physics simulation. ACM SIGGRAPH/Eurographics Symposium on Computer Animation, 2019.
[61] Miles Macklin, Kenny Erleben, Matthias Müller, Nuttapong Chentanez, Stefan Jeschke, and Zach Corse. Local optimization for robust signed distance field collision. Proc. ACM Comput. Graph. Interact. Tech., 2020.
[62] Jeffrey Mahler, Matthew Matl, Vishal Satish, Michael Danielczuk, Bill DeRose, Stephen McKinley, and Ken Goldberg. Learning ambidextrous robot grasping policies. Sci. Robot., 2019.
[63] Denys Makoviichuk and Viktor Makoviychuk. rlgames, 2021. URL https://github.com/Denys88/rl_ games/.
[64] Viktor Makoviychuk, Lukasz Wawrzyniak, Yunrong Guo, Michelle Lu, Kier Storey, Miles Macklin, David Hoeller, Nikita Rudin, Arthur Allshire, Ankur Handa, and Gavriel State. Isaac Gym: High performance GPUbased physics simulation for robot learning. In Neural Information Processing Systems (NeurIPS) Track on Datasets and Benchmarks, 2021.
[65] Khaled Mamou. Volumetric hierarchical approximate convex decomposition. In Game Engine Gems 3. A.K. Peters / CRC Press, 2016.
[66] Ajay Mandlekar, Yuke Zhu, Animesh Garg, Jonathan Booher, Max Spero, Albert Tung, Julian Gao, John Emmons, Anchit Gupta, Emre Orbay, Silvio Savarese, and Li Fei-Fei. RoboTurk: A crowdsourcing platform for robotic skill learning through imitation. In Conference on Robot Learning (CoRL), 2018.
[67] Louis A. Martin-Vega, Harold K. Brown, Wade H. Shaw, and Thomas J. Sanders. Industrial perspective on research needs and opportunities in manufacturing assembly. J. Manuf. Syst., 1995.
[68] Roberto Martín-Martín, Michelle A. Lee, Rachel Gardner, Silvio Savarese, Jeannette Bohg, and Animesh Garg. Variable impedance control in end-effector space: An action space for reinforcement learning in contactrich tasks. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2019.
[69] Matthew T. Mason. Mechanics of Robotic Manipulation. MIT Press, 2001.
[70] Carolyn Matl, Yashraj Narang, Ruzena Bajcsy, Fabio Ramos, and Dieter Fox. Inferring the material properties of granular media for robotic tasks. In IEEE International Conference on Robotics and Automation (ICRA), 2020.
[71] Carolyn Matl, Yashraj Narang, Dieter Fox, Ruzena Bajcsy, and Fabio Ramos. STReSSD: Sim-to-real from sound for stochastic dynamics. In Conference on Robot Learning (CoRL), 2020.
[72] Ádám Moravánszky and Pierre Terdiman. Fast contact reduction for dynamics simulation. In Andrew Kirmse, editor, Game Programming Gems 4, pages 253-263. Charles River Media, 2004.
[73] Yashraj Narang, Balakumar Sundaralingam, Miles Macklin, Arsalan Mousavian, and Dieter Fox. Sim-to-real for robotic tactile sensing via physics-based simulation and learned latent projections. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[74] NVIDIA. NVIDIA Omniverse Platform. https:// developer.nvidia.com/nvidia-omniverse-platform, 2022. [Online; accessed 1-January-2022].
[75] NVIDIA. NVIDIA PhysX SDK. https://github.com/ NVIDIAGameWorks/PhysX, 2022. [Online; accessed 1-January-2022].
[76] M.A. Otaduy and M.C. Lin. A modular haptic rendering algorithm for stable and transparent 6-DOF manipulation. IEEE Trans. Robot., 2006.
[77] Xue Bin Peng and Michiel van de Panne. Learning locomotion skills using DeepRL: does the choice of action space matter? In Proceedings of the ACM SIGGRAPH / Eurographics Symposium on Computer Animation, 2017.
[78] Xue Bin Peng, Glen Berseth, Kangkang Yin, and Michiel Van De Panne. DeepLoco: Dynamic locomo-</p>
<p>tion skills using hierarchical deep reinforcement learning. ACM Trans. Graph., 2017.
[79] Robotic Systems Lab, ETH Zurich. Robot dynamics lecture notes. 2018.
[80] Alessio Rocchi, Barrett Ames, Zhi Li, and Kris Hauser. Stable simulation of underactuated compliant hands. In IEEE International Conference on Robotics and Automation (ICRA), 2016.
[81] Nikita Rudin, David Hoeller, Philipp Reist, and Marco Hutter. Learning to walk in minutes using massively parallel deep reinforcement learning. In Conference on Robot Learning (CoRL), 2021.
[82] Gerrit Schoettler, Ashvin Nair, Juan Aparicio Ojea, Sergey Levine, and Eugen Solowjow. Metareinforcement learning for robotic industrial insertion tasks. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2020.
[83] Lin Shao, Toki Migimatsu, and Jeannette Bohg. Learning to scaffold the development of robotic manipulation skills. In IEEE International Conference on Robotics and Automation (ICRA), 2020.
[84] Zilin Si and Wenzhen Yuan. Taxim: An examplebased simulation model for GelSight tactile sensors. arXiv:2109.04027 [cs], 2021.
[85] Bruno Siciliano, Lorenzo Sciavicco, Luigi Villani, and Giuseppe Oriolo. Robotics. Springer, 2009.
[86] SideFX. Houdini. https://www.sidefx.com/products/ houdini/, 2022. [Online; accessed 1-January-2022].
[87] Dongwon Son, Hyunsoo Yang, and Dongjun Lee. Sim-to-real transfer of bolting tasks with tight tolerance. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2020.
[88] Oren Spector and Miriam Zacksenhouse. Deep reinforcement learning for contact-rich skills using compliant movement primitives. arXiv:2008.13223 [cs], 2020.
[89] Liliana Stan, Adrian Florin Nicolescu, and Cristina Pupăză. Reinforcement learning for assembly robots: A review. Proc. Manuf. Syst., 2020.
[90] Francisco Suárez-Ruiz, Xian Zhou, and Quang-Cuong Pham. Can robots assemble an IKEA chair? Sci. Robot., 2018.
[91] Andrew Szot, Alex Clegg, Eric Undersander, Erik Wijmans, Yili Zhao, John Turner, Noah Maestre, Mustafa Mukadam, Devendra Chaplot, Oleksandr Maksymets, Aaron Gokaslan, Vladimir Vondrus, Sameer Dharur, Franziska Meier, Wojciech Galuba, Angel Chang, Zsolt Kira, Vladlen Koltun, Jitendra Malik, Manolis Savva, and Dhruv Batra. Habitat 2.0: Training home assistants to rearrange their habitat. In Conference on Neural Information Processing Systems (NeurIPS), 2021.
[92] Alessandro Tasora, Radu Serban, Hammad Mazhar, Arman Pazouki, Daniel Melanz, Jonathan Fleischmann, Michael Taylor, Hiroyuki Sugiyama, and Dan Negrut. Chrono: An open source multi-physics dynamics engine. In High Performance Computing in Science and Engineering. Springer International Publishing, 2016.
[93] Garrett Thomas, Melissa Chien, Aviv Tamar, Juan Aparicio Ojea, and Pieter Abbeel. Learning robotic assembly from CAD. In IEEE International Conference on Robotics and Automation (ICRA), 2018.
[94] Josh Tobin, Rachel Fong, Alex Ray, Jonas Schneider, Wojciech Zaremba, and Pieter Abbeel. Domain randomization for transferring deep neural networks from simulation to the real world. In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2017.
[95] Emanuel Todorov, Tom Erez, and Yuval Tassa. MuJoCo: A physics engine for model-based control. In IEEE/RSJ International Conference on Intelligent Robots and Systems, 2012.
[96] Mel Vecerik, Todd Hester, Jonathan Scholz, Fumin Wang, Olivier Pietquin, Bilal Piot, Nicolas Heess, Thomas Rothörl, Thomas Lampe, and Martin Riedmiller. Leveraging demonstrations for deep reinforcement learning on robotics problems with sparse rewards. arXiv:1707.08817 [cs], 2018.
[97] Mel Vecerik, Oleg Sushkov, David Barker, Thomas Rothorl, Todd Hester, and Jon Scholz. A practical approach to insertion with variable socket position using deep reinforcement learning. In IEEE International Conference on Robotics and Automation (ICRA), 2019.
[98] Felix von Drigalski, Christian Schlette, Martin Rudorfer, Nikolaus Correll, Joshua C. Triyonoputro, Weiwei Wan, Tokuo Tsuji, and Tetsuyou Watanabe. Robots assembling machines: learning from the World Robot Summit 2018 Assembly Challenge. Adv. Robot., 2019.
[99] Nghia Vuong, Hung Pham, and Quang-Cuong Pham. Learning sequences of manipulation primitives for robotic assembly. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[100] Shaoxiong Wang, Mike Lambeta, Po-Wei Chou, and Roberto Calandra. TACTO: A fast, flexible and opensource simulator for high-resolution vision-based tactile sensors. arXiv:2012.08456 [cs, stat], 2020.
[101] Daniel E. Whitney. Mechanical Assemblies: Their Design, Manufacture, and Role in Product Development. Oxford University Press, 2004.
[102] Josiah Wong, Viktor Makoviychuk, Anima Anandkumar, and Yuke Zhu. OSCAR: Data-driven operational space control for adaptive and robust robot manipulation. arXiv:2110.00704 [cs], 2021.
[103] Bohan Wu, Iretiayo Akinola, Jacob Varley, and Peter Allen. MAT: Multi-fingered adaptive tactile grasping via deep reinforcement learning. In Conference on Robot Learning (CoRL), 2019.
[104] Zheng Wu, Wenzhao Lian, Vaibhav Unhelkar, Masayoshi Tomizuka, and Stefan Schaal. Learning dense rewards for contact-rich manipulation tasks. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[105] Fanbo Xiang, Yuzhe Qin, Kaichun Mo, Yikuan Xia, Hao Zhu, Fangchen Liu, Minghua Liu, Hanxiao Jiang,</p>
<p>Yifu Yuan, He Wang, Li Yi, Angel X. Chang, Leonidas J. Guibas, and Hao Su. SAPIEN: A simulated part-based interactive environment. In IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2020.
[106] Hongyi Xu, Yili Zhao, and Jernej Barbič. Implicit multibody penalty-based distributed contact. IEEE Trans. Visual. Comput. Graphics, 2014.
[107] Mingxin Yu, Lin Shao, Zhehuan Chen, Tianhao Wu, Qingnan Fan, Kaichun Mo, and Hao Dong. RoboAssembly: Learning generalizable furniture assembly policy in a novel multi-robot contact-rich simulation environment. arXiv:2112.10143 [cs], 2021.
[108] Peter A. Zachares, Michelle A. Lee, Wenzhao Lian, and Jeannette Bohg. Interpreting contact interactions to overcome failure in robot assembly tasks. In IEEE International Conference on Robotics and Automation (ICRA), 2021.
[109] Mabel M. Zhang. Necessity for more realistic contact simulation. In Robotics: Science and Systems (RSS) Workshop on Visuotactile Sensors for Robust Manipulation, 2020.
[110] Xiang Zhang, Shiyu Jin, Changhao Wang, Xinghao Zhu, and Masayoshi Tomizuka. Learning insertion primitives with discrete-continuous hybrid action space for robotic assembly tasks. arXiv:2110.12618 [cs], 2021.
[111] Jialiang Zhao, Daniel Troniak, and Oliver Kroemer. Towards robotic assembly by predicting robust, precise and task-oriented grasps. arXiv:2011.02462 [cs], 2020.
[112] Yuke Zhu, Josiah Wong, Ajay Mandlekar, and Roberto Martín-Martín. robosuite: A modular simulation framework and benchmark for robot learning. arXiv:2009.12293 [cs], 2020.</p>
<h2>APPENDIX</h2>
<h2>A. Introduction</h2>
<p>No supplementary information.</p>
<h2>B. Related Works</h2>
<p>No supplementary information.</p>
<h2>C. Contact-Rich Simulation Methods</h2>
<p>1) Initial Nut-and-Bolt Experiments: We performed initial experiments with various geometric representations of nuts and bolts before proceeding with SDFs. Fig. S10 shows 4 different geometric representations of an M4 bolt mesh.</p>
<p>The convex representation is clearly insufficient to simulate contact-rich interactions. The convex decomposition, generated with voxel-based V-HACD using Omniverse [74], consists of 951 convex hulls and appears to faithfully represent the exact bolt geometry. However, Fig. S11 shows a closer view; artifacts are prevalent. These artifacts cause inaccuracy and instability when simulating contact with a mating M4 nut.</p>
<p>The trimesh representation, consisting of $47 k$ triangles, is highly faithful to the exact geometry. Fig. S12 shows the M4 bolt and nut meshes. Initial experiments were conducted
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>Fig. S10. Geometric representations, demonstrated on an M4 bolt. Left to right: Convex hull. Convex decomposition generated via V-HACD [65] (951 shapes). Triangle mesh generated in Onshape ( $47 k$ triangles). SDF ( $144 \times$ $256 \times 144$ voxels), visualized as a mesh of the isosurface.
<img alt="img-10.jpeg" src="img-10.jpeg" /></p>
<p>Fig. S11. Automatic convex decomposition from Fig. S12 for an M4 bolt ( 951 shapes). Spatial artifacts are apparent.
with trimesh-trimesh collisions using boundary-layer expanded meshes [28]. However, stable behavior was only possible with extremely small timesteps ( $\Delta t=1 e-3 \mathrm{~s}$ with 10 substeps), and the resulting simulations executed at $\frac{1}{80}$ of real-time.</p>
<p>Only SDF representations enabled accurate, efficient, and robust simulation. Fig S12 shows a point-cloud visualization of the SDF for the M4 bolt mesh. However, generating SDFs is an expensive process proportional to the number of samples, and storage requires significant memory. The M4 bolt model consists of 5.3 million samples, each a floating-point distance.
<img alt="img-11.jpeg" src="img-11.jpeg" /></p>
<p>Fig. S12. Left: High-quality triangular mesh representation of an M4 nut and bolt, consisting of $27 k$ triangles (nut) and $47 k$ triangles (bolt). Right: SDF representation of the bolt, stored in a voxel grid of dimensions $144 \times 256 \times 144$ and visualized as a point cloud. For easier visualization, colors are interpolated according to $\phi(\boldsymbol{x})^{\frac{1}{4}}$. Streaks are artifacts of the viewing angle.</p>
<p><img alt="img-12.jpeg" src="img-12.jpeg" /></p>
<p>Fig. S13. Contacts generated between a nut and bolt before and after applying our contact reduction scheme. Left: 16k contacts generated on the bolt before reduction. Right: 300 contacts remaining after reduction.</p>
<p><img alt="img-13.jpeg" src="img-13.jpeg" /></p>
<p>Fig. S14. Renderings of D-sub connector and gear assembly assets used in simulation evaluations and provided in this work.</p>
<h2>2) Additional Scene Descriptions: Franka robot + M16</h2>
<p><strong>nut-and-bolt assemblies.</strong> A vibratory feeder is an ubiquitous mechanism for conveying and isolating mechanical components. The feeder consists of a tray or bowl that vibrates an aggregate of parts at high-frequency and small-amplitude. Under gravity, the parts gradually move towards a singulation mechanism, which isolates them for inspection or downstream handling. We demonstrate a tray-style inclined feeder that vibrates an aggregate of nuts at 60 Hz. The nuts towards a channel that only allows one nut to pass at a time. A Franka robot with a hand-scripted controller then grasps a nut from the channel opening and tightens it onto a bolt (<strong>Fig. 4</strong>).</p>
<p><strong>Franka robot + M16 nuts + flange assembly.</strong> This scene is similar to the above, except that the Franka grasps and tightens multiple nuts in sequence to clamp together 2 halves of a flange (<strong>Fig. S15</strong>). This scene is only qualitatively evaluated.</p>
<h2>3) Rendering:</h2>
<p>For visualization purposes, we render several figures using Omniverse. The details are as follows:</p>
<ul>
<li>The output of the simulation in <strong>Fig. 1</strong> was path-traced.</li>
<li>The simulation in <strong>Fig. 3</strong> was rendered in real-time.</li>
<li>The scene in <strong>Fig. 5</strong> was path-traced.</li>
<li>The scenes in <strong>Fig. 8</strong> were path-traced.</li>
<li>The scenes in <strong>Fig. S14</strong> were path-traced.</li>
<li>The scene in <strong>Fig. S15</strong> was path-traced.</li>
</ul>
<p>For simulation-related figures not listed above, the images were captured directly from PhysX, Isaac Gym, or Onshape.</p>
<p><img alt="img-14.jpeg" src="img-14.jpeg" /></p>
<p>Fig. S15. Renderings of 2 scenes. Left: <strong>M16 nuts</strong> scene. Right: <strong>Franka robot + M16 nuts + flange assembly scene.</strong></p>
<h2>D. Robot Learning Tools</h2>
<h3>1) Assets:</h3>
<p><strong>Table VII</strong> and <strong>Table VIII</strong> provide details on all assets provided in this work. We intend for this to be a growing database, with contributions from the community.</p>
<h3>2) Using Contact Simulation Methods:</h3>
<p>To use the contact simulation methods from this work in Isaac Gym, the user simply needs to add an <em><sdf></em> tag to the <em><collision></em> block of the object that should use SDF collisions (<strong>Listing 1</strong>). PhysX will then interpret the <em><sdf></em> tag as follows:</p>
<p>Consider 2 colliding objects, Object A and Object B.</p>
<ul>
<li>If A and B both have an <em><sdf></em> tag, SDF-mesh collision will be applied. The object with the larger number of features (<em>i.e.</em>, triangles) will be represented as an SDF, and the trimesh of the other object will be queried against the SDF to check for collisions and generate contacts.</li>
<li>If A has an <em><sdf></em> tag and B does not, convex-mesh collision will be applied. Object A will be represented as a trimesh, and object B will be represented as a convex.</li>
<li>If neither A nor B has an <em><sdf></em> tag, a default convex-convex collision will be applied.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;robot</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;nut_m16&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;link</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;nut_m16&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;visual&gt;</span>
<span class="w">            </span><span class="nt">&lt;geometry&gt;</span>
<span class="w">                </span><span class="nt">&lt;mesh</span><span class="w"> </span><span class="na">filename=</span><span class="s">&quot;nut_m16_tight.obj&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/geometry&gt;</span>
<span class="w">        </span><span class="nt">&lt;/visual&gt;</span>
<span class="w">        </span><span class="nt">&lt;collision&gt;</span>
<span class="w">            </span><span class="nt">&lt;geometry&gt;</span>
<span class="w">                </span><span class="nt">&lt;mesh</span><span class="w"> </span><span class="na">filename=</span><span class="s">&quot;nut_m16_tight.obj&quot;</span><span class="nt">/&gt;</span>
<span class="w">            </span><span class="nt">&lt;/geometry&gt;</span>
<span class="w">            </span><span class="nt">&lt;sdf</span><span class="w"> </span><span class="na">resolution=</span><span class="s">&quot;256&quot;</span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/collision&gt;</span>
<span class="w">    </span><span class="nt">&lt;/link&gt;</span>
<span class="nt">&lt;/robot&gt;</span>
</code></pre></div>

<p>Listing 1. Example URDF file for a nut asset with SDF collision enabled. The <em>resolution</em> field specifies the desired number of voxels along the longest dimension of the object. We have typically used 256 or 512.</p>
<h3>3) Helpful Additions:</h3>
<p>For all assembly assets provided (<em>e.g.</em>, nut and bolt), the zero-positions of the parts correspond to the configuration in which they are fully assembled; thus, specifying a goal state for RL is extremely simple for the user.</p>
<p>Furthermore, we provide a helper script called <strong>FrankaCalibrate</strong>. When training RL policies, it is common to randomize the joint state of the robot at the beginning of each episode.</p>
<p><img alt="img-15.jpeg" src="img-15.jpeg" /></p>
<p>Fig. S16. Image of a real NIST Task Board 1.</p>
<p>in order to facilitate robustness. Simultaneously, if a robot is learning a complex multi-step assembly procedure, it can be helpful to learn short-horizon sub-policies that begin when an object is already grasped. Nevertheless, in practice, it is challenging to randomize the state of a robot <em>and</em> a grasped object <em>while maintaining grasp stability</em>. Using FrankaCalibrate, the Franka can grasp an object, go to randomized poses, and generate a large set of stable robot-and-object poses that can be imported when subsequently training policies.</p>
<p><em>4) Controllers:</em> The controllers implemented in this work are based on the mathematical formulations articulated in [11, 30, 59, 79, 85]. Our specific control laws are as follows:</p>
<ul>
<li><strong>Joint-space inverse differential kinematics (IK) motion controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{k}<em _mathbf_t="\mathbf{t">{\mathbf{p}} (\mathbf{q}</em>}} - \mathbf{q<em _mathbf_d="\mathbf{d">{\mathbf{c}}) - \mathbf{k}</em>)
$$}} (\dot{\mathbf{q}}_{\mathbf{c}</p>
<p>where $\boldsymbol{\tau}$ is the joint torque vector ( $\mathbb{R}^7$ ), $\mathbf{k}<em _mathbf_d="\mathbf{d">{\mathbf{p}}$ and $\mathbf{k}</em>$ denote }}$ are diagonal matrices consisting of joint-space proportional gains ( $\mathbb{R}^{7 \times 7}$ ) and joint-space derivative gains ( $\mathbb{R}^{7 \times 7}$ ), $\mathbf{q}$ and $\dot{\mathbf{q}}$ are the joint position vector ( $\mathbb{R}^7$) and joint velocity vector ( $\mathbb{R}^7$ ), and subscripts $\mathbf{t}$ and $\mathbf{c<em>target</em> and <em>current</em>. The quantity $\mathbf{q}<em _mathbf_c="\mathbf{c">{\mathbf{t}} - \mathbf{q}</em>$ is computed by inputting a task-space error into an IK algorithm. For IK, we have implemented Jacobian pseudoinverse, Jacobian transpose, damped least-squares (Levenberg-Marquardt), and adaptive singular value decomposition (SVD) [11].}</p>
<ul>
<li><strong>Joint-space inverse dynamics controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{M} (\mathbf{k}<em _mathbf_t="\mathbf{t">{\mathbf{p}} (\mathbf{q}</em>}} - \mathbf{q<em _mathbf_d="\mathbf{d">{\mathbf{c}}) - \mathbf{k}</em>
$$}} (\dot{\mathbf{q}}_{\mathbf{c}})) + \mathbf{b} + \mathbf{g</p>
<p>where $M$ is the joint-space inertia matrix ( $\mathbb{R}^{7 \times 7}$ ), $\mathbf{b}$ is the joint-space Coriolis and centrifugal torque vector ( $\mathbb{R}^7$ ), and $\mathbf{g}$ is the joint-space gravitational torque vector (<em>i.e.</em>, a gravity compensation term) ( $\mathbb{R}^7$ ). Vector $\mathbf{b}$ is currently ignored due to small joint velocities during assembly.</p>
<ul>
<li><strong>Task-space impedance controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{J}^{\mathbf{T}} (\mathbf{k}<em _mathbf_t="\mathbf{t">{\mathbf{p}} (\mathbf{x}</em>}} \ominus \mathbf{x<em _mathbf_d="\mathbf{d">{\mathbf{c}}) - \mathbf{k}</em>))
$$}} (\dot{\mathbf{x}}_{\mathbf{c}</p>
<p>where $\mathbf{J}$ is the geometric or analytic Jacobian ( $\mathbb{R}^{6 \times 7}$ ), $\mathbf{k}<em _mathbf_d="\mathbf{d">{\mathbf{p}}$ and $\mathbf{k}</em>$ are the derivatives of axis-angle, and $\ominus$ simply computes the difference between target and current.}}$ are now diagonal matrices consisting of task-space proportional gains ( $\mathbb{R}^{6 \times 6}$ ), and $\mathbf{x}$ and $\dot{\mathbf{x}}$ are the task-space position vector ( $\mathbb{R}^6$) and task-space velocity vector ( $\mathbb{R}^6$ ). The analytic Jacobian can be computed from the geometric Jacobian as described in [79]. When using the geometric Jacobian, the orientation components of $\dot{\mathbf{x}}$ are angular velocity, and $\ominus$ computes the rotational transformation from current to target. When using the analytic Jacobian, the orientation components of $\dot{\mathbf{x}</p>
<ul>
<li><strong>Operational-space motion controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{J}^{\mathbf{T}} (\mathbf{M} (\mathbf{k}<em _mathbf_t="\mathbf{t">{\mathbf{p}} (\mathbf{x}</em>}} - \mathbf{x<em _mathbf_d="\mathbf{d">{\mathbf{c}}) - \mathbf{k}</em>)
$$}} (\dot{\mathbf{x}}_{\mathbf{c}})) + \mathbf{b} + \mathbf{g</p>
<p>where $M$ is now the task-space inertia matrix ( $\mathbb{R}^{6 \times 6}$ ), $\mathbf{b}$ is now the task-space Coriolis and centrifugal torque vector ( $\mathbb{R}^6$ ), and $\mathbf{g}$ is now the task-space gravitational torque vector ( $\mathbb{R}^6$ ). The task-space inertia matrix can be computed from the joint-space inertia matrix [39]. As before, vector $\mathbf{b}$ is currently ignored due to small velocities during assembly operations.</p>
<ul>
<li><strong>Open-loop force controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{J}^{\mathbf{T}} \mathbf{F}_{\mathbf{t}}
$$</p>
<p>where $\mathbf{F}_{\mathbf{t}}$ is the target wrench ( $\mathbb{R}^6$ ).</p>
<ul>
<li><strong>Closed-loop P force controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{J}^{\mathbf{T}} (\mathbf{F}<em _mathbf_f="\mathbf{f">{\mathbf{t}} + \mathbf{k}</em>}} (\mathbf{F<em _mathbf_c="\mathbf{c">{\mathbf{t}} - \mathbf{F}</em>))
$$}</p>
<p>where $\mathbf{k}_{\mathbf{f}}$ is a diagonal matrix consisting of task-space proportional gains ( $\mathbb{R}^{6 \times 6}$ ).</p>
<ul>
<li><strong>Hybrid force-motion controller</strong></li>
</ul>
<p>$$
\boldsymbol{\tau} = \mathbf{J}^{\mathbf{T}} (\mathbf{S}<em _mathbf_p="\mathbf{p">{\mathbf{m}} [\mathbf{M} (\mathbf{k}</em>}} (\mathbf{x<em _mathbf_c="\mathbf{c">{\mathbf{t}} - \mathbf{x}</em>}}) - \mathbf{k<em _mathbf_c="\mathbf{c">{\mathbf{d}} (\dot{\mathbf{x}}</em>]
$$}})) + \mathbf{b} + \mathbf{g</p>
<p>$$
+ \mathbf{S}<em _mathbf_t="\mathbf{t">{\mathbf{f}} [\mathbf{F}</em>}} + \mathbf{k<em _mathbf_t="\mathbf{t">{\mathbf{f}} (\mathbf{F}</em>)])
$$}} - \mathbf{F}_{\mathbf{c}</p>
<p>where $\mathbf{S}<em _mathbf_f="\mathbf{f">{\mathbf{m}}$ and $\mathbf{S}</em>$ ). Although common practice, the axes need not be complementary.}}$ are Boolean diagonal selection matrices that specify which axes use motion control and which use force control ( $\mathbb{R}^{6 \times 6</p>
<h4><em>E. Reinforcement Learning</em></h4>
<p>Table IX shows PPO parameters for Pick, Place, and Screw. Table X shows a comparison of controller selection and gains on the Screw task. Table XI shows a comparison of action spaces on the Screw task. Table XII shows a comparison of baseline rewards on the Screw task.</p>
<p><img alt="img-16.jpeg" src="img-16.jpeg" /></p>
<p>Fig. S17. Histograms of joint torques, gripper forces, and bolt forces. Data was collected during inference on the final trained Screw subpolicy over 128 environments and 1024 episodes. At each timestep, norms were computed for each environment, and the maximum value was recorded. Histograms show distributions of these values over all timesteps. Extreme outliers were rejected for visualization.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: center;">Stable Timesteps</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Memory Bandwidth</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Parallelization</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Solver type</td>
<td style="text-align: center;">Substeps</td>
<td style="text-align: center;">Iterations</td>
<td style="text-align: center;">Per frame</td>
<td style="text-align: center;">Per second</td>
<td style="text-align: center;">Max nuts/bolts</td>
</tr>
<tr>
<td style="text-align: left;">Jacobi (before)</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">1.28 GB</td>
<td style="text-align: center;">76.8 GB</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td style="text-align: left;">Jacobi (after)</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">24 MB</td>
<td style="text-align: center;">1.44 GB</td>
<td style="text-align: center;">1100</td>
</tr>
<tr>
<td style="text-align: left;">Gauss Seidel (before)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">40 MB</td>
<td style="text-align: center;">2.4 GB</td>
<td style="text-align: center;">666</td>
</tr>
<tr>
<td style="text-align: left;">Gauss Seidel (after)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">768 KB</td>
<td style="text-align: center;">46 MB</td>
<td style="text-align: center;">35000</td>
</tr>
</tbody>
</table>
<p>TABLE V
Comparison of MEMORY BANDWIDTH REQUIREMENTS FOR A JACOBI AND GAUSS-SeIDEL SOLVER ON THE NUT-AND-BOLT SCENE, BEFORE AND AFTER CONTACT REDUCTION. Max nuts/bolt DENOTES THE THEORETICAL MAXIMUM NUMBER OF NUTS AND BOLTS THAT COULD BE SIMULATED ON A STATE-OF-THE-ART GPU; IN PRACTICE, LIMITATIONS ASIDE FROM CONTACT CONSTRAINT SOLUTION (e.g., SCALING OF SDF-BASED CONTACT GENERATION) TYPICALLY REDUCE THIS UPPER BOUND BY ONE ORDER OF MAGNITUDE. NOTE THAT ALTHOUGH Gauss-Seidel (before) HAS LOWER MEMORY BANDWIDTH REQUIREMENTS THAN Jacobi (before), IT IS NOT PREFERRED DUE TO ITS LOW EXECUTION SPEED.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">Representation Info</th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">SDF Stats</th>
<th style="text-align: left;"></th>
<th style="text-align: left;">Mesh Stats</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Scene</td>
<td style="text-align: left;">Envs</td>
<td style="text-align: left;">Bodies</td>
<td style="text-align: left;">SDF</td>
<td style="text-align: left;">Mesh</td>
<td style="text-align: left;">Resolution</td>
<td style="text-align: left;">Memory</td>
<td style="text-align: left;">Vertices</td>
<td style="text-align: left;">Triangles</td>
</tr>
<tr>
<td style="text-align: left;">Peg-in-hole</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Peg</td>
<td style="text-align: left;">Hole</td>
<td style="text-align: left;">$43 \times 43 \times 104$</td>
<td style="text-align: left;">3.55 MB</td>
<td style="text-align: left;">296</td>
<td style="text-align: left;">592</td>
</tr>
<tr>
<td style="text-align: left;">Nut-and-bolt</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Bolt</td>
<td style="text-align: left;">Nut</td>
<td style="text-align: left;">$144 \times 404 \times 144$</td>
<td style="text-align: left;">31.95 MB</td>
<td style="text-align: left;">8899</td>
<td style="text-align: left;">17798</td>
</tr>
<tr>
<td style="text-align: left;">D-sub connector</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Socket</td>
<td style="text-align: left;">Plug</td>
<td style="text-align: left;">$534 \times 129 \times 254$</td>
<td style="text-align: left;">66.75 MB</td>
<td style="text-align: left;">11935</td>
<td style="text-align: left;">23866</td>
</tr>
<tr>
<td style="text-align: left;">Gear assembly</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">Gear</td>
<td style="text-align: left;">Gear</td>
<td style="text-align: left;">$314 \times 314 \times 104$</td>
<td style="text-align: left;">39.1 MB</td>
<td style="text-align: left;">17557</td>
<td style="text-align: left;">35313</td>
</tr>
<tr>
<td style="text-align: left;">Nuts</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">Nut</td>
<td style="text-align: left;">Nut</td>
<td style="text-align: left;">$284 \times 132 \times 327$</td>
<td style="text-align: left;">46.76 MB</td>
<td style="text-align: left;">8899</td>
<td style="text-align: left;">17798</td>
</tr>
<tr>
<td style="text-align: left;">Bowls</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">Bowl</td>
<td style="text-align: left;">Bowl</td>
<td style="text-align: left;">$257 \times 75 \times 257$</td>
<td style="text-align: left;">14.36 MB</td>
<td style="text-align: left;">582</td>
<td style="text-align: left;">1160</td>
</tr>
<tr>
<td style="text-align: left;">Toruses</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">Torus</td>
<td style="text-align: left;">Torus</td>
<td style="text-align: left;">$304 \times 104 \times 304$</td>
<td style="text-align: left;">36.60 MB</td>
<td style="text-align: left;">1024</td>
<td style="text-align: left;">6144</td>
</tr>
<tr>
<td style="text-align: left;">Franka + nut-and-bolt</td>
<td style="text-align: left;">128</td>
<td style="text-align: left;">44</td>
<td style="text-align: left;">Bolt</td>
<td style="text-align: left;">Nut</td>
<td style="text-align: left;">$144 \times 404 \times 144$</td>
<td style="text-align: left;">31.95 MB</td>
<td style="text-align: left;">8899</td>
<td style="text-align: left;">17798</td>
</tr>
</tbody>
</table>
<p>TABLE VI
GEOMETRIC REPRESENTATIONS USED IN THE SIMULATOR TEST SCENES. Bodies DENOTES THE NUMBER OF BODIES IN EACH PARALLEL ENVIRONMENT. FOR Nuts, Bowls, AND Toruses, ALL BODIES ARE SIMULATED IN THE SAME ENVIRONMENT. SDF AND Mesh DENOTE WHICH BODY IN THE CONTACT PAIR IS REPRESENTED AS AN SDF, AND WHICH IS REPRESENTED AS A MESH THAT IS QUERIED AGAINST THE SDF. FOR Gear assembly, STATISTICS ARE PROVIDED FOR SDF-MESH COLLISIONS BETWEEN THE LARGE AND MEDIUM GEARS. FOR Franka + nut-and-bolt, WHICH CONTAINS MORE THAN 2 TYPES OF BODIES, THE FRANKA-NUT COLLISIONS ARE HANDLED WITH THE FRANKA GRIPPER FINGERS AS CONVEXES AND THE NUT AS A MESH, AND THE NUT-NUT COLLISIONS ARE HANDLED WITH THE NUTS AS CONVEXES.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Part</th>
<th style="text-align: center;">Standards</th>
<th style="text-align: center;">Configurations</th>
<th style="text-align: center;">Clearance (mm)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">4 mm round peg 4 mm round hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.104-0.112$</td>
</tr>
<tr>
<td style="text-align: center;">8 mm round peg 8 mm round hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.105-0.114$</td>
</tr>
<tr>
<td style="text-align: center;">12 mm round peg 12 mm round hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.206-0.217$</td>
</tr>
<tr>
<td style="text-align: center;">16 mm round peg 16 mm round hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.506-0.517$</td>
</tr>
<tr>
<td style="text-align: center;">4 mm rect. peg 4 mm rect. hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.11-0.14$</td>
</tr>
<tr>
<td style="text-align: center;">8 mm rect. peg 8 mm rect. hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.134-0.224$</td>
</tr>
<tr>
<td style="text-align: center;">12 mm rect. peg 12 mm rect. hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.1374-0.2274$</td>
</tr>
<tr>
<td style="text-align: center;">16 mm rect. peg 16 mm rect. hole</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.1576-0.2612$</td>
</tr>
<tr>
<td style="text-align: center;">M4 nut</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.416-0.736$</td>
</tr>
<tr>
<td style="text-align: center;">M4 bolt</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">M8 nut</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.848-1.325$</td>
</tr>
<tr>
<td style="text-align: center;">M8 bolt</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">M12 nut</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$1.26-1.86$</td>
</tr>
<tr>
<td style="text-align: center;">M12 bolt</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">M16 nut</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$1.472-2.127$</td>
</tr>
<tr>
<td style="text-align: center;">M16 bolt</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">M20 nut</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$1.879-2.664$</td>
</tr>
<tr>
<td style="text-align: center;">M20 bolt</td>
<td style="text-align: center;">ISO 724, 965</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Gear base, shafts</td>
<td style="text-align: center;">ISO 286</td>
<td style="text-align: center;">loose, tight</td>
<td style="text-align: center;">$0.005-0.014$</td>
</tr>
<tr>
<td style="text-align: center;">Gear small</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Gear medium</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Gear large</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>TABLE VII
INFORMATION ON PEG, HOLE, NUT, BOLT, AND GEAR MODELS (49 PARTS, 14 DISTINCT SUBASSEMBLIES) PROVIDED AND SIMULATED IN THIS WORK. Loose AND Tight CONFIGURATIONS CORRESPOND TO THE ENDS OF THE MANUFACTURING TOLERANCE BAND SPECIFIED BY THE LISTED STANDARD. Clearance DESIGNATES THE CORRESPONDING RANGE OF CLEARANCES BETWEEN THE GIVEN PART AND ITS MATING COMPONENT (e.g., BETWEEN PEG AND HOLE). CLEARANCE VALUES ARE 2-SIDED (e.g., FOR A ROUND PEG, THE CLEARANCE IS DIAMETRAL).</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Part</th>
<th style="text-align: center;">Manufacturer</th>
<th style="text-align: center;">Configurations</th>
<th style="text-align: center;">Clearance (mm)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">BNC plug (inner)</td>
<td style="text-align: center;">Amphenol</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;">0.1778</td>
</tr>
<tr>
<td style="text-align: center;">BNC plug (outer)</td>
<td style="text-align: center;">Amphenol</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">BNC socket</td>
<td style="text-align: center;">Molex</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">D-sub plug</td>
<td style="text-align: center;">Assmann</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;">D-sub socket</td>
<td style="text-align: center;">Assmann</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">RJ45 plug</td>
<td style="text-align: center;">Harting</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;">0.34177</td>
</tr>
<tr>
<td style="text-align: center;">RJ45 socket</td>
<td style="text-align: center;">Amphenol</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">USB plug</td>
<td style="text-align: center;">Bulgin</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr>
<td style="text-align: center;">USB socket</td>
<td style="text-align: center;">Amphenol</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Waterproof plug</td>
<td style="text-align: center;">Harting</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;">0.4</td>
</tr>
<tr>
<td style="text-align: center;">Waterproof socket</td>
<td style="text-align: center;">Harting</td>
<td style="text-align: center;">visual, collision</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>TABLE VIII
INFORMATION ON ELECTRICAL CONNECTOR ASSETS (11 PARTS, 5 DISTINCT SUBASSEMBLIES) PROVIDED IN THIS WORK. THE RIGID SUBASSEMBLIES (BNC, D-SUB, USB) ARE ALSO SIMULATED; ALTHOUGH THE DEFORMABLE PARTS (RJ45 PLUG, WATERPROOF SOCKET) CAN BE SIMULATED USING PHYSX OR ISAAC GYM, THEY ARE NOT TESTED HERE. THE BNC PLUG CONTAINS BOTH AN INNER AND OUTER COMPONENT COUPLED BY A LINEAR SPRING. Manufacturer SIMPLY DESIGNATES THE SOURCE OF THE ORIGINAL CAD MODEL USED TO GENERATE THE VISUAL MESHES AND DESIGN THE COLLISION MESHES; REGARDLESS OF THE MANUFACTURER, THE MATING FEATURES (e.g., PINS, HOLES) FOR ALL PARTS OF A CERTAIN TYPE ARE HIGHLY STANDARDIZED. Clearance DENOTES THE MINIMUM CLEARANCE BETWEEN THE GIVEN PART AND ITS MATING COMPONENT (i.e., BETWEEN PLUG AND SOCKET) AT THE BEGINNING OF INSERTION. CLEARANCE VALUES ARE 2-SIDED (e.g., FOR THE D-SUB CONNECTOR, THE CLEARANCE IS THE DIAMETRAL CLEARANCE BETWEEN THE PINS AND HOLES). THE D-SUB AND USB CONNECTORS BEGIN WITH ZERO-CLEARANCE, WHEREAS THE REMAINING COMPONENTS ACHIEVE ZERO-CLEARANCE DURING INSERTION. LINKS TO PART-SPECIFIC WEBPAGES ARE AVAILABLE ON OUR WEBSITE.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">MLP network size</td>
<td style="text-align: left;">$[256,128,64]$</td>
</tr>
<tr>
<td style="text-align: left;">Horizon length (T)</td>
<td style="text-align: left;">32</td>
</tr>
<tr>
<td style="text-align: left;">Adam learning rate</td>
<td style="text-align: left;">$1.0 \mathrm{e}-4$</td>
</tr>
<tr>
<td style="text-align: left;">Discount factor $(\gamma)$</td>
<td style="text-align: left;">0.99</td>
</tr>
<tr>
<td style="text-align: left;">GAE parameter $(\lambda)$</td>
<td style="text-align: left;">0.95</td>
</tr>
<tr>
<td style="text-align: left;">Entropy coefficient</td>
<td style="text-align: left;">0.0</td>
</tr>
<tr>
<td style="text-align: left;">Critic coefficient</td>
<td style="text-align: left;">2.0</td>
</tr>
<tr>
<td style="text-align: left;">Minibatch size</td>
<td style="text-align: left;">512</td>
</tr>
<tr>
<td style="text-align: left;">Minibatch epochs</td>
<td style="text-align: left;">8</td>
</tr>
<tr>
<td style="text-align: left;">Clipping parameter $\epsilon$</td>
<td style="text-align: left;">0.2</td>
</tr>
</tbody>
</table>
<p>TABLE IX
PPO PARAMETERS USED IN PICK, PLACE, AND SCREW SUBPOLICIES. THE ACTOR AND CRITIC NETWORKS ARE MLPS WITH A SHARED TRUNK. OBSERVATIONS, ACTIONS, ADVANTAGES, AND VALUES WERE ALL NORMALIZED. THE LEARNING RATE IS SMALL AND FIXED, AS HIGHER RETURNS WERE CONSISTENTLY ACHIEVED COMPARED TO AN ADAPTIVE SCHEDULE BASED ON A KL-DIVERGENCE THRESHOLD.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Controller</th>
<th style="text-align: center;">P Motion Gains</th>
<th style="text-align: center;">D Motion Gains</th>
<th style="text-align: center;">P Force Gains</th>
<th style="text-align: center;">Success Rate</th>
<th style="text-align: center;">Time to Success</th>
<th style="text-align: center;">Reward</th>
<th style="text-align: center;">Joint Torque (Nm)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Task-space impedance</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.321$</td>
<td style="text-align: center;">1.993</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.308$</td>
<td style="text-align: center;">1.966</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.299$</td>
<td style="text-align: center;">1.966</td>
</tr>
<tr>
<td style="text-align: center;">OSC motion</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.797</td>
<td style="text-align: center;">2335</td>
<td style="text-align: center;">$-0.101$</td>
<td style="text-align: center;">1.743</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.669</td>
<td style="text-align: center;">2449</td>
<td style="text-align: center;">$-0.115$</td>
<td style="text-align: center;">1.758</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.305$</td>
<td style="text-align: center;">2.891</td>
</tr>
<tr>
<td style="text-align: center;">Hybrid force-motion</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.01</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.411$</td>
<td style="text-align: center;">4.214</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-1.399$</td>
<td style="text-align: center;">28.179</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-4.274$</td>
<td style="text-align: center;">418.957</td>
</tr>
</tbody>
</table>
<p>TABLE X
COMPARISON OF CONTROLLER SELECTION AND GAINS ON SCREW TASK. P Motion Gains SPECIFIES THE VALUE OF THE PROPORTIONAL GAIN FOR THE FIRST 5 ELEMENTS OF THE ACTION SPACE FOR THE MOTION CONTROLLER; IN ORDER TO BIAS TOWARDS EFFICIENT SCREWING, ELEMENT 6 WAS ASSIGNED TO BE 10 FOR TASK-SPACE IMPEDANCE AND 100 FOR THE OTHERS. D Motion Gains SPECIFIES THE VALUE OF THE DERIVATIVE GAIN FOR ALL 6 ELEMENTS OF THE ACTION SPACE FOR THE MOTION CONTROLLER. P Force Gains SPECIFIES THE VALUE OF THE PROPORTIONAL GAIN FOR ALL 3 ELEMENTS OF THE CLOSED-LOOP FORCE CONTROLLER. Success Rate SPECIFIES THE FRACTION OF EPISODES THAT WERE SUCCESSFUL. Time to Success SPECIFIES THE MEAN NUMBER OF TIMESTEPS REQUIRED TO ACHIEVE SUCCESS. Reward SPECIFIES THE MEAN REWARD DURING EACH EPISODE. Joint Torque SPECIFIES THE MEAN JOINT TORQUE NORM DURING EACH EPISODE. EACH CELL IS COMPUTED FROM THE AVERAGE OF 3 SEEDS.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Actions</th>
<th style="text-align: center;">Observations</th>
<th style="text-align: center;">Success Rate</th>
<th style="text-align: center;">Env Steps to Success</th>
<th style="text-align: center;">Reward</th>
<th style="text-align: center;">Joint Torque (Nm)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">2-DOF (Z, yaw)</td>
<td style="text-align: center;">Pose</td>
<td style="text-align: center;">0.7734</td>
<td style="text-align: center;">2308</td>
<td style="text-align: center;">$-0.1024$</td>
<td style="text-align: center;">1.7378</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Pose, velocity</td>
<td style="text-align: center;">0.7969</td>
<td style="text-align: center;">3658</td>
<td style="text-align: center;">$-0.1004$</td>
<td style="text-align: center;">1.7397</td>
</tr>
<tr>
<td style="text-align: center;">6-DOF</td>
<td style="text-align: center;">Pose</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.1602$</td>
<td style="text-align: center;">1.7838</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Pose, velocity</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">$-0.1647$</td>
<td style="text-align: center;">1.8008</td>
</tr>
</tbody>
</table>
<p>TABLE XI
COMPARISON OF ACTION SPACES ON PERFORMANCE OF SCREW TASK. FOR THE 2-DOF CASE, NO TASK-SPACE FORCE/TORQUE WAS ACTIVELY GENERATED ALONG THE NON-ACTIVE DIMENSIONS OF THE ACTION SPACE. GIVEN THE COMPETITIVE NATURE OF THE RESULTS IN THE OBSERVATION-SPACE ASSESSMENT, OBSERVATION SPACES WERE ALSO TESTED HERE. Success Rate SPECIFIES THE FRACTION OF EPISODES THAT WERE SUCCESSFUL. Time to Success SPECIFIES THE MEAN NUMBER OF TIMESTEPS REQUIRED TO ACHIEVE SUCCESS. Reward SPECIFIES THE MEAN REWARD DURING EACH EPISODE. Joint Torque SPECIFIES THE MEAN JOINT TORQUE NORM DURING EACH EPISODE. EACH CELL IS COMPUTED FROM THE AVERAGE OF 3 SEEDS.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Baseline</th>
<th style="text-align: center;">Success Rate</th>
<th style="text-align: center;">Env Steps to Success</th>
<th style="text-align: center;">Joint Torque (Nm)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Linear: $-|d|$</td>
<td style="text-align: center;">0.8359</td>
<td style="text-align: center;">3148</td>
<td style="text-align: center;">1.7295</td>
</tr>
<tr>
<td style="text-align: left;">Exponential: $e^{-|d|}$</td>
<td style="text-align: center;">0.0052</td>
<td style="text-align: center;">3033</td>
<td style="text-align: center;">0.7425</td>
</tr>
<tr>
<td style="text-align: left;">Inverse: $\frac{1}{1+|d|}$</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">N/A</td>
<td style="text-align: center;">0.7270</td>
</tr>
</tbody>
</table>
<p>TABLE XII
COMPARISON OF BASELINE REWARDS ON PERFORMANCE OF SCREW TASK. QUANTITY $|d|$ DENOTES KEYPOINT DISTANCE, DEFINED IN SECTION V-D. Success Rate SPECIFIES THE FRACTION OF EPISODES THAT WERE SUCCESSFUL. Time to Success SPECIFIES THE MEAN NUMBER OF TIMESTEPS REQUIRED TO ACHIEVE SUCCESS. Joint Torque SPECIFIES THE MEAN JOINT TORQUE NORM DURING EACH EPISODES. DUE TO THE DISTINCT RANGE OF EACH BASELINE REWARD, MEAN REWARD IS NOT PROVIDED. EACH CELL IS COMPUTED FROM THE AVERAGE OF 3 SEEDS.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ https://sites.google.com/nvidia.com/factory/&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>