<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-996 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-996</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-996</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-23.html">extraction-schema-23</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <p><strong>Paper ID:</strong> paper-f44e990c86a8c99e1f778656ad7f15b83298d39e</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/f44e990c86a8c99e1f778656ad7f15b83298d39e" target="_blank">A Gentle Introduction to Epistemic Planning: The DEL Approach</a></p>
                <p><strong>Paper Venue:</strong> M4M@ICLA</p>
                <p><strong>Paper TL;DR:</strong> The paper starts with the most classical framework for planning, STRIPS, and then moves towards epistemic planning in a number of smaller steps, where each step is motivated by the need to be able to model more complex planning scenarios.</p>
                <p><strong>Paper Abstract:</strong> Epistemic planning can be used for decision making in multi-agent situations with distributed knowledge and capabilities. Dynamic Epistemic Logic (DEL) has been shown to provide a very natural and expressive framework for epistemic planning. In this paper, we aim to give an accessible introduction to DEL-based epistemic planning. The paper starts with the most classical framework for planning, STRIPS, and then moves towards epistemic planning in a number of smaller steps, where each step is motivated by the need to be able to model more complex planning scenarios.</p>
                <p><strong>Cost:</strong> 0.021</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e996.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e996.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>STRIPS</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>STRIPS planning language</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A classical planning formalism that represents states as sets of ground atoms and actions as schemas with logical preconditions and add/delete effects; used as the starting point for compact action representations in automated planning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>STRIPS: A new approach to the application of theorem proving to problem solving</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>STRIPS / Propositional planning (background formalism)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>States are sets of ground atoms in a function-free first-order language; actions are action schemas with conjunctive preconditions and add/delete effects; grounded instances induce a (potentially exponentially large) state-transition system used for classical plan search.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>STRIPS / propositional planning (logic-based representation)</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>States represented as sets of ground atoms (propositional valuations); actions are schemas whose ground instances specify preconditions (conjunctions of literals) and deterministic postconditions (add/remove lists). The standard STRIPS model in this paper is deterministic (non‑probabilistic) and propositional once grounded.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Classical state-space search induced by grounded actions (graph search); heuristics from action schemas are discussed in general (e.g., admissible/relaxed heuristics) but no single concrete algorithm is implemented in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>STRIPS is presented as the canonical compact action representation; it does not itself represent epistemic uncertainty or probabilities, but is the basis from which propositional and epistemic generalisations are developed in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e996.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Propositional planning</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Propositional planning tasks (grounded STRIPS)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A propositional instantiation of STRIPS where the planning task is specified over a finite set of atomic propositions; used here as the stepping stone toward belief-state and epistemic planning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Propositional planning (grounded STRIPS)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>The paper defines propositional planning tasks as triples (A, s0, phi_g) over a finite proposition set P where actions are pairs of propositional preconditions and postconditions; grounding of STRIPS action schemas yields this propositional formalism which induces the classical state-space.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Propositional (grounded STRIPS) state space</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>Worlds/states are subsets of atomic propositions P; actions are pairs ⟨pre, post⟩ where pre and post are conjunctions of literals; transitions are deterministic when an action's precondition is satisfied (no intrinsic probabilistic modelling).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Classical search in induced state-space (graph search); the paper notes the use of heuristics derived from action schemas but does not implement a specific planner.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Propositional planning is the non-epistemic instantiation; used to motivate the need for belief-state and epistemic generalisations when dealing with partial observability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e996.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Belief states</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Belief states (sets of propositional states)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Representation of an agent's uncertainty as a set of possible propositional worlds; used to model planning under partial observability with conditional actions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Belief-state planning (partial observability)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>A belief state is a set of propositional states (worlds). Actions are generalized to conditional actions (sets of events); the transition function maps a belief state and a conditional action to the set of successor worlds consistent with applicable events. This supports planning under partial observability and distinguishes plan-time vs run-time uncertainty only after moving to epistemic models.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Belief states (sets of propositional states); conditional (non-probabilistic) event-based actions</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>Belief states: sets of propositional states (each a subset of P). Conditional actions are sets of events ⟨pre(e), post(e)⟩; transition γ(s,a) = {γ(w,e) | w ∈ s, e ∈ a, w ⊨ pre(e)}. This is a qualitative (set-based) representation of epistemic uncertainty (not a probability distribution).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>epistemic uncertainty (state uncertainty; plan-time vs run-time uncertainty)</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Belief states as sets of possible worlds; conditional actions/events to capture nondeterministic outcomes and information-gathering effects; no probabilistic weights are used.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Search in belief-state space; conditional-plan generation via AND-OR exploration (policy synthesis); no single numeric planning algorithm is implemented in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Belief states allow representation of partial observability and conditional actions, but as set-based (qualitative) uncertainty only; plan-time vs run-time uncertainty distinction motivates the move to epistemic models.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e996.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DEL</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Dynamic Epistemic Logic (DEL)-based epistemic planning</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A semantic framework using epistemic models for states and action/event models for actions; uses product update (s ⊗ a) to model combined epistemic and ontic change and supports multi‑agent knowledge and private/public observations.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>DEL-based epistemic planner (framework)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>States are epistemic models (M = (W, (~_i)_i, L)) with designated worlds; actions are action/event models (E, (~_i)_i, pre, post) with designated events. The product update constructs the successor epistemic model by pairing worlds and events that satisfy preconditions and updating labels per postconditions; indistinguishability relations for agents combine via product rules to represent information flow and observability.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Epistemic models (semantic, modal logic based) + DEL action/event models</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>States: finite epistemic models (W, indistinguishability relations per agent, labelling L) with possibly multiple designated worlds (local/global states). Actions: event models with events, pre/post, and agent-specific indistinguishability relations. Product update (s ⊗ a) yields next epistemic state. Representation is qualitative (non‑probabilistic) but models epistemic uncertainty, private/public announcements, and information-gathering actions explicitly.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>epistemic uncertainty (knowledge/belief about states and others' knowledge), non-probabilistic</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Indistinguishability relations (equivalence relations) over worlds for each agent and sets of designated worlds; events model informational effects; no probabilistic distributions are part of the core DEL formalism in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Policy synthesis/conditional planning via exploration of epistemic-state transition system induced by actions (AND-OR style search / generation of uniform policies); discussion of complexity and decidable fragments; bisimulation contraction used for state-space reduction.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>DEL gives a principled semantic way to represent agents' knowledge and information-changing actions, including private/public observations; it supports conditional planning (policies) under epistemic uncertainty but is qualitative (non-probabilistic); complexity results show undecidability in general and motivate restricted decidable fragments.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e996.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Action models</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>DEL action models (event models)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Event-centric representations of actions in DEL: a finite set of events with per-agent indistinguishability relations and pre/postconditions; used to model both ontic and epistemic effects of actions.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Action model formalism (epistemic actions / event models)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Action models are tuples (E, (~_i)_i, pre, post) where each event has a precondition formula and a postcondition (conjunction of literals). Agents may be unable to distinguish which event occurred, modelling private observations and misinformation. Product update composes an epistemic state with an action model to produce the updated epistemic state.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Event/action models with agent indistinguishability (DEL)</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>Events e ∈ E carry pre(e) as an epistemic formula and post(e) as literal conjunctions; indistinguishability edges ~_i between events encode which agents distinguish event outcomes; applicability requires designated events' preconditions to hold in designated worlds. Non-determinism/information outcomes are represented by multiple events rather than probabilities.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>epistemic uncertainty about which event will occur (information outcomes); non-probabilistic</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Multiple events with preconditions and agent-specific indistinguishability relations (qualitative branching); no probabilistic weights.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Used within product update-based state-transition semantics for planning; planning algorithms operate over the induced epistemic states (policy search / AND-OR search); no numeric planner is implemented in the paper.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Action models permit explicit modelling of observability (public/private), information-gathering, and multi-agent perception; they are the core mechanism in DEL to capture epistemic side‑effects of actions, but are qualitative rather than probabilistic in this presentation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e996.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Conditional actions</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Conditional actions (sets of events / conditional effects)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Actions that are represented as sets of possible events (pre/post) so that an action may have multiple mutually exclusive outcomes depending on the world; used to encode sensing and non-deterministic effects.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Conditional actions / TryPickUp example</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Conditional actions are sets of events; each event is an outcome with a precondition and a postcondition (or skip/T). The TryPickUp example shows an event for successful pickup when object is at the location and a skip event when not; execution on a belief/epistemic state yields branching and information gain.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Sets of events (conditional/non-deterministic actions) over propositional or epistemic states</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>Each action a is a set {e1, e2, ...} where pre(e) determines when the event can happen and post(e) updates the state's propositional labels; when applied to a belief state or epistemic model, successor states are generated for each applicable event and world pair. Representation here is non-probabilistic nondeterminism.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>action outcome uncertainty and epistemic uncertainty (sensing effects)</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Branching via multiple events and use of belief/epistemic states to capture which worlds remain possible after each outcome; no probability distributions used.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Used within belief/epistemic state transition semantics; supports conditional plans/policies via branching search (AND-OR graph exploration).</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Conditional actions model sensing and nondeterministic outcomes and produce information gain by splitting indistinguishability; they are central to generating conditional plans/policies under partial observability, but are qualitative in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e996.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Policies / conditional plans</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Policies (uniform conditional plans / strategies)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Uniform mappings from global states to actions (for an agent) that respect indistinguishability and guarantee goal achievement in all executions; the paper uses policies as the notion of solution to epistemic planning tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Policy synthesis for epistemic planning</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>An i-policy is a partial mapping from global states to actions satisfying applicability in the agent's local state and uniformity across indistinguishable global states; a solution policy must be defined for all globals in the initial epistemic state and guarantee that all executions reach the goal.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Policy over epistemic state-transition system (DEL-induced)</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>Policies operate on global epistemic states (each a model with a designated world); the induced transition system is s ⊗ a; policies must be uniform wrt agent indistinguishability and ensure successful termination for all possible global executions. No probabilistic branching is assumed in the formal definition.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>epistemic uncertainty (planning with partial observability), action outcome nondeterminism</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Uniformity constraint and branching executions over epistemic states; solutions are strong (guaranteed) policies across all nondeterministic branches.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>AND-OR style policy synthesis over epistemic state graph; policy execution semantics defined; complexity and decidability of existence are studied at a theoretical level.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Policies provide the correct solution notion for conditional epistemic planning; uniformity and knowledge-of-preconditions constraints are necessary to ensure implementable strategies under partial observability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e996.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>PKS planner</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>PKS (syntactic epistemic planner) [referred to]</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Mentioned as an example of a syntactic approach to epistemic planning where states are represented as knowledge bases (sets of formulas) instead of semantic epistemic models.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>PKS planner (syntactic approach)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Referenced as a syntactic planner that represents agent knowledge as formulas (knowledge-bases) rather than semantic epistemic models; cited in the discussion contrasting semantic vs syntactic approaches to epistemic planning.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Syntactic knowledge-base representation (sets of formulas)</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>States are represented by sets of formulas known to be true; reasoning and action effects operate at the formula-level (syntactic) rather than via model product updates. The paper does not detail PKS internals.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>epistemic uncertainty encoded syntactically (knowledge/ignorance)</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Knowledge-bases and formula manipulation (syntactic), not probabilistic</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>Not detailed in this paper (PKS cited as related work); PKS implements single-agent epistemic planning in a syntactic setting per the citation.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>PKS is given as an example of an alternative (syntactic) approach to epistemic planning; the present paper contrasts it with DEL's semantic approach but does not evaluate or integrate PKS.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e996.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e996.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of systems or methods that use probabilistic symbolic world models (such as PPDDL, PDDL, or belief states) for planning in text-based environments, especially those that integrate uncertainty from large language models.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Kominis & Geffner compilation</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Beliefs in multiagent planning: From one agent to many (compilation approach)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Mentioned as a compilation-style approach that translates restricted epistemic planning fragments into classical planning, enabling the use of classical planners for epistemic problems.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Beliefs in multiagent planning: From one agent to many</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Compilation to classical planning (Kominis & Geffner)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Referenced as a work that compiles a restricted fragment of epistemic planning into classical planning representations, effectively reducing epistemic tasks to classical planners' input languages so they can leverage existing planning technology.</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_type</strong></td>
                            <td>Compilation to classical STRIPS-like representations (state-space encoding of beliefs)</td>
                        </tr>
                        <tr>
                            <td><strong>world_model_description</strong></td>
                            <td>The approach encodes beliefs into a classical planning formalism (grounded propositions and actions) so that classical planners can be applied; the paper being summarized only cites this work and does not detail the encoding or probabilistic aspects.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_llm</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>llm_role</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>llm_model_name</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_modeling</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_type</strong></td>
                            <td>epistemic uncertainty (compiled into propositional encodings)</td>
                        </tr>
                        <tr>
                            <td><strong>uncertainty_method</strong></td>
                            <td>Compilation/encoding of epistemic constructs into classical planning representations (syntactic/semantic encoding); not probabilistic in the cited description.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_algorithm</strong></td>
                            <td>After compilation, classical planning algorithms (existing planners) can be used; the present paper does not report implementation or results.</td>
                        </tr>
                        <tr>
                            <td><strong>planning_integrates_uncertainty</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_name</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>text_environment_description</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_metric</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>performance_value</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_comparison</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>has_ablation_uncertainty</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_results</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Compilation approaches can leverage classical planners for fragments of epistemic planning, but they are restricted and the paper cites them as complementary work; no integration with probabilistic models or LLMs is described here.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'A Gentle Introduction to Epistemic Planning: The DEL Approach', 'publication_date_yy_mm': '2017-03'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Epistemic Planning for Single- and Multi-Agent Systems <em>(Rating: 2)</em></li>
                <li>Automated Planning: Theory and Practice <em>(Rating: 2)</em></li>
                <li>Beliefs in multiagent planning: From one agent to many <em>(Rating: 2)</em></li>
                <li>Planning Over Multi-Agent Epistemic States: A Classical Planning Approach (Amended Version) <em>(Rating: 2)</em></li>
                <li>A Knowledge-Based Approach to Planning with Incomplete Information and Sensing <em>(Rating: 2)</em></li>
                <li>Complexity Results in Epistemic Planning <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-996",
    "paper_id": "paper-f44e990c86a8c99e1f778656ad7f15b83298d39e",
    "extraction_schema_id": "extraction-schema-23",
    "extracted_data": [
        {
            "name_short": "STRIPS",
            "name_full": "STRIPS planning language",
            "brief_description": "A classical planning formalism that represents states as sets of ground atoms and actions as schemas with logical preconditions and add/delete effects; used as the starting point for compact action representations in automated planning.",
            "citation_title": "STRIPS: A new approach to the application of theorem proving to problem solving",
            "mention_or_use": "use",
            "system_name": "STRIPS / Propositional planning (background formalism)",
            "system_description": "States are sets of ground atoms in a function-free first-order language; actions are action schemas with conjunctive preconditions and add/delete effects; grounded instances induce a (potentially exponentially large) state-transition system used for classical plan search.",
            "world_model_type": "STRIPS / propositional planning (logic-based representation)",
            "world_model_description": "States represented as sets of ground atoms (propositional valuations); actions are schemas whose ground instances specify preconditions (conjunctions of literals) and deterministic postconditions (add/remove lists). The standard STRIPS model in this paper is deterministic (non‑probabilistic) and propositional once grounded.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": false,
            "uncertainty_type": "",
            "uncertainty_method": "",
            "planning_algorithm": "Classical state-space search induced by grounded actions (graph search); heuristics from action schemas are discussed in general (e.g., admissible/relaxed heuristics) but no single concrete algorithm is implemented in this paper.",
            "planning_integrates_uncertainty": false,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "STRIPS is presented as the canonical compact action representation; it does not itself represent epistemic uncertainty or probabilities, but is the basis from which propositional and epistemic generalisations are developed in the paper.",
            "uuid": "e996.0",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "Propositional planning",
            "name_full": "Propositional planning tasks (grounded STRIPS)",
            "brief_description": "A propositional instantiation of STRIPS where the planning task is specified over a finite set of atomic propositions; used here as the stepping stone toward belief-state and epistemic planning.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Propositional planning (grounded STRIPS)",
            "system_description": "The paper defines propositional planning tasks as triples (A, s0, phi_g) over a finite proposition set P where actions are pairs of propositional preconditions and postconditions; grounding of STRIPS action schemas yields this propositional formalism which induces the classical state-space.",
            "world_model_type": "Propositional (grounded STRIPS) state space",
            "world_model_description": "Worlds/states are subsets of atomic propositions P; actions are pairs ⟨pre, post⟩ where pre and post are conjunctions of literals; transitions are deterministic when an action's precondition is satisfied (no intrinsic probabilistic modelling).",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": false,
            "uncertainty_type": "",
            "uncertainty_method": "",
            "planning_algorithm": "Classical search in induced state-space (graph search); the paper notes the use of heuristics derived from action schemas but does not implement a specific planner.",
            "planning_integrates_uncertainty": false,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "Propositional planning is the non-epistemic instantiation; used to motivate the need for belief-state and epistemic generalisations when dealing with partial observability.",
            "uuid": "e996.1",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "Belief states",
            "name_full": "Belief states (sets of propositional states)",
            "brief_description": "Representation of an agent's uncertainty as a set of possible propositional worlds; used to model planning under partial observability with conditional actions.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Belief-state planning (partial observability)",
            "system_description": "A belief state is a set of propositional states (worlds). Actions are generalized to conditional actions (sets of events); the transition function maps a belief state and a conditional action to the set of successor worlds consistent with applicable events. This supports planning under partial observability and distinguishes plan-time vs run-time uncertainty only after moving to epistemic models.",
            "world_model_type": "Belief states (sets of propositional states); conditional (non-probabilistic) event-based actions",
            "world_model_description": "Belief states: sets of propositional states (each a subset of P). Conditional actions are sets of events ⟨pre(e), post(e)⟩; transition γ(s,a) = {γ(w,e) | w ∈ s, e ∈ a, w ⊨ pre(e)}. This is a qualitative (set-based) representation of epistemic uncertainty (not a probability distribution).",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "epistemic uncertainty (state uncertainty; plan-time vs run-time uncertainty)",
            "uncertainty_method": "Belief states as sets of possible worlds; conditional actions/events to capture nondeterministic outcomes and information-gathering effects; no probabilistic weights are used.",
            "planning_algorithm": "Search in belief-state space; conditional-plan generation via AND-OR exploration (policy synthesis); no single numeric planning algorithm is implemented in the paper.",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "Belief states allow representation of partial observability and conditional actions, but as set-based (qualitative) uncertainty only; plan-time vs run-time uncertainty distinction motivates the move to epistemic models.",
            "uuid": "e996.2",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "DEL",
            "name_full": "Dynamic Epistemic Logic (DEL)-based epistemic planning",
            "brief_description": "A semantic framework using epistemic models for states and action/event models for actions; uses product update (s ⊗ a) to model combined epistemic and ontic change and supports multi‑agent knowledge and private/public observations.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "DEL-based epistemic planner (framework)",
            "system_description": "States are epistemic models (M = (W, (~_i)_i, L)) with designated worlds; actions are action/event models (E, (~_i)_i, pre, post) with designated events. The product update constructs the successor epistemic model by pairing worlds and events that satisfy preconditions and updating labels per postconditions; indistinguishability relations for agents combine via product rules to represent information flow and observability.",
            "world_model_type": "Epistemic models (semantic, modal logic based) + DEL action/event models",
            "world_model_description": "States: finite epistemic models (W, indistinguishability relations per agent, labelling L) with possibly multiple designated worlds (local/global states). Actions: event models with events, pre/post, and agent-specific indistinguishability relations. Product update (s ⊗ a) yields next epistemic state. Representation is qualitative (non‑probabilistic) but models epistemic uncertainty, private/public announcements, and information-gathering actions explicitly.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "epistemic uncertainty (knowledge/belief about states and others' knowledge), non-probabilistic",
            "uncertainty_method": "Indistinguishability relations (equivalence relations) over worlds for each agent and sets of designated worlds; events model informational effects; no probabilistic distributions are part of the core DEL formalism in this paper.",
            "planning_algorithm": "Policy synthesis/conditional planning via exploration of epistemic-state transition system induced by actions (AND-OR style search / generation of uniform policies); discussion of complexity and decidable fragments; bisimulation contraction used for state-space reduction.",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "DEL gives a principled semantic way to represent agents' knowledge and information-changing actions, including private/public observations; it supports conditional planning (policies) under epistemic uncertainty but is qualitative (non-probabilistic); complexity results show undecidability in general and motivate restricted decidable fragments.",
            "uuid": "e996.3",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "Action models",
            "name_full": "DEL action models (event models)",
            "brief_description": "Event-centric representations of actions in DEL: a finite set of events with per-agent indistinguishability relations and pre/postconditions; used to model both ontic and epistemic effects of actions.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Action model formalism (epistemic actions / event models)",
            "system_description": "Action models are tuples (E, (~_i)_i, pre, post) where each event has a precondition formula and a postcondition (conjunction of literals). Agents may be unable to distinguish which event occurred, modelling private observations and misinformation. Product update composes an epistemic state with an action model to produce the updated epistemic state.",
            "world_model_type": "Event/action models with agent indistinguishability (DEL)",
            "world_model_description": "Events e ∈ E carry pre(e) as an epistemic formula and post(e) as literal conjunctions; indistinguishability edges ~_i between events encode which agents distinguish event outcomes; applicability requires designated events' preconditions to hold in designated worlds. Non-determinism/information outcomes are represented by multiple events rather than probabilities.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "epistemic uncertainty about which event will occur (information outcomes); non-probabilistic",
            "uncertainty_method": "Multiple events with preconditions and agent-specific indistinguishability relations (qualitative branching); no probabilistic weights.",
            "planning_algorithm": "Used within product update-based state-transition semantics for planning; planning algorithms operate over the induced epistemic states (policy search / AND-OR search); no numeric planner is implemented in the paper.",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "Action models permit explicit modelling of observability (public/private), information-gathering, and multi-agent perception; they are the core mechanism in DEL to capture epistemic side‑effects of actions, but are qualitative rather than probabilistic in this presentation.",
            "uuid": "e996.4",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "Conditional actions",
            "name_full": "Conditional actions (sets of events / conditional effects)",
            "brief_description": "Actions that are represented as sets of possible events (pre/post) so that an action may have multiple mutually exclusive outcomes depending on the world; used to encode sensing and non-deterministic effects.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Conditional actions / TryPickUp example",
            "system_description": "Conditional actions are sets of events; each event is an outcome with a precondition and a postcondition (or skip/T). The TryPickUp example shows an event for successful pickup when object is at the location and a skip event when not; execution on a belief/epistemic state yields branching and information gain.",
            "world_model_type": "Sets of events (conditional/non-deterministic actions) over propositional or epistemic states",
            "world_model_description": "Each action a is a set {e1, e2, ...} where pre(e) determines when the event can happen and post(e) updates the state's propositional labels; when applied to a belief state or epistemic model, successor states are generated for each applicable event and world pair. Representation here is non-probabilistic nondeterminism.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "action outcome uncertainty and epistemic uncertainty (sensing effects)",
            "uncertainty_method": "Branching via multiple events and use of belief/epistemic states to capture which worlds remain possible after each outcome; no probability distributions used.",
            "planning_algorithm": "Used within belief/epistemic state transition semantics; supports conditional plans/policies via branching search (AND-OR graph exploration).",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "Conditional actions model sensing and nondeterministic outcomes and produce information gain by splitting indistinguishability; they are central to generating conditional plans/policies under partial observability, but are qualitative in this paper.",
            "uuid": "e996.5",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "Policies / conditional plans",
            "name_full": "Policies (uniform conditional plans / strategies)",
            "brief_description": "Uniform mappings from global states to actions (for an agent) that respect indistinguishability and guarantee goal achievement in all executions; the paper uses policies as the notion of solution to epistemic planning tasks.",
            "citation_title": "",
            "mention_or_use": "use",
            "system_name": "Policy synthesis for epistemic planning",
            "system_description": "An i-policy is a partial mapping from global states to actions satisfying applicability in the agent's local state and uniformity across indistinguishable global states; a solution policy must be defined for all globals in the initial epistemic state and guarantee that all executions reach the goal.",
            "world_model_type": "Policy over epistemic state-transition system (DEL-induced)",
            "world_model_description": "Policies operate on global epistemic states (each a model with a designated world); the induced transition system is s ⊗ a; policies must be uniform wrt agent indistinguishability and ensure successful termination for all possible global executions. No probabilistic branching is assumed in the formal definition.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "epistemic uncertainty (planning with partial observability), action outcome nondeterminism",
            "uncertainty_method": "Uniformity constraint and branching executions over epistemic states; solutions are strong (guaranteed) policies across all nondeterministic branches.",
            "planning_algorithm": "AND-OR style policy synthesis over epistemic state graph; policy execution semantics defined; complexity and decidability of existence are studied at a theoretical level.",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "Policies provide the correct solution notion for conditional epistemic planning; uniformity and knowledge-of-preconditions constraints are necessary to ensure implementable strategies under partial observability.",
            "uuid": "e996.6",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "PKS planner",
            "name_full": "PKS (syntactic epistemic planner) [referred to]",
            "brief_description": "Mentioned as an example of a syntactic approach to epistemic planning where states are represented as knowledge bases (sets of formulas) instead of semantic epistemic models.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "PKS planner (syntactic approach)",
            "system_description": "Referenced as a syntactic planner that represents agent knowledge as formulas (knowledge-bases) rather than semantic epistemic models; cited in the discussion contrasting semantic vs syntactic approaches to epistemic planning.",
            "world_model_type": "Syntactic knowledge-base representation (sets of formulas)",
            "world_model_description": "States are represented by sets of formulas known to be true; reasoning and action effects operate at the formula-level (syntactic) rather than via model product updates. The paper does not detail PKS internals.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "epistemic uncertainty encoded syntactically (knowledge/ignorance)",
            "uncertainty_method": "Knowledge-bases and formula manipulation (syntactic), not probabilistic",
            "planning_algorithm": "Not detailed in this paper (PKS cited as related work); PKS implements single-agent epistemic planning in a syntactic setting per the citation.",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "PKS is given as an example of an alternative (syntactic) approach to epistemic planning; the present paper contrasts it with DEL's semantic approach but does not evaluate or integrate PKS.",
            "uuid": "e996.7",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        },
        {
            "name_short": "Kominis & Geffner compilation",
            "name_full": "Beliefs in multiagent planning: From one agent to many (compilation approach)",
            "brief_description": "Mentioned as a compilation-style approach that translates restricted epistemic planning fragments into classical planning, enabling the use of classical planners for epistemic problems.",
            "citation_title": "Beliefs in multiagent planning: From one agent to many",
            "mention_or_use": "mention",
            "system_name": "Compilation to classical planning (Kominis & Geffner)",
            "system_description": "Referenced as a work that compiles a restricted fragment of epistemic planning into classical planning representations, effectively reducing epistemic tasks to classical planners' input languages so they can leverage existing planning technology.",
            "world_model_type": "Compilation to classical STRIPS-like representations (state-space encoding of beliefs)",
            "world_model_description": "The approach encodes beliefs into a classical planning formalism (grounded propositions and actions) so that classical planners can be applied; the paper being summarized only cites this work and does not detail the encoding or probabilistic aspects.",
            "uses_llm": false,
            "llm_role": "",
            "llm_model_name": "",
            "uncertainty_modeling": true,
            "uncertainty_type": "epistemic uncertainty (compiled into propositional encodings)",
            "uncertainty_method": "Compilation/encoding of epistemic constructs into classical planning representations (syntactic/semantic encoding); not probabilistic in the cited description.",
            "planning_algorithm": "After compilation, classical planning algorithms (existing planners) can be used; the present paper does not report implementation or results.",
            "planning_integrates_uncertainty": true,
            "text_environment_name": null,
            "text_environment_description": "",
            "performance_metric": "",
            "performance_value": "",
            "baseline_comparison": "",
            "has_ablation_uncertainty": false,
            "ablation_results": "",
            "key_findings": "Compilation approaches can leverage classical planners for fragments of epistemic planning, but they are restricted and the paper cites them as complementary work; no integration with probabilistic models or LLMs is described here.",
            "uuid": "e996.8",
            "source_info": {
                "paper_title": "A Gentle Introduction to Epistemic Planning: The DEL Approach",
                "publication_date_yy_mm": "2017-03"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Epistemic Planning for Single- and Multi-Agent Systems",
            "rating": 2
        },
        {
            "paper_title": "Automated Planning: Theory and Practice",
            "rating": 2
        },
        {
            "paper_title": "Beliefs in multiagent planning: From one agent to many",
            "rating": 2
        },
        {
            "paper_title": "Planning Over Multi-Agent Epistemic States: A Classical Planning Approach (Amended Version)",
            "rating": 2
        },
        {
            "paper_title": "A Knowledge-Based Approach to Planning with Incomplete Information and Sensing",
            "rating": 2
        },
        {
            "paper_title": "Complexity Results in Epistemic Planning",
            "rating": 1
        }
    ],
    "cost": 0.02064275,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>A Gentle Introduction to Epistemic Planning: The DEL Approach</h1>
<p>Thomas Bolander<br>DTU Compute<br>Technical University of Denmark<br>Copenhagen, Denmark<br>tobo@dtu.dk</p>
<h4>Abstract</h4>
<p>Epistemic planning can be used for decision making in multi-agent situations with distributed knowledge and capabilities. Dynamic Epistemic Logic (DEL) has been shown to provide a very natural and expressive framework for epistemic planning. In this paper, we aim to give an accessible introduction to DEL-based epistemic planning. The paper starts with the most classical framework for planning, STRIPS, and then moves towards epistemic planning in a number of smaller steps, where each step is motivated by the need to be able to model more complex planning scenarios.</p>
<h2>1 Introduction</h2>
<p>Automated planning is a branch of artificial intelligence concerned with computing plans (sequences of actions) leading to some desired goal. A human or robot could e.g. have the goal of picking up a parcel at the post office, and then the problem becomes to find a succesful sequence of actions achieving this. Epistemic planning is the enrichment of planning with epistemic notions, that is, knowledge and beliefs. The human or robot might have to reason about epistemic aspects such as: Do I know at which post office the parcel is? If not, who would be relevant to ask? Maybe the parcel is a birthday present for my daughter, and I want to ensure that she doesnt get to know, and have to plan my actions accordingly (make sure she doesn't see me with the parcel). The epistemic notions are usually formalised using an epistemic logic. Epistemic planning can naturally be seen as the combination of automated planning with epistemic logic, relying on ideas, concepts and solutions from both areas.</p>
<p>In general, epistemic planning considers the following problem: Given my current state of knowledge, and a desirable state of knowledge, how do I get from one to the other? It is of central importance in settings where agents need to be able to reason about their own lack of knowledge, and e.g. make plans of how to achieve the required knowledge. It is also essential in multi-agent planning, where succesful coordination and collaboration can only be expected if agents are able to reason about the knowledge, uncertainty and capabilities of the other agents.</p>
<p>In this gentle introduction to epistemic planning, the focus will be on the DEL approach: Using Dynamic Epistemic Logic (DEL) as the underlying formalism. We start with the most classical framework for planning, STRIPS, and then stepwise we expand and generalise the framework until finally reaching full multi-agent planning based on dynamic epistemic logic. Each of these steps will be based on the need to be able to formalise specific planning scenarios.</p>
<p>In Section 2 we will first introduce classical planning domains and planning tasks. Then we move to present the basics of the STRIPS planning framework in Section 3, and propositional planning in Section 4. We then slowly progress towards defining the epistemic planning framework via first defining belief states and conditional actions in Section 5, and then epistemic logic and dynamic epistemic logic in Sections 6-7. In Section 8 we finally define epistemic planning tasks, and study various extensions</p>
<p>and generalisations in Sections 9-11. In Section 12 we very briefly study complexity issues of epistemic planning, and we round off with a discussion of alternative approaches to epistemic planning in Section 13 .</p>
<h1>2 Classical planning domains and planning tasks</h1>
<p>Example 1. Suppose a father has his daughter's birthday coming up, and he ordered a present for her which is now at the post office. His goal is to be able to give her the present the next day. This is a planning task (sometimes called a planning problem): He needs to compute a plan to achieve the goal. In a planning task, one is given an initial state, a set of goal states and a set of available actions. The problem is now to compute a sequence of actions (a plan) that, if executed in the initial state, will lead to one of the goal states. In the birthday present example, the initial state describes that the present is at the post office and not yet wrapped. The goal states are those in which the present is at home and wrapped (ready to be given on the next day). The available actions could be actions like going from home to the post office, going from the post office to home, picking up the present at the post office, and wrapping the present. Of course we do not need to limit ourselves to only allowing these specific actions, but could have general actions for going from a location $A$ to a location $B$, general actions for picking up an object at a location, and general actions for wrapping an object that you are currently holding.</p>
<p>To allow us to reason formally about planning tasks and plans, and to allow computers and robots to compute plans, we need an appropriate formalism to describe such objects. The simplest approach is to define planning tasks in terms of state-transition systems.</p>
<p>Definition 1. [17] A (restricted) state-transition system (also called a classical planning domain or simply a state space) is $\Sigma=(S, A, \gamma)$ where:</p>
<ul>
<li>$S$ is a finite or recursively enumerable set of states.</li>
<li>$A$ is a finite or recursively enumerable set of actions.</li>
<li>$\gamma: S \times A \hookrightarrow S$ is a computable partial state-transition function.</li>
</ul>
<p>When $\gamma(s, a)$ is defined, $a$ is said to be applicable in $s$. When $\pi=a_{1} ; \cdots ; a_{n}$ is a sequence of actions from $A$, we write $\gamma(s, \pi)$ for $\gamma\left(\ldots \gamma\left(\gamma\left(\gamma\left(s, a_{1}\right), a_{2}\right), a_{3}\right), \ldots, a_{n}\right) .{ }^{1}$
Definition 2. [17] A classical planning task is a triple $\left(\Sigma, s_{0}, S_{g}\right)$ where:</p>
<ul>
<li>$\Sigma=(S, A, \gamma)$ is a state-transition system (a classical planning domain).</li>
<li>$s_{0} \in S$ is the initial state.</li>
<li>$S_{g} \subseteq S$ is the set of goal states.</li>
</ul>
<p>A solution to a classical planning task $\left((S, A, \gamma), s_{0}, S_{g}\right)$ is a finite sequence of actions (a plan) $\pi=$ $a_{1} ; \cdots ; a_{n}$ from $A$ such that $\gamma\left(s_{0}, \pi\right) \in S_{g}$. The length of a solution $\pi$ is the number of actions in $\pi$.</p>
<p>Example 2. Consider the birthday present example from Example 1. The available actions and their corresponding state transitions could be presented by the state-transitions system of Figure 1. Here we have $\Sigma=(S, A, \gamma)$ with $S=\left{s_{1}, s_{2}, s_{3}, s_{4}, s_{5}, s_{6}\right}, A={$ go to post office, go home, pick up present, wrap present $}$, and $\gamma$ is as given in the figure (e.g. $\gamma\left(s_{1}\right.$, go to post office $)=s_{2}$ since there is an edge labelled "go to post office" from $s_{1}$ to $s_{2}$ ). Note that "wrap present" is only applicable after "pick up present" has been executed: it is necessary to get hold of the present before it can be wrapped. The</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: A state-transition system for the birthday present example.
planning task of Example 1 can then be represented as the classical planning task $\left(\Sigma, s_{0}, S_{g}\right)$ where $s_{0}=s_{1}$ and $S_{g}=\left{s_{5}\right}$. A solution is highlighted in Figure 1:
$\pi=$ go to post office; pick up present; go home; wrap present.
Representing planning tasks directly as state-transition systems has some important weaknesses: 1) there is no internal structure on states and actions to understand or clarify what they represent; 2) statetransition systems are normally of exponential size in the number of propositional variables required to describe the states. To exemplify the second weakness, if the planning task was to take home $n$ parcels from the post office, the state space (state-transition system) would be of size $\geq 2^{n}$ : each parcel could either be at the post office or at home. This is so even though the length of the shortest solution would only be linear in $n$ (e.g. bring the parcels home one at a time). To address both of these weaknesses one introduces logical structures on states and actions. This is e.g. done in the planning language STRIPS to be introduced next.</p>
<h1>3 STRIPS planning</h1>
<p>The classical language for describing states and actions in the field of automated planning is STRIPS [16]. We will here introduce STRIPS slightly informally, and the interested reader is referred to [29] for more details. The reader familiar with STRIPS planning can skip this section, but might want to briefly look at the examples.</p>
<p>In STRIPS, states are represented as sets of ground atoms of a function-free first-order language $\mathcal{L}$. In the birthday present example, the initial state could e.g. be described by</p>
<p>$$
\begin{aligned}
s_{0}= &amp; {\text { At }(\text { Father }, \text { Home }), \text { At }(\text { Present }, \text { PostOffice }), \text { IsAgent }(\text { Father }), \text { IsLocation }(\text { Home }), \
&amp; \text { IsLocation }(\text { PostOffice }), \text { IsObject }(\text { Present }) }
\end{aligned}
$$</p>
<p>where $\operatorname{At}(x, y)$ is a predicate for expressing that object (or agent) $x$ is at location $y$. The predicates IsAgent $(x)$, IsLocation $(x)$ and IsObject $(x)$ are true of agents, objects and locations, respectively (alternatively, one could use a sorted first-order language and then omit these predicates). Actions are described via so-called action schemas. The actions of going from one location to another, picking up an object and wrapping an object can be expressed by the STRIPS action schemas provided in Figure 2, where predicates have names starting with upper-case letters, and variables have names starting with lowercase letters. Each action schema has a name, a precondition and an effect. Preconditions and effects</p>
<div class="codehilite"><pre><span></span><code><span class="n">Action</span><span class="o">:</span><span class="w"> </span><span class="n">Go</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="w"> </span><span class="n">from</span><span class="o">,</span><span class="w"> </span><span class="n">to</span><span class="o">)</span>
<span class="n">PRECOND</span><span class="o">:</span><span class="n">At</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="w"> </span><span class="n">from</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedgeIsAgent</span><span class="o">(</span><span class="n">agt</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedgeIsLocation</span><span class="o">(</span><span class="n">from</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedge</span><span class="w"> </span><span class="n">IsLocation</span><span class="o">(</span><span class="n">to</span><span class="o">)</span>
<span class="n">EFFECT</span><span class="o">:</span><span class="n">At</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">to</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">negAt</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="w"> </span><span class="n">from</span><span class="o">)</span>
<span class="n">ACTION</span><span class="o">:</span><span class="n">PickUp</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">obj</span><span class="o">,</span><span class="n">from</span><span class="o">)</span>
<span class="n">PRECOND</span><span class="o">:</span><span class="n">At</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">from</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedgeAt</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span><span class="n">from</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">negHas</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">obj</span><span class="o">)\</span><span class="n">wedgeIsAgent</span><span class="o">(</span><span class="n">agt</span><span class="o">)\</span><span class="n">wedgeIsObject</span><span class="o">(</span><span class="n">obj</span><span class="o">)\</span><span class="n">wedgeIsLocation</span><span class="o">(</span><span class="n">from</span><span class="o">)</span>
<span class="n">EFFECT</span><span class="o">:</span><span class="n">Has</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">obj</span><span class="o">)\</span><span class="n">wedge</span><span class="o">~</span><span class="n">At</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span><span class="n">from</span><span class="o">)</span>
<span class="n">ACTION</span><span class="o">:</span><span class="n">Wrap</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">obj</span><span class="o">)</span>
<span class="n">PRECOND</span><span class="o">:</span><span class="n">Has</span><span class="o">(</span><span class="n">agt</span><span class="o">,</span><span class="n">obj</span><span class="o">)\</span><span class="n">wedge</span><span class="o">~</span><span class="n">Wrapped</span><span class="o">(</span><span class="n">obj</span><span class="o">)\</span><span class="n">wedgeIsAgent</span><span class="o">(</span><span class="n">agt</span><span class="o">)\</span><span class="n">wedgeIsObject</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span>
<span class="n">EFFECT</span><span class="o">:</span><span class="n">Wrapped</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span>
</code></pre></div>

<p>Figure 2: The set of STRIPS action schemas for the birthday present example.
are conjunctions of literals of the first-order language $\mathcal{L}$. A ground action is achieved by instantiating all variables of an action schema with constants of $\mathcal{L}$. For instance,</p>
<div class="codehilite"><pre><span></span><code><span class="n">Action</span><span class="o">:</span><span class="w"> </span><span class="n">Go</span><span class="o">(</span><span class="n">Father</span><span class="o">,</span><span class="w"> </span><span class="n">Home</span><span class="o">,</span><span class="w"> </span><span class="n">PostOffice</span><span class="o">)</span>
<span class="n">PRECOND</span><span class="o">:</span><span class="n">At</span><span class="o">(</span><span class="n">Father</span><span class="o">,</span><span class="w"> </span><span class="n">Home</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedge</span><span class="w"> </span><span class="n">IsAgent</span><span class="o">(</span><span class="n">Father</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedge</span><span class="w"> </span><span class="n">IsLocation</span><span class="o">(</span><span class="n">Home</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">wedge</span><span class="w"> </span><span class="n">IsLocation</span><span class="o">(</span><span class="n">PostOffice</span><span class="o">)</span>
<span class="n">EFFECT</span><span class="o">:</span><span class="n">At</span><span class="o">(</span><span class="n">Father</span><span class="o">,</span><span class="w"> </span><span class="n">PostOffice</span><span class="o">)</span><span class="w"> </span><span class="o">\</span><span class="n">negAt</span><span class="o">(</span><span class="n">Father</span><span class="o">,</span><span class="w"> </span><span class="n">Home</span><span class="o">)</span>
</code></pre></div>

<p>The precondition of a ground action describes what has to be true for the action to be applicable. ${ }^{2}$ It is easy to check that Go(Father, Home, PostOffice) is applicable in the initial state $s_{0}$ defined by (1) (all precondition atoms of the action occur in $s_{0}$ ). The effect of a ground action describes how the state is modified when the action is executed. The effect of Go(Father, Home, PostOffice) expresses that At(Father, PostOffice) becomes true, and that At(Father, Home) becomes false. Hence the result of executing Go(Father, Home, PostOffice) in $s_{0}$ will be the state</p>
<p>$$
\begin{aligned}
s_{1}= &amp; {\text { At(Father, PostOffice), At(Present, PostOffice), IsAgent(Father), IsLocation(Home), } \
&amp; \text { IsLocation(PostOffice), IsObject(Present) }}
\end{aligned}
$$</p>
<p>Any finite set of STRIPS action schemas $A$ induce a state-transition system (classical planning domain) $\Sigma=\left(S, A^{\prime}, \gamma\right)$ by:</p>
<ul>
<li>$S=2^{P}$, where $P$ is the set of ground atoms of $\mathcal{L}$.</li>
<li>$A^{\prime}={$ all ground instances of the action schemas in $A}$</li>
<li>$\gamma(s, a)= \begin{cases}(s-{\varphi \mid \neg \varphi$ is a negative literal of $\operatorname{EFFECT}(a)) \cup &amp; \ {\varphi \mid \varphi$ is a positive literal of $\operatorname{EFFECT}(a)} &amp; \text { if } s \models \operatorname{PrECOND}(a) \ \text { undefined } &amp; \text { otherwise }\end{cases}$</li>
</ul>
<p>The state-transition system induced by the STRIPS schemas of Figure 2 is provided in Figure 3. The rigid atoms, those that cannot change truth-value, have been omitted. Furthermore, each constant name is abbreviated by the capital letters it contains (so for instance PostOffice is abbreviated PO). Note that</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 3: The state-transition system induced by the action schemas of Figure 2.
the resulting state-transition system is isomorphic to the state-transition system of Figure 1.
The advantage of the current STRIPS representation over the previous pure state-transition representation is that there is now structure on states and actions. This for instance means that the current formulation is easily generalisable, e.g. we can add $n-1$ additional parcels to the initial state without any need to modify the underlying action schemas. The induced state-transition system would become exponentially bigger, as earlier noted, but the size of the STRIPS action schemas would stay the same (though the size of the description of the initial state would grow linearly with $n$ ).</p>
<p>A STRIPS planning task on a function-free first-order language $\mathcal{L}$ is $\left(A, s_{0}, \varphi_{g}\right)$ where $A$ is a set of STRIPS action schemas over $\mathcal{L}, s_{0}$ is a set of ground atoms over $\mathcal{L}$ and $\varphi_{g}$ is a conjunction of ground literals over $\mathcal{L}$ called the goal formula. Any STRIPS planning task $\left(A, s_{0}, \varphi_{g}\right)$ induces a classical planning task $\left(\Sigma, s_{0}, S_{g}\right)$ by letting $\Sigma$ be the state-transition system induced by $A$ and letting $S_{g}=\left{s \in S \mid s \models \varphi_{g}\right}$. A solution to a STRIPS planning task is then a solution to the induced classical planning task.</p>
<p>Example 3. The birthday present example can be represented as a STRIPS planning task $\left(A, s_{0}, \varphi_{g}\right)$ where $A$ is the set of action schemas of Figure 2, $s_{0}$ is defined by (1), and $\varphi_{g}=\operatorname{At}($ Father, Home $) \wedge$ Has(Father, Present) $\wedge$ Wrapped (Present). This is a STRIPS planning task on the function-free first order language $\mathcal{L}$ with binary predicate symbols At and Has, unary predicate symbols Wrapped, IsAgent, IsLocation and IsObject, and constant symbols Home, PostOffice, Father, Present. Consulting Figure 3, it is easy to show that a solution to this planning task is</p>
<p>$$
\begin{aligned}
\pi= &amp; \text { Go(Father, Home, PostOffice); PickUp(Father, Present, PostOffice); } \
&amp; \text { Go(Father, PostOffice, Home); Wrap(Father, Present). }
\end{aligned}
$$</p>
<p>In the field of automated planning, actions are always described compactly in an action description language like STRIPS (or e.g. PDDL, ADL or SAS ${ }^{+}$). A lot of research effort goes into finding ways to automatically derive efficient heuristics from action schemas, such that solutions can be found with minimal search. If given an induced state-transition system of a set of STRIPS action schemas, finding a solution to a planning task becomes a simple graph search problem (find a path from $s_{0}$ to a state in $S_{g}$ ). This can be done in linear time in the size of the state-transition system. However, as earlier noted, the induced state-transition system is often exponential in the size of the action schemas. Hence the complexity of computing solutions or deciding whether a solution exists (the plan existence problem) is in automated planning always measured in the size of the compact action schema representation. This is different from many formalisms in logic that consider plans or strategies and where complexity is measured in terms of the size of the state space. This is e.g. why epistemic planning based on ATEL</p>
<p>in [19] can be claimed to be tractable, even though already basic propositional STRIPS planning, which is much less expressive, is intractable. For most planning domains considered in automated planning (e.g. the planning domains of the International Planning Competition, IPC), calculating the entire statetransition system is computationally infeasible, and the goal is then for the heuristics to be sufficiently efficient that only the most relevant parts of the state-transition system are explored.</p>
<h1>4 Propositional planning tasks</h1>
<p>Even though STRIPS action schemas are formulated using first-order logic, for most purposes we can consider STRIPS as a planning formalism based on propositional logic. To see this, we first define propositional planning tasks.
Definition 3. A propositional planning task ${ }^{3}$ on a finite set of atomic propositions $P$ is $\left(A, s_{0}, \varphi_{g}\right)$ where</p>
<ul>
<li>$A$ is a finite set of actions. Each action is a pair $a=\langle\operatorname{pre}(a), \operatorname{post}(a)\rangle$ where $\operatorname{pre}(a)$ and $\operatorname{post}(a)$ are conjunctions of propositional literals over $P$. The element $\operatorname{pre}(a)$ is called the precondition of $a$ and $\operatorname{post}(a)$ its postcondition.</li>
<li>$s_{0}$ is the initial state, a propositional state over $P$ (a subset of $P$ ). ${ }^{4}$</li>
<li>$\varphi_{g}$ is the goal formula, a propositional formula over $P$.</li>
</ul>
<p>A propositional planning task $\left(A, s_{0}, \varphi_{g}\right)$ on $P$ induces a classical planning task $\left((S, A, \gamma), s_{0}, S_{g}\right)$ in the expected way (compare with the classical planning task induced by a STRIPS planning task defined in Section 3):</p>
<ul>
<li>$S=2^{p}$</li>
<li>$\gamma(s, a)= \begin{cases}(s-{p \mid \neg p \text { is a negative literal of } p o s t(a)) \cup &amp; \ {p \mid p \text { is a positive literal of } p o s t(a)} &amp; \text { if } s \models p r e(a) \ \text { undefined } &amp; \text { otherwise }\end{cases}$</li>
<li>$S_{g}=\left{s \in S \mid s \models \varphi_{g}\right}$.</li>
</ul>
<p>A solution to a propositional planning task is any solution to the induced classical planning task.
For any function-free first-order language $\mathcal{L}$, let $P_{\mathcal{L}}$ denote the set of ground atoms of $\mathcal{L}$. The set $P_{\mathcal{L}}$ can be thought of as the atomic propositions of a propositional language. Any quantifier-free ground formula of $\mathcal{L}$ is then at the same time a formula of propositional logic over $P_{\mathcal{L}}$. Any STRIPS planning task $\left(A, s_{0}, \varphi_{g}\right)$ on $\mathcal{L}$ induces a propositional planning task $\left(A^{\prime}, s_{0}, \varphi_{g}\right)$ on $P_{\mathcal{L}}$ by simply letting</p>
<p>$$
A^{\prime}={\langle\operatorname{Precond}(a), \operatorname{Effect}(a)\rangle \mid a \text { is a ground instance of an action schema in } A} .
$$</p>
<p>It is easy to show that the STRIPS planning task $\left(A, s_{0}, \varphi_{g}\right)$ and its induced propositional planning task $\left(A^{\prime}, s_{0}, \varphi_{g}\right)$ both induce the same classical planning task. They thus also have the same solutions. Note that the conventions for preconditions and effects are a bit different in propositional planning tasks than in STRIPS planning tasks. We now write precondition and effect pairs of an action $a$ as a pair of the form $\langle\operatorname{pre}(a), \operatorname{post}(a)\rangle$, where we have also relabelled effects as postconditions. The point of both these changes is to gradually move away from the classical conventions of STRIPS planning into the conventions of dynamic epistemic logic that we will later present a planning framework based on.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Example 4. The birthday present example can be represented as the propositional planning task $\left(A, s_{0}, \varphi_{g}\right)$ below. It is a simplified version of the propositional planning task induced by the STRIPS planning task of Example 3, where we have done away with the rigid atoms that are no longer necessary. In the definitions below, Agt is a set of agent names (including Father), Loc is a set of locations (including Home and PostOffice) and $O b j$ is a set of objects (including Present).</p>
<ul>
<li>$A={\mathrm{Go}($ agt, from, to $) \mid$ agt $\in$ Agt \&amp; from, to $\in$ Loc $} \cup{\operatorname{PickUp}($ agt, obj, from $) \mid$ agt $\in$ Agt \&amp; obj $\in$ Obj \&amp; from $\in$ Loc $} \cup{\operatorname{Wrap}($ agt, obj $) \mid$ agt $\in$ Agt \&amp;obj $\in$ Obj $}$ where, for all agt $\in$ Agt, all from, to $\in$ Loc and all obj $\in O b j$,</li>
<li>Go (agt, from, to) $=\langle\mathrm{At}($ agt, from $), \mathrm{At}($ agt, to $) \wedge \neg \mathrm{At}($ agt, from $)\rangle$</li>
<li>PickUp (agt, obj, from) $=\langle\mathrm{At}($ agt, from $) \wedge \mathrm{At}($ obj, from $) \wedge \neg \mathrm{Has}($ agt, obj $), \mathrm{Has}($ agt, obj $)\rangle$</li>
<li>$\operatorname{Wrap}($ agt, obj $)=\langle\operatorname{Has}($ agt, obj $) \wedge \neg \operatorname{Wrapped}($ obj $), \operatorname{Wrapped}($ obj $)\rangle$.</li>
<li>$s_{0}={$ At $($ Father, Home $), \mathrm{At}($ Present, PostOffice $}}$.</li>
<li>$\varphi_{g}=\operatorname{At}($ Father, Home $) \wedge \operatorname{Has}($ Father, Present $) \wedge \operatorname{Wrapped}($ Present $)$.</li>
</ul>
<p>Note that expressions like $\mathrm{At}($ agt, from $)$ with $a g t \in A g t$ and from $\in L o c$ are no longer considered as ground atoms of the original first-order language $\mathcal{L}$, but as atoms of propositional logic over $P_{\mathcal{L}}$. A solution to this planning task is exactly as to the original STRIPS version: $\pi=\mathrm{Go}($ Father, Home, PostOffice); PickUp(Father, Present, PostOffice); Go(Father, PostOffice, Home); Wrap(Father, Present).</p>
<p>Since any STRIPS planning task can be propositionalised as above, it means we can now work in a simpler formalism, propositional logic, which also makes it easier to generalise the formalism to e.g. planning with partial observability, non-determinism or epistemic planning. ${ }^{5}$</p>
<h1>5 Belief states, partial observability, and conditional actions</h1>
<p>Consider the birthday present example formalised as the propositional planning task of Example 4. Assume now that there is not only one, but two, local post offices, and the father does not know in which one the parcel is. We can assume Loc correspondingly contains two constants, PostOffice1 and PostOffice2. To represent this modified planning task we need two changes in the underlying formalism: belief states and conditional actions. We need belief states to represent the uncertainty of the agent. A belief state in this setting is a set of propositional states, that is, a set of subsets of $P$ (where $P$ is the set of atomic propositions). The initial belief state of our agent is now:</p>
<p>$$
s_{0}={{\mathrm{At}(\text { Father, Home }), \mathrm{At}(\text { Present, PostOffice1 })},{\mathrm{At}(\text { Father, Home }), \mathrm{At}(\text { Present, PostOffice2 })}}
$$</p>
<p>The state $s_{0}$ contains two propositional states, where the first one represents the situation where the present is in PostOffice1, and the second presents the situation where it is in PostOffice2. We define a propositional formula $\varphi$ to be true in a belief state $s$, written $s \models \varphi$, if $\varphi$ is true in all propositional states of $s$. Hence we have
(1) $s_{0} \models \mathrm{At}($ Father, Home $)$
(2) $s_{0} \not \models \mathrm{At}($ Present, PostOffice1)</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>(3) $s_{0} \not \models \operatorname{At}($ Present, PostOffice2)
(4) $s_{0} \models \operatorname{At}($ Present, PostOffice1) $\vee \operatorname{At}($ Present, PostOffice2).</p>
<p>This represents the internal perspective of the father in the belief state $s_{0}$ : He can verify (knows) that he is home (1) and can verify (knows) that the present is in PostOffice1 or PostOffice2 (4), but doesn't know which (2-3). Planning in the space of belief states rather than propositional states is called planning under partial observability (and planning on propositional states is then called planning under full observability). In the following, and in line with modal logic, we will call the elements of belief states worlds.</p>
<p>To represent the modified example we also need to allow conditional actions. The agent can attempt to pick up the present at either of the two post offices, but whether he is succesful is conditional on whether it is the correct one. Symmetric to the generalisation from representing states as subsets of $P$ to sets of such subsets, we can generalise actions from being pairs $\langle\operatorname{pre}(a), \operatorname{post}(a)\rangle$ to be sets of such pairs. We can then represent the attempted pickup action by:</p>
<div class="codehilite"><pre><span></span><code>\(\operatorname{TryPickUp}(\) agt, obj, from \()=\{\)
    \(\langle\operatorname{At}(\) agt, from \() \wedge \operatorname{At}(o b j\), from \() \wedge \neg \operatorname{Has}(\) agt, obj \(), \operatorname{Has}(\) agt, obj \() \wedge \neg \operatorname{At}(o b j\), from \()\) \rangle\)
    \(\langle\operatorname{At}(\) agt, from \() \wedge \neg \operatorname{At}(o b j\), from \(), T\rangle\)
\}
</code></pre></div>

<p>where the postcondition $T$ means that nothing changes. From now on we will, in line with the literature on dynamic epistemic logic, call pairs $\langle\operatorname{pre}(e), \operatorname{post}(a)\rangle$ events. So a conditional action like the one above is a set of events: a set of the possible things that might happen when the action is executed. The TryPickUp action above expresses that if the agent and the object are in the same location, the object will be successfully picked up (the first event of the action), and otherwise nothing will happen (the second event of the action).</p>
<p>Given a belief state $s$ represented as a set of worlds and an action action $a$ represented as a set of events, we can define a generalised transition function by</p>
<p>$$
\gamma(s, a)={\gamma(w, e) \mid w \in s, e \in a, w \models \operatorname{pre}(e)} .{ }^{6}
$$</p>
<p>Thus, e.g., where we abbreviate PostOffice1 by PO1, PostOffice2 by PO2 and Home by H:</p>
<div class="codehilite"><pre><span></span><code><span class="err">\</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">1</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">gamma</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">0</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">Go</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="nf">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="o">=</span><span class="err">\</span><span class="n">gamma</span><span class="p">(</span><span class="err">\{\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">),</span><span class="w"> </span><span class="k">At</span><span class="p">(</span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}</span><span class="p">,</span><span class="err">\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">),</span><span class="w"> </span><span class="k">At</span><span class="p">(</span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}\}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">Go</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="o">=</span><span class="err">\{\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">),</span><span class="w"> </span><span class="k">At</span><span class="p">(</span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}</span><span class="p">,</span><span class="err">\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">),</span><span class="w"> </span><span class="k">At</span><span class="p">(</span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}\}\</span><span class="p">)</span>
<span class="err">\</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">2</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">gamma</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">1</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">TryPickUp</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="nf">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="o">=</span><span class="err">\{\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">),</span><span class="w"> </span><span class="n">Has</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}</span><span class="p">,</span><span class="err">\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">),</span><span class="w"> </span><span class="k">At</span><span class="p">(</span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}\}\</span><span class="p">)</span>
<span class="err">\</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">3</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">gamma</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">2</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">Go</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="nf">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="o">=</span><span class="err">\{\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">),</span><span class="w"> </span><span class="n">Has</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}</span><span class="p">,</span><span class="err">\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">),</span><span class="w"> </span><span class="k">At</span><span class="p">(</span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}\}\</span><span class="p">)</span>
<span class="err">\</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">4</span><span class="err">}</span><span class="o">=</span><span class="err">\</span><span class="n">gamma</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="n">s_</span><span class="err">{</span><span class="mi">3</span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="n">operatorname</span><span class="err">{</span><span class="n">TryPickUp</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="w"> </span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="nf">right</span><span class="p">.</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="err">\</span><span class="p">(</span><span class="o">=</span><span class="err">\{\{\</span><span class="n">operatorname</span><span class="err">{</span><span class="k">At</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">),</span><span class="w"> </span><span class="n">Has</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="err">\}\}\</span><span class="p">)</span>
</code></pre></div>

<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>$$
\begin{aligned}
s_{5} &amp; =\gamma\left(s_{4}, \text { Go(Father, PO2, Home) }\right) \
&amp; ={{\text { At(Father, Home), Has(Father, Present) }}} \
s_{6} &amp; =\gamma\left(s_{5}, \text { Wrap(Father, Present) }\right) \
&amp; ={{\text { At(Father, Home), Has(Father, Present), Wrapped(Present) }}}
\end{aligned}
$$</p>
<p>Note how the belief state goes down from cardinality 2 to cardinality 1 when going from $s_{3}$ to $s_{4}$. At plan time, when deliberating about the possible action sequences, the father doesn't know whether he will have the present after having visited only PostOffice1, and he hence has to represent both possibilities. In $s_{4}$, however, he knows, even at plan time, that he will have the present, since if he didn't get it at PostOffice1, he will be sure to get it at PostOffice2. The calculations above show that a solution to the modified planning task is</p>
<p>$$
\begin{aligned}
\pi= &amp; \text { Go(Father, H, PO1); TryPickUp(Father, Present, PO1);Go(Father, PO1, PO2); } \
&amp; \text { TryPickUp(Father, Present, PO2);Go(Father, PO2, Home); Wrap(Father, Present). }
\end{aligned}
$$</p>
<p>There are, unfortunately, several weaknesses in the current approach. An important weakness is that the formalism does so far not distinguish between between the kind of uncertainty the father has in $s_{1}$ and the kind of uncertainty he has in $s_{2}$. In $s_{1}$, the father has run time uncertainty [26] about the location of the present. This means that even at execution time, when the action Go(Father, H, PO1) has been executed in the initial state, the father still does not know which of the two worlds of $s_{1}$ is the actual one. In $s_{2}$, however, he should only have plan time uncertainty [26]. This means that when he is deliberating about the possible action sequences and their potential outcomes, he can not tell which of the two worlds of $s_{2}$ is going to be realised, but at execution time he will know. This is because attempting to pick up the present at PO1 has the side-effect of informing him whether the present is there or not. The distinction between plan time and run time uncertainty is not represented in our current formalism, since both kinds of uncertainty are modelled exactly the same: by simply having a set of worlds representing those situations that the agent cannot distinguish between (whether at plan time or at run time).</p>
<p>The simplest and most common solution to this problem in the automated planning literature (see e.g. $[17,28])$ is to treat observability as a static partition on the set of possible worlds, so that certain possible worlds are always distinguishable and others never are. What becomes distinguishable at execution time is then hardcoded into this observability partition. This approach is however insufficient for our purposes. For instance, assume the present is initially located at PO2. Assume further that the father initially goes to PO1 to attempt picking it up and then goes home again. Then afterwards he will be in exactly the same world as initially, namely the world satisfying $\mathrm{At}($ Father, Home $) \wedge \mathrm{At}($ Present, PO2). But he will not be in the same information state: He learned that the present is not at PO1 (and therefore also learned that it must be at PO2). To be able to represent this in an appropriate way we need to take the final step into planning based on epistemic logic. ${ }^{7}$</p>
<p><sup id="fnref6:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>6 Epistemic logic</h1>
<p>Let $P$ be a finite set of atomic propositions (often we will take $P$ to be the set of ground atoms of a function-free first-order language as in the previous sections). Let $\mathcal{A}$ be a finite set of agents. The epistemic language on $P, \mathcal{A}$, denoted $\mathcal{L}_{\mathrm{KC}}(P, \mathcal{A})$, is generated by the following BNF:</p>
<p>$$
\varphi::=\top|\perp| p|\neg \varphi|\varphi \wedge \varphi| K_{i} \varphi \mid C \varphi
$$</p>
<p>where $p \in P$ and $i \in \mathcal{A}$. We read $K_{i} \varphi$ as "agent $i$ knows $\varphi$ " and $C \varphi$ as "it is common knowledge that $\varphi$ ". When $P$ and $\mathcal{A}$ are clear from the context (or no assumptions about them are made), we will write $\mathcal{L}<em _mathrm_KC="\mathrm{KC">{\mathrm{KC}}$ for $\mathcal{L}</em>}}(P, \mathcal{A}) . \mathcal{L<em _mathrm_KC="\mathrm{KC">{\mathrm{K}}$ is the language $\mathcal{L}</em>$ without the $C$ modality.}</p>
<p>Definition 4. Let $P$ and $\mathcal{A}$ be as above. An epistemic model on $P, \mathcal{A}$ is $\mathcal{M}=\left(W,\left(\sim_{i}\right)_{i \in \mathcal{A}}, L\right)$ where</p>
<ul>
<li>The domain $W$ is a non-empty finite set of worlds.</li>
<li>$\sim_{i} \subseteq W \times W$ is an equivalence relation called the indistinguishability relation for agent $i \in \mathcal{A} .^{8}$</li>
<li>$L: W \rightarrow 2^{P}$ is a labelling function assigning a propositional valuation (a set of propositions) to each world.</li>
</ul>
<p>For $W_{d} \subseteq W$, the pair $\left(\mathcal{M}, W_{d}\right)$ is called an epistemic state (or simply a state), and the worlds of $W_{d}$ are called the designated worlds. A state is called global if $W_{d}={w}$ for some world $w$ (called the actual world), and we then often write $(\mathcal{M}, w)$ instead of $(\mathcal{M},{w})$. We use $S^{\mathrm{gl}}(P, \mathcal{A})$ to denote the set of global states (or simply $S^{\mathrm{gl}}$ if $P$ and $\mathcal{A}$ are clear from the context). For any state $s=\left(\mathcal{M}, W_{d}\right)$ we let Globals $(s)=\left{(\mathcal{M}, w) \mid w \in W_{d}\right}$. A state $\left(\mathcal{M}, W_{d}\right)$ is called a local state for agent $i$ if $W_{d}$ is closed under $\sim_{i}$ (that is, if $w \in W_{d}$ and $w \sim_{i} v$ implies $v \in W_{d}$ ). Given a state $s=\left(\mathcal{M}, W_{d}\right)$, the associated local state of agent $i$, denoted $s^{i}$, is $\left(\mathcal{M},\left{v \mid v \sim_{i} w\right.\right.$ and $\left.\left.w \in W_{d}\right}\right)$.
Definition 5. Let $\left(\mathcal{M}, W_{d}\right)$ be a state on $P, \mathcal{A}$ with $\mathcal{M}=\left(W,\left(\sim_{i}\right)<em _mathrm_KC="\mathrm{KC">{i \in \mathcal{A}}, L\right)$. For $i \in \mathcal{A}, p \in P$ and $\varphi, \psi \in$ $\mathcal{L}</em>)$, we define truth as follows:}}(P, \mathcal{A</p>
<table>
<thead>
<tr>
<th style="text-align: left;">$\left(\mathcal{M}, W_{d}\right) \models \varphi$</th>
<th style="text-align: left;">iff</th>
<th style="text-align: left;">$(\mathcal{M}, w) \models \varphi$ for all $w \in W_{d}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">$(\mathcal{M}, w) \models p$</td>
<td style="text-align: left;">iff</td>
<td style="text-align: left;">$p \in L(w)$</td>
</tr>
<tr>
<td style="text-align: left;">$(\mathcal{M}, w) \models \neg \varphi$</td>
<td style="text-align: left;">iff</td>
<td style="text-align: left;">$\mathcal{M}, w \not \models \varphi$</td>
</tr>
<tr>
<td style="text-align: left;">$(\mathcal{M}, w) \models \varphi \wedge \psi$</td>
<td style="text-align: left;">iff</td>
<td style="text-align: left;">$\mathcal{M}, w \models \varphi$ and $\mathcal{M}, w \models \psi$</td>
</tr>
<tr>
<td style="text-align: left;">$(\mathcal{M}, w) \models K_{i} \varphi$</td>
<td style="text-align: left;">iff</td>
<td style="text-align: left;">$(\mathcal{M}, v) \models \varphi$ for all $v \sim_{i} w$</td>
</tr>
<tr>
<td style="text-align: left;">$(\mathcal{M}, w) \models C \varphi$</td>
<td style="text-align: left;">iff</td>
<td style="text-align: left;">$(\mathcal{M}, v) \models \varphi$ for all $v \sim^{*} w$</td>
</tr>
</tbody>
</table>
<p>where $\sim^{*}$ is the transitive closure of $\bigcup_{i \in \mathcal{A}} \sim_{i}$.
Note that a formula $\varphi$ is defined to be true in a non-global state $\left(\mathcal{M}, W_{d}\right)$ iff it is true in each of the global states $(\mathcal{M}, w), w \in W_{d}$, it contains. This is consistent with our previous definition of truth in belief states as truth in all worlds of that state.</p>
<p>Example 5. Let $P=P_{\mathcal{L}}$, where $\mathcal{L}$ is the function-free first-order language of Example 3 extended with constant symbols PostOffice1 and PostOffice2 and let $\mathcal{A}={$ Father $}$. Consider the initial state $s_{0}$ defined by (2). We can represent this via an epistemic model $\mathcal{M}=\left(W, \sim_{\text {Father }}, L\right)$ on $P, \mathcal{A}$ with $W=\left{w_{1}, w_{2}\right}, \sim_{\text {Father }}=W \times W, L\left(w_{1}\right)={$ At $($ Father, Home $), \mathrm{At}($ Present, PostOffice1) $}$ and $L\left(w_{2}\right)=$</p>
<p><sup id="fnref7:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>${\mathrm{At}($ Father, Home $), \mathrm{At}($ Present, PostOffice2) $}$. Graphically, this epistemic model is represented as follows, using the abbreviations from earlier:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Father</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$w_{1}: \mathrm{At}($ Father, H$), \mathrm{At}($ Present, PO1 $)$</td>
<td style="text-align: center;">$w_{2}: \mathrm{At}($ Father, H$), \mathrm{At}($ Present, PO2 $)$</td>
</tr>
</tbody>
</table>
<p>Here the nodes represent the worlds and the edges represent the indistinguishability relation (reflexive edges left out). Each node is labelled by its name and the set of atomic propositions true at the world. Consider the case where initially the present is at PostOffice2. This means that the actual world is $w_{2}$, and this situation can be represented by the global state $s_{0}=\left(\mathcal{M}, w_{2}\right)$, that we graphically present as</p>
<p>$$
s_{0}=\quad w_{1}: \mathrm{At}(\text { Father }, \mathrm{H}), \mathrm{At}(\text { Present }, \mathrm{PO1}) \quad w_{2}: \mathrm{At}(\text { Father }, \mathrm{H}), \mathrm{At}(\text { Present }, \mathrm{PO} 2)
$$</p>
<p>We use $\otimes$ for designated worlds. The planning agent, Father, does not have access to this global state, since he considers it equally possible that the present is at PO1 ( $w_{1}$ and $w_{2}$ are indistinguishable to him). The internal initial state of the father is his associated local state $s_{0}^{\text {Father }}=(\mathcal{M}, W)$ :</p>
<p>$$
s_{0}^{\text {Father }}=\quad w_{1}: \text { At(Father, H), At(Present, PO1) Father }
$$</p>
<p>We have $s \models \mathrm{At}($ Present, PO2) but $s^{\text {Father }} \not \equiv \mathrm{At}($ Present, PO2): From the outside global perspective (the perspective of an omniscient external observer) it can initially be verified that the present is at PO2, but not from the perspective of the planning agent, Father, himself.</p>
<p>In general, any belief state $B=\left{s_{1}, \ldots, s_{n}\right}$ (set of propositional states) can be equivalently represented as an epistemic state $((W, \sim, L), W)$ with $W=\left{w_{1}, \ldots, w_{n}\right}, \sim=W \times W, L\left(w_{i}\right)=s_{i}$ for all $i=1, \ldots, n$.</p>
<p>With epistemic models we can also capture the distinction between run time and plan time uncertainty. When the father contemplates on the possible action sequences to execute in his local state $s^{\text {Father }}$, the epistemic state representing the result of executing the action sequence</p>
<p>$$
\text { Go(Father, H, PO1); TryPickUp(Father, Present, PO1); Go(Father, PO1, H) }
$$</p>
<p>will be</p>
<p>$$
s^{\prime}=\quad w_{1}: \text { At(Father, H), Has(Father, Present) } \quad w_{2}: \text { At(Father, H), At(Present, PO2) }
$$</p>
<p>There is still two designated worlds: the agent do not at plan time know which one it will end up in. But they are now not indistinguishable (there is no indistinguishability edge connecting them): at run time, when the plan is executed, the agent will be able to tell whether it is in $w_{1}$ or $w_{2}$. In fact we have e.g. $s^{\prime} \models K_{\text {Father }} \mathrm{At}($ Present, PO2 $) \vee K_{\text {Father }} \neg \mathrm{At}($ Present, PO2 $)$ : In $s^{\prime}$, the father knows whether the present is at PO2 or not. More generally, let $s=\left(\mathcal{M}, W_{d}\right)$ be any local state of an agent $i \in \mathcal{A}$ and let $w_{1}, w_{2} \in W_{d}$. The worlds $w_{1}$ and $w_{2}$ are called run time indistinguishable (for agent $i$ ) if $w_{1} \sim_{i} w_{2}$. Otherwise, they are plan time indistinguishable.</p>
<p>The generalisation from belief states (in the standard AI sense of sets of propositional states [29]) to epistemic states (in the sense of epistemic logic) also allows us to represent planning tasks involving multiple agents. E.g. the father might want to make sure that his daughter doesn't get to know that he has a present for her (it is supposed to be a surprise). In this case, we could reformulate the goal as</p>
<p>$$
\varphi_{g}=\operatorname{At}(\text { Father }, \text { Home }) \wedge \operatorname{Has}(\text { Father }, \text { Present }) \wedge \operatorname{Wrapped}(\text { Present }) \wedge \neg K_{\text {Daughter }} \operatorname{Has}(\text { Father }, \text { Present })
$$</p>
<h1>7 Dynamic epistemic logic</h1>
<p>Generalising from propositional states to epistemic states amounted to generalise from propositional valuations to multisets of such valuations with an added indistinguishability relation for each agent. We can now apply the exact same trick to generalise from propositional actions to epistemic actions. A propositional action is an event $\langle\operatorname{pre}(a), \operatorname{post}(a)\rangle$, so an epistemic action will be a multiset of events with an indistinguishability relation for each agent. This is exactly how epistemic actions are defined in dynamic epistemic logic (DEL) with postconditions [12]. Such structures are called event models or action models.
Definition 6. An action model on $P, \mathcal{A}$ is $\mathcal{E}=\left(E,\left(\sim_{i}\right)_{i \in \mathcal{A}}\right.$, pre, post $)$ where</p>
<ul>
<li>The domain $E$ is a non-empty finite set of events.</li>
<li>$\sim_{i} \subseteq E \times E$ is an equivalence relation called the indistinguishability relation for agent $i \in \mathcal{A}$.</li>
<li>pre $: E \rightarrow \mathcal{L}_{\mathrm{KC}}(P, \mathcal{A})$ assigns a precondition to each event.</li>
<li>post $: E \rightarrow \mathcal{L}<em d="d">{\mathrm{KC}}(P, \mathcal{A})$ assigns a postcondition to each event. For all $e \in E, \operatorname{post}(e)$ is a conjunction of literals over $P$ (including the special atom $\top$ ). ${ }^{9}$
For $E</em>\right}\right)$.} \subseteq E$, the pair $\left(\mathcal{E}, E_{d}\right)$ is called an epistemic action (or simply an action), and the events in $E_{d}$ are called the designated events. An action is called global if $E_{d}={e}$ for some event $e$, and we then often write $(\mathcal{E}, e)$ instead of $(\mathcal{E},{e})$. Similar to states, $\left(\mathcal{E}, E_{d}\right)$ is called a local action for agent $i$ when $E_{d}$ is closed under $\sim_{i}$. Given an action $a=\left(\mathcal{E}, E_{d}\right)$, the associated local action of agent $i \in \mathcal{A}$, denoted $a^{i}$, is $\left(\mathcal{E},\left{f \in E \mid f \sim_{i} e\right.\right.$ for some $\left.\left.e \in E_{d</li>
</ul>
<p>Any propositional action $a=\langle\operatorname{pre}(a), \operatorname{post}(a)\rangle$ trivially induces an epistemic action $(\mathcal{E},{e})$ with $\mathcal{E}=({e},{(e, e)}$, pre, post $)$ where $\operatorname{pre}(e)=\operatorname{pre}(a)$ and $\operatorname{post}(e)=\operatorname{post}(a)$.
Example 6. We can now finally, using action models, give a satisfactory formal representation of the TryPickUp action of Section 5, cf. (3):</p>
<p>$$
\begin{aligned}
&amp; \operatorname{TryPick} \operatorname{Up}(a g t, o b j, f r o m)= \
&amp; \quad \nsim \
&amp; e_{1}:\langle\operatorname{At}(a g t, f r o m) \wedge \operatorname{At}(o b j, f r o m) \wedge \neg \operatorname{Has}(a g t, o b j), \quad e_{2}:\langle\operatorname{At}(a g t, f r o m) \wedge \neg \operatorname{At}(o b j, f r o m), \
&amp; \operatorname{Has}(a g t, o b j) \wedge \neg \operatorname{At}(o b j, f r o m)\rangle \quad \top\rangle
\end{aligned}
$$</p>
<p><sup id="fnref8:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>We here use the same conventions for representing action models graphically as we did for epistemic models. Note that there is no indistinguishability edge for Father: He will at run time observe whether the action is succesful $\left(e_{1}\right)$ or not $\left(e_{2}\right)$. But at plan time he does not know which one it will be, which is why both events are designated.</p>
<p>The state-transition function of DEL is called product update, and is denoted by an infix $\otimes$ symbol. So instead of writing $\gamma(s, a)$, one writes $s \otimes a$.
Definition 7. Let a state $s=\left(\mathcal{M}, W_{d}\right)$ and an action $a=\left(\mathcal{E}, E_{d}\right)$ be given with $\mathcal{M}=\left(W,\left(\sim_{i}\right)<em i="i">{i \in \mathcal{A}}, L\right)$ and $\mathcal{E}=\left(E,\left(\sim</em>\right)<em i="i">{i \in \mathcal{A}}\right.$, pre, post $)$. Then the product update of $s$ with $a$ is $s \otimes a=\left(\left(W^{\prime},\left(\sim</em>\right)}^{\prime<em d="d">{i \in \mathcal{A}}, L^{\prime}\right), W</em>\right)$ where}^{\prime</p>
<ul>
<li>$W^{\prime}={(w, e) \in W \times E \mid(\mathcal{M}, w) \models \operatorname{pre}(e)}$</li>
<li>$\sim_{i}^{\prime}=\left{\left((w, e),\left(w^{\prime}, e^{\prime}\right)\right) \in W^{\prime} \times W^{\prime} \mid w \sim_{i} w^{\prime}\right.$ and $\left.e \sim_{i} e^{\prime}\right}$</li>
<li>$L^{\prime}(p)=(L(p)-{p \mid \neg p$ is a negative literal of $\operatorname{post}(e)) \cup{p \mid p$ is a positive literal of $\operatorname{post}(e)}$</li>
<li>$W_{d}^{\prime}=\left{(w, e) \in W^{\prime} \mid w \in W_{d}\right.$ and $\left.e \in E_{d}\right}$.</li>
</ul>
<p>We say that an action $\left(\mathcal{E}, E_{d}\right)$ is applicable in a state $\left(\mathcal{M}, W_{d}\right)$ if for all $w \in W_{d}$ there is an event $e \in E_{d}$ such that $(\mathcal{M}, w) \models \operatorname{pre}(e)$.</p>
<p>Note that this is the obvious generalisation to the epistemic setting of the state-transition function for belief states and sets of events given in (4). In particular, if $s^{\prime}$ is the epistemic state induced by a belief state $s$, and $a^{\prime}$ is the action model induced by a propositional action $a$, then $s^{\prime} \otimes a^{\prime}$ is the epistemic state induced by $\gamma(s, a)$.</p>
<p>Let $i \in \mathcal{A}$ be an agent, let $\left(\mathcal{M}, W_{d}\right)$ be a local state for $i$ and let $\left(\mathcal{E}, E_{d}\right)$ be a local action for $i$. Then $\left(\mathcal{M}, W_{d}\right)$ and $\left(\mathcal{E}, E_{d}\right)$ represent agent $i$ 's view on a particular state and action. According to the definition above, the action $\left(\mathcal{E}, E_{d}\right)$ is then applicable in the state $\left(\mathcal{M}, W_{d}\right)$ if, for any of the worlds agent $i$ considers possible (any world $w$ in $W_{d}$ ), the action specifies at least one applicable event that agent $i$ considers possible (an event $e$ in $E_{d}$ with $(\mathcal{M}, w) \models \operatorname{pre}(e)$ ). In other words, the action is applicable from the perspective of agent $i$.</p>
<h1>8 Epistemic planning tasks</h1>
<p>We now have all the necessary ingredients for defining planning tasks in epistemic planning based on DEL. We simply define these as for propositional planning tasks, except we replace propositional actions by epistemic actions, propositional states by epistemic states and propositional goal formulas by epistemic goal formulas.
Definition 8. An epistemic planning task on $P, \mathcal{A}$ is $\left(A, s_{0}, \varphi_{g}\right)$ where $A$ is a finite set of epistemic actions on $P, \mathcal{A}, s_{0}$ is an epistemic state on $P, \mathcal{A}$, and $\varphi_{g} \in \mathcal{L}<em 0="0">{\mathrm{KC}}(P, \mathcal{A})$. We say that $\left(A, s</em>$}, \varphi_{g}\right)$ is an epistemic planning task for agent $i \in \mathcal{A}$ if $s_{0}$ and all $a \in A$ are local for $i$. A planning task $\left(A, s_{0}, \varphi_{g}\right)$ is called global if $s_{0}$ is global. Given any planning task $\Pi=\left(A, s_{0}, \varphi_{g}\right)$, the associated local planning task of agent $i$, denoted $\Pi^{i}$, is $\left(\left{a^{i} \mid a \in A\right}, s_{0}^{i}, \varphi_{g}\right) .^{10</p>
<p>An epistemic planning task $\left(A, s_{0}, \varphi_{g}\right)$ induces a classical planning task $\left((S, A, \gamma), s_{0}, S_{g}\right)$ in a similar manner to propositional planning tasks:</p>
<p><sup id="fnref9:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<ul>
<li>$S=\left{s_{0} \otimes a_{1} \otimes \cdots \otimes a_{n} \mid n \in \mathbb{N}\right.$ and $\left.a_{1}, \ldots, a_{n} \in A\right}$</li>
<li>$\gamma(s, a)= \begin{cases}s \otimes a &amp; \text { if } a \text { is applicable in } s \ \text { undefined } &amp; \text { otherwise }\end{cases}$</li>
<li>$S_{g}=\left{s \in S \mid s \models \varphi_{g}\right}$.</li>
</ul>
<p>As for propositional planning tasks, we can then define a solution to an epistemic planning task $\left(A, s_{0}, \varphi_{g}\right)$ to be a solution to the induced classical planning task. This is equivalent to the existence of a sequence of actions $a_{1} ; \cdots ; a_{n}$ from $A$ such that each $a_{i}$ is applicable in $s_{0} \otimes a_{1} \otimes \cdots \otimes a_{i-1}(i \leq n)$ and $s_{0} \otimes a_{1} \otimes$ $\cdots \otimes a_{n} \models \varphi_{g}$.
Example 7. Let us provide a full formalisation of the birthday present example as an epistemic planning task. The epistemic action TryPickUp was presented in Example 6. The actions Go(agt,from,to) and $\operatorname{Wrap}(a g t, o b j)$ are simply the ones induced by their propositional counterparts. The initial state is the state $s_{0}^{\text {Father }}$ of Example 5. The goal formula is $\varphi_{g}=\operatorname{At}($ Father, Home $) \wedge \operatorname{Has}($ Father, Present $) \wedge$ Wrapped (Present). Clearly the resulting planning task is a planning task for agent Father. We now get</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Note that the indistinguishability link between the two worlds is being cut when going from $s_{1}$ to $s_{2}$, since the two events of TryPickUp are distinguishable. We further get</p>
<p><img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Since the two worlds of $s_{6}$ have identical labels, we can take the bisimulation contraction which will preserve only one of them. ${ }^{11}$ We clearly have $s_{5} \models \varphi_{g}$. Hence the action sequence (5) above is a solution to the epistemic planning task. We could actually replace the TryPickUp(Father, Present, PO2) action in this plan with the epistemic action induced by the original non-conditional PickUp(Father, Present, PO2) action. This is because the father will know that the present is at PO2 when he gets there (since it wasn't at PO1).</p>
<p><sup id="fnref10:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>9 Conditional epistemic planning</h1>
<p>The plan found in the previous example, Example 7, is clearly not always optimal. If the father gets the present already at PO1, there is no need to go to PO2 as well. So in this case the father will be able to reach the goal in 4 instead of 6 steps. But the father will of course not know this until run time (after having attempted to pick up the present at PO1). A sequential plan (sequence of actions) can not capture this, since it has a fixed number of actions, independent of the action outcomes. So we need to move to conditional plans (not to be confused with conditional actions that we already have). A conditional plan for the current planning task could e.g. be formulated as the following program</p>
<div class="codehilite"><pre><span></span><code><span class="k">Go</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">PO1</span><span class="p">);</span><span class="w"> </span><span class="n">TryPickUp</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="n">Present</span><span class="p">,</span><span class="n">PO1</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="err">\</span><span class="p">(</span><span class="n">K_</span><span class="err">{\</span><span class="nc">text</span><span class="w"> </span><span class="err">{</span><span class="n">Father</span><span class="w"> </span><span class="err">}}</span><span class="w"> </span><span class="err">\</span><span class="n">mathrm</span><span class="err">{</span><span class="n">Has</span><span class="err">}</span><span class="p">(</span><span class="err">\</span><span class="p">)</span><span class="w"> </span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">Go</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w"> </span><span class="n">Wrap</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">)</span><span class="w"> </span><span class="k">else</span>
<span class="k">Go</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO1</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">);</span><span class="w"> </span><span class="n">TryPickUp</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">);</span><span class="w"> </span><span class="k">Go</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">PO2</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">);</span>
<span class="n">Wrap</span><span class="p">(</span><span class="n">Father</span><span class="p">,</span><span class="w"> </span><span class="n">Present</span><span class="p">)</span>
</code></pre></div>

<p>Such programs for epistemic planning tasks are formally defined and explored in [1] (single-agent case only). ${ }^{12}$ Alternatively, such programs can be seen as abbreviations of PDL programs, e.g. the program if $\varphi$ then $\pi_{1}$ else $\pi_{2}$ can be seen as shorthand for the PDL program $\left(\varphi ? ; \pi_{1}\right) \cup\left(\neg \varphi ? ; \pi_{2}\right)$. In [13], dynamic epistemic logic with postconditions and PDL constructs is studied (however not in a planning context). Programs like the one above are in [15] called knowledge-based programs and are there studied in an alternative logical setting. Knowledge-based programs are studied in a planning context in [23].</p>
<p>An alternative to conditional plans as programs is policies. A policy is a mapping from states into actions, that is, for each state the policy specifies the action chosen in that state (a policy is also sometimes called a strategy or a protocol, depending on the area). Since implemented planning systems often generate conditional plans via an AND-OR graph search in the state space, a policy comes as a more direct output of these algorithms than a program (e.g. one does not have to synthesise appropriate ifconditions). From now on we will only consider conditional plans as policies, not programs.
Definition 9. Let $\Pi=\left(A, s_{0}, \varphi_{g}\right)$ be a planning task and $i \in \mathcal{A}$ be an agent. An $i$-policy $\pi$ for $\Pi$ is a partial mapping $\pi: S^{\mathrm{gl}} \hookrightarrow A$ from global states into actions such that
(1) If $\pi(s)=a$ then $a$ is applicable in $s^{i}$.
(2) If $s^{i}=t^{i}$ then $\pi(s)=\pi(t)$.</p>
<p>An $i$-policy is a policy from the perspective of agent $i$. Condition (1) ensures that in such a policy, agent $i$ always knows that the next action to be performed is applicable (knowledge of preconditions). Condition (2) is a uniformity condition: If two global states are indistinguishable to agent $i$, agent $i$ has to make the same choice in both.
Definition 10. An execution of a policy $\pi$ from a global state $s_{0}$ is a maximal (finite or infinite) sequence of alternating global states and actions $\left(s_{0}, a_{1}, s_{1}, a_{2}, s_{2}, \ldots\right)$ such that for all $m \geq 0$,
(1) $\pi\left(s_{m}\right)=a_{m+1}$, and
(2) $s_{m+1} \in \operatorname{Globals}\left(s_{m} \otimes a_{m+1}\right)$.</p>
<p><sup id="fnref11:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>An execution is called successful for a global planning task $\Pi=\left(A, s_{0}, \varphi_{g}\right)$ if it is a finite execution $\left(s_{0}, a_{1}, s_{1}, \ldots, a_{n}, s_{n}\right)$ such that $s_{n} \models \varphi_{g}$.</p>
<p>Definition 11. A policy $\pi$ for a planning task $\Pi=\left(A, s_{0}, \varphi_{g}\right)$ is called a solution to $\Pi$ if Globals $\left(s_{0}\right) \subseteq$ $\operatorname{Dom}(\pi)$ and for each $s \in \operatorname{Dom}(\pi)$, any execution of $\pi$ from $s$ is successful for $\Pi .{ }^{13}$</p>
<p>Example 8. In the birthday present task we can now specify distinct actions to be performed in the two distinct global states of the state $s_{2}$ of Example 7 (the state after the father has attempted to pickup the present at PO1):</p>
<p>This partial policy can easily be extended into a full solution policy to the planning task.
Example 9. Consider extending the birthday present example with a post office employee, Employee, working at PO1. We can think of this as a new agent, so now $\mathcal{A}={$ Father, Employee $}$. It might be possible to call the employee from home to ask whether the present is at the post office. We can assume the employee knows whether the present is at his or her post office, so the initial state would be the same as in Example 7 ( $s_{0}^{\text {Father }}$ ), except there is now reflexive loops for Employee at both worlds. We can now represent a general action of an agent $i$ calling an agent $j$ to ask whether a formula $\varphi$ is true as the following action, where $i, j \in \mathcal{A}$ and $\varphi \in \mathcal{L}_{\mathrm{KC}}$ :</p>
<p>The action model above corresponds to agent $j$ giving a sincere answer to the question "is $\varphi$ true?". Agent $j$ saying "yes" to the question is represented by the event $e_{1}$, that is, it corresponds to an announcement that agent $j$ knows $\varphi$. Event $e_{2}$ corresponds to saying "no", and $e_{3}$ corresponds to saying "I don't know". We now get</p>
<p>This is because in $w_{1}$ of $s_{0}^{\text {Father }}$ we have that $K_{\text {Employee }} \mathrm{At}($ Present, PO1 $)$ holds and in $w_{2}$ of $s_{0}^{\text {Father }}$ we have $K_{\text {Employee }} \neg \mathrm{At}($ Present, PO1), and the action model for Ask(Father,Employee, At(Present,PO1))</p>
<p><sup id="fnref12:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>is clearly seen to cut the link between worlds satisfying $K_{\text {Employee }} \neg \mathrm{At}($ Present, PO1) and worlds satisfying $K_{\text {Employee }} \neg \mathrm{At}($ Present, PO1) (since there are two distinguishable events with these formulas as preconditions). Hence the planning agent, Father, can conclude</p>
<p>$$
s_{0} \otimes \operatorname{Ask}(\text { Father }, \text { Employee }, \mathrm{At}(\text { Present }, \mathrm{PO} 1)) \models K_{\text {Father }} \mathrm{At}(\text { Present }, \mathrm{PO} 1) \vee K_{\text {Father }} \mathrm{At}(\text { Present }, \mathrm{PO} 2)
$$</p>
<p>and hence that he can first call to ask the post office employee whether she has the present, and then next he will know where to go.</p>
<h1>10 Public and private actions</h1>
<p>The Ask action above is a bit simplified. It is publicly observable: the indistinguishability relation is the identity. When there is only two agents in the scenario this is acceptable, since they can only call each other, but if there were more agents present, these would probably not observe the phone call taking place. Consider adding a third agent, Employee2, working at PostOffice2. If Father calls Employee, Employee2 will not know, and might not even consider it possible that the phone call could have taken place. To model this we have to go beyond equivalence classes in epistemic models and action models, since now it becomes possible to have false beliefs, e.g. a false belief that no phone call took place (or a false belief that Father does not yet know At(Present, PO2)). In this case, we could model the private phone call of agent $i$ to agent $j$ asking about $\varphi$ as follows:</p>
<p>$$
\operatorname{Ask}(i, j, \varphi)=\frac{\left\langle K_{j} \varphi, \top\right\rangle}{\left\langle\mathrm{T}, \mathrm{~T}\right\rangle}
$$</p>
<p>This models that agent $i$ and $j$ know the phone call takes place (and know the outcome of the phone call), but all other agents think that nothing has happened (the skip event $\langle\top, \top\rangle$ ). We can even model that some subset $\mathcal{B} \subseteq \mathcal{A}$ of agents hear the question being asked, but not the answer (they are together with $i$, but cannot hear what is being said in the other end):
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>These examples illustrate that designing action models to represent actions under multi-agent partial observability is far from a trivial matter. Some recent papers try to propose different ways of encoding observability information into a logical language, so that the action models themselves can become simpler, more uniform, and automatically induced from the underlying observability information [5, 7, 18]. However, there are still many unsolved problems in this area.</p>
<p>The possibility of representing private actions (only observed by a subset of agents, whereas the other agents believe nothing happens) is also what allows us to model the full version of the birthday present example, where the daughter does not get to know that the father has the present. We can for instance model that only agents who are copresent (in the same location) can observe actions taking place in that location (see [10] for a discussion and treatment of copresence in an epistemic planning setting). For instance, the Wrap action could be reformulated as follows:</p>
<p>$$
\operatorname{Wrap}(a g t, o b j, l o c)=\frac{{i: \neg \operatorname{At}(i, l o c)}_{i \in \mathcal{A}}}{\langle\operatorname{At}(a g t, l o c) \wedge \operatorname{Has}(a g t, o b j) \wedge \neg \operatorname{Wrapped}(o b j), \quad \text { (T, T) }}
$$</p>
<p>We here use a new type of action model that we call an edge-conditioned action model [5]. The meaning of the label on the edge is that there is an edge for agent $i$ here if $\neg \mathrm{At}(i, l o c)$ is true (agent $i$ is not present in the location where the present is being wrapped). Such edge-conditioned action models are a variant of generalised arrow updates [22].</p>
<p>With the wrapping action presented as above, the father will e.g. be able to figure out that if the daughter is at home (At(Daughter, Home) is true), then only the plan where he executes Wrap at the post office will lead to Wrapped (Present) $\wedge \neg K_{\text {Daughter }}$ Has(Father, Present) (recall the state-transition system in Figure 2 that shows that the present can either be wrapped in the post office or at home).</p>
<h1>11 Multi-agent planning</h1>
<p>So far we have only considered the case of a single agent planning in the presence of other agents. The formal framework of course also allows to represent real multi-agent planning tasks. However, for true multi-agent planning a lot of additional design choices have to be made. Are the agents collaborating or competing? Are there coalitions of agents trying to achieve a joint goal, perhaps against the agents outside the coalition? Can the agents communicate and coordinate arbitrarily when coming up with a plan, and will they commit to such a joint plan? The papers [14, 8] look at implicitly coordinated plans, where agents have a joint goal but are not allowed to coordinate or negotiate in advance. All coordination should happen during plan executions as a result of announcements and observing the actions of others.</p>
<p>In the birthday present example it could e.g. be that Father calls Employee to announce the goal Has(Father, Present). Assuming Employee is altruistic and adopts this as his or her own goal, Father and Employee are now engaged in planning with implicit coordination towards the joint goal Has(Father, Present). Assume the present is at PostOffice2. Since Employee knows that Father doesn't know the location of the present, and that he cannot get the present unless he knows, she will choose to announce that the present is at PostOffice2. This is a case of implicit coordination: The father doesn't ask the employee about the location of the present, but the employee knows about the goal and can still plan to inform him, in order to allow him to plan the rest of the required actions. These ideas are explored further in $[14,8]$.</p>
<h2>12 (Un)decidability and complexity</h2>
<p>One of the most studied problems in epistemic planning based on DEL is the complexity of the plan existence problems. The plan existence problem for a class of planning tasks $X$ is the following decision</p>
<p>problem: Given a planning task $\Pi \in X$, does there exist a solution to $\Pi$ ? So far only the complexity of deciding whether a sequential plan exists have been studied. For general epistemic planning tasks the problem is undecidable already with two agents, no common knowledge, and even without postconditions (that is, purely epistemic planning without ontic change) [2]. This has lead to a quest for finding decidable, but still reasonably expressive, fragments of epistemic planning. The first result along these lines proved that epistemic planning with propositional preconditions (that is, no epistemic formulas in the preconditions) is decidable [31]. An upper bound on complexity is in that paper shown to be $(n+1)$ EXPTIME for planning tasks in which the goal formula has modal depth $n$. In [11] it is shown that when the preconditions are propositional and there are no postconditions, then the plan existence problem is PSPACE-complete (for arbitrary goal formulas). If restricting further to certain types of actions, like private and public announcements, complexity of plan existence goes further down to NP-complete [9].</p>
<h1>13 Alternative approaches to epistemic planning</h1>
<p>Epistemic planning based on DEL takes a semantic approach, where states are represented as semantical objects, epistemic states. It is also possible to take a syntactic approach, where states are represented as knowledge-bases, sets of formulas known to be true. Interestingly, STRIPS and propositional planning are semantic and syntactic at the same time, since in propositional logic a semantic state is just a set of formulas (a set of true atomic propositions). This means that when generalising from STRIPS or propositional planning to epistemic planning, it is not immediately obvious whether a semantic or syntactic approach would be most appropriate. Both approaches have their strength and weaknesses.</p>
<p>Epistemic planning based on DEL also takes the approach of insisting on succinct action representations via action models. We argued in favour of this approach already very early in the paper by mentioning the weaknesses of attempting to represent planning tasks explicitly as state-transition systems. In fact, the state-transition systems induced by epistemic planning tasks will often be infinite, so even if choosing a state-transition system based approach, one will need a way to represent them finitely in order to be able to do planning based on them [20]. From the perspective of classical planning, the most appropriate approach to representing state-transition systems compactly seems to be representing the actions themselves in a compact way (using some kind of action models or action schemas).</p>
<p>Based on the above, we can distinguish approaches to epistemic planning along two dimensions:</p>
<ul>
<li>Semantic approaches versus syntactic approaches.</li>
<li>Action model based approaches versus state-transition system based approaches.</li>
</ul>
<p>The approach of this paper is, as mentioned, semantic and action model based. Syntactic approaches to epistemic planning can be found in e.g. the (single-agent) PKS planner [27], the (multi-agent) planning framework of [25] and the compilation approach of [21], translating a restricted fragment of epistemic planning into classical planning. The state-transition system based approach is found in a number of papers in temporal epistemic logic, e.g. [19, 20]. In these papers, the planning domains are represented by a type of epistemic state-transition system called a concurrent epistemic game structure (CEGS). Having an explicitly represented state-transition system like a CEGS tends to make it easier to define complex notions of multi-agent plans (strategies). On the other hand, by working directly with statetransition systems, some of the important problems of epistemic planning are being silently bypassed. These problems include compact representations of the state-transition system, and efficient heuristics for avoiding to build the entire state-transition system when planning. They also include problems of how to provide a general approach to multi-agent observability and problems of concurrent composition</p>
<p>of actions of multiple agents. In CEGS, transitions represent joint actions, one action per agent. The problem of how to make a parallel composition of the actions of the individual agents has to be solved before one can even build the CEGS for a given planning domain. In epistemic planning based on DEL, this problem has to be solved at the level of action models: How do we make a parallel composition of two action models in case they are not independent (e.g. two agents trying to open a door at the same time, but from opposite sides). Epistemic planning tasks can be seen as inducing e.g. forests of epistemic temporal logic [3] or CEGSs. The exact relations have not been explored yet, but providing a link between the action model based approaches and the state-transition system based approaches could be very valuable and provide a possibility of getting the best of both worlds.</p>
<p>Similarly, providing links and connections between syntactic and semantic approaches seem to be potentially very valuable. In a semantic approach, one is essentially modelling ignorance: the more ignorance, the bigger the state. In a syntactic approach, one is essentially modelling knowledge: the more knowledge, the bigger the state. Knowledge and ignorance are each others duals, and hence the semantic and the syntactic approach are also each others duals. It seems that when humans are planning, we are sometimes using a more semantic approach, and sometimes a more syntactic one, depending on the planning task at hand. It would hence also be very interesting to see whether planning frameworks could be developed that would employ or combine both approaches.</p>
<h1>References</h1>
<p>[1] Mikkel Birkegaard Andersen, Thomas Bolander \&amp; Martin Holm Jensen (2012): Conditional Epistemic Planning. Lecture Notes in Artificial Intelligence 7519, pp. 94-106, doi:10.1007/978-3-642-33353-8_8. Proceedings of JELIA 2012.
[2] Guillaume Aucher \&amp; Thomas Bolander (2013): Undecidability in Epistemic Planning. In: Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence (IJCAI), pp. 27-33.
[3] Johan van Benthem, Jelle Gerbrandy \&amp; Eric Pacuit (2007): Merging frameworks for interaction: DEL and ETL. In: Proceedings of the 11th conference on Theoretical aspects of rationality and knowledge, TARK '07, ACM, New York, NY, USA, pp. 72-81, doi:10.1145/1324249.1324262.
[4] P. Blackburn, M. de Rijke \&amp; Y. Venema (2001): Modal Logic. Cambridge Tracts in Theoretical Computer Science 53, Cambridge University Press, Cambridge, UK, doi:10.1017/CBO9781107050884.
[5] Thomas Bolander (2014): Seeing is Believing: Formalising False-Belief Tasks in Dynamic Epistemic Logic. In Andreas Herzig \&amp; Emiliano Lorini, editors: Proceedings of the European Conference on Social Intelligence (ECSI-2014), CEUR Workshop Proceedings 1283, CEUR-WS.org, pp. 87-107.
[6] Thomas Bolander \&amp; Mikkel Birkegaard Andersen (2011): Epistemic Planning for Single- and Multi-Agent Systems. Journal of Applied Non-Classical Logics 21, pp. 9-34, doi:10.3166/jancl.21.9-34.
[7] Thomas Bolander, Hans van Ditmarsch, Andreas Herzig, Emiliano Lorini, Pere Pardo \&amp; François Schwarzentruber (2015): Announcements to Attentive Agents. Journal of Logic, Language and Information, pp. 1-35, doi:10.1007/s10849-015-9234-3.
[8] Thomas Bolander, Thorsten Engesser, Robert Mattmller \&amp; Bernhard Nebel (2016): Better Eager Than Lazy? How Agent Types Impact the Successfulness of Implicit Coordination. In: Distributed and Multi-Agent Planning (DMAP-16), pp. 42-49.
[9] Thomas Bolander, Martin Holm Jensen \&amp; François Schwarzentruber (2015): Complexity Results in Epistemic Planning. In Qiang Yang \&amp; Michael Wooldridge, editors: Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence, IJCAI 2015, Buenos Aires, Argentina, July 25-31, 2015, AAAI Press, pp. 2791-2797.</p>
<p>[10] Michael Brenner \&amp; Bernhard Nebel (2009): Continual planning and acting in dynamic multiagent environments. Autonomous Agents and Multi-Agent Systems 19(3), pp. 297-331, doi:10.1007/s10458-009-9081-1.
[11] Tristan Charrier, Bastien Maubert \&amp; François Schwarzentruber (2016): On the Impact of Modal Depth in Epistemic Planning. In: Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016, New York, USA, July 12-15, 2016.
[12] Hans van Ditmarsch \&amp; Barteld Kooi (2008): Semantic Results for Ontic and Epistemic Change. In Giacomo Bonanno, Wiebe van der Hoek \&amp; Michael Wooldridge, editors: Logic and the Foundation of Game and Decision Theory (LOFT 7), Texts in Logic and Games 3, Amsterdam University Press, pp. 87-117.
[13] Jan van Eijck (2014): Dynamic epistemic logics. In: Johan van Benthem on Logic and Information Dynamics, Springer, pp. 175-202.
[14] Thorsten Engesser, Thomas Bolander, Robert Mattmller \&amp; Bernhard Nebel (2017): Cooperative Epistemic Multi-Agent Planning for Implicit Coordination. In: Proceedings of Methods for Modalities, Electronic Proceedings in Theoretical Computer Science.
[15] Ronald Fagin, Joseph Y. Halpern, Yoram Moses \&amp; Moshe Y. Vardi (1995): Reasoning About Knowledge. MIT Press.
[16] R. Fikes \&amp; N. Nilsson (1971): STRIPS: A new approach to the application of theorem proving to problem solving. Artificial Intelligence 2, pp. 189-203, doi:10.1016/0004-3702(71)90010-5.
[17] Malik Ghallab, Dana S. Nau \&amp; Paolo Traverso (2004): Automated Planning: Theory and Practice. Morgan Kaufmann.
[18] Andreas Herzig, Emiliano Lorini \&amp; Faustine Maffre (2015): A poor mans epistemic logic based on propositional assignment and higher-order observation. In: Logic, Rationality and Interaction, Lecture Notes in Computer Science 9394, Springer, doi:10.1007/978-3-662-48561-3_13.
[19] Wiebe van der Hoek \&amp; Michael Wooldridge (2002): Tractable Multiagent Planning for Epistemic Goals. In: In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS-2002), ACM Press, pp. 1167-1174, doi:10.1145/545056.545095.
[20] Wojciech Jamroga \&amp; Thomas Aagotnes (2007): Constructive knowledge: what agents can achieve under imperfect information. Journal of Applied Non-Classical Logics 17(4), pp. 423-475, doi:10.3166/jancl.17.423475 .
[21] Filippos Kominis \&amp; Hector Geffner (2014): Beliefs in multiagent planning: From one agent to many. In: Proc. ICAPS Workshop on Distributed and Multi-Agent Planning.
[22] Barteld Kooi \&amp; Bryan Renne (2011): Generalized arrow update logic. In: Proceedings of the 13th Conference on Theoretical Aspects of Rationality and Knowledge, ACM, pp. 205-211, doi:10.1145/2000378.2000403.
[23] Jérôme Lang \&amp; Bruno Zanuttini (2013): Knowledge-Based Programs as Plans: Succinctness and the Complexity of Plan Existence. In: TARK 2013.
[24] Kira Mourão, Luke S. Zettlemoyer, Ronald P. A. Petrick \&amp; Mark Steedman (2012): Learning STRIPS Operators from Noisy and Incomplete Observations. In Nando de Freitas \&amp; Kevin P. Murphy, editors: Proceedings of the Twenty-Eighth Conference on Uncertainty in Artificial Intelligence, Catalina Island, CA, USA, August 14-18, 2012, AUAI Press, pp. 614-623.
[25] Christian Muise, Vaishak Belle, Paolo Felli, Sheila McIlraith, Tim Miller, Adrian R Pearce \&amp; Liz Sonenberg (2015): Planning Over Multi-Agent Epistemic States: A Classical Planning Approach (Amended Version). In: Distributed and Multi-Agent Planning (DMAP-15), pp. 60-67, doi:10.1.1.684.2394.
[26] Ronald P. A. Petrick \&amp; Fahiem Bacchus (2002): A Knowledge-Based Approach to Planning with Incomplete Information and Sensing. In Malik Ghallab, Joachim Hertzberg \&amp; Paolo Traverso, editors: Proceedings of the Sixth International Conference on Artificial Intelligence Planning and Scheduling (AIPS-2002), AAAI Press, Menlo Park, CA, pp. 212-221.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{13}$ Note that a solution policy has to lead to successful executions for all global states in $s_{0}$ (and for all global states along all possible executions of the policy). Such policies are often called strong policies, because the requirement is that they are guaranteed to succeed under alle circumstances (considered possible by the planning agent). In conditional planning, one often also considers weak solutions (weak policies) that have a possibility of succeeding, but might not always succeed. A weak solution to the birthday present task would be to go to PO1, attempt picking up the present there, go home, and then wrap the present if one has it. This plan can clearly fail if the present is at PO2. In this paper we restrict attention to strong solutions.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref7:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref8:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref9:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref10:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref11:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref12:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>