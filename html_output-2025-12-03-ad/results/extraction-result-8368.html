<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8368 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8368</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8368</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-149.html">extraction-schema-149</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <p><strong>Paper ID:</strong> paper-5259755f9c100e220ffaa7e08439c5d34be7757a</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/5259755f9c100e220ffaa7e08439c5d34be7757a" target="_blank">Reinforcement Learning Neural Turing Machines - Revised</a></p>
                <p><strong>Paper TL;DR:</strong> This work examines feasibility of learning models to interact with discrete Interfaces, and uses a Reinforcement Learning algorithm to train a neural network that interacts with such Interfaces to solve simple algorithmic tasks.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8368.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8368.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RL-NTM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reinforcement Learning Neural Turing Machine</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An NTM-style model that uses an LSTM-based controller (or a task-specific direct-access controller) interacting with discrete Input, Memory, and Output tapes; discrete head actions are trained with the Reinforce policy-gradient algorithm while continuous outputs/content are trained with backpropagation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RL-NTM (this paper)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Controller: LSTM or 'direct access' LSTM variant; Interfaces: 1-D discrete Input Tape, Memory Tape (backpropagated real-value vectors, memory size used in experiments = 35), Output Tape (write-only). Discrete head-movement decisions (move left/right/stay, whether to emit output) are sampled from categorical distributions trained with Reinforce; content written to memory and output vocabulary distributions trained with backpropagation. Training used SGD lr=0.05, momentum=0.9, batch size 200, gradient clipping, inverse temperature 0.01 for action distributions, curriculum learning.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Mentioned attempt at long integer addition (base-3) as an algorithmic task; paper's experiments focus on symbol-manipulation tasks (copy, duplicate-input, reverse, repeat-copy, forward-reverse) rather than standard arithmetic benchmarks.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Computation proceeds by discrete head movements over tapes and storing symbol content as real-valued vectors in memory cells; the model represents symbols (including digits when used) as discrete tokens drawn from a vocabulary (in experiments a 30-symbol set). The direct-access controller adds input vectors directly to memory and/or output with dynamic scalar gating (sigmoid) computed from controller state, providing an architectural shortcut for symbol copying.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>No explicit probing of internal arithmetic processing reported. Paper introduces and uses (1) reinforcement-learning training diagnostics (gradient checking by enumerating all terminating action sequences for small instances), (2) variance-reduction interventions for Reinforce (causality-aware reward backpropagation, online and offline baselines including a baseline LSTM that first reads full input), (3) curriculum learning to progressively increase problem complexity, and (4) controller-architecture ablations (LSTM vs direct-access controller), plus forced-interface interventions (e.g., restricting input-head to only move forward to force memory usage).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Qualitative performance: RL-NTM successfully solved Copy and DuplicatedInput with both controllers; Reverse, ForwardReverse and RepeatCopy were only solvable with the direct-access controller (LSTM controller failed on those). Sorting and long integer addition (base-3) were reported as too difficult—addition failed. No numeric accuracy curves or per-task percentages are provided beyond binary success/failure and statements like 'solvable in under 20,000 parameter updates or fail indefinitely.'</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>High variance in Reinforce gradients making learning unstable; strong dependence on controller architecture (generic LSTM often fails on symbol-rearrangement tasks); failure to learn difficult tasks without curriculum; inability to solve long integer addition (base-3) and some variants of RepeatCopy when the input tape is forced to only move forward; when sorting, RL-NTM learned ad-hoc, non-general algorithms and overused controller memory.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Execution traces (figures) show that for ForwardReverse the model moves to sequence end without emitting predictions, writes inputs into memory, and later uses memory to produce reversed outputs—evidence that memory tape encodes sequence and is read back to perform reversal. Success/failure ablations: direct-access controller's built-in copy pathway enables solving tasks (Reverse, RepeatCopy, ForwardReverse) that generic LSTM controller cannot learn, indicating the importance of architectural mechanisms for symbol copying. Gradient checking routine demonstrates correctness of Reinforce implementation (supporting reliability of reported training behavior).</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Long integer addition (base-3) and sorting (robust general solutions) resisted training—sorting yielded brittle ad-hoc strategies; forcing the input head to only move forward makes RepeatCopy unsolvable for their controllers (failure trace shown). Attempts without curriculum fail for non-trivial sequence lengths. These negative results challenge claims about general algorithmic competence and show limitations of learned mechanisms for arithmetic-like tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reinforcement Learning Neural Turing Machines - Revised', 'publication_date_yy_mm': '2015-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8368.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8368.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>DirectAccessController</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Direct Access Controller (architectural modification for symbol copying)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A controller variant that adds direct pathways to copy current input into memory and output, and memory to output/adjacent memories, modulated by dynamic scalar gates computed from controller state — designed to ease symbol rearrangement tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RL-NTM (direct access controller variant)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Same base RL-NTM but controller augmented with additive connections: input -> memory, input -> output, memory -> output, memory -> adjacent memory cells; each additive contribution is multiplied by a sigmoid gating scalar produced by the controller at each timestep.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Used to solve symbol-manipulation tasks (Reverse, RepeatCopy, ForwardReverse) which are relevant building blocks for algorithmic arithmetic; no successful numeric addition experiments reported with this controller.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Provides an architectural copy mechanism enabling near-direct transfer of input symbol vectors into memory/output, effectively reducing reliance on LSTM hidden-state registerization of symbols; representations remain real-valued memory vectors per cell.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Evaluated via ablation: compared to generic LSTM controller on same tasks; success/failure table in paper shows tasks solvable only with direct-access controller.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Qualitative: direct-access controller succeeded on Reverse, ForwardReverse, RepeatCopy whereas generic LSTM failed on these; no numeric accuracy values provided.</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Architectural specialization reduces generality — authors note it's not domain-independent and may not help on other tasks (a drawback).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Empirical training results: tasks that require symbol rearrangement solved only by direct-access controller; execution traces show correct copying and memory usage when direct pathways available.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Despite enabling several tasks, this controller still failed on more complex algorithmic tasks like long integer addition and some sorting instances (ad-hoc strategies observed).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reinforcement Learning Neural Turing Machines - Revised', 'publication_date_yy_mm': '2015-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8368.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8368.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Reinforce+Baselines+GradientCheck</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reinforce training with causality-aware rewards, baselines, and enumerative gradient checking</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The paper uses standard REINFORCE with several variance-reduction techniques (backpropagating only future rewards, online scalar baselines, an offline baseline LSTM trained to predict return) and introduces an enumerative gradient-checker for REINFORCE by deterministically enumerating all terminating action sequences on small tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Training / analysis methods used on RL-NTM</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Policy gradient (REINFORCE) is used for discrete head actions; continuous outputs trained with backpropagation. Variance reduction: (1) exploit causality to use sum of future rewards from time t, (2) online baseline (scalar) subtraction, (3) offline baseline LSTM that first reads entire input and then predicts baselines per step. Gradient checking: for small instances enumerate all possible terminating action sequences by overriding sampling to deterministically produce each sequence and computing exact expected gradients numerically.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Applied to algorithmic symbol-manipulation tasks; attempted addition (base-3) but failed — training method limitations implicated.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Training-level mechanisms rather than model internals: baseline networks represent expected return given current observed input; enumerative gradient checking provides exact expected gradient values for debugging.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Interventions: deterministic sampling override to enumerate action-sequences for exact gradient computation (used for implementation verification), use of baseline LSTM trained to predict returns (offline baseline), curriculum learning to shape task difficulty during training.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>No numeric performance for REINFORCE method itself; authors assert these variance-reduction techniques were 'crucial' to solving their tasks; without them learning often fails. Training hyperparameters reported (SGD settings, batch sizes, gradient clipping, inverse temperature) that influenced optimization stability.</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>High variance of policy-gradient estimates leading to instability; poor baseline estimates degrade training; without gradient checking debugging is extremely hard and implementations can be silently incorrect.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Anecdotal/empirical: authors state all three variance-reduction techniques were essential; gradient checker caught implementation errors and enabled correct training of RL-NTM; providing baseline LSTM access to entire input improved baseline quality and training stability.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Even with these interventions, some algorithmic tasks (addition, robust sorting) remained unsolved, indicating limits of REINFORCE + architecture choices for learning arithmetic-like algorithms in this setup.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reinforcement Learning Neural Turing Machines - Revised', 'publication_date_yy_mm': '2015-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8368.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8368.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>LongIntegerAddition(base-3)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Long integer addition (base-3) task (mentioned)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A classic algorithmic arithmetic task (adding long integers presented as digit sequences) mentioned as an attempted but unsolved problem in the RL-NTM experiments; used to illustrate limits of current approach.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>RL-NTM (attempted task)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Task described as addition of long integers in base-3 for simplicity; input delivered as sequences of digit symbols; required use of external memory and algorithmic carry handling.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Multi-digit integer addition (base-3), i.e., algorithmic addition requiring carry propagation.</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Not demonstrated; would require sequential digit-by-digit processing with memory to store carries or reversed sequences — RL-NTM attempted but failed to learn a general solution.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Task attempted under same RL-NTM training regime (REINFORCE + baselines + curriculum + controller variants); no successful intervention to enable generalization reported.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Reported as 'too difficult' / failed; no numeric accuracies provided.</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Model failed to learn correct addition algorithm; failure suggests inability to learn reliable carry-propagation strategies under the RL-NTM training configuration and interfaces.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Negative result only — the paper explicitly notes failure on this task, providing evidence of limitation rather than a mechanism.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Authors note that some tasks like addition and sorting either failed or produced non-general ad-hoc strategies, indicating the approach does not reliably learn arithmetic algorithms in this setting.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Reinforcement Learning Neural Turing Machines - Revised', 'publication_date_yy_mm': '2015-05'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural turing machines <em>(Rating: 2)</em></li>
                <li>Learning to execute <em>(Rating: 2)</em></li>
                <li>Simple statistical gradient-following algorithms for connectionist reinforcement learning <em>(Rating: 2)</em></li>
                <li>Recurrent models of visual attention <em>(Rating: 1)</em></li>
                <li>Weakly supervised memory networks <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8368",
    "paper_id": "paper-5259755f9c100e220ffaa7e08439c5d34be7757a",
    "extraction_schema_id": "extraction-schema-149",
    "extracted_data": [
        {
            "name_short": "RL-NTM",
            "name_full": "Reinforcement Learning Neural Turing Machine",
            "brief_description": "An NTM-style model that uses an LSTM-based controller (or a task-specific direct-access controller) interacting with discrete Input, Memory, and Output tapes; discrete head actions are trained with the Reinforce policy-gradient algorithm while continuous outputs/content are trained with backpropagation.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RL-NTM (this paper)",
            "model_description": "Controller: LSTM or 'direct access' LSTM variant; Interfaces: 1-D discrete Input Tape, Memory Tape (backpropagated real-value vectors, memory size used in experiments = 35), Output Tape (write-only). Discrete head-movement decisions (move left/right/stay, whether to emit output) are sampled from categorical distributions trained with Reinforce; content written to memory and output vocabulary distributions trained with backpropagation. Training used SGD lr=0.05, momentum=0.9, batch size 200, gradient clipping, inverse temperature 0.01 for action distributions, curriculum learning.",
            "arithmetic_task_type": "Mentioned attempt at long integer addition (base-3) as an algorithmic task; paper's experiments focus on symbol-manipulation tasks (copy, duplicate-input, reverse, repeat-copy, forward-reverse) rather than standard arithmetic benchmarks.",
            "mechanism_or_representation": "Computation proceeds by discrete head movements over tapes and storing symbol content as real-valued vectors in memory cells; the model represents symbols (including digits when used) as discrete tokens drawn from a vocabulary (in experiments a 30-symbol set). The direct-access controller adds input vectors directly to memory and/or output with dynamic scalar gating (sigmoid) computed from controller state, providing an architectural shortcut for symbol copying.",
            "probing_or_intervention_method": "No explicit probing of internal arithmetic processing reported. Paper introduces and uses (1) reinforcement-learning training diagnostics (gradient checking by enumerating all terminating action sequences for small instances), (2) variance-reduction interventions for Reinforce (causality-aware reward backpropagation, online and offline baselines including a baseline LSTM that first reads full input), (3) curriculum learning to progressively increase problem complexity, and (4) controller-architecture ablations (LSTM vs direct-access controller), plus forced-interface interventions (e.g., restricting input-head to only move forward to force memory usage).",
            "performance_metrics": "Qualitative performance: RL-NTM successfully solved Copy and DuplicatedInput with both controllers; Reverse, ForwardReverse and RepeatCopy were only solvable with the direct-access controller (LSTM controller failed on those). Sorting and long integer addition (base-3) were reported as too difficult—addition failed. No numeric accuracy curves or per-task percentages are provided beyond binary success/failure and statements like 'solvable in under 20,000 parameter updates or fail indefinitely.'",
            "error_types_or_failure_modes": "High variance in Reinforce gradients making learning unstable; strong dependence on controller architecture (generic LSTM often fails on symbol-rearrangement tasks); failure to learn difficult tasks without curriculum; inability to solve long integer addition (base-3) and some variants of RepeatCopy when the input tape is forced to only move forward; when sorting, RL-NTM learned ad-hoc, non-general algorithms and overused controller memory.",
            "evidence_for_mechanism": "Execution traces (figures) show that for ForwardReverse the model moves to sequence end without emitting predictions, writes inputs into memory, and later uses memory to produce reversed outputs—evidence that memory tape encodes sequence and is read back to perform reversal. Success/failure ablations: direct-access controller's built-in copy pathway enables solving tasks (Reverse, RepeatCopy, ForwardReverse) that generic LSTM controller cannot learn, indicating the importance of architectural mechanisms for symbol copying. Gradient checking routine demonstrates correctness of Reinforce implementation (supporting reliability of reported training behavior).",
            "counterexamples_or_challenges": "Long integer addition (base-3) and sorting (robust general solutions) resisted training—sorting yielded brittle ad-hoc strategies; forcing the input head to only move forward makes RepeatCopy unsolvable for their controllers (failure trace shown). Attempts without curriculum fail for non-trivial sequence lengths. These negative results challenge claims about general algorithmic competence and show limitations of learned mechanisms for arithmetic-like tasks.",
            "uuid": "e8368.0",
            "source_info": {
                "paper_title": "Reinforcement Learning Neural Turing Machines - Revised",
                "publication_date_yy_mm": "2015-05"
            }
        },
        {
            "name_short": "DirectAccessController",
            "name_full": "Direct Access Controller (architectural modification for symbol copying)",
            "brief_description": "A controller variant that adds direct pathways to copy current input into memory and output, and memory to output/adjacent memories, modulated by dynamic scalar gates computed from controller state — designed to ease symbol rearrangement tasks.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "RL-NTM (direct access controller variant)",
            "model_description": "Same base RL-NTM but controller augmented with additive connections: input -&gt; memory, input -&gt; output, memory -&gt; output, memory -&gt; adjacent memory cells; each additive contribution is multiplied by a sigmoid gating scalar produced by the controller at each timestep.",
            "arithmetic_task_type": "Used to solve symbol-manipulation tasks (Reverse, RepeatCopy, ForwardReverse) which are relevant building blocks for algorithmic arithmetic; no successful numeric addition experiments reported with this controller.",
            "mechanism_or_representation": "Provides an architectural copy mechanism enabling near-direct transfer of input symbol vectors into memory/output, effectively reducing reliance on LSTM hidden-state registerization of symbols; representations remain real-valued memory vectors per cell.",
            "probing_or_intervention_method": "Evaluated via ablation: compared to generic LSTM controller on same tasks; success/failure table in paper shows tasks solvable only with direct-access controller.",
            "performance_metrics": "Qualitative: direct-access controller succeeded on Reverse, ForwardReverse, RepeatCopy whereas generic LSTM failed on these; no numeric accuracy values provided.",
            "error_types_or_failure_modes": "Architectural specialization reduces generality — authors note it's not domain-independent and may not help on other tasks (a drawback).",
            "evidence_for_mechanism": "Empirical training results: tasks that require symbol rearrangement solved only by direct-access controller; execution traces show correct copying and memory usage when direct pathways available.",
            "counterexamples_or_challenges": "Despite enabling several tasks, this controller still failed on more complex algorithmic tasks like long integer addition and some sorting instances (ad-hoc strategies observed).",
            "uuid": "e8368.1",
            "source_info": {
                "paper_title": "Reinforcement Learning Neural Turing Machines - Revised",
                "publication_date_yy_mm": "2015-05"
            }
        },
        {
            "name_short": "Reinforce+Baselines+GradientCheck",
            "name_full": "Reinforce training with causality-aware rewards, baselines, and enumerative gradient checking",
            "brief_description": "The paper uses standard REINFORCE with several variance-reduction techniques (backpropagating only future rewards, online scalar baselines, an offline baseline LSTM trained to predict return) and introduces an enumerative gradient-checker for REINFORCE by deterministically enumerating all terminating action sequences on small tasks.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Training / analysis methods used on RL-NTM",
            "model_description": "Policy gradient (REINFORCE) is used for discrete head actions; continuous outputs trained with backpropagation. Variance reduction: (1) exploit causality to use sum of future rewards from time t, (2) online baseline (scalar) subtraction, (3) offline baseline LSTM that first reads entire input and then predicts baselines per step. Gradient checking: for small instances enumerate all possible terminating action sequences by overriding sampling to deterministically produce each sequence and computing exact expected gradients numerically.",
            "arithmetic_task_type": "Applied to algorithmic symbol-manipulation tasks; attempted addition (base-3) but failed — training method limitations implicated.",
            "mechanism_or_representation": "Training-level mechanisms rather than model internals: baseline networks represent expected return given current observed input; enumerative gradient checking provides exact expected gradient values for debugging.",
            "probing_or_intervention_method": "Interventions: deterministic sampling override to enumerate action-sequences for exact gradient computation (used for implementation verification), use of baseline LSTM trained to predict returns (offline baseline), curriculum learning to shape task difficulty during training.",
            "performance_metrics": "No numeric performance for REINFORCE method itself; authors assert these variance-reduction techniques were 'crucial' to solving their tasks; without them learning often fails. Training hyperparameters reported (SGD settings, batch sizes, gradient clipping, inverse temperature) that influenced optimization stability.",
            "error_types_or_failure_modes": "High variance of policy-gradient estimates leading to instability; poor baseline estimates degrade training; without gradient checking debugging is extremely hard and implementations can be silently incorrect.",
            "evidence_for_mechanism": "Anecdotal/empirical: authors state all three variance-reduction techniques were essential; gradient checker caught implementation errors and enabled correct training of RL-NTM; providing baseline LSTM access to entire input improved baseline quality and training stability.",
            "counterexamples_or_challenges": "Even with these interventions, some algorithmic tasks (addition, robust sorting) remained unsolved, indicating limits of REINFORCE + architecture choices for learning arithmetic-like algorithms in this setup.",
            "uuid": "e8368.2",
            "source_info": {
                "paper_title": "Reinforcement Learning Neural Turing Machines - Revised",
                "publication_date_yy_mm": "2015-05"
            }
        },
        {
            "name_short": "LongIntegerAddition(base-3)",
            "name_full": "Long integer addition (base-3) task (mentioned)",
            "brief_description": "A classic algorithmic arithmetic task (adding long integers presented as digit sequences) mentioned as an attempted but unsolved problem in the RL-NTM experiments; used to illustrate limits of current approach.",
            "citation_title": "",
            "mention_or_use": "mention",
            "model_name": "RL-NTM (attempted task)",
            "model_description": "Task described as addition of long integers in base-3 for simplicity; input delivered as sequences of digit symbols; required use of external memory and algorithmic carry handling.",
            "arithmetic_task_type": "Multi-digit integer addition (base-3), i.e., algorithmic addition requiring carry propagation.",
            "mechanism_or_representation": "Not demonstrated; would require sequential digit-by-digit processing with memory to store carries or reversed sequences — RL-NTM attempted but failed to learn a general solution.",
            "probing_or_intervention_method": "Task attempted under same RL-NTM training regime (REINFORCE + baselines + curriculum + controller variants); no successful intervention to enable generalization reported.",
            "performance_metrics": "Reported as 'too difficult' / failed; no numeric accuracies provided.",
            "error_types_or_failure_modes": "Model failed to learn correct addition algorithm; failure suggests inability to learn reliable carry-propagation strategies under the RL-NTM training configuration and interfaces.",
            "evidence_for_mechanism": "Negative result only — the paper explicitly notes failure on this task, providing evidence of limitation rather than a mechanism.",
            "counterexamples_or_challenges": "Authors note that some tasks like addition and sorting either failed or produced non-general ad-hoc strategies, indicating the approach does not reliably learn arithmetic algorithms in this setting.",
            "uuid": "e8368.3",
            "source_info": {
                "paper_title": "Reinforcement Learning Neural Turing Machines - Revised",
                "publication_date_yy_mm": "2015-05"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural turing machines",
            "rating": 2
        },
        {
            "paper_title": "Learning to execute",
            "rating": 2
        },
        {
            "paper_title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
            "rating": 2
        },
        {
            "paper_title": "Recurrent models of visual attention",
            "rating": 1
        },
        {
            "paper_title": "Weakly supervised memory networks",
            "rating": 1
        }
    ],
    "cost": 0.01159475,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>REINFORCEMENT LEARNING NEURAL TURING MACHINES - REVISED</h1>
<p>Wojciech Zaremba ${ }^{1,2}$<br>New York University<br>Facebook AI Research<br>woj.zaremba@gmail.com</p>
<p>Ilya Sutskever ${ }^{2}$<br>Google Brain<br>ilyasu@google.com</p>
<h4>Abstract</h4>
<p>The Neural Turing Machine (NTM) is more expressive than all previously considered models because of its external memory. It can be viewed as a broader effort to use abstract external Interfaces and to learn a parametric model that interacts with them. The capabilities of a model can be extended by providing it with proper Interfaces that interact with the world. These external Interfaces include memory, a database, a search engine, or a piece of software such as a theorem verifier. Some of these Interfaces are provided by the developers of the model. However, many important existing Interfaces, such as databases and search engines, are discrete. We examine feasibility of learning models to interact with discrete Interfaces. We investigate the following discrete Interfaces: a memory Tape, an input Tape, and an output Tape. We use a Reinforcement Learning algorithm to train a neural network that interacts with such Interfaces to solve simple algorithmic tasks. Our Interfaces are expressive enough to make our model Turing complete.</p>
<h2>1 INTRODUCTION</h2>
<p>Graves et al. (2014b)'s Neural Turing Machine (NTM) is model that learns to interact with an external memory that is differentiable and continuous. An external memory extends the capabilities of the NTM, allowing it to solve tasks that were previously unsolvable by conventional machine learning methods. This is the source of the NTM's expressive power. In general, it appears that ML models become significantly more powerful if they are able to learn to interact with external interfaces.</p>
<p>There exist a vast number of Interfaces that could be used with our models. For example, the Google search engine is an example of such Interface. The search engine consumes queries (which are actions), and outputs search results. However, the search engine is not differentiable, and the model interacts with the Interface using discrete actions. This work examines the feasibility of learning to interact with discrete Interfaces using the reinforce algorithm.</p>
<p>Discrete Interfaces cannot be trained directly with standard backpropagation because they are not differentiable. It is most natural to learn to interact with discrete Interfaces using Reinforcement Learning methods. In this work, we consider an Input Tape and a Memory Tape interface with discrete access. Our concrete proposal is to use the Reinforce algorithm to learn where to access the discrete interfaces, and to use the backpropagation algorithm to determine what to write to the memory and to the output. We call this model the RL-NTM.</p>
<p>Discrete Interfaces are computationally attractive because the cost of accessing a discrete Interface is often independent of its size. It is not the case for the continuous Interfaces, where the cost of access scales linearly with size. It is a significant disadvantage since slow models cannot scale to large difficult problems that require intensive training on large datasets. In addition, an output Interface that lets the model decide when it wants to make a prediction allows the model's runtime to be in principle unbounded. If the model has an output interface of this kind together with an interface to an unbounded memory, the model becomes Turing complete.</p>
<p>We evaluate the RL-NTM on a number of simple algorithmic tasks. The RL-NTM succeeds on problems such as copying an input several times to the output tape (the "repeat copy" task from Graves et al. (2014b)), reversing a sequence, and a few more tasks of comparable difficulty. However, its success is highly dependent on the architecture of the "controller". We discuss this in more details in Section 8.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Finally, we found it non-trivial to correctly implement the RL-NTM due its large number of interacting components. We developed a simple procedure to numerically check the gradients of the Reinforce algorithm (Section 5). The procedure can be applied to problems unrelated to NTMs, and is of the independent interest. The code for this work can be found at https://github.com/ilyasu123/rlntm.</p>
<h1>2 THE MODEL</h1>
<p>Many difficult tasks require a prolonged, multi-step interaction with an external environment. Examples of such environments include computer games (Mnih et al., 2013), the stock market, an advertisement system, or the physical world (Levine et al., 2015). A model can observe a partial state from the environment, and influence the environment through its actions. This is seen as a general reinforcement leaning problem. However, our setting departs from the classical RL, i.e. we have a freedom to design tools available to solve a given problem. Tools might cooperate with the model (i.e. backpropagation through memory), and the tools specify the actions over the environment. We formalize this concept under the name Interface-Controller interaction.</p>
<p>The external environment is exposed to the model through a number of Interfaces, each with its own API. For instance, a human perceives the world through its senses, which include the vision Interface and the touch Interface. The touch Interface provides methods for contracting the various muscles, and methods for sensing the current state of the muscles, pain level, temperature and a few others. In this work, we explore a number of simple Interfaces that allow the controller to access an input tape, a memory tape, and an output tape.</p>
<p>The part of the model that communicates with Interfaces is called the Controller, which is the only part of the system which learns. The Controller can have prior knowledge about behavior of its Interfaces, but it is not the case in our experiments. The Controller learns to interact with Interfaces in a way that allows it to solve a given task. Fig. 1 illustrates the complete Interfaces-Controller abstraction.
<img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: (Left) The Interface-Controller abstraction, (Right) an instantiation of our model as an InterfaceController. The bottom boxes are the read methods, and the top are the write methods. The RL-NTM makes discrete decisions regarding the move over the input tape, the memory tape, and whether to make a prediction at a given timestep. During training, the model's prediction is compared with the desired output, and is used to train the model when the RL-NTM chooses to advance its position on the output tape; otherwise it is ignored. The memory value vector is a vector of content that is stored in the memory cell.</p>
<p>We now describe the RL-NTM. As a controller, it uses either LSTM, direct access, or LSTM (see sec. 8.1 for a definition). It has a one-dimensional input tape, a one-dimensional memory, and a onedimensional output tape as Interfaces. Both the input tape and the memory tape have a head that reads the Tape's content at the current location. The head of the input tape and the memory tape can move in any direction. However, the output tape is a write-only tape, and its head can either stay at the current position or move forward. Fig. 2 shows an example execution trace for the entire RL-NTM on the reverse task (sec. 6).</p>
<p>At the core of the RL-NTM is an LSTM controller which receives multiple inputs and has to generate multiple outputs at each timestep. Table 1 summarizes the controller's inputs and outputs, and the way in which the RL-NTM is trained to produce them. The objective function of the RL-NTM is the expected log probability of the desired outputs, where the expectation is taken over all possible sequences of actions, weighted with probability of taking these actions. Both backpropagation and Reinforce maximize this objective. Backpropagation maximizes the log probabilities of the model's predictions, while the reinforce algorithm influences the probabilities of action sequences.</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: Execution of RL-NTM on the ForwardReverse task. At each timestep, the RL-NTM consumes the value of the current input tape, the value of the current memory cell, and a representation of all the actions that have been taken in the previous timestep (not marked on the figures). The RLNTM then outputs a new value for the current memory cell (marked with a star), a prediction for the next target symbol, and discrete decisions for changing the positions of the heads on the various tapes. The RL-NTM learns to make discrete decisions using the Reinforce algorithm, and learns to produce continuous outputs using backpropagation.</p>
<p>The global objective can be written formally as:</p>
<p>$$
\sum_{\left[a_{1}, a_{2}, \ldots, a_{n}\right] \in \mathbb{A}^{\dagger}} p_{\text {reinforce }}\left(a_{1}, a_{2}, \ldots, a_{n} \mid \theta\right)\left[\sum_{i=1}^{n} \log \left(p_{\mathrm{bp}}\left(y_{i} \mid x_{1}, \ldots, x_{i}, a_{1}, \ldots a_{i}, \theta\right)\right]\right.
$$</p>
<p>$\mathbb{A}^{\dagger}$ represents the space of sequences of actions that lead to the end of episode. The probabilities in the above equation are parametrized with a neural network (the Controller). We have marked with $p_{\text {reinforce }}$ the part of the equation which is learned with Reinforce. $p_{\mathrm{bp}}$ indicates the part of the equation optimized with the classical backpropagation.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Interface</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Read</th>
<th style="text-align: center;">Write</th>
<th style="text-align: center;">Training Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Input Tape</td>
<td style="text-align: center;">Head</td>
<td style="text-align: center;">window of values surrounding the current position</td>
<td style="text-align: center;">distribution over $[-1,0,1]$</td>
<td style="text-align: center;">Reinforce</td>
</tr>
<tr>
<td style="text-align: center;">Output Tape</td>
<td style="text-align: center;">Head</td>
<td style="text-align: center;">$\varnothing$</td>
<td style="text-align: center;">distribution over $[0,1]$</td>
<td style="text-align: center;">Reinforce</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Content</td>
<td style="text-align: center;">$\varnothing$</td>
<td style="text-align: center;">distribution over output vocabulary</td>
<td style="text-align: center;">Backpropagation</td>
</tr>
<tr>
<td style="text-align: center;">Memory Tape</td>
<td style="text-align: center;">Head</td>
<td style="text-align: center;">window of memory values surrounding the current address</td>
<td style="text-align: center;">distribution over $[-1,0,1]$</td>
<td style="text-align: center;">Reinforce</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">Content</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">vector of real values to store</td>
<td style="text-align: center;">Backpropagation</td>
</tr>
<tr>
<td style="text-align: center;">Miscellaneous</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">all actions taken in the previous time step</td>
<td style="text-align: center;">$\varnothing$</td>
<td style="text-align: center;">$\varnothing$</td>
</tr>
</tbody>
</table>
<p>Table 1: Table summarizes what the Controller reads at every time step, and what it has to produce. The "training" column indicates how the given part of the model is trained.</p>
<p>The RL-NTM receives a direct learning signal only when it decides to make a prediction. If it chooses to not make a prediction at a given timestep, then it will not receive a direct learning signal. Theoretically, we can allow the RL-NTM to run for an arbitrary number of steps without making any prediction, hoping that after sufficiently many steps, it would decide to make a prediction. Doing so will also provide the RL-NTM with arbitrary computational capability. However, this strategy is both unstable and computationally infeasible. Thus, we resort to limiting the total number of computational steps to a fixed upper bound, and force the RL-NTM to predict the next desired output whenever the number of remaining desired outputs is equal to the number of remaining computational steps.</p>
<h1>3 RELATED WORK</h1>
<p>This work is the most similar to the Neural Turing Machine <em>Graves et al. (2014b)</em>. The NTM is an ambitious, computationally universal model that can be trained (or "automatically programmed") with the backpropagation algorithm using only input-output examples.</p>
<p>Following the introduction NTM, several other memory-based models have been introduced. All of them can be seen as part of a larger community effort. These models are constructed according to the Interface-Controller abstraction (Section 2).</p>
<p>Neural Turing Machine (NTM) <em>Graves et al. (2014a)</em> has a modified LSTM as the Controller, and the following three Interfaces: a sequential input, a delayed Output, and a differentiable Memory.</p>
<p>Weakly supervised Memory Network (Sukhbaatar et al., 2015) uses a feed forward network as the Controller, and has a differentiable soft-attention Input, and Delayed Output as Interfaces.
Stack RNN (Joulin \&amp; Mikolov, 2015) has a RNN as the Controller, and the sequential input, a differentiable memory stack, and sequential output as Interfaces. Also uses search to improve its performance.
Neural DeQue (Grefenstette et al., 2015) has a LSTM as the Controller, and a Sequential Input, a differentiable Memory Queue, and the Sequential Output as Interfaces.
Our model fits into the Interfaces-Controller abstraction. It has a direct access LSTM as the Controller (or LSTM or feed forward network), and its three interfaces are the Input Tape, the Memory Tape, and the Output Tape. All three Interfaces of the RL-NTM are discrete and cannot be trained only with backpropagation.</p>
<p>This prior work investigates continuous and differentiable Interfaces, while we consider discrete Interfaces. Discrete Interfaces are more challenging to train because backpropagation cannot be used. However, many external Interfaces are inherently discrete, even though humans can easily use them (apparently without using continuous backpropagation). For instance, one interacts with the Google search engine with discrete actions. This work examines the possibility of learning models that interact with discrete Interfaces with the Reinforce algorithm.</p>
<p>The Reinforce algorithm (Williams, 1992) is a classical RL algorithm, which has been applied to the broad spectrum of planning problems (Peters \&amp; Schaal, 2006; Kohl \&amp; Stone, 2004; Aberdeen \&amp; Baxter, 2002). In addition, it has been applied in object recognition to implement visual attention (Mnih et al., 2014; Ba et al., 2014). This work uses Reinforce to train an attention mechanism: we use it to train how to access the various tapes provided to the model.</p>
<p>The RL-NTM can postpone prediction for an arbitrary number of timesteps, and in principle has access to the unbounded memory. As a result, the RL-NTM is Turing complete in principle. There have been very few prior models that are Turing complete Schmidhuber (2012; 2004). Although our model is Turing complete, it is not very powerful because it is very difficult to train, and our model can solve only relatively simple problems. Moreover, the RL-NTM does not exploit Turing completeness, as none of tasks that it solves require superlinear runtime to be solved.</p>
<h1>4 The Reinforce Algorithm</h1>
<h2>Notation</h2>
<p>Let $\mathbb{A}$ be a space of actions, and $\mathbb{A}^{\dagger}$ be a space of all sequences of actions that cause an episode to end (so $\mathbb{A}^{\dagger} \subset \mathbb{A}^{*}$ ) . An action at time-step $t$ is denoted by $a_{t}$. We denote time at the end of episode by $T$ (this is not completely formal as some episodes can vary in time). Let $a_{1: t}$ stand for a sequence of actions $\left[a_{1}, a_{2}, \ldots, a_{t}\right]$. Let $r\left(a_{1: t}\right)$ denote the reward achieved at time $t$, having executed the sequence of actions $a_{1: t}$, and $R\left(a_{1: T}\right)$ is the cumulative reward, namely $R\left(a_{k: T}\right)=\sum_{t=k}^{T} r\left(a_{1: t}\right)$. Let $p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$ be a parametric conditional probability of an action $a_{t}$ given all previous actions $a_{1:(t-1)}$. Finally, $p_{\theta}$ is a policy parametrized by $\theta$.
This work relies on learning discrete actions with the Reinforce algorithm (Williams, 1992). We now describe this algorithm in detail. Moreover, the supplementary materials include descriptions of techniques for reducing variance of the gradient estimators.</p>
<p>The goal of reinforcement learning is to maximize the sum of future rewards. The Reinforce algorithm (Williams, 1992) does so directly by optimizing the parameters of the policy $p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$. Reinforce follows the gradient of the sum of the future rewards. The objective function for episodic reinforce can be expressed as the sum over all sequences of valid actions that cause the episode to end:</p>
<p>$$
J(\theta)=\sum_{\left[a_{1}, a_{2}, \ldots, a_{T}\right] \in \mathbb{A}^{\dagger}} p_{\theta}\left(a_{1}, a_{2}, \ldots, a_{T}\right) R\left(a_{1}, a_{2}, \ldots, a_{T}\right)=\sum_{a_{1: T} \in \mathbb{A}^{\dagger}} p_{\theta}\left(a_{1: T}\right) R\left(a_{1: T}\right)
$$</p>
<p>This sum iterates over sequences of all possible actions. This set is usually exponential or even infinite, so it cannot be computed exactly and cheaply for most of problems. However, it can be written as</p>
<p>expectation, which can be approximated with an unbiased estimator. We have that:</p>
<p>$$
\begin{aligned}
J(\theta)= &amp; \sum_{a_{1:T} \in \mathbb{A}^{\dagger}} p_{\theta}\left(a_{1: T}\right) R\left(a_{1: T}\right)= \
&amp; \mathbb{E}<em 1:="1:" T="T">{a</em>\right)= \
&amp; \mathbb{E}} \sim p_{\theta}} \sum_{t=1}^{n} r\left(a_{1: t<em 1="1">{a</em>} \sim p_{\theta}\left(a_{1}\right)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a_{2} \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>\right)
\end{aligned}
$$} \sim p_{\theta}\left(a_{T} \mid a_{1:(T-1)}\right)} \sum_{t=1}^{T} r\left(a_{1: t</p>
<p>The last expression suggests a procedure to estimate $J(\theta)$ : simply sequentially sample each $a_{t}$ from the model distribution $p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$ for $t$ from 1 to $T$. The unbiased estimator of $J(\theta)$ is the sum of $r\left(a_{1: t}\right)$. This gives us an algorithm to estimate $J(\theta)$. However, the main interest is in training a model to maximize this quantity.</p>
<p>The reinforce algorithm maximizes $J(\theta)$ by following the gradient of it:</p>
<p>$$
\partial_{\theta} J(\theta)=\sum_{a_{1: T} \in \mathbb{A}^{\dagger}}\left[\partial_{\theta} p_{\theta}\left(a_{1: T}\right)\right] R\left(a_{1: T}\right)
$$</p>
<p>However, the above expression is a sum over the set of the possible action sequences, so it cannot be computed directly for most $\mathbb{A}^{\dagger}$. Once again, the Reinforce algorithm rewrites this sum as an expectation that is approximated with sampling. It relies on the equation: $\partial_{\theta} f(\theta)=f(\theta) \frac{\partial_{\theta} f(\theta)}{f(\theta)}=f(\theta) \partial_{\theta}[\log f(\theta)]$. This identity is valid as long as $f(x) \neq 0$. As typical neural network parametrizations of distributions assign non-zero probability to every action, this condition holds for $f=p_{\theta}$. We have that:</p>
<p>$$
\begin{aligned}
\partial_{\theta} J(\theta) &amp; =\sum_{\left[a_{1: T}\right] \in \mathbb{A}^{\dagger}}\left[\partial_{\theta} p_{\theta}\left(a_{1: T}\right)\right] R\left(a_{1: T}\right)= \
&amp; =\sum_{a_{1: T} \in \mathbb{A}^{\dagger}} p_{\theta}\left(a_{1: T}\right)\left[\partial_{\theta} \log p_{\theta}\left(a_{1: T}\right)\right] R\left(a_{1: T}\right) \
&amp; =\sum_{a_{1: T} \in \mathbb{A}^{\dagger}} p_{\theta}\left(a_{1: T}\right)\left[\sum_{t=1}^{n} \partial_{\theta} \log p_{\theta}\left(a_{i} \mid a_{1:(t-1)}\right)\right] R\left(a_{1: T}\right) \
&amp; =\mathbb{E}<em 1="1">{a</em>} \sim p_{\theta}\left(a_{1}\right)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a_{2} \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>\right)\right]
\end{aligned}
$$} \sim p_{\theta}\left(a_{T} \mid a_{1: T-1)}\right)}\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{i} \mid a_{1:(t-1)}\right)\right]\left[\sum_{t=1}^{T} r\left(a_{1: t</p>
<p>The last expression gives us an algorithm for estimating $\partial_{\theta} J(\theta)$. We have sketched it at the left side of the Figure 3. It's easiest to describe it with respect to computational graph behind a neural network. Reinforce can be implemented as follows. A neural network outputs: $l_{t}=\log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$. Sequentially sample action $a_{t}$ from the distribution $e^{l_{t}}$, and execute the sampled action $a_{t}$. Simultaneously, experience a reward $r\left(a_{1: t}\right)$. Backpropagate the sum of the rewards $\sum_{t=1}^{T} r\left(a_{1: t}\right)$ to the every node $\partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$.
We have derived an unbiased estimator for the sum of future rewards, and the unbiased estimator of its gradient. However, the derived gradient estimator has high variance, which makes learning difficult. RL-NTM employs several techniques to reduce gradient estimator variance: (1) future rewards backpropagation, (2) online baseline prediction, and (3) offline baseline prediction. All these techniques are crucial to solve our tasks. We provide detailed description of techniques in the Supplementary material.</p>
<p>Finally, we needed a way of verifying the correctness of our implementation. We discovered a technique that makes it possible to easily implement a gradient checker for nearly any model that uses Reinforce. Following Section 5 describes this technique.</p>
<h1>5 GRADIENT CHECKING</h1>
<p>The RL-NTM is complex, so we needed to find an automated way of verifying the correctness of our implementation. We discovered a technique that makes it possible to easily implement a gradient checker for nearly any model that uses Reinforce. This discovery is an independent contribution of this</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Figure sketches algorithms: (Left) the reinforce algorithm, (Right) gradient checking for the reinforce algorithm. The red color indicates necessary steps to override the reinforce to become the gradient checker for the reinforce.
work. This Section describes the gradient checking for any implementation of the reinforce algorithm that uses a general function for sampling from multinomial distribution.</p>
<p>The reinforce gradient verification should ensure that expected gradient over all sequences of actions matches the numerical derivative of the expected objective. However, even for a tiny problem, we would need to draw billions of samples to achieve estimates accurate enough to state if there is match or mismatch. Instead, we developed a technique which avoids sampling, and allows for gradient verification of reinforce within seconds on a laptop.</p>
<p>First, we have to reduce the size of our a task to make sure that the number of possible actions is manageable (e.g., $&lt;10^{4}$ ). This is similar to conventional gradient checkers, which can only be applied to small models. Next, we enumerate all possible sequences of actions that terminate the episode. By definition, these are precisely all the elements of $\mathbb{A}^{\dagger}$.</p>
<p>The key idea is the following: we override the sampling function which turns a multinomial distribution into a random sample with a deterministic function that deterministically chooses actions from an appropriate action sequence from $\mathbb{A}^{\dagger}$, while accumulating their probabilities. By calling the modified sampler, it will produce every possible action sequence from $\mathbb{A}^{\dagger}$ exactly once.</p>
<p>For efficiency, it is desirable to use a single minibatch whose size is $# \mathbb{A}^{\dagger}$. The sampling function needs to be adapted in such a way, so that it incrementally outputs the appropriate sequence from $\mathbb{A}^{\dagger}$ as we repeatedly call the sampling function. At the end of the minibatch, the sampling function will have access to the total probability of each action sequence $\left(\prod_{t} p_{\theta}\left(a_{t} \mid a_{1: t-1}\right)\right)$, which in turn can be used to exactly compute $J(\theta)$ and its derivative. To compute the derivative, the reinforce gradient produced by each sequence $a_{1: T} \in \mathbb{A}^{\dagger}$ should be weighted by its probability $p_{\theta}\left(a_{1: T}\right)$. We summarize this procedure on Figure 3.</p>
<p>The gradient checking is critical for ensuring the correctness of our implementation. While the basic reinforce algorithm is conceptually simple, the RL-NTM is fairly complicated, as reinforce is used to train several Interfaces of our model. Moreover, the RL-NTM uses three separate techniques for reducing the variance of the gradient estimators. The model's high complexity greatly increases the probability of a code error. In particular, our early implementations were incorrect, and we were able to fix them only after implementing gradient checking.</p>
<h1>6 TASKS</h1>
<p>This section defines tasks used in the experiments. Figure 4 shows exemplary instantiations of our tasks. Table 2 summarizes the Interfaces that are available for each task.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">Interface</th>
<th style="text-align: center;">Input Tape</th>
<th style="text-align: center;">Memory Tape</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Task</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Copy</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
</tr>
<tr>
<td style="text-align: center;">DuplicatedInput</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
</tr>
<tr>
<td style="text-align: center;">Reverse</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
</tr>
<tr>
<td style="text-align: center;">RepeatCopy</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\times$</td>
</tr>
<tr>
<td style="text-align: center;">ForwardReverse</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
</tbody>
</table>
<p>Table 2: This table marks the available Interfaces for each task. The difficulty of a task is dependent on the type of Interfaces available to the model.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Output <br> Tape 70483</th>
<th style="text-align: center;">Output <br> Tape 74</th>
<th style="text-align: center;">Output <br> Tape 2514</th>
<th style="text-align: center;">Output <br> Tape 7070</th>
<th style="text-align: center;">Output <br> Tape <br> Memory <br> Tape <br> Forced</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Input <br> Tape 00483</td>
<td style="text-align: center;">Input <br> Tape 077444</td>
<td style="text-align: center;">Input <br> Tape 152 r</td>
<td style="text-align: center;">Input <br> Tape 270</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Copy</td>
<td style="text-align: center;">DuplicatedInput</td>
<td style="text-align: center;">Reverse</td>
<td style="text-align: center;">RepeatCopy</td>
<td style="text-align: center;">ForwardReverse</td>
</tr>
</tbody>
</table>
<p>Figure 4: This Figure presents the initial state for every task. The yellow box indicates the starting position of the reading head over the Input Interface. The gray characters on the Output Tape represent the target symbols. Our tasks involve reordering symbols, and and the symbols $x_{i}$ have been picked uniformly from the set of size 30 .
Copy. A generic input is $x_{1} x_{2} x_{3} \ldots x_{C} \varnothing$ and the desired output is $x_{1} x_{2} \ldots x_{C} \varnothing$. Thus the goal is to repeat the input. The length of the input sequence is variable and is allowed to change. The input sequence and the desired output both terminate with a special end-of-sequence symbol $\varnothing$.
DuplicatedInput. A generic input has the form $x_{1} x_{1} x_{1} x_{2} x_{2} x_{2} x_{3} \ldots x_{C-1} x_{C} x_{C} x_{C} \varnothing$ while the desired output is $x_{1} x_{2} x_{3} \ldots x_{C} \varnothing$. Thus each input symbol is replicated three times, so the RL-NTM must emit every third input symbol.
Reverse. A generic input is $x_{1} x_{2} \ldots x_{C-1} x_{C} \varnothing$ and the desired output is $x_{C} x_{C-1} \ldots x_{2} x_{1} \varnothing$.
RepeatCopy. A generic input is $m x_{1} x_{2} x_{3} \ldots x_{C} \varnothing$ and the desired output is $x_{1} x_{2} \ldots x_{C} x_{1} \ldots x_{C} x_{1} \ldots x_{C} \varnothing$, where the number of copies is given by $m$. Thus the goal is to copy the input $m$ times, where $m$ can be only 2 or 3 .
ForwardReverse. The task is identical to Reverse, but the RL-NTM is only allowed to move its input tape pointer forward. It means that a perfect solution must use the NTM's external memory.</p>
<h1>7 CURRICULUM LEARNING</h1>
<p>Humans and animals learn much better when the examples are not randomly presented but organized in a meaningful order which illustrates gradually more concepts, and gradually more complex ones. ... and call them "curriculum learning".</p>
<p>Bengio et al. (2009)</p>
<p>We were unable to solve tasks with RL-NTM by training it on the difficult instances of the problems (where difficult usually means long). To succeed, we had to create a curriculum of tasks of increasing complexity. We verified that our tasks were completely unsolvable (in an all-or-nothing sense) for all but the shortest sequences when we did not use a curriculum. In our experiments, we measure the complexity $c$ of a problem instance by the maximal length of the desired output to typical inputs. During training, we maintain a distribution over the task complexity. We shift the distribution over the task complexities whenever the performance of the RL-NTM exceeds a threshold. Then, our model focuses on more difficult problem instances as its performance improves.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Probability</th>
<th style="text-align: center;">Procedure to pick complexity $d$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">10\%</td>
<td style="text-align: center;">uniformly at random from the possible task complexities.</td>
</tr>
<tr>
<td style="text-align: center;">25\%</td>
<td style="text-align: center;">uniformly from $[1, C+e]$</td>
</tr>
<tr>
<td style="text-align: center;">65\%</td>
<td style="text-align: center;">$d=D+e$</td>
</tr>
</tbody>
</table>
<p>Table 3: The curriculum learning distribution, indexed by $C$. Here $e$ is a sample from a geometric distribution whose success probability is $\frac{1}{2}$, i.e., $p(e=k)=\frac{1}{2^{k}}$.</p>
<p>The distribution over task complexities is indexed with an integer $c$, and is defined in Table 3. While we have not tuned the coefficients in the curriculum learning setup, we experimentally verified that it is critical to always maintain non-negligible mass over the hardest difficulty levels (Zaremba \&amp; Sutskever, 2014). Removing it makes the curriculum much less effective.</p>
<p>Whenever the average zero-one-loss (normalized by the length of the target sequence) of our RL-NTM decreases below 0.2 , we increase $c$ by 1 . We kept doing so until $c$ reaches its maximal allowable value. Finally, we enforced a refractory period to ensure that successive increments of $C$ are separated by at least 100 parameter updates, since we encountered situations where $C$ increased in rapid succession which consistently caused learning to fail.</p>
<h1>8 CONTROLLERS</h1>
<p>The success of reinforcement learning training highly depends on the complexity of the controller, and its ease of training. It's common to either limit number of parameters of the network, or to constraint it by initialization from pretrained model on some other task (for instance, object recognition network for robotics). Ideally, models should be generic enough to not need such "tricks". However, still some tasks require building task specific architectures.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 5: LSTM as a controller.
<img alt="img-4.jpeg" src="img-4.jpeg" /></p>
<p>Figure 6: The direct access controller.</p>
<p>This work considers two controllers. The first is a LSTM (Fig. 5), and the second is a direct access controller (Fig. 6). LSTM is a generic controller, that in principle should be powerful enough to solve any of the considered tasks. However, it has trouble solving many of them. Direct access controller, is a much better fit for symbol rearrangement tasks, however it's not a generic solution.</p>
<h3>8.1 DIRECT ACCESS CONTROLLER</h3>
<p>All the tasks that we consider involve rearranging the input symbols in some way. For example, a typical task is to reverse a sequence (section 6 lists the tasks). For such tasks, the controller would benefit from a built-in mechanism for directly copying an appropriate input to memory and to the output. Such a mechanism would free the LSTM controller from remembering the input symbol in its control variables ("registers"), and would shorten the backpropagation paths and therefore make learning easier. We implemented this mechanism by adding the input to the memory and the output, and also adding the memory to the output and to the adjacent memories (figure 6), while modulating these additive contribution by a dynamic scalar (sigmoid) which is computed from the controller's state. This way, the controller can decide to effectively not add the current input to the output at a given timestep. Unfortunately the necessity of this architectural modification is a drawback of our implementation, since it is not domain independent and would therefore not improve the performance of the RL-NTM on many tasks of interest.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Controller</th>
<th style="text-align: center;">LSTM</th>
<th style="text-align: center;">Direct Access</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Task</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">Copy</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">DuplicateInput</td>
<td style="text-align: center;">$\checkmark$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">Reverse</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">ForwardReverse</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
<tr>
<td style="text-align: left;">RepeatCopy</td>
<td style="text-align: center;">$\times$</td>
<td style="text-align: center;">$\checkmark$</td>
</tr>
</tbody>
</table>
<p>Table 4: Success of training on various task for a given controller.</p>
<h1>9 EXPERIMENTS</h1>
<p>We presents results of training RL-NTM on all aforementioned tasks. The main drawback of our experiments is in the lack of comparison to the other models. However, the tasks that we consider have to be considered in conjunction with available Interfaces, and other models haven't been considered with the same set of interfaces. The statement, "this model solves addition" is difficult to assess, as the way that digits are delivered defines task difficulty.</p>
<p>The closest model to ours is NTM, and the shared task that they consider is copying. We are able to generalize with copying to an arbitrary length. However, our Interfaces make this task very simple. Table 4 summarizes results.</p>
<p>We trained our model using SGD with a fixed learning rate of 0.05 and a fixed momentum of 0.9 . We used a batch of size 200, which we found to work better than smaller batch sizes (such as 50 or 20). We normalized the gradient by batch size but not by sequence length. We independently clip the norm of the gradients w.r.t. the RL-NTM parameters to 5 , and the gradient w.r.t. the baseline network to 2 . We initialize the RL-NTM controller and the baseline model using a Gaussian with standard deviation 0.1. We used an inverse temperature of 0.01 for the different action distributions. Doing so reduced the effective learning rate of the Reinforce derivatives. The memory consists of 35 real values through which we backpropagate. The initial memory state and the controller's initial hidden states were set to the zero vector.
<img alt="img-5.jpeg" src="img-5.jpeg" /></p>
<p>Figure 7: (Left) Trace of ForwardReverse solution, (Right) trace of RepeatInput. The vertical depicts execution time. The rows show the input pointer, output pointer, and memory pointer (with the $*$ symbol) at each step of the RL-NTM's execution. Note that we represent the set ${1, \ldots, 30}$ with 30 distinct symbols, and lack of prediction with $#$.</p>
<p>The ForwardReverse task is particularly interesting. In order to solve the problem, the RL-NTM has to move to the end of the sequence without making any predictions. While doing so, it has to store the input sequence into its memory (encoded in real values), and use its memory when reversing the sequence (Fig. 7).</p>
<p>We have also experimented with a number of additional tasks but with less empirical success. Tasks we found to be too difficult include sorting and long integer addition (in base 3 for simplicity), and RepeatCopy when the input tape is forced to only move forward. While we were able to achieve reasonable performance on the sorting task, the RL-NTM learned an ad-hoc algorithm and made excessive use of its controller memory in order to sort the sequence.
Empirically, we found all the components of the RL-NTM essential to successfully solving these problems. All our tasks are either solvable in under 20,000 parameter updates or fail in arbitrary number of updates. We were completely unable to solve RepeatCopy, Reverse, and Forward reverse with the LSTM controller, but with direct access controller we succeeded. Moreover, we were also unable to solve any of these problems at all without a curriculum (except for short sequences of length 5). We present more traces for our tasks in the supplementary material (together with failure traces).</p>
<h1>10 CONCLUSIONS</h1>
<p>We have shown that the Reinforce algorithm is capable of training an NTM-style model to solve very simple algorithmic problems. While the Reinforce algorithm is very general and is easily applicable to a wide range of problems, it seems that learning memory access patterns with Reinforce is difficult.</p>
<p>Our gradient checking procedure for Reinforce can be applied to a wide variety of implementations. We also found it extremely useful: without it, we had no way of being sure that our gradient was correct, which made debugging and tuning much more difficult.</p>
<h2>11 ACKNOWLEDGMENTS</h2>
<p>We thank Christopher Olah for the LSTM figure that have been used in the paper, and to Tencia Lee for revising the paper.</p>
<h2>REFERENCES</h2>
<p>Aberdeen, Douglas and Baxter, Jonathan. Scaling internal-state policy-gradient methods for pomdps. In MACHINE LEARNING-INTERNATIONAL WORKSHOP THEN CONFERENCE-, pp. 3-10, 2002.</p>
<p>Ba, Jimmy, Mnih, Volodymyr, and Kavukcuoglu, Koray. Multiple object recognition with visual attention. arXiv preprint arXiv:1412.7755, 2014.</p>
<p>Bengio, Yoshua, Louradour, Jérôme, Collobert, Ronan, and Weston, Jason. Curriculum learning. In Proceedings of the 26th annual international conference on machine learning, pp. 41-48. ACM, 2009.</p>
<p>Graves, Alex, Wayne, Greg, and Danihelka, Ivo. Neural turing machines. arXiv preprint arXiv:1410.5401, 2014a.
Graves, Alex, Wayne, Greg, and Danihelka, Ivo. Neural turing machines. arXiv preprint arXiv:1410.5401, 2014b.
Grefenstette, Edward, Hermann, Karl Moritz, Suleyman, Mustafa, and Blunsom, Phil. Learning to transduce with unbounded memory. arXiv preprint arXiv:1506.02516, 2015.</p>
<p>Joulin, Armand and Mikolov, Tomas. Inferring algorithmic patterns with stack-augmented recurrent nets. arXiv preprint arXiv:1503.01007, 2015.</p>
<p>Kohl, Nate and Stone, Peter. Policy gradient reinforcement learning for fast quadrupedal locomotion. In Robotics and Automation, 2004. Proceedings. ICRA'04. 2004 IEEE International Conference on, volume 3, pp. 26192624. IEEE, 2004.</p>
<p>Levine, Sergey, Finn, Chelsea, Darrell, Trevor, and Abbeel, Pieter. End-to-end training of deep visuomotor policies. arXiv preprint arXiv:1504.00702, 2015.</p>
<p>Mnih, Volodymyr, Kavukcuoglu, Koray, Silver, David, Graves, Alex, Antonoglou, Ioannis, Wierstra, Daan, and Riedmiller, Martin. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.</p>
<p>Mnih, Volodymyr, Heess, Nicolas, Graves, Alex, et al. Recurrent models of visual attention. In Advances in Neural Information Processing Systems, pp. 2204-2212, 2014.</p>
<p>Peters, Jan and Schaal, Stefan. Policy gradient methods for robotics. In Intelligent Robots and Systems, 2006 IEEE/RSJ International Conference on, pp. 2219-2225. IEEE, 2006.</p>
<p>Schmidhuber, Juergen. Self-delimiting neural networks. arXiv preprint arXiv:1210.0118, 2012.
Schmidhuber, Jürgen. Optimal ordered problem solver. Machine Learning, 54(3):211-254, 2004.
Sukhbaatar, Sainbayar, Szlam, Arthur, Weston, Jason, and Fergus, Rob. Weakly supervised memory networks. arXiv preprint arXiv:1503.08895, 2015.</p>
<p>Williams, Ronald J. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine learning, 8(3-4):229-256, 1992.</p>
<p>Zaremba, Wojciech and Sutskever, Ilya. Learning to execute. arXiv preprint arXiv:1410.4615, 2014.</p>
<h1>APPENDIX A: DETAILED REINFORCE EXPLANATION</h1>
<p>We present here several techniques to decrease variance of the gradient estimation for the Reinforce. We have employed all of these tricks in our RL-NTM implementation.
We expand notation introduced in Sec. 4. Let $\mathcal{A}^{\ddagger}$ denote all valid subsequences of actions (i.e. $\mathcal{A}^{\ddagger} \subset$ $\mathcal{A}^{\dagger} \subset \mathcal{A}^{*}$ ). Moreover, we define set of sequences of actions that are valid after executing a sequence $a_{1: t}$, and that terminate. We denote such set by: $\mathcal{A}<em 1:="1:" t="t">{a</em>}}^{\dagger}$. Every sequence $a_{(t+1): T} \in \mathcal{A<em 1:="1:" t="t">{a</em>$ terminates an episode.}}^{\dagger</p>
<h2>CAUSALITY OF ACTIONS</h2>
<p>Actions at time $t$ cannot possibly influence rewards obtained in the past, because the past rewards are caused by actions prior to them. This idea allows to derive an unbiased estimator of $\partial_{\theta} J(\theta)$ with lower variance. Here, we formalize it:</p>
<p>$$
\begin{aligned}
\partial_{\theta} J(\theta) &amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} p_{\theta}(a)\left[\partial_{\theta} \log p_{\theta}(a)\right] R(a) \
&amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} p_{\theta}(a)\left[\partial_{\theta} \log p_{\theta}(a)\right]\left[\sum_{t=1}^{T} r\left(a_{1: t}\right)\right] \
&amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} p_{\theta}(a)\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right)\right] \
&amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} p_{\theta}(a)\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right)+\partial_{\theta} \log p_{\theta}\left(a_{(t+1): T} \mid a_{1: t}\right) r\left(a_{1: t}\right)\right] \
&amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} \sum_{t=1}^{T} p_{\theta}\left(a_{1: t}\right) \partial_{\theta} \log p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right)+p_{\theta}(a) \partial_{\theta} \log p_{\theta}\left(a_{(t+1): T} \mid a_{1: t}\right) r\left(a_{1: t}\right) \
&amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} \sum_{t=1}^{T} p_{\theta}\left(a_{1: t}\right) \partial_{\theta} \log p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right)+p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right) \partial_{\theta} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t}\right) \
&amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}}\left[\sum_{t=1}^{T} p_{\theta}\left(a_{1: t}\right) \partial_{\theta} \log p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right)\right]+\sum_{a_{1: T} \in \mathcal{A}^{\dagger}} \sum_{t=1}^{T}\left[p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right) \partial_{\theta} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t}\right)\right]
\end{aligned}
$$</p>
<p>We will show that the right side of this equation is equal to zero. It's zero, because the future actions $a_{(t+1): T}$ don't influence past rewards $r\left(a_{1: t}\right)$. Here we formalize it; we use an identity $\mathbb{E}<em T="T" _t_1_:="(t+1):">{a</em>} \in \mathcal{A<em 1:="1:" t="t">{a</em>\right)=1:$}}^{\dagger}} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t</p>
<p>$$
\begin{aligned}
&amp; \sum_{a_{1: T} \in \mathcal{A}^{\dagger}} \sum_{t=1}^{T}\left[p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right) \partial_{\theta} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t}\right)\right]= \
&amp; \sum_{a_{1: t} \in \mathcal{A}^{\ddagger}}\left[p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right) \sum_{a_{(t+1): T} \in \mathcal{A}<em 1:="1:" t="t">{a</em>\right)\right]= \
&amp; \sum_{a_{1: t} \in \mathcal{A}^{\ddagger}} p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right) \partial_{\theta} 1=0
\end{aligned}
$$}}^{\dagger}} \partial_{\theta} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t</p>
<p>We can purge the right side of the equation for $\partial_{\theta} J(\theta)$ :</p>
<p>$$
\begin{aligned}
\partial_{\theta} J(\theta) &amp; =\sum_{a_{1: T} \in \mathcal{A}^{\dagger}}\left[\sum_{t=1}^{T} p_{\theta}\left(a_{1: t}\right) \partial_{\theta} \log p_{\theta}\left(a_{1: t}\right) r\left(a_{1: t}\right)\right] \
&amp; =\mathbb{E}<em 1="1">{a</em>} \sim p_{\theta}(a)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>\right)\right]
\end{aligned}
$$} \sim p_{\theta}\left(a \mid a_{1:(T-1)}\right)}\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=1}^{T} r\left(a_{1: i</p>
<p>The last line of derived equations describes the learning algorithm. This can be implemented as follows. A neural network outputs: $l_{t}=\log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$. We sequentially sample action $a_{t}$ from the distribution $e^{l_{t}}$, and execute the sampled action $a_{t}$. Simultaneously, we experience a reward $r\left(a_{1: t}\right)$. We should backpropagate to the node $\partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)$ the sum of rewards starting from time step $t$ : $\sum_{i=t}^{T} r\left(a_{1: i}\right)$. The only difference in comparison to the initial algorithm is that we backpropagate sum of rewards starting from the current time step, instead of the sum of rewards over the entire episode.</p>
<h1>ONLINE BASELINE PREDICTION</h1>
<p>Online baseline prediction is an idea, that the importance of reward is determined by its relative relation to other rewards. All the rewards could be shifted by a constant factor and such change shouldn't effect its relation, thus it shouldn't influence expected gradient. However, it could decrease the variance of the gradient estimate.
Aforementioned shift is called the baseline, and it can be estimated separately for the every time-step. We have that:</p>
<p>$$
\begin{aligned}
&amp; \sum_{a_{(t+1): T} \in \mathcal{A}<em 1:="1:" t="t">{a</em>\right)=1 \
&amp; \partial_{\theta} \sum_{a_{(t+1): T} \in \mathcal{A}}}^{t}} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t<em 1:="1:" t="t">{a</em>\right)=0
\end{aligned}
$$}}^{t}} p_{\theta}\left(a_{(t+1): T} \mid a_{1: t</p>
<p>We are allowed to subtract above quantity (multiplied by $b_{t}$ ) from our estimate of the gradient without changing its expected value:</p>
<p>$$
\partial_{\theta} J(\theta)=\mathbb{E}<em 1="1">{a</em>} \sim p_{\theta}(a)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>\right)\right]
$$} \sim p_{\theta}\left(a \mid a_{1:(T-1)}\right)}\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=\mathbf{t}}^{T}\left(r\left(a_{1: i}\right)-b_{t</p>
<p>Above statement holds for an any sequence of $b_{t}$. We aim to find the sequence $b_{t}$ that yields the lowest variance estimator on $\partial_{\theta} J(\theta)$. The variance of our estimator is:</p>
<p>$$
\begin{aligned}
V a r= &amp; \mathbb{E}<em 1="1">{a</em>} \sim p_{\theta}(a)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>- \
&amp; {\left[\mathbb{E}} \sim p_{\theta}\left(a \mid a_{1:(T-1)}\right)}\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=\mathbf{t}}^{T}\left(r\left(a_{1: i}\right)-b_{t}\right)\right]^{2<em 1="1">{a</em>} \sim p_{\theta}(a)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>
\end{aligned}
$$} \sim p_{\theta}\left(a \mid a_{1:(T-1)}\right)}\left[\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=\mathbf{t}}^{T}\left(r\left(a_{1: i}\right)-b_{t}\right)\right]\right]^{2}</p>
<p>The second term doesn't depend on $b_{t}$, and the variance is always positive. It's sufficient to minimize the first term. The first term is minimal when it's derivative with respect to $b_{t}$ is zero. This implies</p>
<p>$$
\begin{aligned}
&amp; \mathbb{E}<em 1="1">{a</em>} \sim p_{\theta}(a)} \mathbb{E<em 2="2">{a</em>} \sim p_{\theta}\left(a \mid a_{1}\right)} \ldots \mathbb{E<em T="T">{a</em>\right)=0 \
&amp; \sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=\mathbf{t}}^{T}\left(r\left(a_{1: i}\right)-b_{t}\right)=0 \
&amp; b_{t}=\frac{\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=\mathbf{t}}^{T} r\left(a_{1: t}\right)}{\sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right)}
\end{aligned}
$$} \sim p_{\theta}\left(a \mid a_{1:(T-1)}\right)} \sum_{t=1}^{T} \partial_{\theta} \log p_{\theta}\left(a_{t} \mid a_{1:(t-1)}\right) \sum_{i=\mathbf{t}}^{T}\left(r\left(a_{1: i}\right)-b_{t</p>
<p>This gives us estimate for a vector $b_{t} \in \mathbb{R}^{# #}$. However, it is common to use a single scalar for $b_{t} \in \mathbb{R}$, and estimate it as $\mathbb{E}<em _theta="\theta">{p</em>: T\right)$.}\left(a_{t}: T \mid a_{1:(t-1)}\right)} R\left(a_{t</p>
<h2>OFFLINE BASELINE PREDICTION</h2>
<p>The Reinforce algorithm works much better whenever it has accurate baselines. A separate LSTM can help in the baseline estimation. First, run the baseline LSTM on the entire input tape to produce a vector summarizing the input. Next, continue running the baseline LSTM in tandem with the controller LSTM,</p>
<p><img alt="img-6.jpeg" src="img-6.jpeg" /></p>
<p>Figure 8: The baseline LSTM computes a baseline $b_{t}$ for every computational step $t$ of the RL-NTM. The baseline LSTM receives the same inputs as the RL-NTM, and it computes a baseline $b_{t}$ for time $t$ before observing the chosen actions of time $t$. However, it is important to first provide the baseline LSTM with the entire input tape as a preliminary inputs, because doing so allows the baseline LSTM to accurately estimate the true difficulty of a given problem instance and therefore compute better baselines. For example, if a problem instance is unusually difficult, then we expect $R_{1}$ to be large and negative. If the baseline LSTM is given entire input tape as an auxiliary input, it could compute an appropriately large and negative $b_{1}$.
so that the baseline LSTM receives precisely the same inputs as the controller LSTM, and outputs a baseline $b_{t}$ at each timestep $t$. The baseline LSTM is trained to minimize $\sum_{t=1}^{T}\left[R\left(a_{t: T}\right)-b_{t}\right]^{2}$ (Fig. 8). This technique introduces a biased estimator, however it works well in practise.
We found it important to first have the baseline LSTM go over the entire input before computing the baselines $b_{t}$. It is especially beneficial whenever there is considerable variation in the difficulty of the examples. For example, if the baseline LSTM can recognize that the current instance is unusually difficult, it can output a large negative value for $b_{t=1}$ in anticipation of a large and a negative $R_{1}$. In general, it is cheap and therefore worthwhile to provide the baseline network with all of the available information, even if this information would not be available at test time, because the baseline network is not needed at test time.</p>
<h1>Appendix B: Execution Traces</h1>
<p>We present several execution traces of the RL-NTM. Each figure shows execution traces of the trained RL-NTM on each of the tasks. The first row shows the input tape and the desired output, while each subsequent row shows the RL-NTM's position on the input tape and its prediction for the output tape. In these examples, the RL-NTM solved each task perfectly, so the predictions made in the output tape perfectly match the desired outputs listed in the first row.</p>
<p><img alt="img-7.jpeg" src="img-7.jpeg" /></p>
<p>An RL-NTM successfully solving a small instance of the Reverse problem (where the external memory is not used).
<img alt="img-8.jpeg" src="img-8.jpeg" /></p>
<p>An RL-NTM successfully solving an instance of the RepeatCopy problem where the input is to be repeated three times.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Input Tape</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Output Tape</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">WE30LPA5TCW58FT</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">TF85RCT5APL03EW8</td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>An RL-NTM successfully solving a small instance of the ForwardReverse problem, where the external memory is used.
<img alt="img-9.jpeg" src="img-9.jpeg" /></p>
<p>An example of a failure of the RepeatCopy task, where the input tape is only allowed to move forward. The correct solution would have been to copy the input to the memory, and then solve the task using the memory. Instead, the memory pointer is moving randomly.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{1}$ Work done while the author was at Google.
${ }^{2}$ Both authors contributed equally to this work.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>