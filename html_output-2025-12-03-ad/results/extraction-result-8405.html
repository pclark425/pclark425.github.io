<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-8405 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-8405</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-8405</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-149.html">extraction-schema-149</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <p><strong>Paper ID:</strong> paper-0427110f0e79f41e69a8eb00a3ec8868bac26a4f</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/0427110f0e79f41e69a8eb00a3ec8868bac26a4f" target="_blank">Do NLP Models Know Numbers? Probing Numeracy in Embeddings</a></p>
                <p><strong>Paper Venue:</strong> Conference on Empirical Methods in Natural Language Processing</p>
                <p><strong>Paper TL;DR:</strong> This work investigates the numerical reasoning capabilities of a state-of-the-art question answering model on the DROP dataset and finds this model excels on questions that require numerical reasoning, i.e., it already captures numeracy.</p>
                <p><strong>Paper Abstract:</strong> The ability to understand and work with numbers (numeracy) is critical for many complex reasoning tasks. Currently, most NLP models treat numbers in text in the same way as other tokens—they embed them as distributed vectors. Is this enough to capture numeracy? We begin by investigating the numerical reasoning capabilities of a state-of-the-art question answering model on the DROP dataset. We find this model excels on questions that require numerical reasoning, i.e., it already captures numeracy. To understand how this capability emerges, we probe token embedding methods (e.g., BERT, GloVe) on synthetic list maximum, number decoding, and addition tasks. A surprising degree of numeracy is naturally present in standard embeddings. For example, GloVe and word2vec accurately encode magnitude for numbers up to 1,000. Furthermore, character-level embeddings are even more precise—ELMo captures numeracy the best for all pre-trained methods—but BERT, which uses sub-word units, is less exact.</p>
                <p><strong>Cost:</strong> 0.019</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e8405.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e8405.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NAQANet</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Numerically-augmented QANet (NAQANet)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A QANet-based reading-comprehension model augmented to output passage span, question span, count, or addition/subtraction answers; represents tokens as concatenation of 300-d GloVe and a character-level CNN and learns numeric reasoning end-to-end from QA supervision.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>NAQANet</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>QANet-derived model with four output branches (passage span, question span, count, addition/subtraction). Inputs are token embeddings formed by concatenating pre-trained GloVe vectors and a Char-CNN; no explicit numeric module is provided.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Comparative (binary/non-binary), Superlative (list max/min and argmax), addition/subtraction answer branch (as dataset answer types)</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Numeracy appears to arise from the token embeddings (GloVe + Char-CNN) together with learned comparison/sorting behavior in the QA model — i.e., the model implicitly learns comparison algorithms over scalar-like embedding representations rather than using an explicit arithmetic module.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Evaluation on DROP subset of comparative and superlative questions; stress tests by programmatically adding/multiplying paragraph numbers and converting digits to word forms, and ablation removing GloVe to isolate Char-CNN.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Validation F1 on DROP: full val 49.2 F1; Comparative overall 76.4 F1; Binary (either-or) comparative 89.0 F1; Non-binary comparative 49.8 F1; Superlative questions overall 67.7 F1; Superlative (number answers) 69.2 F1; Superlative (span answers / argmax) 66.3 F1. (See Table 2.)</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Fails to extrapolate to numbers outside its training range: stress tests show small drops for small additive changes but severe drops for large-add/multiply (e.g., Multiply [11,100] drops superlative F1 from 67.7 to 32.0); converting digits to words for larger magnitudes also hurts performance; ablation shows dependence on embedding types.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>High accuracy on comparative/superlative questions despite no explicit numerical modules implies algorithms for comparison were learned; ablation (-GloVe) retains numeracy via Char-CNN; probing experiments on embeddings (separate in paper) show embeddings contain magnitude information that NAQANet can leverage.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>When numbers are moved outside the distribution seen during training (e.g., scaled by large multiplicative factors or replaced by large word-form numbers), NAQANet performance falls sharply, indicating learned numerical operations do not reliably generalize beyond training-range values.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e8405.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Word Vectors</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Pre-trained Word Vectors (GloVe and word2vec)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>300-dimensional pre-trained static word embeddings (GloVe and word2vec) which, despite objective functions unrelated to numeracy, encode number magnitude and ordering sufficient for many numerical probes within training ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>GloVe / word2vec (300-d)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Pre-trained static word embedding vectors (300-dimensional) fixed during probing experiments; in-vocabulary integers are represented by their token embedding.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>List maximum (classification over indices), decoding (regression to numeric value), addition (regression to sum)</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Number magnitude and ordering are embedded in the continuous word-vector space; for small ranges a roughly linear subspace encodes numeric magnitude (linear probe is competitive for small ranges).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Fixed embeddings; probes trained on top: LSTM + classifier for list maximum, linear and 3-layer MLP regressors for decoding and addition; interpolation/extrapolation splits and synthetic inputs (integers/floats/negatives/word-forms).</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation (Table 4): word2vec list-max accuracy: [0,99]=0.90, [0,999]=0.78, [0,9999]=0.71; decoding RMSE: 2.34, 18.77, 333.47 (for the same ranges); addition RMSE: 0.75, 21.23, 210.07. GloVe similar: list-max 0.90/0.78/0.72; decoding RMSE 2.23/13.77/174.21; addition RMSE 0.80/16.51/180.31.</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Degrades substantially on larger numeric ranges (RMSE explodes for [0,9999]); cannot represent out-of-vocabulary formats like arbitrary floats/negatives in these experiments; extrapolation to values outside training range fails (see extrapolation results: poor list-max accuracy on test ranges).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Linear probe success on small ranges and interpolation results indicate that magnitude is encoded in embedding geometry; probes trained on fixed embeddings generalize across held-out values within training range.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>While embeddings encode magnitude for small/medium ranges, their performance breaks down for large ranges and extrapolation; subword/char methods outperform them for digit-granular numeracy.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e8405.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>ELMo</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>ELMo (Deep contextualized word representations)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Contextualized word representations built from character-level convolutions followed by contextual layers; ELMo embeddings show strong numeracy in probes, outperforming subword BERT on many numeric tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>ELMo</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Contextualized embeddings that use character-level convolutions (convolutions of size 1-7 with max pooling) followed by contextual layers; embeddings were extracted and fixed during probing.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>List maximum, decoding, addition (same synthetic probes)</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Character-level convolution prior captures digit morphology and produces embeddings that encode numeric magnitude and ordering; often admits a linear subspace for small ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Fixed ELMo embeddings with the same LSTM/linear/MLP probes as for other embedding types; interpolation and extrapolation tests, floats and negatives included.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation (Table 4): list-max accuracy [0,99]=0.98, [0,999]=0.88, [0,9999]=0.76; decoding RMSE 2.35, 13.48, 62.20; addition RMSE 0.94, 15.50, 45.71. Floats and negatives: list-max on floats [0.0,99.9]=0.91 (Table 5); negatives [-50,50] list-max=0.96 (Table 6). Extrapolation (Table 7) list-max on test ranges: 0.65, 0.57, 0.38 (for [151,160],[151,180],[151,200]).</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Extrapolation to values outside the training range is limited (performance drops as test values move away from training distribution); performance still degrades on very large numeric ranges though more robust than sub-word methods.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Superior interpolation performance compared to BERT and word vectors, and the ablation/analysis linking ELMo strength to its Char-CNN architecture, support the conclusion that character-level convolutional priors encode numeracy.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Although ELMo is strong, it still fails to extrapolate to much larger unseen values and performance is not perfect for very large ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e8405.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>BERT</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>BERT-base (lowercased, 30k subword pieces)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A transformer-based contextualized model using sub-word tokenization; BERT embeddings contain some numeracy but are less precise for digits and struggle on large ranges and floats due to subword segmentation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>BERT-base (lowercased)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Transformer-based contextualized encoder; in experiments the lowercased BERT-base model using ~30k WordPiece/subword pieces was used and embeddings were fixed during probing.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>List maximum, decoding, addition (probed synthetically)</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Sub-word tokenization splits digit sequences into inconsistent subword pieces, resulting in embeddings that are less consistent with numeric magnitude; numeric information is present but less linearly encoded.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Fixed BERT token embeddings with the standard LSTM classifier for list max and linear/MLP regressors for decoding and addition; interpolation/extrapolation splits and float/negative tests.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation (Table 4): list-max accuracy [0,99]=0.95, [0,999]=0.62, [0,9999]=0.52; decoding RMSE 3.21, 29.00, 431.78; addition RMSE 4.56, 67.81, 454.78. Float list-max (Table 5) = 0.82. Extrapolation behavior: Figure 1 shows predictions for held-out numbers cluster near training extremes; Table 7 extrapolation list-max on test ranges = 0.35, 0.11, 0.14.</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Struggles with larger numeric ranges and float inputs; poor extrapolation (predictions saturate near maximum seen during training or behave non-monotonically); subword tokenization causes inconsistent encodings for numerically similar tokens.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Compared to ELMo and Char-CNN, BERT's lower interpolation and much worse extrapolation and large RMSE indicate subword scheme harms numeric encoding; visualization of extrapolation behavior (Figure 1) shows systemic failure modes.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>BERT still performs well on very small ranges and can be competitive in some interpolation settings (e.g., list-max [0,99]=0.95), but breaks down as numeric ranges grow or when inputs are floats/negatives.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e8405.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Char-CNN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Character-level Convolutional Neural Network embeddings (learned)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Learned character-CNN embeddings (with left padding) which provide the strongest empirical numeracy in probes: precise magnitude encoding, good interpolation and relatively strong extrapolation compared to other methods.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Char-CNN (learned)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A character-level CNN encoder (trained on the synthetic probing tasks or jointly) using left character padding; embeddings are trained (or trained jointly with the probe) rather than fixed pre-trained vectors.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>List maximum, decoding, addition</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Direct character-level processing gives consistent digit-aware representations that preserve numeric magnitude/order; architectural prior of convolution appears particularly effective.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Char-CNN trained on synthetic tasks (probes may be trained jointly) and evaluated under same interpolation/extrapolation regimes as other embeddings.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation (Table 4): list-max accuracy [0,99]=0.97, [0,999]=0.93, [0,9999]=0.88; decoding RMSE 2.50, 4.92, 11.57; addition RMSE 1.19, 7.75, 15.09. Extrapolation (Table 7): list-max on test ranges = 0.81, 0.75, 0.73.</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Although the best performing method overall, it still shows degraded accuracy for extremely large ranges and can struggle with values far outside the training distribution (but degrades less than other embeddings).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Best interpolation numbers across tasks and relatively strong extrapolation numbers indicate the Char-CNN architectural prior is effective at capturing numeracy; results consistent with NAQANet ablation (Char-CNN-only retains much numeracy).</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Untrained Char-CNNs are surprisingly competitive, indicating some effect of architecture vs. learned weights; still not perfect at extrapolation.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e8405.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Char-LSTM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Character-level LSTM embeddings (learned)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Character-level LSTM encoder trained on the synthetic probes; strong at capturing numeracy and, in extrapolation tests, often performs best or near-best among methods.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Char-LSTM (learned)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A character-level LSTM encoder that produces token representations from character sequences; trained on synthetic probing tasks and evaluated under interpolation/extrapolation regimes.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>List maximum, decoding, addition</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Sequence-modeling over characters yields representations that capture digit morphology and magnitude; LSTM inductive bias supports generalization in some extrapolation settings.</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Learned embedding trained jointly with probes (same architectures for downstream probe tasks); evaluated on interpolation and extrapolation synthetic datasets.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation (Table 4): list-max [0,99]=0.98, [0,999]=0.92, [0,9999]=0.76; decoding RMSE 2.55, 8.65, 18.33; addition RMSE 1.21, 15.11, 25.37. Extrapolation (Table 7): list-max test ranges = 0.88, 0.84, 0.82 (best in that table).</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>While strong, performance on very large ranges still degrades, and decoding/addition RMSE increases with range; training stability and left-padding choices affect performance.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Top extrapolation numbers (Table 7) and strong interpolation numbers indicate character-sequence modeling supports both magnitude encoding and somewhat better extrapolation than many pre-trained methods.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Performance advantage can be sensitive to architectural and training details (e.g., left padding), and Char-LSTM isn't immune to extrapolation failure for extreme values.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e8405.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Value Embedding</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Number-as-Value Embedding (direct numeric embedding)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>An embedding that maps a token representing a number directly to its scalar numeric value (optionally log-scaled); intended as a baseline to give probes direct access to numeric values but found difficult to train for large ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Value Embedding</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A direct mapping that sets a token's embedding to a vector derived from the numeric value (e.g., the scalar value or log-scaled); used as a baseline embedding type fixed during probing.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>Decoding and addition (regression) and list maximum</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Trivially encodes numeric value in the embedding; however, large magnitude/variance makes training standard probes difficult without transformations (log scale improves results).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>Fixed value-based embeddings; same probe architectures (linear/MLP/LSTM) used for evaluation and compared against other embedding types.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Interpolation (Table 4): list-max [0,99]=0.99, [0,999]=0.88, [0,9999]=0.68; decoding RMSE 1.20, 11.23, 275.50; addition RMSE 0.30, 15.98, 654.33 (large ranges cause RMSE explosion).</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Despite providing direct numeric information, models using raw value embeddings were difficult to train for large ranges and produced very large errors for wide ranges unless transformed (log-scale helped); training instability and scale variance are problems.</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Strong performance on small ranges confirms that direct value information is sufficient in principle, but the training difficulties and poor large-range RMSE support the paper's claim that neural probes struggle to output/extrapolate large numeric values.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Value embedding fails in practice for large ranges even though it directly encodes numbers, showing that probe architecture/training dynamics are critical and not just the availability of numeric information.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e8405.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e8405.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of how language models perform arithmetic, including mechanisms, representations, probing results, interventions, performance, and error analysis.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Probing Suite</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Synthetic Probing Suite (List Maximum / Decoding / Addition)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A set of synthetic tasks designed to probe numeric information in token embeddings: (1) List Maximum (5-way index prediction), (2) Decoding (regress token embedding to numeric value), (3) Addition (regress sum from two embeddings); used with interpolation and extrapolation splits.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Probing models: LSTM classifier for list-max; linear and 3-layer MLP regressors for decoding and addition</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>List maximum: LSTM reads list of 5 embeddings and softmax predicts index of maximum. Decoding: linear or 3-layer MLP regresses embedding to numeric value (MSE loss). Addition: concatenated embeddings fed to 3-layer MLP to predict sum (MSE loss). Probes trained with fixed pre-trained embeddings except for learned char encoders which are trained jointly.</td>
                        </tr>
                        <tr>
                            <td><strong>arithmetic_task_type</strong></td>
                            <td>List max (ordinal comparison), decoding (mapping embedding -> scalar), addition (binary arithmetic sum)</td>
                        </tr>
                        <tr>
                            <td><strong>mechanism_or_representation</strong></td>
                            <td>Probes test whether numeric magnitude/order is present in fixed embedding spaces (linear or non-linear maps); success implies embeddings represent numeric information (possibly in a linear subspace for small ranges).</td>
                        </tr>
                        <tr>
                            <td><strong>probing_or_intervention_method</strong></td>
                            <td>80/20 random splits over integer/float/negative ranges for interpolation; separate extrapolation experiments training on a range and testing on larger unseen values; NAQANet stress tests via add/multiply and digits->words replacements; data augmentation experiments to turn extrapolation into interpolation.</td>
                        </tr>
                        <tr>
                            <td><strong>performance_metrics</strong></td>
                            <td>Summarized results: pre-trained embeddings (GloVe/word2vec/ELMo) capture numeracy under interpolation (list-max accuracies often >0.9 for small ranges); char-level learned embeddings (Char-CNN/Char-LSTM) perform best overall with list-max 0.97-0.98 on [0,99] and remain strong on larger ranges. Extrapolation performance much worse across many embeddings (see Tables 4,5,6,7 and Figure 1 for detailed numbers).</td>
                        </tr>
                        <tr>
                            <td><strong>error_types_or_failure_modes</strong></td>
                            <td>Probing models and downstream systems generalize poorly to values outside the training distribution; linear probes work for small ranges but fail for large ranges; different embeddings fail in distinct ways (e.g., BERT predictions saturate at training max).</td>
                        </tr>
                        <tr>
                            <td><strong>evidence_for_mechanism</strong></td>
                            <td>Interpolation success shows magnitude/order encoded in embeddings; linear probe competitiveness on small ranges shows existence of a linear subspace encoding magnitude; Figure 1 and extrapolation experiments demonstrate that probe/model prediction mechanisms fail to extrapolate beyond training range.</td>
                        </tr>
                        <tr>
                            <td><strong>counterexamples_or_challenges</strong></td>
                            <td>Data augmentation (adding/multiplying training cases) can substantially ameliorate extrapolation failures, indicating failures are not purely representational but also due to training distribution; Value Embedding shows that direct access to numeric value does not automatically guarantee stable probe training for large ranges.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Do NLP Models Know Numbers? Probing Numeracy in Embeddings', 'publication_date_yy_mm': '2019-09'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Neural arithmetic logic units <em>(Rating: 2)</em></li>
                <li>Numeracy for language models: Evaluating and improving their ability to predict numbers <em>(Rating: 2)</em></li>
                <li>DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs <em>(Rating: 2)</em></li>
                <li>Exploring numeracy in word embeddings <em>(Rating: 2)</em></li>
                <li>Analysing mathematical reasoning abilities of neural models <em>(Rating: 2)</em></li>
                <li>On the practical computational power of finite precision rnns for language recognition <em>(Rating: 1)</em></li>
                <li>QANet: Combining local convolution with global self-attention for reading comprehension <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-8405",
    "paper_id": "paper-0427110f0e79f41e69a8eb00a3ec8868bac26a4f",
    "extraction_schema_id": "extraction-schema-149",
    "extracted_data": [
        {
            "name_short": "NAQANet",
            "name_full": "Numerically-augmented QANet (NAQANet)",
            "brief_description": "A QANet-based reading-comprehension model augmented to output passage span, question span, count, or addition/subtraction answers; represents tokens as concatenation of 300-d GloVe and a character-level CNN and learns numeric reasoning end-to-end from QA supervision.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "NAQANet",
            "model_description": "QANet-derived model with four output branches (passage span, question span, count, addition/subtraction). Inputs are token embeddings formed by concatenating pre-trained GloVe vectors and a Char-CNN; no explicit numeric module is provided.",
            "arithmetic_task_type": "Comparative (binary/non-binary), Superlative (list max/min and argmax), addition/subtraction answer branch (as dataset answer types)",
            "mechanism_or_representation": "Numeracy appears to arise from the token embeddings (GloVe + Char-CNN) together with learned comparison/sorting behavior in the QA model — i.e., the model implicitly learns comparison algorithms over scalar-like embedding representations rather than using an explicit arithmetic module.",
            "probing_or_intervention_method": "Evaluation on DROP subset of comparative and superlative questions; stress tests by programmatically adding/multiplying paragraph numbers and converting digits to word forms, and ablation removing GloVe to isolate Char-CNN.",
            "performance_metrics": "Validation F1 on DROP: full val 49.2 F1; Comparative overall 76.4 F1; Binary (either-or) comparative 89.0 F1; Non-binary comparative 49.8 F1; Superlative questions overall 67.7 F1; Superlative (number answers) 69.2 F1; Superlative (span answers / argmax) 66.3 F1. (See Table 2.)",
            "error_types_or_failure_modes": "Fails to extrapolate to numbers outside its training range: stress tests show small drops for small additive changes but severe drops for large-add/multiply (e.g., Multiply [11,100] drops superlative F1 from 67.7 to 32.0); converting digits to words for larger magnitudes also hurts performance; ablation shows dependence on embedding types.",
            "evidence_for_mechanism": "High accuracy on comparative/superlative questions despite no explicit numerical modules implies algorithms for comparison were learned; ablation (-GloVe) retains numeracy via Char-CNN; probing experiments on embeddings (separate in paper) show embeddings contain magnitude information that NAQANet can leverage.",
            "counterexamples_or_challenges": "When numbers are moved outside the distribution seen during training (e.g., scaled by large multiplicative factors or replaced by large word-form numbers), NAQANet performance falls sharply, indicating learned numerical operations do not reliably generalize beyond training-range values.",
            "uuid": "e8405.0",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Word Vectors",
            "name_full": "Pre-trained Word Vectors (GloVe and word2vec)",
            "brief_description": "300-dimensional pre-trained static word embeddings (GloVe and word2vec) which, despite objective functions unrelated to numeracy, encode number magnitude and ordering sufficient for many numerical probes within training ranges.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "GloVe / word2vec (300-d)",
            "model_description": "Pre-trained static word embedding vectors (300-dimensional) fixed during probing experiments; in-vocabulary integers are represented by their token embedding.",
            "arithmetic_task_type": "List maximum (classification over indices), decoding (regression to numeric value), addition (regression to sum)",
            "mechanism_or_representation": "Number magnitude and ordering are embedded in the continuous word-vector space; for small ranges a roughly linear subspace encodes numeric magnitude (linear probe is competitive for small ranges).",
            "probing_or_intervention_method": "Fixed embeddings; probes trained on top: LSTM + classifier for list maximum, linear and 3-layer MLP regressors for decoding and addition; interpolation/extrapolation splits and synthetic inputs (integers/floats/negatives/word-forms).",
            "performance_metrics": "Interpolation (Table 4): word2vec list-max accuracy: [0,99]=0.90, [0,999]=0.78, [0,9999]=0.71; decoding RMSE: 2.34, 18.77, 333.47 (for the same ranges); addition RMSE: 0.75, 21.23, 210.07. GloVe similar: list-max 0.90/0.78/0.72; decoding RMSE 2.23/13.77/174.21; addition RMSE 0.80/16.51/180.31.",
            "error_types_or_failure_modes": "Degrades substantially on larger numeric ranges (RMSE explodes for [0,9999]); cannot represent out-of-vocabulary formats like arbitrary floats/negatives in these experiments; extrapolation to values outside training range fails (see extrapolation results: poor list-max accuracy on test ranges).",
            "evidence_for_mechanism": "Linear probe success on small ranges and interpolation results indicate that magnitude is encoded in embedding geometry; probes trained on fixed embeddings generalize across held-out values within training range.",
            "counterexamples_or_challenges": "While embeddings encode magnitude for small/medium ranges, their performance breaks down for large ranges and extrapolation; subword/char methods outperform them for digit-granular numeracy.",
            "uuid": "e8405.1",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "ELMo",
            "name_full": "ELMo (Deep contextualized word representations)",
            "brief_description": "Contextualized word representations built from character-level convolutions followed by contextual layers; ELMo embeddings show strong numeracy in probes, outperforming subword BERT on many numeric tasks.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "ELMo",
            "model_description": "Contextualized embeddings that use character-level convolutions (convolutions of size 1-7 with max pooling) followed by contextual layers; embeddings were extracted and fixed during probing.",
            "arithmetic_task_type": "List maximum, decoding, addition (same synthetic probes)",
            "mechanism_or_representation": "Character-level convolution prior captures digit morphology and produces embeddings that encode numeric magnitude and ordering; often admits a linear subspace for small ranges.",
            "probing_or_intervention_method": "Fixed ELMo embeddings with the same LSTM/linear/MLP probes as for other embedding types; interpolation and extrapolation tests, floats and negatives included.",
            "performance_metrics": "Interpolation (Table 4): list-max accuracy [0,99]=0.98, [0,999]=0.88, [0,9999]=0.76; decoding RMSE 2.35, 13.48, 62.20; addition RMSE 0.94, 15.50, 45.71. Floats and negatives: list-max on floats [0.0,99.9]=0.91 (Table 5); negatives [-50,50] list-max=0.96 (Table 6). Extrapolation (Table 7) list-max on test ranges: 0.65, 0.57, 0.38 (for [151,160],[151,180],[151,200]).",
            "error_types_or_failure_modes": "Extrapolation to values outside the training range is limited (performance drops as test values move away from training distribution); performance still degrades on very large numeric ranges though more robust than sub-word methods.",
            "evidence_for_mechanism": "Superior interpolation performance compared to BERT and word vectors, and the ablation/analysis linking ELMo strength to its Char-CNN architecture, support the conclusion that character-level convolutional priors encode numeracy.",
            "counterexamples_or_challenges": "Although ELMo is strong, it still fails to extrapolate to much larger unseen values and performance is not perfect for very large ranges.",
            "uuid": "e8405.2",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "BERT",
            "name_full": "BERT-base (lowercased, 30k subword pieces)",
            "brief_description": "A transformer-based contextualized model using sub-word tokenization; BERT embeddings contain some numeracy but are less precise for digits and struggle on large ranges and floats due to subword segmentation.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "BERT-base (lowercased)",
            "model_description": "Transformer-based contextualized encoder; in experiments the lowercased BERT-base model using ~30k WordPiece/subword pieces was used and embeddings were fixed during probing.",
            "arithmetic_task_type": "List maximum, decoding, addition (probed synthetically)",
            "mechanism_or_representation": "Sub-word tokenization splits digit sequences into inconsistent subword pieces, resulting in embeddings that are less consistent with numeric magnitude; numeric information is present but less linearly encoded.",
            "probing_or_intervention_method": "Fixed BERT token embeddings with the standard LSTM classifier for list max and linear/MLP regressors for decoding and addition; interpolation/extrapolation splits and float/negative tests.",
            "performance_metrics": "Interpolation (Table 4): list-max accuracy [0,99]=0.95, [0,999]=0.62, [0,9999]=0.52; decoding RMSE 3.21, 29.00, 431.78; addition RMSE 4.56, 67.81, 454.78. Float list-max (Table 5) = 0.82. Extrapolation behavior: Figure 1 shows predictions for held-out numbers cluster near training extremes; Table 7 extrapolation list-max on test ranges = 0.35, 0.11, 0.14.",
            "error_types_or_failure_modes": "Struggles with larger numeric ranges and float inputs; poor extrapolation (predictions saturate near maximum seen during training or behave non-monotonically); subword tokenization causes inconsistent encodings for numerically similar tokens.",
            "evidence_for_mechanism": "Compared to ELMo and Char-CNN, BERT's lower interpolation and much worse extrapolation and large RMSE indicate subword scheme harms numeric encoding; visualization of extrapolation behavior (Figure 1) shows systemic failure modes.",
            "counterexamples_or_challenges": "BERT still performs well on very small ranges and can be competitive in some interpolation settings (e.g., list-max [0,99]=0.95), but breaks down as numeric ranges grow or when inputs are floats/negatives.",
            "uuid": "e8405.3",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Char-CNN",
            "name_full": "Character-level Convolutional Neural Network embeddings (learned)",
            "brief_description": "Learned character-CNN embeddings (with left padding) which provide the strongest empirical numeracy in probes: precise magnitude encoding, good interpolation and relatively strong extrapolation compared to other methods.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Char-CNN (learned)",
            "model_description": "A character-level CNN encoder (trained on the synthetic probing tasks or jointly) using left character padding; embeddings are trained (or trained jointly with the probe) rather than fixed pre-trained vectors.",
            "arithmetic_task_type": "List maximum, decoding, addition",
            "mechanism_or_representation": "Direct character-level processing gives consistent digit-aware representations that preserve numeric magnitude/order; architectural prior of convolution appears particularly effective.",
            "probing_or_intervention_method": "Char-CNN trained on synthetic tasks (probes may be trained jointly) and evaluated under same interpolation/extrapolation regimes as other embeddings.",
            "performance_metrics": "Interpolation (Table 4): list-max accuracy [0,99]=0.97, [0,999]=0.93, [0,9999]=0.88; decoding RMSE 2.50, 4.92, 11.57; addition RMSE 1.19, 7.75, 15.09. Extrapolation (Table 7): list-max on test ranges = 0.81, 0.75, 0.73.",
            "error_types_or_failure_modes": "Although the best performing method overall, it still shows degraded accuracy for extremely large ranges and can struggle with values far outside the training distribution (but degrades less than other embeddings).",
            "evidence_for_mechanism": "Best interpolation numbers across tasks and relatively strong extrapolation numbers indicate the Char-CNN architectural prior is effective at capturing numeracy; results consistent with NAQANet ablation (Char-CNN-only retains much numeracy).",
            "counterexamples_or_challenges": "Untrained Char-CNNs are surprisingly competitive, indicating some effect of architecture vs. learned weights; still not perfect at extrapolation.",
            "uuid": "e8405.4",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Char-LSTM",
            "name_full": "Character-level LSTM embeddings (learned)",
            "brief_description": "Character-level LSTM encoder trained on the synthetic probes; strong at capturing numeracy and, in extrapolation tests, often performs best or near-best among methods.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Char-LSTM (learned)",
            "model_description": "A character-level LSTM encoder that produces token representations from character sequences; trained on synthetic probing tasks and evaluated under interpolation/extrapolation regimes.",
            "arithmetic_task_type": "List maximum, decoding, addition",
            "mechanism_or_representation": "Sequence-modeling over characters yields representations that capture digit morphology and magnitude; LSTM inductive bias supports generalization in some extrapolation settings.",
            "probing_or_intervention_method": "Learned embedding trained jointly with probes (same architectures for downstream probe tasks); evaluated on interpolation and extrapolation synthetic datasets.",
            "performance_metrics": "Interpolation (Table 4): list-max [0,99]=0.98, [0,999]=0.92, [0,9999]=0.76; decoding RMSE 2.55, 8.65, 18.33; addition RMSE 1.21, 15.11, 25.37. Extrapolation (Table 7): list-max test ranges = 0.88, 0.84, 0.82 (best in that table).",
            "error_types_or_failure_modes": "While strong, performance on very large ranges still degrades, and decoding/addition RMSE increases with range; training stability and left-padding choices affect performance.",
            "evidence_for_mechanism": "Top extrapolation numbers (Table 7) and strong interpolation numbers indicate character-sequence modeling supports both magnitude encoding and somewhat better extrapolation than many pre-trained methods.",
            "counterexamples_or_challenges": "Performance advantage can be sensitive to architectural and training details (e.g., left padding), and Char-LSTM isn't immune to extrapolation failure for extreme values.",
            "uuid": "e8405.5",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Value Embedding",
            "name_full": "Number-as-Value Embedding (direct numeric embedding)",
            "brief_description": "An embedding that maps a token representing a number directly to its scalar numeric value (optionally log-scaled); intended as a baseline to give probes direct access to numeric values but found difficult to train for large ranges.",
            "citation_title": "",
            "mention_or_use": "use",
            "model_name": "Value Embedding",
            "model_description": "A direct mapping that sets a token's embedding to a vector derived from the numeric value (e.g., the scalar value or log-scaled); used as a baseline embedding type fixed during probing.",
            "arithmetic_task_type": "Decoding and addition (regression) and list maximum",
            "mechanism_or_representation": "Trivially encodes numeric value in the embedding; however, large magnitude/variance makes training standard probes difficult without transformations (log scale improves results).",
            "probing_or_intervention_method": "Fixed value-based embeddings; same probe architectures (linear/MLP/LSTM) used for evaluation and compared against other embedding types.",
            "performance_metrics": "Interpolation (Table 4): list-max [0,99]=0.99, [0,999]=0.88, [0,9999]=0.68; decoding RMSE 1.20, 11.23, 275.50; addition RMSE 0.30, 15.98, 654.33 (large ranges cause RMSE explosion).",
            "error_types_or_failure_modes": "Despite providing direct numeric information, models using raw value embeddings were difficult to train for large ranges and produced very large errors for wide ranges unless transformed (log-scale helped); training instability and scale variance are problems.",
            "evidence_for_mechanism": "Strong performance on small ranges confirms that direct value information is sufficient in principle, but the training difficulties and poor large-range RMSE support the paper's claim that neural probes struggle to output/extrapolate large numeric values.",
            "counterexamples_or_challenges": "Value embedding fails in practice for large ranges even though it directly encodes numbers, showing that probe architecture/training dynamics are critical and not just the availability of numeric information.",
            "uuid": "e8405.6",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        },
        {
            "name_short": "Probing Suite",
            "name_full": "Synthetic Probing Suite (List Maximum / Decoding / Addition)",
            "brief_description": "A set of synthetic tasks designed to probe numeric information in token embeddings: (1) List Maximum (5-way index prediction), (2) Decoding (regress token embedding to numeric value), (3) Addition (regress sum from two embeddings); used with interpolation and extrapolation splits.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Probing models: LSTM classifier for list-max; linear and 3-layer MLP regressors for decoding and addition",
            "model_description": "List maximum: LSTM reads list of 5 embeddings and softmax predicts index of maximum. Decoding: linear or 3-layer MLP regresses embedding to numeric value (MSE loss). Addition: concatenated embeddings fed to 3-layer MLP to predict sum (MSE loss). Probes trained with fixed pre-trained embeddings except for learned char encoders which are trained jointly.",
            "arithmetic_task_type": "List max (ordinal comparison), decoding (mapping embedding -&gt; scalar), addition (binary arithmetic sum)",
            "mechanism_or_representation": "Probes test whether numeric magnitude/order is present in fixed embedding spaces (linear or non-linear maps); success implies embeddings represent numeric information (possibly in a linear subspace for small ranges).",
            "probing_or_intervention_method": "80/20 random splits over integer/float/negative ranges for interpolation; separate extrapolation experiments training on a range and testing on larger unseen values; NAQANet stress tests via add/multiply and digits-&gt;words replacements; data augmentation experiments to turn extrapolation into interpolation.",
            "performance_metrics": "Summarized results: pre-trained embeddings (GloVe/word2vec/ELMo) capture numeracy under interpolation (list-max accuracies often &gt;0.9 for small ranges); char-level learned embeddings (Char-CNN/Char-LSTM) perform best overall with list-max 0.97-0.98 on [0,99] and remain strong on larger ranges. Extrapolation performance much worse across many embeddings (see Tables 4,5,6,7 and Figure 1 for detailed numbers).",
            "error_types_or_failure_modes": "Probing models and downstream systems generalize poorly to values outside the training distribution; linear probes work for small ranges but fail for large ranges; different embeddings fail in distinct ways (e.g., BERT predictions saturate at training max).",
            "evidence_for_mechanism": "Interpolation success shows magnitude/order encoded in embeddings; linear probe competitiveness on small ranges shows existence of a linear subspace encoding magnitude; Figure 1 and extrapolation experiments demonstrate that probe/model prediction mechanisms fail to extrapolate beyond training range.",
            "counterexamples_or_challenges": "Data augmentation (adding/multiplying training cases) can substantially ameliorate extrapolation failures, indicating failures are not purely representational but also due to training distribution; Value Embedding shows that direct access to numeric value does not automatically guarantee stable probe training for large ranges.",
            "uuid": "e8405.7",
            "source_info": {
                "paper_title": "Do NLP Models Know Numbers? Probing Numeracy in Embeddings",
                "publication_date_yy_mm": "2019-09"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Neural arithmetic logic units",
            "rating": 2
        },
        {
            "paper_title": "Numeracy for language models: Evaluating and improving their ability to predict numbers",
            "rating": 2
        },
        {
            "paper_title": "DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs",
            "rating": 2
        },
        {
            "paper_title": "Exploring numeracy in word embeddings",
            "rating": 2
        },
        {
            "paper_title": "Analysing mathematical reasoning abilities of neural models",
            "rating": 2
        },
        {
            "paper_title": "On the practical computational power of finite precision rnns for language recognition",
            "rating": 1
        },
        {
            "paper_title": "QANet: Combining local convolution with global self-attention for reading comprehension",
            "rating": 1
        }
    ],
    "cost": 0.01909025,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Do NLP Models Know Numbers? Probing Numeracy in Embeddings</h1>
<p>Eric Wallace ${ }^{<em> 1}$, Yizhong Wang ${ }^{</em> 2}$, Sujian Li ${ }^{2}$, Sameer Singh ${ }^{3}$, Matt Gardner ${ }^{1}$<br>${ }^{1}$ Allen Institute for Artificial Intelligence<br>${ }^{2}$ Peking University<br>${ }^{3}$ University of California, Irvine<br>{ericw, mattg}@allenai.org, {yizhong, lisujian}@pku.edu.cn, sameer@uci.edu</p>
<h4>Abstract</h4>
<p>The ability to understand and work with numbers (numeracy) is critical for many complex reasoning tasks. Currently, most NLP models treat numbers in text in the same way as other tokens-they embed them as distributed vectors. Is this enough to capture numeracy? We begin by investigating the numerical reasoning capabilities of a state-of-the-art question answering model on the DROP dataset. We find this model excels on questions that require numerical reasoning, i.e., it already captures numeracy. To understand how this capability emerges, we probe token embedding methods (e.g., BERT, GloVe) on synthetic list maximum, number decoding, and addition tasks. A surprising degree of numeracy is naturally present in standard embeddings. For example, GloVe and word2vec accurately encode magnitude for numbers up to 1,000. Furthermore, character-level embeddings are even more precise-ELMo captures numeracy the best for all pre-trained methods-but BERT, which uses sub-word units, is less exact.</p>
<h2>1 Introduction</h2>
<p>Neural NLP models have become the de-facto standard tool across language understanding tasks, even solving basic reading comprehension and textual entailment datasets (Yu et al., 2018; Devlin et al., 2019). Despite this, existing models are incapable of complex forms of reasoning, in particular, we focus on the ability to reason numerically. Recent datasets such as DROP (Dua et al., 2019), EQUATE (Ravichander et al., 2019), or Mathematics Questions (Saxton et al., 2019) test numerical reasoning; they contain examples which require comparing, sorting, and adding numbers in natural language (e.g., Figure 2).</p>
<p>The first step in performing numerical reasoning over natural language is numeracy: the abil-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: We train a probing model to decode a number from its word embedding over a random $80 \%$ of the integers from $[-500,500]$, e.g., " 71 " $\rightarrow 71.0$. We plot the model's predictions for all numbers from [-2000, 2000]. The model accurately decodes numbers within the training range (in blue), i.e., pre-trained embeddings like GloVe and BERT capture numeracy. However, the probe fails to extrapolate to larger numbers (in red). The Char-CNN (e) and Char-LSTM (f) are trained jointly with the probing model.
ity to understand and work with numbers in either digit or word form (Spithourakis and Riedel, 2018). For example, one must understand that the string " 23 " represents a bigger value than "twentytwo". Once a number's value is (perhaps implicitly) represented, reasoning algorithms can then process the text, e.g., extracting the list of field goals and computing that list's maximum (first question in Figure 2). Learning to reason numerically over paragraphs with only question-answer supervision appears daunting for end-to-end models; our work seeks to understand if and how "out-of-the-box" neural NLP models already learn this.</p>
<p>We begin by analyzing the state-of-the-art NAQANet model (Dua et al., 2019) for DROPtesting it on a subset of questions that evaluate numerical reasoning (Section 2). To our surprise,</p>
<p>the model exhibits excellent numerical reasoning abilities. Amidst reading and comprehending natural language, the model successfully computes list maximums/minimums, extracts superlative entities (argmax reasoning), and compares numerical quantities. For instance, despite NAQANet achieving only 49 F 1 on the entire validation set, it scores 89 F 1 on numerical comparison questions. We also stress test the model by perturbing the validation paragraphs and find one failure mode: the model struggles to extrapolate to numbers outside its training range.</p>
<p>We are especially intrigued by the model's ability to learn numeracy, i.e., how does the model know the value of a number given its embedding? The model uses standard embeddings (GloVe and a Char-CNN) and receives no direct supervision for number magnitude/ordering. To understand how numeracy emerges, we probe token embedding methods (e.g., BERT, GloVe) using synthetic list maximum, number decoding, and addition tasks (Section 3).</p>
<p>We find that all widely-used pre-trained embeddings, e.g., ELMo (Peters et al., 2018), BERT (Devlin et al., 2019), and GloVe (Pennington et al., 2014), capture numeracy: number magnitude is present in the embeddings, even for numbers in the thousands. Among all embeddings, characterlevel methods exhibit stronger numeracy than word- and sub-word-level methods (e.g., ELMo excels while BERT struggles), and character-level models learned directly on the synthetic tasks are the strongest overall. Finally, we investigate why NAQANet had trouble extrapolating-was it a failure in the model or the embeddings? We repeat our probing tasks and test for model extrapolation, finding that neural models struggle to predict numbers outside the training range.</p>
<h2>2 Numeracy Case Study: DROP QA</h2>
<p>This section examines the state-of-the-art model for DROP by investigating its accuracy on questions that require numerical reasoning.</p>
<h3>2.1 DROP Dataset</h3>
<p>DROP is a reading comprehension dataset that tests numerical reasoning operations such as counting, sorting, and addition (Dua et al., 2019). The dataset's input-output format is a superset of SQuAD (Rajpurkar et al., 2016): the answers are paragraph spans, as well as question</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup>Figure 2: Three DROP questions that require numerical reasoning; the state-of-the-art NAQANet answers every question correct. Plausible answer candidates to the questions are underlined and the model's predictions are shown in bold.
spans, number answers (e.g., 35), and dates (e.g., 03/01/2014). The only supervision provided is the question-answer pairs, i.e., a model must learn to reason numerically while simultaneously learning to read and comprehend.</p>
<h3>2.2 NAQANet Model</h3>
<p>Modeling approaches for DROP include both semantic parsing (Krishnamurthy et al., 2017) and reading comprehension (Yu et al., 2018) models. We focus on the latter, specifically on Numerically-augmented QANet (NAQANet), the current state-of-the-art model (Dua et al., 2019). ${ }^{1}$ The model's core structure closely follows QANet (Yu et al., 2018) except that it contains four output branches, one for each of the four answer types (passage span, question span, count answer, or addition/subtraction of numbers.)</p>
<p>Words and numbers are represented as the concatenation of GloVe embeddings and the output of a character-level CNN. The model contains no auxiliary components for representing number magnitude or performing explicit comparisons. We refer readers to Yu et al. (2018) and Dua et al. (2019) for further details.</p>
<h3>2.3 Comparative and Superlative Questions</h3>
<p>We focus on questions that NAQANet requires numeracy to answer, namely Comparative and Superlative questions. ${ }^{2}$ Comparative questions</p>
<p><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Question Type</th>
<th style="text-align: left;">Example</th>
<th style="text-align: left;">Reasoning Required</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Comparative (Binary)</td>
<td style="text-align: left;">Which country is a bigger exporter, Brazil or Uruguay?</td>
<td style="text-align: left;">Binary Comparison</td>
</tr>
<tr>
<td style="text-align: left;">Comparative (Non-binary)</td>
<td style="text-align: left;">Which player had a touchdown longer than 20 yards?</td>
<td style="text-align: left;">Greater Than</td>
</tr>
<tr>
<td style="text-align: left;">Superlative (Number)</td>
<td style="text-align: left;">How many yards was the shortest field goal?</td>
<td style="text-align: left;">List Minimum</td>
</tr>
<tr>
<td style="text-align: left;">Superlative (Span)</td>
<td style="text-align: left;">Who kicked the longest field goal?</td>
<td style="text-align: left;">Argmax</td>
</tr>
</tbody>
</table>
<p>Table 1: We focus on DROP Comparative and Superlative questions which test NAQANet's numeracy.
probe a model's understanding of quantities or events that are "larger", "smaller", or "longer" than others. Certain comparative questions ask about "either-or" relations (e.g., first row of Table 1), which test binary comparison. Other comparative questions require more diverse comparative reasoning, such as greater than relationships (e.g., second row of Table 1).</p>
<p>Superlative questions ask about the "shortest", "largest", or "biggest" quantity in a passage. When the answer type is a number, superlative questions require finding the maximum or minimum of a list (e.g., third row of Table 1). When the answer type is a span, superlative questions usually require an argmax operation, i.e., one must find the superlative action or quantity and then extract the associated entity (e.g., fourth row of Table 1). We filter the validation set to comparative and superlative questions by writing templates to match words in the question.</p>
<h3>2.4 Emergent Numeracy in NAQANet</h3>
<p>NAQANet's accuracy on comparative and superlative questions is significantly higher than its average accuracy on the validation set (Table 2). ${ }^{3}$</p>
<p>NAQANet achieves 89.0 F1 on binary (eitheror) comparative questions, approximately 40 F 1 points higher than the average validation question and within 7 F 1 points of human test performance. The model achieves a lower, but respectable, accuracy on non-binary comparisons. These questions require multiple reasoning steps, e.g., the second question in Table 1 requires (1) extracting all the touchdown distances, (2) finding the distance that is greater than twenty, and (3) selecting the player associated with the touchdown of that distance.</p>
<p>We divide the superlative questions into questions that have number answers and questions with span answers according to the dataset's provided answer type. NAQANet achieves nearly 70 F1 on superlative questions with number answers, i.e., it can compute list maximum and minimums.</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup>| Question Type | Count | EM | F1 |
| :-- | :--: | :--: | :--: |
| Human (Test Set) | 9622 | 92.4 | 96.0 |
| Full Validation | 9536 | 46.2 | 49.2 |
| $\quad$ Number Answers | 5842 | 44.3 | 44.4 |
| Comparative | 704 | 73.6 | 76.4 |
| $\quad$ Binary (either-or) | 477 | 86.0 | 89.0 |
| $\quad$ Non-binary | 227 | 47.6 | 49.8 |
| Superlative Questions | 861 | 64.6 | 67.7 |
| $\quad$ Number Answers | 475 | 68.8 | 69.2 |
| $\quad$ Span Answers | 380 | 59.7 | 66.3 |</p>
<p>Table 2: NAQANet achieves higher accuracy on questions that require numerical reasoning (Superlative and Comparative) than on standard validation questions. Human performance is reported from Dua et al. (2019).</p>
<p>The model answers about two-thirds of superlative questions with span answers correctly ( 66.3 F 1 ), i.e., it can perform argmax reasoning.</p>
<p>Figure 2 shows examples of superlative questions answered correctly by NAQANet. The first two questions require computing the maximum/minimum of a list: the model must recognize which digits correspond to field goals and touchdowns passes, and then extract the maximum/minimum of the correct list. The third question requires argmax reasoning: the model must first compute the longest touchdown pass and then find the corresponding receiver "Chaz Schilens".</p>
<h3>2.5 Stress Testing NAQANet's Numeracy</h3>
<p>Just how far does the numeracy of NAQANet go? Here, we stress test the model by automatically modifying DROP validation paragraphs.</p>
<p>We test two phenomena: larger numbers and word-form numbers. For larger numbers, we generate a random positive integer and multiply or add that value to the numbers in each paragraph. For word forms, we replace every digit in the paragraph with its word form (e.g., " 75 " $\rightarrow$ "seventyfive"). Since word-form numbers are usually small in magnitude when they occur in DROP, we perform word replacements for integers in the range $[0,100]$. We guarantee the ground-truth answer is</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Stress Test Dataset</th>
<th style="text-align: left;">All Questions</th>
<th style="text-align: left;"></th>
<th style="text-align: left;">Superlative</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;">F1</td>
<td style="text-align: left;">$\Delta$</td>
<td style="text-align: left;">F1</td>
<td style="text-align: left;">$\Delta$</td>
</tr>
<tr>
<td style="text-align: left;">Original Validation Set</td>
<td style="text-align: left;">49.2</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">67.7</td>
<td style="text-align: left;">-</td>
</tr>
<tr>
<td style="text-align: left;">Add $[1,20]$</td>
<td style="text-align: left;">47.7</td>
<td style="text-align: left;">-1.5</td>
<td style="text-align: left;">64.1</td>
<td style="text-align: left;">-3.6</td>
</tr>
<tr>
<td style="text-align: left;">Add $[21,100]$</td>
<td style="text-align: left;">41.4</td>
<td style="text-align: left;">-7.8</td>
<td style="text-align: left;">40.4</td>
<td style="text-align: left;">-27.3</td>
</tr>
<tr>
<td style="text-align: left;">Multiply $[2,10]$</td>
<td style="text-align: left;">41.1</td>
<td style="text-align: left;">-8.1</td>
<td style="text-align: left;">39.3</td>
<td style="text-align: left;">-28.4</td>
</tr>
<tr>
<td style="text-align: left;">Multiply $[11,100]$</td>
<td style="text-align: left;">38.8</td>
<td style="text-align: left;">-10.4</td>
<td style="text-align: left;">32.0</td>
<td style="text-align: left;">-35.7</td>
</tr>
<tr>
<td style="text-align: left;">Digits to Words $[0,20]$</td>
<td style="text-align: left;">45.5</td>
<td style="text-align: left;">-3.7</td>
<td style="text-align: left;">63.8</td>
<td style="text-align: left;">-3.9</td>
</tr>
<tr>
<td style="text-align: left;">Digits to Words $[21,100]$</td>
<td style="text-align: left;">41.9</td>
<td style="text-align: left;">-7.3</td>
<td style="text-align: left;">46.1</td>
<td style="text-align: left;">-21.6</td>
</tr>
</tbody>
</table>
<p>Table 3: We stress test NAQANet's numeracy by manipulating the numbers in the validation paragraphs. Add or Multiply $[x, y]$ indicates adding or multiplying all of the numbers in the passage by a random integer in the range $[\mathrm{x}, \mathrm{y}]$. Digits $\rightarrow$ Words $[x, y]$ converts all integers in the passage within the range $[\mathrm{x}, \mathrm{y}]$ to their corresponding word form (e.g., " 75 " $\rightarrow$ "seventy-five").
still valid by only modifying NAQANet's internal representation (Appendix E).</p>
<p>Table 3 shows the results for different paragraph modifications. The model exhibits a tiny degradation in performance for small magnitude changes (e.g., NAQANet drops 1.5 F1 overall for Add [1,20]) but severely struggles on larger changes (e.g., NAQANet drops 35.7 F1 on superlative questions for Multiply [11,200]). Similar trends hold for word forms: the model exhibits small drops in accuracy when converting small numbers to words ( 3.9 degradation on Digits to Words [0,20]) but fails on larger magnitude word forms ( 21.6 F 1 drop over [21,100]). These results show that NAQANet has a strong understanding of numeracy for numbers in the training range, but, the model can fail to extrapolate to other values.</p>
<h3>2.6 Whence this behavior?</h3>
<p>NAQANet exhibits numerical reasoning capabilities that exceed our expectations. What enables this behavior? Aside from reading and comprehending the passage/question, this kind of numerical reasoning requires two components: numeracy (i.e., representing numbers) and comparison algorithms (i.e., computing the maximum of a list).</p>
<p>Although the natural emergence of comparison algorithms is surprising, previous results show neural models are capable of learning to count and sort synthetic lists of scalar values when given explicit supervision (Weiss et al., 2018; Vinyals et al., 2016). NAQANet demonstrates that a model can learn comparison algorithms while simultane-
ously learning to read and comprehend, even with only question-answer supervision.</p>
<p>How, then, does NAQANet know numeracy? The source of numerical information eventually lies in the token embeddings themselves, i.e., the character-level convolutions and GloVe embeddings of the NAQANet model. Therefore, we can understand the source of numeracy by isolating and probing these embeddings.</p>
<h2>3 Probing Numeracy of Embeddings</h2>
<p>We use synthetic numerical tasks to probe the numeracy of token embeddings.</p>
<h3>3.1 Probing Tasks</h3>
<p>We consider three synthetic tasks to evaluate numeracy (Figure 3). Appendix C provides further details on training and evaluation.</p>
<p>List Maximum Given a list of the embeddings for five numbers, the task is to predict the index of the maximum number. Each list consists of values of similar magnitude in order to evaluate fine-grained comparisons (see Appendix C). As in typical span selection models (Seo et al., 2017), an LSTM reads the list of token embeddings, and a weight matrix and softmax function assign a probability to each index using the model's hidden state. We use the negative log-likelihood of the maximum number as the loss function.</p>
<p>Decoding The decoding task probes whether number magnitude is captured (rather than the relative ordering of numbers as in list maximum). Given a number's embedding, the task is to regress to its value, e.g., the embedding for the string "five" has a target of 5.0. We consider a linear regression model and a three-layer fully-connected network with ReLU activations. The models are trained using a mean squared error (MSE) loss.</p>
<p>Addition The addition task requires number manipulation-given the embeddings of two numbers, the task is to predict their sum. Our model concatenates the two token embeddings and feeds the result through a three-layer fullyconnected network with ReLU activations, trained using MSE loss. Unlike the decoding task, the model needs to capture number magnitude internally without direct label supervision.</p>
<p>Training and Evaluation We focus on a numerical interpolation setting (we revisit extrapolation</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 3: Our probing setup. We pass numbers through a pre-trained embedder (e.g., BERT, GloVe) and train a probing model to solve numerical tasks such as finding a list's maximum, decoding a number, or adding two numbers. If the probing model generalizes to held-out numbers, the pre-trained embeddings must contain numerical information. We provide numbers as either words (shown here), digits ("9"), floats ("9.1"), or negatives ("-9").
in Section 3.4): the model is tested on values that are within the training range. We first pick a range (we vary the range in our experiments) and randomly shuffle the integers over it. We then split $80 \%$ of the numbers into a training set and $20 \%$ into a test set. We report the mean and standard deviation across five different random shuffles for a particular range, using the exact same shuffles across all embedding methods.</p>
<p>Numbers are provided as integers ("75"), single-word form ("seventy-five"), floats ("75.1"), or negatives ("-75"). We consider positive numbers less than 100 for word-form numbers to avoid multiple tokens. We report the classification accuracy for the list maximum task ( 5 classes), and the Root Mean Squared Error (RMSE) for decoding and addition. Note that larger ranges will naturally amplify the RMSE error.</p>
<h3>3.2 Embedding Methods</h3>
<p>We evaluate various token embedding methods.
Word Vectors We use 300-dimensional GloVe (Pennington et al., 2014) and word2vec vectors Mikolov et al., 2018). We ensure all values are in-vocabulary for word vectors.
Contextualized Embeddings We use ELMo (Peters et al., 2018) and BERT (Devlin et al., 2019) embeddings. ${ }^{4}$ ELMo uses character-level convo-</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup>lutions of size 1-7 with max pooling. BERT represents tokens via sub-word pieces; we use lowercased BERT-base with 30k pieces.</p>
<p>NAQANet Embeddings We extract the GloVe embeddings and Char-CNN from the NAQANet model trained on DROP. We also consider an ablation that removes the GloVe embeddings.
Learned Embeddings We use a character-level CNN (Char-CNN) and a character-Level LSTM (Char-LSTM). We use left character padding, which greatly improves numeracy for characterlevel CNNs (details in Appendix B).
Untrained Embeddings We consider two untrained baselines. The first baseline is random token vectors, which trivially fail to generalize (there is no pattern between train and test numbers). These embeddings are useful for measuring the improvement of pre-trained embeddings. We also consider a randomly initialized and untrained Char-CNN and Char-LSTM.</p>
<p>Number's Value as Embedding The final embedding method is simple: map a number's embedding directly to its value (e.g., "seventy-five" embeds to [75]). We found this strategy performs poorly for large ranges; using a base-10 logarithmic scale improves performance. We report this as Value Embedding in our results. ${ }^{5}$</p>
<p><sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">2</a></sup></p>
<p>All pre-trained embeddings (all methods except the Char-CNN and Char-LSTM) are fixed during training. The probing models are trained on the synthetic tasks on top of these embeddings.</p>
<h3>3.3 Results: Embeddings Capture Numeracy</h3>
<p>We find that all pre-trained embeddings contain fine-grained information about number magnitude and order. We first focus on integers (Table 4).</p>
<p>Word Vectors Succeed Both word2vec and GloVe significantly outperform the random vector baseline and are among the strongest methods overall. This is particularly surprising given the training methodology for these embeddings, e.g., a continuous bag of words objective can teach finegrained number magnitude.</p>
<p>Character-level Methods Dominate Models which use character-level information have a clear advantage over word-level models for encoding numbers. This is reflected in our probing results: character-level CNNs are the best architecture for capturing numeracy. For example, the NAQANet model without GloVe (only using its Char-CNN) and ELMo (uses a Char-CNN) are the strongest pre-trained methods, and a learned Char-CNN is the strongest method overall. The strength of the character-level convolutions seems to lie in the architectural prior-an untrained Char-CNN is surprisingly competitive. Similar results have been shown for images (Saxe et al., 2011): random CNNs are powerful feature extractors.</p>
<p>Sub-word Models Struggle BERT struggles for large ranges (e.g., $52 \%$ accuracy for list maximum for $[0,9999])$. We suspect this results from subword pieces being a poor method to encode digits: two numbers which are similar in value can have very different sub-word divisions.</p>
<p>A Linear Subspace Exists For small ranges on the decoding task (e.g., $[0,99]$ ), a linear model is competitive, i.e., a linear subspace captures number magnitude (Appendix D). For larger ranges (e.g., $[0,999]$ ), the linear model's performance degrades, especially for BERT.</p>
<p>Value Embedding Fails The Value Embedding method fails for large ranges. This is surprising as the embedding directly provides a number's value, thus, the synthetic tasks should be easy to solve. However, we had difficulty training models for
large ranges, even when using numerous architecture variants (e.g., tiny networks with 10 hidden units and tanh activations) and hyperparameters. Trask et al. (2018) discuss similar problems and ameliorate them using new neural architectures.</p>
<p>Words, Floats, and Negatives are Captured Finally, we probe the embeddings on word-form numbers, floats, and negatives. We observe similar trends for these inputs as integers: pre-trained models exhibit natural numeracy and learned embeddings are strong (Tables 5, 6, and 10). The ordering of the different embedding methods according to performance is also relatively consistent across the different input types. One notable exception is that BERT struggles on floats, which is likely a result of its sub-word pieces. We do not test word2vec and GloVe on floats/negatives because they are out-of-vocabulary.</p>
<h3>3.4 Probing Models Struggle to Extrapolate</h3>
<p>Thus far, our synthetic experiments evaluate on held-out values within the same range as the training data (i.e., numerical interpolation). In Section 2.5, we found that NAQANet struggles to extrapolate to values outside the training range. Is this an idiosyncrasy of NAQANet or is it a more general problem? We investigate this using a numerical extrapolation setting: we train models on a specific integer range and test them on values greater than the largest training number and smaller than the smallest training number.</p>
<p>Extrapolation for Decoding and Addition For decoding and addition, models struggle to extrapolate. Figure 1 shows the predictions for models trained on $80 \%$ of the values from [-500,500] and tested on held-out numbers in the range [2000, 2000] for six embedding types. The embedding methods fail to extrapolate in different ways, e.g., predictions using word2vec decrease almost monotonically as the input increases, while predictions using BERT are usually near the highest training value. Trask et al. (2018) also observe that models struggle outside the training range; they attribute this to failures in neural models themselves.</p>
<p>Extrapolation for List Maximum For the list maximum task, accuracies are closer to those in the interpolation setting, however, they still fall short. Table 7 shows the accuracy for models trained on the integer range $[0,150]$ and tested on</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Interpolation</th>
<th style="text-align: center;">List Maximum (5-classes)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Decoding (RMSE)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Addition (RMSE)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Integer Range</td>
<td style="text-align: center;">$[0,99]$</td>
<td style="text-align: center;">$[0,999]$</td>
<td style="text-align: center;">$[0,9999]$</td>
<td style="text-align: center;">$[0,99]$</td>
<td style="text-align: center;">$[0,999]$</td>
<td style="text-align: center;">$[0,9999]$</td>
<td style="text-align: center;">$[0,99]$</td>
<td style="text-align: center;">$[0,999]$</td>
<td style="text-align: center;">$[0,9999]$</td>
</tr>
<tr>
<td style="text-align: center;">Random Vectors</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.23</td>
<td style="text-align: center;">0.21</td>
<td style="text-align: center;">29.86</td>
<td style="text-align: center;">292.88</td>
<td style="text-align: center;">2882.62</td>
<td style="text-align: center;">42.03</td>
<td style="text-align: center;">410.33</td>
<td style="text-align: center;">4389.39</td>
</tr>
<tr>
<td style="text-align: center;">Untrained CNN</td>
<td style="text-align: center;">0.97</td>
<td style="text-align: center;">0.87</td>
<td style="text-align: center;">0.84</td>
<td style="text-align: center;">2.64</td>
<td style="text-align: center;">9.67</td>
<td style="text-align: center;">44.40</td>
<td style="text-align: center;">1.41</td>
<td style="text-align: center;">14.43</td>
<td style="text-align: center;">69.14</td>
</tr>
<tr>
<td style="text-align: center;">Untrained LSTM</td>
<td style="text-align: center;">0.70</td>
<td style="text-align: center;">0.66</td>
<td style="text-align: center;">0.55</td>
<td style="text-align: center;">7.61</td>
<td style="text-align: center;">46.5</td>
<td style="text-align: center;">210.34</td>
<td style="text-align: center;">5.11</td>
<td style="text-align: center;">45.69</td>
<td style="text-align: center;">510.19</td>
</tr>
<tr>
<td style="text-align: center;">Value Embedding</td>
<td style="text-align: center;">0.99</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.68</td>
<td style="text-align: center;">1.20</td>
<td style="text-align: center;">11.23</td>
<td style="text-align: center;">275.50</td>
<td style="text-align: center;">0.30</td>
<td style="text-align: center;">15.98</td>
<td style="text-align: center;">654.33</td>
</tr>
<tr>
<td style="text-align: center;">Pre-trained</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Word2Vec</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">0.71</td>
<td style="text-align: center;">2.34</td>
<td style="text-align: center;">18.77</td>
<td style="text-align: center;">333.47</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">21.23</td>
<td style="text-align: center;">210.07</td>
</tr>
<tr>
<td style="text-align: center;">GloVe</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.78</td>
<td style="text-align: center;">0.72</td>
<td style="text-align: center;">2.23</td>
<td style="text-align: center;">13.77</td>
<td style="text-align: center;">174.21</td>
<td style="text-align: center;">0.80</td>
<td style="text-align: center;">16.51</td>
<td style="text-align: center;">180.31</td>
</tr>
<tr>
<td style="text-align: center;">ELMo</td>
<td style="text-align: center;">0.98</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.76</td>
<td style="text-align: center;">2.35</td>
<td style="text-align: center;">13.48</td>
<td style="text-align: center;">62.20</td>
<td style="text-align: center;">0.94</td>
<td style="text-align: center;">15.50</td>
<td style="text-align: center;">45.71</td>
</tr>
<tr>
<td style="text-align: center;">BERT</td>
<td style="text-align: center;">0.95</td>
<td style="text-align: center;">0.62</td>
<td style="text-align: center;">0.52</td>
<td style="text-align: center;">3.21</td>
<td style="text-align: center;">29.00</td>
<td style="text-align: center;">431.78</td>
<td style="text-align: center;">4.56</td>
<td style="text-align: center;">67.81</td>
<td style="text-align: center;">454.78</td>
</tr>
<tr>
<td style="text-align: center;">Learned</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Char-CNN</td>
<td style="text-align: center;">0.97</td>
<td style="text-align: center;">0.93</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">2.50</td>
<td style="text-align: center;">4.92</td>
<td style="text-align: center;">11.57</td>
<td style="text-align: center;">1.19</td>
<td style="text-align: center;">7.75</td>
<td style="text-align: center;">15.09</td>
</tr>
<tr>
<td style="text-align: center;">Char-LSTM</td>
<td style="text-align: center;">0.98</td>
<td style="text-align: center;">0.92</td>
<td style="text-align: center;">0.76</td>
<td style="text-align: center;">2.55</td>
<td style="text-align: center;">8.65</td>
<td style="text-align: center;">18.33</td>
<td style="text-align: center;">1.21</td>
<td style="text-align: center;">15.11</td>
<td style="text-align: center;">25.37</td>
</tr>
<tr>
<td style="text-align: center;">DROP-trained</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">NAQANet</td>
<td style="text-align: center;">0.91</td>
<td style="text-align: center;">0.81</td>
<td style="text-align: center;">0.72</td>
<td style="text-align: center;">2.99</td>
<td style="text-align: center;">14.19</td>
<td style="text-align: center;">62.17</td>
<td style="text-align: center;">1.11</td>
<td style="text-align: center;">11.33</td>
<td style="text-align: center;">90.01</td>
</tr>
<tr>
<td style="text-align: center;">- GloVe</td>
<td style="text-align: center;">0.88</td>
<td style="text-align: center;">0.90</td>
<td style="text-align: center;">0.82</td>
<td style="text-align: center;">2.87</td>
<td style="text-align: center;">5.34</td>
<td style="text-align: center;">35.39</td>
<td style="text-align: center;">1.45</td>
<td style="text-align: center;">9.91</td>
<td style="text-align: center;">60.70</td>
</tr>
</tbody>
</table>
<p>Table 4: Interpolation with integers (e.g., "18"). All pre-trained embedding methods (e.g., GloVe and ELMo) surprisingly capture numeracy. The probing model is trained on a randomly shuffled $80 \%$ of the Integer Range and tested on the remaining $20 \%$. The probing model architecture and train/test splits are equivalent across all embeddings. We show the mean over 5 random shuffles (standard deviation in Appendix D).</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Interpolation</th>
<th style="text-align: left;">List Maximum (5-classes)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Float Range</td>
<td style="text-align: left;">$[0.0,99.9]$</td>
</tr>
<tr>
<td style="text-align: left;">Rand. Vectors</td>
<td style="text-align: left;">$0.18 \pm 0.03$</td>
</tr>
<tr>
<td style="text-align: left;">ELMo</td>
<td style="text-align: left;">$0.91 \pm 0.03$</td>
</tr>
<tr>
<td style="text-align: left;">BERT</td>
<td style="text-align: left;">$0.82 \pm 0.05$</td>
</tr>
<tr>
<td style="text-align: left;">Char-CNN</td>
<td style="text-align: left;">$0.87 \pm 0.04$</td>
</tr>
<tr>
<td style="text-align: left;">Char-LSTM</td>
<td style="text-align: left;">$0.81 \pm 0.05$</td>
</tr>
</tbody>
</table>
<p>Table 5: Interpolation with floats (e.g., "18.1") for list maximum. Pre-trained embeddings capture numeracy for float values. The probing model is trained on a randomly shuffled $80 \%$ of the Float Range and tested on the remaining $20 \%$. See the text for details on selecting decimal values. We show the mean alongside the standard deviation over 5 different random shuffles.
the ranges [151,160], [151,180], and [151,200]; all methods struggle, especially token vectors.</p>
<h2>Augmenting Data to Aid Extrapolation Of</h2>
<p>course, in many real-word tasks it is possible to ameliorate these extrapolation failures by augmenting the training data (i.e., turn extrapolation into interpolation). Here, we apply this idea to aid in training NAQANet for DROP. For each superlative and comparative example, we duplicate the example and modify the numbers in its paragraph using the Add and Multiply techniques de-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Interpolation</th>
<th style="text-align: center;">List Maximum (5-classes)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Integer Range</td>
<td style="text-align: center;">$[-50,50]$</td>
</tr>
<tr>
<td style="text-align: left;">Rand. Vectors</td>
<td style="text-align: center;">$0.23 \pm 0.12$</td>
</tr>
<tr>
<td style="text-align: left;">Word2Vec</td>
<td style="text-align: center;">$0.89 \pm 0.02$</td>
</tr>
<tr>
<td style="text-align: left;">GloVe</td>
<td style="text-align: center;">$0.89 \pm 0.03$</td>
</tr>
<tr>
<td style="text-align: left;">ELMo</td>
<td style="text-align: center;">$0.96 \pm 0.01$</td>
</tr>
<tr>
<td style="text-align: left;">BERT</td>
<td style="text-align: center;">$0.94 \pm 0.02$</td>
</tr>
<tr>
<td style="text-align: left;">Char-CNN</td>
<td style="text-align: center;">$0.95 \pm 0.07$</td>
</tr>
<tr>
<td style="text-align: left;">Char-LSTM</td>
<td style="text-align: center;">$0.97 \pm 0.02$</td>
</tr>
</tbody>
</table>
<p>Table 6: Interpolation with negatives (e.g., " -18 ") on list maximum. Pre-trained embeddings capture numeracy for negative values.
scribed in Section 2.5. Table 11 shows that this data augmentation can improve both interpolation and extrapolation, e.g., the accuracy on superlative questions with large numbers can double.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Extrapolation</th>
<th style="text-align: center;">List Maximum (5-classes)</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Test Range</td>
<td style="text-align: center;">$[151,160]$</td>
<td style="text-align: center;">$[151,180]$</td>
<td style="text-align: center;">$[151,200]$</td>
</tr>
<tr>
<td style="text-align: left;">Rand. Vectors</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.22</td>
<td style="text-align: center;">0.15</td>
</tr>
<tr>
<td style="text-align: left;">Untrained CNN</td>
<td style="text-align: center;">0.80</td>
<td style="text-align: center;">0.47</td>
<td style="text-align: center;">0.41</td>
</tr>
<tr>
<td style="text-align: left;">Pre-trained</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Word2Vec</td>
<td style="text-align: center;">0.14</td>
<td style="text-align: center;">0.16</td>
<td style="text-align: center;">0.11</td>
</tr>
<tr>
<td style="text-align: left;">GloVe</td>
<td style="text-align: center;">0.19</td>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;">0.21</td>
</tr>
<tr>
<td style="text-align: left;">ELMo</td>
<td style="text-align: center;">0.65</td>
<td style="text-align: center;">0.57</td>
<td style="text-align: center;">0.38</td>
</tr>
<tr>
<td style="text-align: left;">BERT</td>
<td style="text-align: center;">0.35</td>
<td style="text-align: center;">0.11</td>
<td style="text-align: center;">0.14</td>
</tr>
<tr>
<td style="text-align: left;">Learned</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Char-CNN</td>
<td style="text-align: center;">0.81</td>
<td style="text-align: center;">0.75</td>
<td style="text-align: center;">0.73</td>
</tr>
<tr>
<td style="text-align: left;">Char-LSTM</td>
<td style="text-align: center;">$\mathbf{0 . 8 8}$</td>
<td style="text-align: center;">$\mathbf{0 . 8 4}$</td>
<td style="text-align: center;">$\mathbf{0 . 8 2}$</td>
</tr>
<tr>
<td style="text-align: left;">DROP</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">NAQANet</td>
<td style="text-align: center;">0.31</td>
<td style="text-align: center;">0.29</td>
<td style="text-align: center;">0.25</td>
</tr>
<tr>
<td style="text-align: left;">- GloVe</td>
<td style="text-align: center;">0.58</td>
<td style="text-align: center;">0.53</td>
<td style="text-align: center;">0.48</td>
</tr>
</tbody>
</table>
<p>Table 7: Extrapolation on list maximum. The probing model is trained on the integer range $[0,150]$ and evaluated on integers from the Test Range. The probing model struggles to extrapolate when trained on the pre-trained embeddings.</p>
<h2>4 Discussion and Related Work</h2>
<p>An open question is how the training process elicits numeracy for word vectors and contextualized embeddings. Understanding this, perhaps by tracing numeracy back to the training data, is a fruitful direction to explore further (c.f., influence functions (Koh and Liang, 2017; Brunet et al., 2019)).</p>
<p>More generally, numeracy is one type of emergent knowledge. For instance, embeddings may capture the size of objects (Forbes and Choi, 2017), speed of vehicles, and many other "commonsense" phenomena (Yang et al., 2018). Vendrov et al. (2016) introduce methods to encode the order of such phenomena into embeddings for concepts such as hypernymy; our work and Yang et al. (2018) show that a relative ordering naturally emerges for certain concepts.</p>
<p>In concurrent work, Naik et al. (2019) also explore numeracy in word vectors. Their methodology is based on variants of nearest neighbors and cosine distance; we use neural network probing classifiers which can capture highly non-linear dependencies between embeddings. We also explore more powerful embedding methods such as ELMo, BERT, and learned embedding methods.</p>
<p>Probing Models Our probes of numeracy parallel work in understanding the linguistic capabilities (literacy) of neural models (Conneau et al., 2018; Liu et al., 2019). LSTMs can remember sentence length, word order, and which words were present in a sentence (Adi et al., 2017). Khandel-
wal et al. (2018) show how language models leverage context, while Linzen et al. (2016) demonstrate that language models understand subjectverb agreement.</p>
<p>Numerical Value Prediction Spithourakis and Riedel (2018) improve the ability of language models to predict numbers, i.e., they go beyond categorical predictions over a fixed-size vocabulary. They focus on improving models; our focus is probing embeddings. Kotnis and García-Durán (2019) predict numerical attributes in knowledge bases, e.g., they develop models that try to predict the population of Paris.</p>
<p>Synthetic Numerical Tasks Similar to our synthetic numerical reasoning tasks, other work considers sorting (Graves et al., 2014), counting (Weiss et al., 2018), or decoding tasks (Trask et al., 2018). They use synthetic tasks as a testbed to prove or design better models, whereas we use synthetic tasks as a probe to understand token embeddings. In developing the Neural Arithmetic Logic Unit, Trask et al. (2018) arrive at similar conclusions regarding extrapolation: neural models have difficulty outputting numerical values outside the training range.</p>
<h2>5 Conclusion</h2>
<p>How much do NLP models know about numbers? By digging into a surprisingly successful model on a numerical reasoning dataset (DROP), we discover that pre-trained token representations naturally encode numeracy.</p>
<p>We analyze the limits of this numeracy, finding that CNNs are a particularly good prior (and likely the cause of ELMo's superior numeracy compared to BERT) and that it is difficult for neural models to extrapolate beyond the values seen during training. There are still many fruitful areas for future research, including discovering why numeracy naturally emerges in embeddings, and what other properties are similarly emergent.</p>
<h2>Acknowledgements</h2>
<p>We thank Mark Neumann, Suchin Gururangan, Pranav Goel, Shi Feng, Nikhil Kandpal, Dheeru Dua, the members of AllenNLP and UCI NLP, and the reviewers for their valuable feedback.</p>
<h2>References</h2>
<p>Yossi Adi, Einat Kermany, Yonatan Belinkov, Ofer Lavi, and Yoav Goldberg. 2017. Finegrained analysis of sentence embeddings using auxiliary prediction tasks. In $I C L R$.</p>
<p>Marc-Etienne Brunet, Colleen Alkalay-Houlihan, Ashton Anderson, and Richard Zemel. 2019. Understanding the origins of bias in word embeddings. In ICML.</p>
<p>Alexis Conneau, German Kruszewski, Guillaume Lample, Loïc Barrault, and Marco Baroni. 2018. What you can cram into a single vector: Probing sentence embeddings for linguistic properties. In $A C L$.</p>
<p>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: pre-training of deep bidirectional transformers for language understanding. In NAACL.</p>
<p>Dheeru Dua, Yizhong Wang, Pradeep Dasigi, Gabriel Stanovsky, Sameer Singh, and Matt Gardner. 2019. DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs. In NAACL.</p>
<p>Maxwell Forbes and Yejin Choi. 2017. Verb physics: Relative physical knowledge of actions and objects. In $A C L$.</p>
<p>Alex Graves, Greg Wayne, and Ivo Danihelka. 2014. Neural turing machines. arXiv preprint arXiv:1410.5401.</p>
<p>Urvashi Khandelwal, He He, Peng Qi, and Dan Jurafsky. 2018. Sharp nearby, fuzzy far away: How neural language models use context. In $A C L$.</p>
<p>Pang Wei Koh and Percy Liang. 2017. Understanding black-box predictions via influence functions. In ICML.</p>
<p>Bhushan Kotnis and Alberto García-Durán. 2019. Learning numerical attributes in knowledge bases. In $A K B C$.</p>
<p>Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gardner. 2017. Neural semantic parsing with type constraints for semi-structured tables. In EMNLP.</p>
<p>Tal Linzen, Emmanuel Dupoux, and Yoav Goldberg. 2016. Assessing the ability of LSTMs to learn syntax-sensitive dependencies. In TACL.</p>
<p>Nelson F Liu, Matt Gardner, Yonatan Belinkov, Matthew Peters, and Noah A Smith. 2019. Linguistic knowledge and transferability of contextual representations. In NAACL.</p>
<p>Tomas Mikolov, Edouard Grave, Piotr Bojanowski, Christian Puhrsch, and Armand Joulin. 2018. Advances in pre-training distributed word representations. In LREC.</p>
<p>Aakanksha Naik, Abhilasha Ravichander, Carolyn Rose, and Eduard Hovy. 2019. Exploring numeracy in word embeddings. In $A C L$.</p>
<p>Jeffrey Pennington, Richard Socher, and Christopher D. Manning. 2014. GloVe: Global vectors for word representation. In EMNLP.</p>
<p>Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized word representations. In North American Association for Computational Linguistics.</p>
<p>Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. SQuAD: 100,000+ questions for machine comprehension of text. In EMNLP.</p>
<p>Abhilasha Ravichander, Aakanksha Naik, Carolyn Rose, and Eduard Hovy. 2019. EQUATE: A benchmark evaluation framework for quantitative reasoning in natural language inference. arXiv preprint arXiv:1901.03735.</p>
<p>Andrew M Saxe, Pang Wei Koh, Zhenghao Chen, Maneesh Bhand, Bipin Suresh, and Andrew Y Ng. 2011. On random weights and unsupervised feature learning. In ICML.</p>
<p>David Saxton, Edward Grefenstette, Felix Hill, and Pushmeet Kohli. 2019. Analysing mathematical reasoning abilities of neural models.</p>
<p>Min Joon Seo, Aniruddha Kembhavi, Ali Farhadi, and Hannaneh Hajishirzi. 2017. Bidirectional attention flow for machine comprehension. In $I C L R$.</p>
<p>Georgios Spithourakis and Sebastian Riedel. 2018. Numeracy for language models: Evaluating and improving their ability to predict numbers. In $A C L$.</p>
<p>Andrew Trask, Felix Hill, Scott Reed, Jack W. Rae, Chris Dyer, and Phil Blunsom. 2018. Neural arithmetic logic units. In NeurIPS.</p>
<p>Ivan Vendrov, Ryan Kiros, Sanja Fidler, and Raquel Urtasun. 2016. Order-embeddings of images and language. In $I C L R$.</p>
<p>Oriol Vinyals, Samy Bengio, and Manjunath Kudlur. 2016. Order matters: Sequence to sequence for sets. In $I C L R$.</p>
<p>Gail Weiss, Yoav Goldberg, and Eran Yahav. 2018. On the practical computational power of finite precision rnns for language recognition. In $A C L$.</p>
<p>Yiben Yang, Larry Birnbaum, Ji-Ping Wang, and Doug Downey. 2018. Extracting commonsense properties from embeddings with limited human guidance. In $A C L$.</p>
<p>Adams Wei Yu, David Dohan, Minh-Thang Luong, Rui Zhao, Kai Chen, Mohammad Norouzi, and Quoc V. Le. 2018. QANet: Combining local convolution with global self-attention for reading comprehension. In $I C L R$.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ Since our inputs are numbers, not natural sentences, language models may exhibit strange behavior. We experimented with extracting the context-independent feature vector immediately following the character convolutions for ELMo but found little difference in results.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:1">
<p>${ }^{5}$ We suspect the failures result from the raw values being too high in magnitude and/or variance for the model. We also experimented with normalizing the values to mean 0 and variance 1; a logarithmic scale performed better.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>