<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-3543 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-3543</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-3543</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-78.html">extraction-schema-78</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <p><strong>Paper ID:</strong> paper-4ca430d4640afa4a3838371a08f8f418284bdb7c</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/4ca430d4640afa4a3838371a08f8f418284bdb7c" target="_blank">Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision</a></p>
                <p><strong>Paper Venue:</strong> Annual Meeting of the Association for Computational Linguistics</p>
                <p><strong>Paper TL;DR:</strong> A Neural Symbolic Machine is introduced, which contains a neural “programmer” that maps language utterances to programs and utilizes a key-variable memory to handle compositionality, and a symbolic “computer”, i.e., a Lisp interpreter that performs program execution, and helps find good programs by pruning the search space.</p>
                <p><strong>Paper Abstract:</strong> Harnessing the statistical power of neural networks to perform language understanding and symbolic reasoning is difficult, when it requires executing efficient discrete operations against a large knowledge-base. In this work, we introduce a Neural Symbolic Machine, which contains (a) a neural “programmer”, i.e., a sequence-to-sequence model that maps language utterances to programs and utilizes a key-variable memory to handle compositionality (b) a symbolic “computer”, i.e., a Lisp interpreter that performs program execution, and helps find good programs by pruning the search space. We apply REINFORCE to directly optimize the task reward of this structured prediction problem. To train with weak supervision and improve the stability of REINFORCE, we augment it with an iterative maximum-likelihood training process. NSM outperforms the state-of-the-art on the WebQuestionsSP dataset when trained from question-answer pairs only, without requiring any feature engineering or domain-specific knowledge.</p>
                <p><strong>Cost:</strong> 0.019</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e3543.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e3543.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>NSM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neural Symbolic Machine</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A neuro-symbolic semantic parsing system combining a neural sequence-to-sequence 'programmer' (1-layer GRU with attention and a key-variable memory) with a symbolic non-differentiable Lisp 'computer' that executes programs against Freebase; trained from weak supervision using REINFORCE augmented with iterative maximum-likelihood pseudo-gold programs and curriculum learning.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Neural Symbolic Machine (NSM)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Encoder-decoder sequence-to-sequence model with 1-layer GRU encoder and decoder, dot-product attention, dynamically-generated key-variable memory (pointer-like) to name intermediate symbolic variables; a separate Lisp interpreter executes generated programs against a large Freebase KB and provides code-assistance (valid-token pruning). Training combines iterative ML to find pseudo-gold programs and an augmented REINFORCE policy-gradient step; other interventions include curriculum learning, beam search, pretrained GloVe embeddings, and dropout.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>WebQuestionsSP (semantic parsing / KB question answering)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Mapping natural language questions to executable programs/logical forms which, when executed on a large knowledge base (Freebase), return the answer; requires compositional, discrete logical reasoning (variable binding, property traversal, filtering, comparison, aggregation).</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Key-variable memory to represent and refer to intermediate symbolic results; non-differentiable Lisp interpreter providing syntax+semantic code assistance to prune search; iterative ML to find pseudo-gold programs; augmented REINFORCE (mixing model probabilities with pseudo-gold program mass α=0.1); curriculum learning (gradually increase functions and program length); beam search for decoding; dropout and pretrained embeddings to reduce overfitting.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>On WebQuestionsSP test set: Precision 70.8%, Recall 76.0%, F1 69.0, Accuracy 59.5. Validation: augmented REINFORCE valid F1 67.2. Training F1 (augmented REINFORCE) 83.0.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td>STAGG (previous state-of-the-art weakly supervised baseline) reported Precision 67.3%, Recall 73.1%, F1 66.8, Accuracy 58.8 on the same test set (as presented in this paper).</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>NSM improves test F1 from STAGG's 66.8 to 69.0 (+2.2 absolute F1 points) and slightly improves accuracy (58.8 -> 59.5); authors state NSM closes roughly half the gap between weak and full supervision on this dataset.</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Reported failure modes include (1) search failure: correct high-reward programs not found during beam search or missing requisite interpreter functions (~≥10% of questions), (2) ranking failure: correct programs are in the beam but not ranked top due to overfitting or spurious programs (~20% of questions), (3) overfitting evidenced by gap between training F1 (83.0%) and validation F1 (67.2%), (4) susceptibility to spurious programs (pseudo-gold programs that accidentally produce correct denotations and do not generalize).</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Ablations / analyses reported in paper: (a) component comparisons of training strategy (Table 3): Iterative ML: train F1 68.6 / valid 60.1; REINFORCE: train 55.1 / valid 47.8; Augmented REINFORCE: train 83.0 / valid 67.2 — showing augmented REINFORCE best; (b) curriculum learning effect (Table 4): best programs with curriculum F1 89.5 vs no curriculum F1 78.5; (c) overfitting controls (Table 5): removing pretrained word embeddings -5.5 F1, removing pretrained property embeddings -2.7 F1, removing dropout -2.4 F1 etc.; (d) program complexity analysis (Table 6): distribution of #expressions and per-complexity F1s (0 expr 0.4% with F1 0.0; 1 expr 62.9% with F1 73.5; 2 expr 29.8% F1 59.9; 3 expr 6.9% F1 70.3); (e) code-assistance/pruning reduced candidate properties per step from ~23k to <100 on average.</td>
                        </tr>
                        <tr>
                            <td><strong>extra_notes</strong></td>
                            <td>NSM specifically targets strict discrete logical reasoning over a large KB by offloading discrete operations to a symbolic interpreter while using neural components for generation and variable-key embeddings.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e3543.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Seq2seq+KV</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Sequence-to-sequence programmer with Key-Variable Memory</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>The NSM's 'programmer' component: a 1-layer GRU encoder-decoder with attention augmented by a dynamically-populated key-variable memory that maps continuous key embeddings to symbolic variable names whose values reside in the external 'computer'.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Seq2seq programmer with key-variable memory</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Encoder: 1-layer GRU; Decoder: 1-layer GRU with attention. During encoding, entities linked in the question create memory entries keyed by averaged encoder hidden states; during decoding completed expressions are executed by the Lisp computer and their results are stored as variables whose keys are decoder hidden states and whose tokens are added to decoder vocabulary (pointer-like mechanism).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Semantic parsing for KB QA (WebQuestionsSP)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Learning to generate executable programs (logical forms) from natural language that perform discrete symbolic operations (KB traversal, filtering, comparison) requires representing intermediate compositions and variable references.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Key-variable memory (dynamically-created pointer-style keys), integration with symbolic executor that executes partial programs and creates variables during decoding, entity anonymization (replace entities with ENT token).</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>No isolated performance numbers reported separate from full NSM; contributes to overall NSM performance (test F1 69.0).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>Enables compositionality and variable reuse; authors report significant fraction (36.7%) of generated programs use >1 expression, and performance across deeper compositions does not degrade markedly (see Table 6).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Values referenced by variables are symbolic and non-differentiable, so gradients flow only through keys; the system still depends on search to discover correct programs and can produce spurious keys/programs.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Program complexity analysis (Table 6) shows the model can produce multi-expression programs; no standalone quantitative ablation isolating key-variable memory from other components is reported.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e3543.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Augmented REINFORCE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Augmented REINFORCE (with pseudo-gold mixing)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A training strategy that bootstraps REINFORCE by mixing model-normalized beam probabilities with a mass placed on pseudo-gold programs found by iterative maximum-likelihood search (mixing coefficient α).</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Augmented REINFORCE (IML-REINFORCE)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>First run iterative ML to discover best-found (pseudo-gold) program per example; during REINFORCE, decode a beam and re-normalize model probabilities to sum to (1-α) and add α to the pseudo-gold program's probability, then perform policy-gradient updates using beam-normalized probabilities; typical α used = 0.1 in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Training for semantic parsing over Freebase (WebQuestionsSP)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Optimization objective is expected F1 reward (denotation-level); used to stabilize training under sparse rewards and large search spaces in structured prediction with discrete program outputs.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Mix model distribution with pseudo-gold program mass (imitation-like interpolation), beam search for gradient estimation (top-k normalized), replay of successful programs to reduce variance.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Augmented REINFORCE achieves Training F1 83.0 and Validation F1 67.2 (Table 3).</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td>REINFORCE (vanilla) Training F1 55.1 / Validation F1 47.8; Iterative ML Training F1 68.6 / Validation F1 60.1.</td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>Compared to vanilla REINFORCE, augmented REINFORCE improved validation F1 by 19.4 points (47.8 -> 67.2) and training F1 by 27.9 points (55.1 -> 83.0); it also outperforms iterative ML by validation F1 +7.1 points (60.1 -> 67.2).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Relies on quality of pseudo-gold programs; pseudo-gold programs can be spurious, which can bias learning; authors note initializing REINFORCE from final ML parameters led to worse local optima, so they reinitialized randomly before REINFORCE.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Table 3 compares iterative ML, REINFORCE, and augmented REINFORCE showing the latter best; algorithmic design discussion highlights why beam-normalized gradient estimation reduces variance compared to sampling-based REINFORCE in this setting.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e3543.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Iterative ML</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Iterative Maximum-Likelihood (pseudo-gold search)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A bootstrapping training loop: decode with a large beam to find the highest-reward (and shortest) program so far per example, treat it as pseudo-gold, and maximize its likelihood; repeat decoding and retraining iteratively.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Iterative ML (pseudo-gold program search)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Beam-decode with a large beam (k=100 in experiments) to find best program by reward for each question, then train with maximum likelihood on these pseudo-gold programs for multiple epochs; repeat the search-and-train loop (EM-like / hard-EM style).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Weakly-supervised semantic parsing (WebQuestionsSP)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>A search-driven approach to learn program generation from question-answer pairs only (without gold logical forms), using denotation-level reward to select pseudo-gold programs.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Large-beam decoding to produce pseudo-gold programs; curriculum learning to control function set and program length during search; repeated training epochs per decoding step.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Iterative ML yields Training F1 68.6 and Validation F1 60.1 (Table 3). Decoding with curriculum produced best-in-beam programs with F1 89.5 (Table 4) but iterative ML alone validation F1 60.1.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td>Iterative ML alone outperforms vanilla REINFORCE on validation (60.1 vs 47.8), but is inferior to augmented REINFORCE (67.2).</td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Does not directly optimize final denotation metric; susceptible to selecting spurious pseudo-gold programs that do not generalize; lacks exposure to negative examples which can hinder learning to distinguish related tokens (e.g., ParentsOf vs SiblingsOf).</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Curriculum learning during iterative ML (restricting functions and expression depth early) substantially improved best-found programs (Table 4: with curriculum best-in-beam F1 89.5 vs no curriculum 78.5).</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e3543.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>REINFORCE</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>REINFORCE (policy gradient)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A classic policy-gradient reinforcement learning algorithm used to directly optimize expected denotation-level reward when training the program-generation model end-to-end under non-differentiable execution.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Simple statistical gradient-following algorithms for connectionist reinforcement learning</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>REINFORCE (Williams, 1992)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Policy gradient method that estimates gradients of expected reward by sampling trajectories (or here approximating via beam-normalized top-k sequences) and scaling log-probability gradients by (reward - baseline).</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Policy optimization for semantic parsing to maximize F1 (WebQuestionsSP)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Optimize program-generation policy so that generated programs produce high-F1 denotations when executed on KB.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Beam-based approximate gradient estimation (normalize top-k beam probabilities instead of sampling); use of baseline equal to expected reward over beam to reduce variance; augmented with pseudo-gold mixing to stabilize training.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Vanilla REINFORCE (as implemented in this work) yields Training F1 55.1 and Validation F1 47.8 (Table 3), and authors report it converged slowly and often got stuck in local optima without bootstrapping.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Struggles with sparse rewards and large discrete search spaces; small beam sizes cause good programs to drop from beam (zero gradients), large beams are slow and dilute probability mass over many sequences making gradients near-zero; empirically got stuck in poor local optima in this setting.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Paper reports beam-based gradient approximation reduces variance compared to naive sampling, but still insufficient without pseudo-gold bootstrapping; discussion motivates iterative ML and augmented REINFORCE.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.5">
                <h3 class="extraction-instance">Extracted Data Instance 5 (e3543.5)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>STAGG</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>STAGG (staged query graph generation model)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior state-of-the-art semantic parsing / KB QA system (Yih et al.) that uses staged query graph generation with hand-crafted features and domain-specific engineering; used as the main baseline in experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Semantic parsing via staged query graph generation: Question answering with knowledge base</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>STAGG (staged query graph generation)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A staged query-graph generation approach for semantic parsing over Freebase that uses hand-engineered features and staged search to construct candidate query graphs and rank them; not a purely end-to-end neural model.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>WebQuestionsSP semantic parsing / KB QA</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Same task: map questions to Freebase queries; STAGG uses feature engineering and staged search rather than an end-to-end neural programmer with symbolic execution.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Staged query-graph generation, engineered features, domain-specific heuristics.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td>Reported in this paper as Precision 67.3%, Recall 73.1%, F1 66.8, Accuracy 58.8 on the test set used here.</td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Requires feature engineering and domain-specific knowledge; authors highlight NSM attains stronger results without those handcrafted components.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Used as comparative baseline; no ablation details provided here beyond reported metrics.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.6">
                <h3 class="extraction-instance">Extracted Data Instance 6 (e3543.6)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>RL-NTM</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Reinforcement Learning Neural Turing Machine (RL-NTM)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A related prior model where a nondifferentiable machine (Neural Turing Machine-like) is controlled by a sequence model and trained with REINFORCE; cited for similarity in leveraging nondifferentiable machines and policy-gradient training.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Reinforcement learning neural turing machines</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Reinforcement Learning Neural Turing Machine (RL-NTM)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>An approach that controls a nondifferentiable memory/manipulation machine using a sequence model and trains via REINFORCE; operates at lower-level operations like memory addressing and byte read/write.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Program induction / algorithm learning (related tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Inducing programs that manipulate low-level memory; typically used for algorithmic tasks or synthetic benchmarks requiring precise low-level operations.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>REINFORCE-based training over nondifferentiable operations; lower-level action set compared to NSM's high-level KB operations.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Paper notes main difference vs NSM: RL-NTM uses lower-level operations which can be harder to scale to high-level KB reasoning; both rely on REINFORCE and thus inherit difficulties with sparse rewards and search.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Mentioned in related work as conceptually similar; no experimental comparisons in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.7">
                <h3 class="extraction-instance">Extracted Data Instance 7 (e3543.7)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Neural Programmer</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Neural Programmer</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A prior neural model that induces latent programs with gradient descent by representing intermediate results as differentiable vectors; cited as related work but noted to be less scalable to very large KBs.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Neural programmer: Inducing latent programs with gradient descent</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Neural Programmer</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>A neural architecture that learns to compose operations over table-like data by producing differentiable selectors/attention vectors representing intermediate results, enabling end-to-end gradient-based training.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Program induction / semantic-like operations over structured data</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Learns to generate and execute sequences of (differentiable) operations over structured inputs (e.g., tables) where intermediate results are continuous vectors.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Represents intermediate results as continuous weighted vectors / selectors to permit backpropagation through program execution.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Authors note that representing results as vectors (continuous memory) is not applicable to very large KBs like Freebase (~100M entities and >20k properties) due to scalability; contrasts with NSM's symbolic variable approach.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Cited as contrast to NSM's non-differentiable symbolic storage; no experimental overlap in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e3543.8">
                <h3 class="extraction-instance">Extracted Data Instance 8 (e3543.8)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of language models performing strict logical reasoning tasks, including the models used, logical reasoning tasks or benchmarks, methods or interventions applied to improve logical reasoning, performance results, comparisons to baselines, and any reported limitations or failure cases.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Dynamic-NMN</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Dynamic Neural Module Network (Dynamic-NMN)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A modular neural architecture that composes small neural modules into a network specific to the input question; used for question answering, represents an alternative approach to composing operations for semantic parsing.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>Learning to compose neural networks for question answering</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>model_name</strong></td>
                            <td>Dynamic Neural Module Network (Dynamic-NMN)</td>
                        </tr>
                        <tr>
                            <td><strong>model_description</strong></td>
                            <td>Builds a network by composing small neural modules according to a predicted layout derived from the input; intermediate computations are continuous vectors, enabling end-to-end training for QA tasks.</td>
                        </tr>
                        <tr>
                            <td><strong>model_size</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_name</strong></td>
                            <td>Neural module-based question answering / semantic composition</td>
                        </tr>
                        <tr>
                            <td><strong>reasoning_task_description</strong></td>
                            <td>Per-question dynamic composition of neural modules to perform multi-step reasoning for question answering; supports compositional semantics via learned modules.</td>
                        </tr>
                        <tr>
                            <td><strong>method_or_intervention</strong></td>
                            <td>Dynamic composition of neural modules based on parsed representations of the input question.</td>
                        </tr>
                        <tr>
                            <td><strong>performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>baseline_performance</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>improvement_over_baseline</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>limitations_or_failures</strong></td>
                            <td>Paper contrasts it with NSM: module networks use continuous intermediate representations which may not scale to a massive KB like Freebase; also require layout prediction and often use supervision or different training regimes.</td>
                        </tr>
                        <tr>
                            <td><strong>ablation_or_analysis</strong></td>
                            <td>Mentioned in related work as alternative design for compositional semantics; no direct comparisons reported in this paper.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision', 'publication_date_yy_mm': '2016-10'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Reinforcement learning neural turing machines <em>(Rating: 2)</em></li>
                <li>Neural programmer: Inducing latent programs with gradient descent <em>(Rating: 2)</em></li>
                <li>Learning to compose neural networks for question answering <em>(Rating: 2)</em></li>
                <li>Semantic parsing via staged query graph generation: Question answering with knowledge base <em>(Rating: 2)</em></li>
                <li>Random walk inference and learning in a large scale knowledge base <em>(Rating: 1)</em></li>
                <li>Neural programmer-interpreters <em>(Rating: 1)</em></li>
                <li>The value of semantic parse labeling for knowledge base question answering <em>(Rating: 1)</em></li>
                <li>Reward augmented maximum likelihood for neural structured prediction <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-3543",
    "paper_id": "paper-4ca430d4640afa4a3838371a08f8f418284bdb7c",
    "extraction_schema_id": "extraction-schema-78",
    "extracted_data": [
        {
            "name_short": "NSM",
            "name_full": "Neural Symbolic Machine",
            "brief_description": "A neuro-symbolic semantic parsing system combining a neural sequence-to-sequence 'programmer' (1-layer GRU with attention and a key-variable memory) with a symbolic non-differentiable Lisp 'computer' that executes programs against Freebase; trained from weak supervision using REINFORCE augmented with iterative maximum-likelihood pseudo-gold programs and curriculum learning.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Neural Symbolic Machine (NSM)",
            "model_description": "Encoder-decoder sequence-to-sequence model with 1-layer GRU encoder and decoder, dot-product attention, dynamically-generated key-variable memory (pointer-like) to name intermediate symbolic variables; a separate Lisp interpreter executes generated programs against a large Freebase KB and provides code-assistance (valid-token pruning). Training combines iterative ML to find pseudo-gold programs and an augmented REINFORCE policy-gradient step; other interventions include curriculum learning, beam search, pretrained GloVe embeddings, and dropout.",
            "model_size": null,
            "reasoning_task_name": "WebQuestionsSP (semantic parsing / KB question answering)",
            "reasoning_task_description": "Mapping natural language questions to executable programs/logical forms which, when executed on a large knowledge base (Freebase), return the answer; requires compositional, discrete logical reasoning (variable binding, property traversal, filtering, comparison, aggregation).",
            "method_or_intervention": "Key-variable memory to represent and refer to intermediate symbolic results; non-differentiable Lisp interpreter providing syntax+semantic code assistance to prune search; iterative ML to find pseudo-gold programs; augmented REINFORCE (mixing model probabilities with pseudo-gold program mass α=0.1); curriculum learning (gradually increase functions and program length); beam search for decoding; dropout and pretrained embeddings to reduce overfitting.",
            "performance": "On WebQuestionsSP test set: Precision 70.8%, Recall 76.0%, F1 69.0, Accuracy 59.5. Validation: augmented REINFORCE valid F1 67.2. Training F1 (augmented REINFORCE) 83.0.",
            "baseline_performance": "STAGG (previous state-of-the-art weakly supervised baseline) reported Precision 67.3%, Recall 73.1%, F1 66.8, Accuracy 58.8 on the same test set (as presented in this paper).",
            "improvement_over_baseline": "NSM improves test F1 from STAGG's 66.8 to 69.0 (+2.2 absolute F1 points) and slightly improves accuracy (58.8 -&gt; 59.5); authors state NSM closes roughly half the gap between weak and full supervision on this dataset.",
            "limitations_or_failures": "Reported failure modes include (1) search failure: correct high-reward programs not found during beam search or missing requisite interpreter functions (~≥10% of questions), (2) ranking failure: correct programs are in the beam but not ranked top due to overfitting or spurious programs (~20% of questions), (3) overfitting evidenced by gap between training F1 (83.0%) and validation F1 (67.2%), (4) susceptibility to spurious programs (pseudo-gold programs that accidentally produce correct denotations and do not generalize).",
            "ablation_or_analysis": "Ablations / analyses reported in paper: (a) component comparisons of training strategy (Table 3): Iterative ML: train F1 68.6 / valid 60.1; REINFORCE: train 55.1 / valid 47.8; Augmented REINFORCE: train 83.0 / valid 67.2 — showing augmented REINFORCE best; (b) curriculum learning effect (Table 4): best programs with curriculum F1 89.5 vs no curriculum F1 78.5; (c) overfitting controls (Table 5): removing pretrained word embeddings -5.5 F1, removing pretrained property embeddings -2.7 F1, removing dropout -2.4 F1 etc.; (d) program complexity analysis (Table 6): distribution of #expressions and per-complexity F1s (0 expr 0.4% with F1 0.0; 1 expr 62.9% with F1 73.5; 2 expr 29.8% F1 59.9; 3 expr 6.9% F1 70.3); (e) code-assistance/pruning reduced candidate properties per step from ~23k to &lt;100 on average.",
            "extra_notes": "NSM specifically targets strict discrete logical reasoning over a large KB by offloading discrete operations to a symbolic interpreter while using neural components for generation and variable-key embeddings.",
            "uuid": "e3543.0",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "Seq2seq+KV",
            "name_full": "Sequence-to-sequence programmer with Key-Variable Memory",
            "brief_description": "The NSM's 'programmer' component: a 1-layer GRU encoder-decoder with attention augmented by a dynamically-populated key-variable memory that maps continuous key embeddings to symbolic variable names whose values reside in the external 'computer'.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Seq2seq programmer with key-variable memory",
            "model_description": "Encoder: 1-layer GRU; Decoder: 1-layer GRU with attention. During encoding, entities linked in the question create memory entries keyed by averaged encoder hidden states; during decoding completed expressions are executed by the Lisp computer and their results are stored as variables whose keys are decoder hidden states and whose tokens are added to decoder vocabulary (pointer-like mechanism).",
            "model_size": null,
            "reasoning_task_name": "Semantic parsing for KB QA (WebQuestionsSP)",
            "reasoning_task_description": "Learning to generate executable programs (logical forms) from natural language that perform discrete symbolic operations (KB traversal, filtering, comparison) requires representing intermediate compositions and variable references.",
            "method_or_intervention": "Key-variable memory (dynamically-created pointer-style keys), integration with symbolic executor that executes partial programs and creates variables during decoding, entity anonymization (replace entities with ENT token).",
            "performance": "No isolated performance numbers reported separate from full NSM; contributes to overall NSM performance (test F1 69.0).",
            "baseline_performance": null,
            "improvement_over_baseline": "Enables compositionality and variable reuse; authors report significant fraction (36.7%) of generated programs use &gt;1 expression, and performance across deeper compositions does not degrade markedly (see Table 6).",
            "limitations_or_failures": "Values referenced by variables are symbolic and non-differentiable, so gradients flow only through keys; the system still depends on search to discover correct programs and can produce spurious keys/programs.",
            "ablation_or_analysis": "Program complexity analysis (Table 6) shows the model can produce multi-expression programs; no standalone quantitative ablation isolating key-variable memory from other components is reported.",
            "uuid": "e3543.1",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "Augmented REINFORCE",
            "name_full": "Augmented REINFORCE (with pseudo-gold mixing)",
            "brief_description": "A training strategy that bootstraps REINFORCE by mixing model-normalized beam probabilities with a mass placed on pseudo-gold programs found by iterative maximum-likelihood search (mixing coefficient α).",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Augmented REINFORCE (IML-REINFORCE)",
            "model_description": "First run iterative ML to discover best-found (pseudo-gold) program per example; during REINFORCE, decode a beam and re-normalize model probabilities to sum to (1-α) and add α to the pseudo-gold program's probability, then perform policy-gradient updates using beam-normalized probabilities; typical α used = 0.1 in experiments.",
            "model_size": null,
            "reasoning_task_name": "Training for semantic parsing over Freebase (WebQuestionsSP)",
            "reasoning_task_description": "Optimization objective is expected F1 reward (denotation-level); used to stabilize training under sparse rewards and large search spaces in structured prediction with discrete program outputs.",
            "method_or_intervention": "Mix model distribution with pseudo-gold program mass (imitation-like interpolation), beam search for gradient estimation (top-k normalized), replay of successful programs to reduce variance.",
            "performance": "Augmented REINFORCE achieves Training F1 83.0 and Validation F1 67.2 (Table 3).",
            "baseline_performance": "REINFORCE (vanilla) Training F1 55.1 / Validation F1 47.8; Iterative ML Training F1 68.6 / Validation F1 60.1.",
            "improvement_over_baseline": "Compared to vanilla REINFORCE, augmented REINFORCE improved validation F1 by 19.4 points (47.8 -&gt; 67.2) and training F1 by 27.9 points (55.1 -&gt; 83.0); it also outperforms iterative ML by validation F1 +7.1 points (60.1 -&gt; 67.2).",
            "limitations_or_failures": "Relies on quality of pseudo-gold programs; pseudo-gold programs can be spurious, which can bias learning; authors note initializing REINFORCE from final ML parameters led to worse local optima, so they reinitialized randomly before REINFORCE.",
            "ablation_or_analysis": "Table 3 compares iterative ML, REINFORCE, and augmented REINFORCE showing the latter best; algorithmic design discussion highlights why beam-normalized gradient estimation reduces variance compared to sampling-based REINFORCE in this setting.",
            "uuid": "e3543.2",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "Iterative ML",
            "name_full": "Iterative Maximum-Likelihood (pseudo-gold search)",
            "brief_description": "A bootstrapping training loop: decode with a large beam to find the highest-reward (and shortest) program so far per example, treat it as pseudo-gold, and maximize its likelihood; repeat decoding and retraining iteratively.",
            "citation_title": "here",
            "mention_or_use": "use",
            "model_name": "Iterative ML (pseudo-gold program search)",
            "model_description": "Beam-decode with a large beam (k=100 in experiments) to find best program by reward for each question, then train with maximum likelihood on these pseudo-gold programs for multiple epochs; repeat the search-and-train loop (EM-like / hard-EM style).",
            "model_size": null,
            "reasoning_task_name": "Weakly-supervised semantic parsing (WebQuestionsSP)",
            "reasoning_task_description": "A search-driven approach to learn program generation from question-answer pairs only (without gold logical forms), using denotation-level reward to select pseudo-gold programs.",
            "method_or_intervention": "Large-beam decoding to produce pseudo-gold programs; curriculum learning to control function set and program length during search; repeated training epochs per decoding step.",
            "performance": "Iterative ML yields Training F1 68.6 and Validation F1 60.1 (Table 3). Decoding with curriculum produced best-in-beam programs with F1 89.5 (Table 4) but iterative ML alone validation F1 60.1.",
            "baseline_performance": null,
            "improvement_over_baseline": "Iterative ML alone outperforms vanilla REINFORCE on validation (60.1 vs 47.8), but is inferior to augmented REINFORCE (67.2).",
            "limitations_or_failures": "Does not directly optimize final denotation metric; susceptible to selecting spurious pseudo-gold programs that do not generalize; lacks exposure to negative examples which can hinder learning to distinguish related tokens (e.g., ParentsOf vs SiblingsOf).",
            "ablation_or_analysis": "Curriculum learning during iterative ML (restricting functions and expression depth early) substantially improved best-found programs (Table 4: with curriculum best-in-beam F1 89.5 vs no curriculum 78.5).",
            "uuid": "e3543.3",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "REINFORCE",
            "name_full": "REINFORCE (policy gradient)",
            "brief_description": "A classic policy-gradient reinforcement learning algorithm used to directly optimize expected denotation-level reward when training the program-generation model end-to-end under non-differentiable execution.",
            "citation_title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
            "mention_or_use": "use",
            "model_name": "REINFORCE (Williams, 1992)",
            "model_description": "Policy gradient method that estimates gradients of expected reward by sampling trajectories (or here approximating via beam-normalized top-k sequences) and scaling log-probability gradients by (reward - baseline).",
            "model_size": null,
            "reasoning_task_name": "Policy optimization for semantic parsing to maximize F1 (WebQuestionsSP)",
            "reasoning_task_description": "Optimize program-generation policy so that generated programs produce high-F1 denotations when executed on KB.",
            "method_or_intervention": "Beam-based approximate gradient estimation (normalize top-k beam probabilities instead of sampling); use of baseline equal to expected reward over beam to reduce variance; augmented with pseudo-gold mixing to stabilize training.",
            "performance": "Vanilla REINFORCE (as implemented in this work) yields Training F1 55.1 and Validation F1 47.8 (Table 3), and authors report it converged slowly and often got stuck in local optima without bootstrapping.",
            "baseline_performance": null,
            "improvement_over_baseline": null,
            "limitations_or_failures": "Struggles with sparse rewards and large discrete search spaces; small beam sizes cause good programs to drop from beam (zero gradients), large beams are slow and dilute probability mass over many sequences making gradients near-zero; empirically got stuck in poor local optima in this setting.",
            "ablation_or_analysis": "Paper reports beam-based gradient approximation reduces variance compared to naive sampling, but still insufficient without pseudo-gold bootstrapping; discussion motivates iterative ML and augmented REINFORCE.",
            "uuid": "e3543.4",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "STAGG",
            "name_full": "STAGG (staged query graph generation model)",
            "brief_description": "A prior state-of-the-art semantic parsing / KB QA system (Yih et al.) that uses staged query graph generation with hand-crafted features and domain-specific engineering; used as the main baseline in experiments.",
            "citation_title": "Semantic parsing via staged query graph generation: Question answering with knowledge base",
            "mention_or_use": "use",
            "model_name": "STAGG (staged query graph generation)",
            "model_description": "A staged query-graph generation approach for semantic parsing over Freebase that uses hand-engineered features and staged search to construct candidate query graphs and rank them; not a purely end-to-end neural model.",
            "model_size": null,
            "reasoning_task_name": "WebQuestionsSP semantic parsing / KB QA",
            "reasoning_task_description": "Same task: map questions to Freebase queries; STAGG uses feature engineering and staged search rather than an end-to-end neural programmer with symbolic execution.",
            "method_or_intervention": "Staged query-graph generation, engineered features, domain-specific heuristics.",
            "performance": "Reported in this paper as Precision 67.3%, Recall 73.1%, F1 66.8, Accuracy 58.8 on the test set used here.",
            "baseline_performance": null,
            "improvement_over_baseline": null,
            "limitations_or_failures": "Requires feature engineering and domain-specific knowledge; authors highlight NSM attains stronger results without those handcrafted components.",
            "ablation_or_analysis": "Used as comparative baseline; no ablation details provided here beyond reported metrics.",
            "uuid": "e3543.5",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "RL-NTM",
            "name_full": "Reinforcement Learning Neural Turing Machine (RL-NTM)",
            "brief_description": "A related prior model where a nondifferentiable machine (Neural Turing Machine-like) is controlled by a sequence model and trained with REINFORCE; cited for similarity in leveraging nondifferentiable machines and policy-gradient training.",
            "citation_title": "Reinforcement learning neural turing machines",
            "mention_or_use": "mention",
            "model_name": "Reinforcement Learning Neural Turing Machine (RL-NTM)",
            "model_description": "An approach that controls a nondifferentiable memory/manipulation machine using a sequence model and trains via REINFORCE; operates at lower-level operations like memory addressing and byte read/write.",
            "model_size": null,
            "reasoning_task_name": "Program induction / algorithm learning (related tasks)",
            "reasoning_task_description": "Inducing programs that manipulate low-level memory; typically used for algorithmic tasks or synthetic benchmarks requiring precise low-level operations.",
            "method_or_intervention": "REINFORCE-based training over nondifferentiable operations; lower-level action set compared to NSM's high-level KB operations.",
            "performance": null,
            "baseline_performance": null,
            "improvement_over_baseline": null,
            "limitations_or_failures": "Paper notes main difference vs NSM: RL-NTM uses lower-level operations which can be harder to scale to high-level KB reasoning; both rely on REINFORCE and thus inherit difficulties with sparse rewards and search.",
            "ablation_or_analysis": "Mentioned in related work as conceptually similar; no experimental comparisons in this paper.",
            "uuid": "e3543.6",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "Neural Programmer",
            "name_full": "Neural Programmer",
            "brief_description": "A prior neural model that induces latent programs with gradient descent by representing intermediate results as differentiable vectors; cited as related work but noted to be less scalable to very large KBs.",
            "citation_title": "Neural programmer: Inducing latent programs with gradient descent",
            "mention_or_use": "mention",
            "model_name": "Neural Programmer",
            "model_description": "A neural architecture that learns to compose operations over table-like data by producing differentiable selectors/attention vectors representing intermediate results, enabling end-to-end gradient-based training.",
            "model_size": null,
            "reasoning_task_name": "Program induction / semantic-like operations over structured data",
            "reasoning_task_description": "Learns to generate and execute sequences of (differentiable) operations over structured inputs (e.g., tables) where intermediate results are continuous vectors.",
            "method_or_intervention": "Represents intermediate results as continuous weighted vectors / selectors to permit backpropagation through program execution.",
            "performance": null,
            "baseline_performance": null,
            "improvement_over_baseline": null,
            "limitations_or_failures": "Authors note that representing results as vectors (continuous memory) is not applicable to very large KBs like Freebase (~100M entities and &gt;20k properties) due to scalability; contrasts with NSM's symbolic variable approach.",
            "ablation_or_analysis": "Cited as contrast to NSM's non-differentiable symbolic storage; no experimental overlap in this paper.",
            "uuid": "e3543.7",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        },
        {
            "name_short": "Dynamic-NMN",
            "name_full": "Dynamic Neural Module Network (Dynamic-NMN)",
            "brief_description": "A modular neural architecture that composes small neural modules into a network specific to the input question; used for question answering, represents an alternative approach to composing operations for semantic parsing.",
            "citation_title": "Learning to compose neural networks for question answering",
            "mention_or_use": "mention",
            "model_name": "Dynamic Neural Module Network (Dynamic-NMN)",
            "model_description": "Builds a network by composing small neural modules according to a predicted layout derived from the input; intermediate computations are continuous vectors, enabling end-to-end training for QA tasks.",
            "model_size": null,
            "reasoning_task_name": "Neural module-based question answering / semantic composition",
            "reasoning_task_description": "Per-question dynamic composition of neural modules to perform multi-step reasoning for question answering; supports compositional semantics via learned modules.",
            "method_or_intervention": "Dynamic composition of neural modules based on parsed representations of the input question.",
            "performance": null,
            "baseline_performance": null,
            "improvement_over_baseline": null,
            "limitations_or_failures": "Paper contrasts it with NSM: module networks use continuous intermediate representations which may not scale to a massive KB like Freebase; also require layout prediction and often use supervision or different training regimes.",
            "ablation_or_analysis": "Mentioned in related work as alternative design for compositional semantics; no direct comparisons reported in this paper.",
            "uuid": "e3543.8",
            "source_info": {
                "paper_title": "Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision",
                "publication_date_yy_mm": "2016-10"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Reinforcement learning neural turing machines",
            "rating": 2
        },
        {
            "paper_title": "Neural programmer: Inducing latent programs with gradient descent",
            "rating": 2
        },
        {
            "paper_title": "Learning to compose neural networks for question answering",
            "rating": 2
        },
        {
            "paper_title": "Semantic parsing via staged query graph generation: Question answering with knowledge base",
            "rating": 2
        },
        {
            "paper_title": "Random walk inference and learning in a large scale knowledge base",
            "rating": 1
        },
        {
            "paper_title": "Neural programmer-interpreters",
            "rating": 1
        },
        {
            "paper_title": "The value of semantic parse labeling for knowledge base question answering",
            "rating": 1
        },
        {
            "paper_title": "Reward augmented maximum likelihood for neural structured prediction",
            "rating": 1
        }
    ],
    "cost": 0.018848499999999997,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Neural Symbolic Machines: Learning Semantic Parsers on Freebase with Weak Supervision</h1>
<p>Chen Liang, Jonathan Berant, Quoc Le, Kenneth D. Forbus, Ni Lao<br>Northwestern University, Evanston, IL<br>Tel-Aviv University, Tel Aviv-Yafo, Israel<br>Google Inc., Mountain View, CA<br>{chenliang2013,forbus}@u.northwestern.edu, joberant@cs.tau.ac.il, {qvl,nlao}@google.com</p>
<h4>Abstract</h4>
<p>Harnessing the statistical power of neural networks to perform language understanding and symbolic reasoning is difficult, when it requires executing efficient discrete operations against a large knowledge-base. In this work, we introduce a Neural Symbolic Machine (NSM), which contains (a) a neural "programmer", i.e., a sequence-to-sequence model that maps language utterances to programs and utilizes a key-variable memory to handle compositionality (b) a symbolic "computer", i.e., a Lisp interpreter that performs program execution, and helps find good programs by pruning the search space. We apply REINFORCE to directly optimize the task reward of this structured prediction problem. To train with weak supervision and improve the stability of REINFORCE we augment it with an iterative maximum-likelihood training process. NSM outperforms the state-of-theart on the WebQuestionsSP dataset when trained from question-answer pairs only, without requiring any feature engineering or domain-specific knowledge.</p>
<h2>1 Introduction</h2>
<p>Deep neural networks have achieved impressive performance in supervised classification and structured prediction tasks such as speech recognition (Hinton et al., 2012), machine translation (Bahdanau et al., 2014; Wu et al., 2016) and more. However, training neural networks for semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011) or program induction, where language is mapped to a sym-</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: The main challenges of training a semantic parser from weak supervision: (a) compositionality: we use variables $\left(v_{0}, v_{1}, v_{2}\right)$ to store execution results of intermediate generated programs. (b) search: we prune the search space and augment REINFORCE with pseudo-gold programs.
bolic representation that is executed by an executor, through weak supervision remains challenging. This is because the model must interact with a symbolic executor through non-differentiable operations to search over a large program space.</p>
<p>In semantic parsing, recent work handled this (Dong and Lapata, 2016; Jia and Liang, 2016) by training from manually annotated programs and avoiding program execution at training time. However, annotating programs is known to be expensive and scales poorly. In program induction, attempts to address this problem (Graves et al., 2014; Reed and de Freitas, 2016; Kaiser and Sutskever, 2015; Graves et al., 2016b; Andreas et al., 2016) either utilized low-level memory (Zaremba and Sutskever, 2015), or required memory to be differentiable (Neelakantan et al., 2015; Yin et al., 2015) so that the model can be trained with backpropagation. This makes it difficult to use the efficient discrete operations and memory of a traditional computer, and limited the application to synthetic or small knowledge bases.</p>
<p>In this paper, we propose to utilize the memory and discrete operations of a traditional com-</p>
<p>puter in a novel Manager-Programmer-Computer (MPC) framework for neural program induction, which integrates three components:</p>
<ol>
<li>A "manager" that provides weak supervision (e.g., 'NYC' in Figure 1) through a reward indicating how well a task is accomplished. Unlike full supervision, weak supervision is easy to obtain at scale (Section 3.1).</li>
<li>A "programmer" that takes natural language as input and generates a program that is a sequence of tokens (Figure 2). The programmer learns from the reward and must overcome the hard search problem of finding correct programs (Section 2.2).</li>
<li>A "computer" that executes programs in a high level programming language. Its nondifferentiable memory enables abstract, scalable and precise operations, but makes training more challenging (Section 2.3). To help the "programmer" prune the search space, it provides a friendly neural computer interface, which detects and eliminates invalid choices (Section 2.1).
Within this framework, we introduce the Neural Symbolic Machine (NSM) and apply it to semantic parsing. NSM contains a neural sequence-to-sequence (seq2seq) "programmer" (Sutskever et al., 2014) and a symbolic non-differentiable Lisp interpreter ("computer") that executes programs against a large knowledge-base (KB).</li>
</ol>
<p>Our technical contribution in this work is threefold. First, to support language compositionality, we augment the standard seq2seq model with a key-variable memory to save and reuse intermediate execution results (Figure 1). This is a novel application of pointer networks (Vinyals et al., 2015) to compositional semantics.</p>
<p>Second, to alleviate the search problem of finding correct programs when training from questionanswer pairs, we use the computer to execute partial programs and prune the programmer's search space by checking the syntax and semantics of generated programs. This generalizes the weakly supervised semantic parsing framework (Liang et al., 2011; Berant et al., 2013) by leveraging semantic denotations during structural search.</p>
<p>Third, to train from weak supervision and directly maximize the expected reward we turn to the REINFORCE (Williams, 1992) algorithm. Since learning from scratch is difficult for REINFORCE, we combine it with an iterative max-
imum likelihood (ML) training process, where beam search is used to find pseudo-gold programs, which are then used to augment the objective of REINFORCE.</p>
<p>On the WebQuestionsSP dataset (Yih et al., 2016), NSM achieves new state-of-the-art results with weak supervision, significantly closing the gap between weak and full supervision for this task. Unlike prior works, it is trained end-toend, and does not require feature engineering or domain-specific knowledge.</p>
<h2>2 Neural Symbolic Machines</h2>
<p>We now introduce NSM by first describing the "computer", a non-differentiable Lisp interpreter that executes programs against a large KB and provides code assistance (Section 2.1). We then propose a seq2seq model ("programmer") that supports compositionality using a key-variable memory to save and reuse intermediate results (Section 2.2). Finally, we describe a training procedure that is based on REINFORCE, but is augmented with pseudo-gold programs found by an iterative ML training procedure (Section 2.3).</p>
<p>Before diving into details, we define the semantic parsing task: given a knowledge base $\mathbb{K}$, and a question $x=\left(w_{1}, w_{2}, \ldots, w_{m}\right)$, produce a program or logical form $z$ that when executed against $\mathbb{K}$ generates the right answer $y$. Let $\mathcal{E}$ denote a set of entities (e.g., ABELINCOLN), ${ }^{1}$ and let $\mathcal{P}$ denote a set of properties (e.g., PlaceOfBirth). A knowledge base $\mathbb{K}$ is a set of assertions or triples $\left(e_{1}, p, e_{2}\right) \in \mathcal{E} \times \mathcal{P} \times \mathcal{E}$, such as (AbELINCOLN, PlaceOfBirth, HODGENVILLE).</p>
<h3>2.1 Computer: Lisp Interpreter with Code Assistance</h3>
<p>Semantic parsing typically requires using a set of operations to query the knowledge base and process the results. Operations learned with neural networks such as addition and sorting do not perfectly generalize to inputs that are larger than the ones observed in the training data (Graves et al., 2014; Reed and de Freitas, 2016). In contrast, operations implemented in high level programming languages are abstract, scalable, and precise, thus generalizes perfectly to inputs of arbitrary size. Based on this observation, we implement operations necessary for semantic parsing with an or-</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>dinary programming language instead of trying to learn them with a neural network.</p>
<p>We adopt a Lisp interpreter as the "computer". A program $C$ is a list of expressions $\left(c_{1} \ldots c_{N}\right)$, where each expression is either a special token "Return" indicating the end of the program, or a list of tokens enclosed by parentheses " $\left(F A_{1} \ldots A_{K}\right)$ ". $F$ is a function, which takes as input $K$ arguments of specific types. Table 1 defines the semantics of each function and the types of its arguments (either a property $p$ or a variable $r$ ). When a function is executed, it returns an entity list that is the expression's denotation in $\mathbb{K}$, and save it to a new variable.</p>
<p>By introducing variables that save the intermediate results of execution, the program naturally models language compositionality and describes from left to right a bottom-up derivation of the full meaning of the natural language input, which is convenient in a seq2seq model (Figure 1). This is reminiscent of the floating parser (Wang et al., 2015; Pasupat and Liang, 2015), where a derivation tree that is not grounded in the input is incrementally constructed.</p>
<p>The set of programs defined by our functions is equivalent to the subset of $\lambda$-calculus presented in (Yih et al., 2015). We did not use full Lisp programming language here, because constructs like control flow and loops are unnecessary for most current semantic parsing tasks, and it is simple to add more functions to the model when necessary.</p>
<p>To create a friendly neural computer interface, the interpreter provides code assistance to the programmer by producing a list of valid tokens at each step. First, a valid token should not cause a syntax error: e.g., if the previous token is " $($ ", the next token must be a function name, and if the previous token is "Hop", the next token must be a variable. More importantly, a valid token should not cause a semantic (run-time) error: this is detected using the denotation saved in the variables. For example, if the previously generated tokens were " $($ Hop $r$ ", the next available token is restricted to properties $\left{p \mid \exists e, e^{\prime}: e \in r,\left(e, p, e^{\prime}\right) \in \mathbb{K}\right}$ that are reachable from entities in $r$ in the KB. These checks are enabled by the variables and can be derived from the definition of the functions in Table 1. The interpreter prunes the "programmer"'s search space by orders of magnitude, and enables learning from weak supervision on a large KB.</p>
<h3>2.2 Programmer: Seq2seq Model with Key-Variable Memory</h3>
<p>Given the "computer", the "programmer" needs to map natural language into a program, which is a sequence of tokens that reference operations and values in the "computer". We base our programmer on a standard seq2seq model with attention, but extend it with a key-variable memory that allows the model to learn to represent and refer to program variables (Figure 2).</p>
<p>Sequence-to-sequence models consist of two RNNs, an encoder and a decoder. We used a 1-layer GRU (Cho et al., 2014) for both the encoder and decoder. Given a sequence of words $w_{1}, w_{2} \ldots w_{m}$, each word $w_{t}$ is mapped to an embedding $q_{t}$ (embedding details are in Section 3). Then, the encoder reads these embeddings and updates its hidden state step by step using $h_{t+1}=$ $G R U\left(h_{t}, q_{t}, \theta_{\text {Encoder }}\right)$, where $\theta_{\text {Encoder }}$ are the GRU parameters. The decoder updates its hidden states $u_{t}$ by $u_{t+1}=G R U\left(u_{t}, c_{t-1}, \theta_{\text {Decoder }}\right)$, where $c_{t-1}$ is the embedding of last step's output token $a_{t-1}$, and $\theta_{\text {Decoder }}$ are the GRU parameters. The last hidden state of the encoder $h_{T}$ is used as the decoder's initial state. We also adopt a dot-product attention similar to Dong and Lapata (2016). The tokens of the program $a_{1}, a_{2} \ldots a_{n}$ are generated one by one using a softmax over the vocabulary of valid tokens at each step, as provided by the "computer" (Section 2.1).</p>
<p>To achieve compositionality, the decoder must learn to represent and refer to intermediate variables whose value was saved in the "computer" after execution. Therefore, we augment the model with a key-variable memory, where each entry has two components: a continuous embedding key $v_{i}$, and a corresponding variable token $R_{i}$ referencing the value in the "computer" (see Figure 2). During encoding, we use an entity linker to link text spans (e.g., "US") to KB entities. For each linked entity we add a memory entry where the key is the average of GRU hidden states over the entity span, and the variable token $\left(R_{1}\right)$ is the name of a variable in the computer holding the linked entity (m.USA) as its value. During decoding, when a full expression is generated (i.e., the decoder generates " $)$ "), it gets executed, and the result is stored as the value of a new variable in the "computer". This variable is keyed by the GRU hidden state at that step. When a new variable $R_{1}$ with key embedding $v_{1}$ is added into the key-variable memory,</p>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Table 1: Interpreter functions. $r$ represents a variable, $p$ a property in Freebase. $\geq$ and $\leq$ are defined on numbers and dates.</p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 2: Semantic Parsing with NSM. The key embeddings of the key-variable memory are the output of the sequence model at certain encoding or decoding steps. For illustration purposes, we also show the values of the variables in parentheses, but the sequence model never sees these values, and only references them with the name of the variable (" $R_{1}$ "). A special token " $G O$ " indicates the start of decoding, and "Return" indicates the end of decoding.
the token $R_{1}$ is added into the decoder vocabulary with $v_{1}$ as its embedding. The final answer returned by the "programmer" is the value of the last computed variable.</p>
<p>Similar to pointer networks (Vinyals et al., 2015), the key embeddings for variables are dynamically generated for each example. During training, the model learns to represent variables by backpropagating gradients from a time step where a variable is selected by the decoder, through the key-variable memory, to an earlier time step when the key embedding was computed. Thus, the encoder/decoder learns to generate representations for variables such that they can be used at the right time to construct the correct program.</p>
<p>While the key embeddings are differentiable, the values referenced by the variables (lists of entities), stored in the "computer", are symbolic and non-differentiable. This distinguishes the keyvariable memory from other memory-augmented neural networks that use continuous differentiable embeddings as the values of memory entries (Weston et al., 2014; Graves et al., 2016a).</p>
<h3>2.3 Training NSM with Weak Supervision</h3>
<p>NSM executes non-differentiable operations against a KB, and thus end-to-end backpropagation is not possible. Therefore, we base our training procedure on REINFORCE (Williams, 1992; Norouzi et al., 2016). When the reward signal is sparse and the search space is large, it is common to utilize some full supervision to pre-train REINFORCE (Silver et al., 2016).</p>
<p>To train from weak supervision, we suggest an iterative ML procedure for finding pseudo-gold programs that will bootstrap REINFORCE.</p>
<p>REINFORCE We can formulate training as a reinforcement learning problem: given a question $x$, the state, action and reward at each time step $t \in$ ${0,1, \ldots, T}$ are $\left(s_{t}, a_{t}, r_{t}\right)$. Since the environment is deterministic, the state is defined by the question $x$ and the action sequence: $s_{t}=\left(x, a_{0: t-1}\right)$, where $a_{0: t-1}=\left(a_{0}, \ldots, a_{t-1}\right)$ is the history of actions at time $t$. A valid action at time $t$ is $a_{t} \in A\left(s_{t}\right)$, where $A\left(s_{t}\right)$ is the set of valid tokens given by the "computer". Since each action corresponds to a token, the full history $a_{0: T}$ corresponds to a program. The reward $r_{t}=I[t=T] \cdot F_{1}\left(x, a_{0: T}\right)$ is non-zero only at the last step of decoding, and is the $F_{1}$ score computed comparing the gold answer and the answer generated by executing the program $a_{0: T}$. Thus, the cumulative reward of a program $a_{0: T}$ is</p>
<p>$$
R\left(x, a_{0: T}\right)=\sum_{t} r_{t}=F_{1}\left(x, a_{0: T}\right)
$$</p>
<p>The agent's decision making procedure at each time is defined by a policy, $\pi_{\theta}(s, a)=P_{\theta}\left(a_{t}=\right.$ $\left.a \mid x, a_{0: t-1}\right)$, where $\theta$ are the model parameters. Since the environment is deterministic, the probability of generating a program $a_{0: T}$ is</p>
<p>$$
P_{\theta}\left(a_{0: T} \mid x\right)=\prod_{t} P_{\theta}\left(a_{t} \mid x, a_{0: t-1}\right)
$$</p>
<p>We can define our objective to be the expected cumulative reward and use policy gradient meth-</p>
<p>ods such as REINFORCE for training. The objective and gradient are:</p>
<p>$$
\begin{aligned}
J^{R L}(\theta)= &amp; \sum_{x} \mathbb{E}<em _theta="\theta">{P</em>\right)\right] \
\nabla_{\theta} J^{R L}(\theta)= &amp; \sum_{x} \sum_{a_{0: T}} P_{\theta}\left(a_{0: T} \mid x\right) \cdot\left[R\left(x, a_{0: T}\right)-\right. \
&amp; B(x)] \cdot \nabla_{\theta} \log P_{\theta}\left(a_{0: T} \mid x\right)
\end{aligned}
$$}\left(a_{0: T} \mid x\right)}\left[R\left(x, a_{0: T</p>
<p>where $B(x)=\sum_{a_{0: T}} P_{\theta}\left(a_{0: T} \mid x\right) R\left(x, a_{0: T}\right)$ is a baseline that reduces the variance of the gradient estimation without introducing bias. Having a separate network to predict the baseline is an interesting future direction.</p>
<p>While REINFORCE assumes a stochastic policy, we use beam search for gradient estimation. Thus, in contrast with common practice of approximating the gradient by sampling from the model, we use the top- $k$ action sequences (programs) in the beam with normalized probabilities. This allows training to focus on sequences with high probability, which are on the decision boundaries, and reduces the variance of the gradient.</p>
<p>Empirically (and in line with prior work), REINFORCE converged slowly and often got stuck in local optima (see Section 3). The difficulty of training resulted from the sparse reward signal in the large search space, which caused model probabilities for programs with non-zero reward to be very small at the beginning. If the beam size $k$ is small, good programs fall off the beam, leading to zero gradients for all programs in the beam. If the beam size $k$ is large, training is very slow, and the normalized probabilities of good programs when the model is untrained are still very small, leading to (1) near zero baselines, thus near zero gradients on "bad" programs (2) near zero gradients on good programs due to the low probability $P_{\theta}\left(a_{0: T} \mid x\right)$. To combat this, we present an alternative training strategy based on maximum-likelihood.</p>
<p>Iterative ML If we had gold programs, we could directly optimize their likelihood. Since we do not have gold programs, we can perform an iterative procedure (similar to hard ExpectationMaximization (EM)), where we search for good programs given fixed parameters, and then optimize the probability of the best program found so far. We do decoding on an example with a large beam size and declare $a_{0: T}^{\text {best }}(x)$ to be the pseudogold program, which achieved highest reward with shortest length among the programs decoded on $x$
in all previous iterations. Then, we can optimize the ML objective:</p>
<p>$$
J^{M L}(\theta)=\sum_{x} \log P_{\theta}\left(a_{0: T}^{\text {best }}(x) \mid x\right)
$$</p>
<p>A question $x$ is not included if we did not find any program with positive reward.</p>
<p>Training with iterative ML is fast because there is at most one program per example and the gradient is not weighted by model probability. while decoding with a large beam size is slow, we could train for multiple epochs after each decoding. This iterative process has a bootstrapping effect that a better model leads to a better program $a_{0: T}^{\text {best }}(x)$ through decoding, and a better program $a_{0: T}^{\text {best }}(x)$ leads to a better model through training.</p>
<p>Even with a large beam size, some programs are hard to find because of the large search space. A common solution to this problem is to use curriculum learning (Zaremba and Sutskever, 2015; Reed and de Freitas, 2016). The size of the search space is controlled by both the set of functions used in the program and the program length. We apply curriculum learning by gradually increasing both these quantities (see details in Section 3) when performing iterative ML.</p>
<p>Nevertheless, iterative ML uses only pseudogold programs and does not directly optimize the objective we truly care about. This has two adverse effects: (1) The best program $a_{0: T}^{\text {best }}(x)$ could be a spurious program that accidentally produces the correct answer (e.g., using the property PlaceOfBirth instead of PlaceOfDeath when the two places are the same), and thus does not generalize to other questions. (2) Because training does not observe full negative programs, the model often fails to distinguish between tokens that are related to one another. For example, differentiating ParentsOf vs. SiblingsOf vs. ChildrenOf can be challenging. We now present learning where we combine iterative ML with REINFORCE.</p>
<p>Augmented REINFORCE To bootstrap REINFORCE, we can use iterative ML to find pseudogold programs, and then add these programs to the beam with a reasonably large probability. This is similar to methods from imitation learning (Ross et al., 2011; Jiang et al., 2012) that define a proposal distribution by linearly interpolating the model distribution and an oracle.</p>
<div class="codehilite"><pre><span></span><code>Algorithm 1 IML-REINFORCE
    Input: question-answer pairs \(\mathbb{D}=\left\{\left(x_{i}, y_{i}\right)\right\}\), mix ratio
    \(\alpha\), reward function \(R(\cdot)\), training iterations \(N_{M L}, N_{R L}\)
    and beam sizes \(B_{M L}, B_{R L}\).
    Procedure:
    Initialize \(C_{x}^{*}=\emptyset\) the best program so far for \(x\)
    Initialize model \(\theta\) randomly \(\triangleright\) Iterative ML
    for \(n=1\) to \(N_{M L}\) do
        for \((x, y)\) in \(D\) do
            \(\mathbb{C} \leftarrow\) Decode \(B_{M L}\) programs given \(x\)
            for \(j\) in \(1 \ldots|\mathbb{C}|\) do
                if \(R_{x, y}\left(C_{j}\right)&gt;R_{x, y}\left(C_{x}^{*}\right)\) then \(C_{x}^{*} \leftarrow C_{j}\)
            \(\theta \leftarrow\) ML training with \(\mathbb{D}_{M L}=\left\{\left(x, C_{x}^{*}\right)\right\}\)
    Initialize model \(\theta\) randomly \(\triangleright\) REINFORCE
    for \(n=1\) to \(N_{R L}\) do
        \(\mathbb{D}_{R L} \leftarrow \emptyset\) is the RL training set
        for \((x, y)\) in \(D\) do
            \(\mathbb{C} \leftarrow\) Decode \(B_{R L}\) programs from \(x\)
            for \(j\) in \(1 \ldots|\mathbb{C}|\) do
                if \(R_{x, y}\left(C_{j}\right)&gt;R_{x, y}\left(C_{x}^{*}\right)\) then \(C_{x}^{*} \leftarrow C_{j}\)
            \(\mathbb{C} \leftarrow \mathbb{C} \cup\left\{C_{x}^{*}\right\}\)
            for \(j\) in \(1 \ldots|\mathbb{C}|\) do
                \(\hat{p}_{j} \leftarrow(1-\alpha) \cdot \frac{p_{j}}{\sum_{j^{\prime}} p_{j^{\prime}}}\) where \(p_{j}=P_{\theta}\left(C_{j} \mid x\right)\)
                if \(C_{j}=C_{x}^{*}\) then \(\hat{p}_{j} \leftarrow \hat{p}_{j}+\alpha\)
                \(\mathbb{D}_{R L} \leftarrow \mathbb{D}_{R L} \cup\left\{\left(x, C_{j}, \hat{p}_{j}\right)\right\}\)
            \(\theta \leftarrow\) REINFORCE training with \(\mathbb{D}_{R L}\)
</code></pre></div>

<p>Algorithm 1 describes our overall training procedure. We first run iterative ML for $N_{M L}$ iterations and record the best program found for every example $x_{i}$. Then, we run REINFORCE, where we normalize the probabilities of the programs in beam to sum to $(1-\alpha)$ and add $\alpha$ to the probability of the best found program $C^{*}\left(x_{i}\right)$. Consequently, the model always puts a reasonable amount of probability on a program with high reward during training. Note that we randomly initialized the parameters for REINFORCE, since initializing from the final ML parameters seems to get stuck in a local optimum and produced worse results.</p>
<p>On top of imitation learning, our approach is related to the common practice in reinforcement learning (Schaul et al., 2016) to replay rare successful experiences to reduce the training variance and improve training efficiency. This is also similar to recent developments (Wu et al., 2016) in machine translation, where ML and RL objectives are linearly combined, because anchoring the model to some high-reward outputs stabilizes training.</p>
<h2>3 Experiments and Analysis</h2>
<p>We now empirically show that NSM can learn a semantic parser from weak supervision over a large KB. We evaluate on WebQuestionsSP, a challenging semantic parsing dataset with strong baselines. Experiments show that NSM achieves
new state-of-the-art performance on WebQUESTIONSSP with weak supervision, and significantly closes the gap between weak and full supervisions for this task.</p>
<h3>3.1 The WebQuestionsSP dataset</h3>
<p>The WebQuestionsSP dataset (Yih et al., 2016) contains full semantic parses for a subset of the questions from WebQuestions (Berant et al., 2013), because $18.5 \%$ of the original dataset were found to be "not answerable". It consists of 3,098 question-answer pairs for training and 1,639 for testing, which were collected using Google Suggest API, and the answers were originally obtained using Amazon Mechanical Turk workers. They were updated in (Yih et al., 2016) by annotators who were familiar with the design of Freebase and added semantic parses. We further separated out 620 questions from the training set as a validation set. For query pre-processing we used an in-house named entity linking system to find the entities in a question. The quality of the entity linker is similar to that of (Yih et al., 2015) at $94 \%$ of the gold root entities being included. Similar to Dong and Lapata (2016), we replaced named entity tokens with a special token "ENT". For example, the question "who plays meg in family guy" is changed to "who plays ENT in ENT ENT". This helps reduce overfitting, because instead of memorizing the correct program for a specific entity, the model has to focus on other context words in the sentence, which improves generalization.</p>
<p>Following (Yih et al., 2015) we used the last publicly available snapshot of Freebase (Bollacker et al., 2008). Since NSM training requires random access to Freebase during decoding, we preprocessed Freebase by removing predicates that are not related to world knowledge (starting with "/common/", "/type/", "/freebase/"), ${ }^{2}$ and removing all text valued predicates, which are rarely the answer. Out of all 27 K relations, 434 relations are removed during preprocessing. This results in a graph that fits in memory with 23 K relations, 82 M nodes, and 417 M edges.</p>
<h3>3.2 Model Details</h3>
<p>For pre-trained word embeddings, we used the 300 dimension GloVe word embeddings trained on 840B tokens (Pennington et al., 2014). On the encoder side, we added a projection matrix to</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>transform the embeddings into 50 dimensions. On the decoder side, we used the same GloVe embeddings to construct an embedding for each property using its Freebase id, and also added a projection matrix to transform this embedding to 50 dimensions. A Freebase id contains three parts: domain, type, and property. For example, the Freebase id for ParentsOf is "/people/person/parents". "people" is the domain, "person" is the type and "parents" is the property. The embedding is constructed by concatenating the average of word embeddings in the domain and type name to the average of word embeddings in the property name. For example, if the embedding dimension is 300, the embedding dimension for "/people/person/parents" will be 600. The first 300 dimensions will be the average of the embeddings for "people" and "person", and the second 300 dimensions will be the embedding for "parents".</p>
<p>The dimension of encoder hidden state, decoder hidden state and key embeddings are all 50. The embeddings for the functions and special tokens (e.g., "UNK", "GO") are randomly initialized by a truncated normal distribution with mean $=0.0$ and stddev $=0.1$. All the weight matrices are initialized with a uniform distribution in $\left[-\frac{\sqrt{3}}{d}, \frac{\sqrt{3}}{d}\right]$ where $d$ is the input dimension. Dropout rate is set to 0.5 , and we see a clear tendency for larger dropout rate to produce better performance, indicating overfitting is a major problem for learning.</p>
<h3>3.3 Training Details</h3>
<p>In iterative ML training, the decoder uses a beam of size $k=100$ to update the pseudo-gold programs and the model is trained for 20 epochs after each decoding step. We use the Adam optimizer (Kingma and Ba, 2014) with initial learning rate 0.001 . In our experiment, this process usually converges after a few (5-8) iterations.</p>
<p>For REINFORCE training, the best hyperparameters are chosen using the validation set. We use a beam of size $k=5$ for decoding, and $\alpha$ is set to 0.1 . Because the dataset is small and some relations are only used once in the whole training set, we train the model on the entire training set for 200 iterations with the best hyperparameters. Then we train the model with learning rate decay until convergence. Learning rate is decayed as $g_{t}=g_{0} \times \beta^{\frac{\max \left(0, t-t_{s}\right)}{m}}$, where $g_{0}=0.001, \beta=0.5$ $m=1000$, and $t_{s}$ is the number of training steps at the end of iteration 200.</p>
<p>Since decoding needs to query the knowledge base (KB) constantly, the speed bottleneck for training is decoding. We address this problem in our implementation by partitioning the dataset, and using multiple decoders in parallel to handle each partition. We use 100 decoders, which queries 50 KG servers, and one trainer. The neural network model is implemented in TensorFlow. Since the model is small, we didn't see a significant speedup by using GPU, so all the decoders and the trainer are using CPU only.</p>
<p>Inspired by the staged generation process in Yih et al. (2015), curriculum learning includes two steps. We first run iterative ML for 10 iterations with programs constrained to only use the "Hop" function and the maximum number of expressions is 2 . Then, we run iterative ML again, but use both "Hop" and "Filter". The maximum number of expressions is 3 , and the relations used by "Hop" are restricted to those that appeared in $a_{0: T}^{b e a t}(q)$ in the first step.</p>
<h3>3.4 Results and discussion</h3>
<p>We evaluate performance using the offical evaluation script for WebQuestionsSP. Because the answer to a question may contain multiple entities or values, precision, recall and F1 are computed based on the output of each individual question, and average F1 is reported as the main evaluation metric. Accuracy measures the proportion of questions that are answered exactly.</p>
<p>A comparison to STAGG, the previous state-of-the-art model (Yih et al., 2016, 2015), is shown in Table 2. Our model beats STAGG with weak supervision by a significant margin on all metrics, while relying on no feature engineering or handcrafted rules. When STAGG is trained with strong supervision it obtains an F1 of 71.7, and thus NSM closes half the gap between training with weak and full supervision.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Model</th>
<th style="text-align: center;">Prec.</th>
<th style="text-align: center;">Rec.</th>
<th style="text-align: center;">F1</th>
<th style="text-align: center;">Acc.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">STAGG</td>
<td style="text-align: center;">67.3</td>
<td style="text-align: center;">73.1</td>
<td style="text-align: center;">66.8</td>
<td style="text-align: center;">58.8</td>
</tr>
<tr>
<td style="text-align: left;">NSM</td>
<td style="text-align: center;">70.8</td>
<td style="text-align: center;">76.0</td>
<td style="text-align: center;">$\mathbf{6 9 . 0}$</td>
<td style="text-align: center;">59.5</td>
</tr>
</tbody>
</table>
<p>Table 2: Results on the test set. Average F1 is the main evaluation metric and NSM outperforms STAGG with no domainspecific knowledge or feature engineering.</p>
<p>Four key ingredients lead to the final performance of NSM. The first one is the neural computer interface that provides code assistance by checking for syntax and semantic errors. We find</p>
<p>that semantic checks are very effective for opendomain KBs with a large number of properties. For our task, the average number of choices is reduced from 23 K per step (all properties) to less than 100 (the average number of properties connected to an entity).</p>
<p>The second ingredient is augmented REINFORCE training. Table 3 compares augmented REINFORCE, REINFORCE, and iterative ML on the validation set. REINFORCE gets stuck in local optimum and performs poorly. Iterative ML training is not directly optimizing the F1 measure, and achieves sub-optimal results. In contrast, augmented REINFORCE is able to bootstrap using pseudo-gold programs found by iterative ML and achieves the best performance on both the training and validation set.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Settings</th>
<th style="text-align: center;">Train F1</th>
<th style="text-align: center;">Valid F1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Iterative ML</td>
<td style="text-align: center;">68.6</td>
<td style="text-align: center;">60.1</td>
</tr>
<tr>
<td style="text-align: left;">REINFORCE</td>
<td style="text-align: center;">55.1</td>
<td style="text-align: center;">47.8</td>
</tr>
<tr>
<td style="text-align: left;">Augmented REINFORCE</td>
<td style="text-align: center;">83.0</td>
<td style="text-align: center;">$\mathbf{6 7 . 2}$</td>
</tr>
</tbody>
</table>
<p>Table 3: Average F1 on the validation set for augmented REINFORCE, REINFORCE, and iterative ML.</p>
<p>The third ingredient is curriculum learning during iterative ML. We compare the performance of the best programs found with and without curriculum learning in Table 4. We find that the best programs found with curriculum learning are substantially better than those found without curriculum learning by a large margin on every metric.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Settings</th>
<th style="text-align: center;">Prec.</th>
<th style="text-align: center;">Rec.</th>
<th style="text-align: center;">F1</th>
<th style="text-align: center;">Acc.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">No curriculum</td>
<td style="text-align: center;">79.1</td>
<td style="text-align: center;">91.1</td>
<td style="text-align: center;">78.5</td>
<td style="text-align: center;">67.2</td>
</tr>
<tr>
<td style="text-align: left;">Curriculum</td>
<td style="text-align: center;">88.6</td>
<td style="text-align: center;">96.1</td>
<td style="text-align: center;">89.5</td>
<td style="text-align: center;">79.8</td>
</tr>
</tbody>
</table>
<p>Table 4: Evaluation of the programs with the highest F1 score in the beam $\left(a_{9 / 4}^{3 \times 4}\right)$ with and without curriculum learning.</p>
<p>The last important ingredient is reducing overfitting. Given the small size of the dataset, overfitting is a major problem for training neural network models. We show the contributions of different techniques for controlling overfitting in Table 5. Note that after all the techniques have been applied, the model is still overfitting with training F1@1=83.0\% and validation F1@1=67.2\%.</p>
<p>Among the programs generated by the model, a significant portion ( $36.7 \%$ ) uses more than one expression. From Table 6, we can see that the performance doesn't decrease much as the composi-</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Settings</th>
<th style="text-align: center;">$\Delta$ F1@1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">-Pretrained word embeddings</td>
<td style="text-align: center;">-5.5</td>
</tr>
<tr>
<td style="text-align: left;">-Pretrained property embeddings</td>
<td style="text-align: center;">-2.7</td>
</tr>
<tr>
<td style="text-align: left;">-Dropout on GRU input and output</td>
<td style="text-align: center;">-2.4</td>
</tr>
<tr>
<td style="text-align: left;">-Dropout on softmax</td>
<td style="text-align: center;">-1.1</td>
</tr>
<tr>
<td style="text-align: left;">-Anonymize entity tokens</td>
<td style="text-align: center;">-2.0</td>
</tr>
</tbody>
</table>
<p>Table 5: Contributions of different overfitting techniques on the validation set.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">#Expressions</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Percentage</td>
<td style="text-align: center;">$0.4 \%$</td>
<td style="text-align: center;">$62.9 \%$</td>
<td style="text-align: center;">$29.8 \%$</td>
<td style="text-align: center;">$6.9 \%$</td>
</tr>
<tr>
<td style="text-align: left;">F1</td>
<td style="text-align: center;">0.0</td>
<td style="text-align: center;">73.5</td>
<td style="text-align: center;">59.9</td>
<td style="text-align: center;">70.3</td>
</tr>
</tbody>
</table>
<p>Table 6: Percentage and performance of model generated programs with different complexity (number of expressions).
tional depth increases, indicating that the model is effective at capturing compositionality. We observe that programs with three expressions use a more limited set of properties, mainly focusing on answering a few types of questions such as "who plays meg in family guy", "what college did jeff corwin go to" and "which countries does russia border". In contrast, programs with two expressions use a more diverse set of properties, which could explain the lower performance compared to programs with three expressions.</p>
<p>Error analysis Error analysis on the validation set shows two main sources of errors:</p>
<ol>
<li>Search failure: Programs with high reward are not found during search for pseudo-gold programs, either because the beam size is not large enough, or because the set of functions implemented by the interpreter is insufficient. The $89.5 \%$ F1 score in Table 4 indicates that at least $10 \%$ of the questions are of this kind.</li>
<li>Ranking failure: Programs with high reward exist in the beam, but are not ranked at the top during decoding. Because the training error is low, this is largely due to overfitting or spurious programs. The $67.2 \%$ F1 score in Table 3 indicates that about $20 \%$ of the questions are of this kind.</li>
</ol>
<h2>4 Related work</h2>
<p>Among deep learning models for program induction, Reinforcement Learning Neural Turing Machines (RL-NTMs) (Zaremba and Sutskever, 2015) are the most similar to NSM, as a nondifferentiable machine is controlled by a sequence</p>
<p>model. Therefore, both models rely on REINFORCE for training. The main difference between the two is the abstraction level of the programming language. RL-NTM uses lower level operations such as memory address manipulation and byte reading/writing, while NSM uses a high level programming language over a large knowledge base that includes operations such as following properties from entities, or sorting based on a property, which is more suitable for representing semantics. Earlier works such as OOPS (Schmidhuber, 2004) has desirable characteristics, for example, the ability to define new functions. These remain to be future improvements for NSM.</p>
<p>We formulate NSM training as an instance of reinforcement learning (Sutton and Barto, 1998) in order to directly optimize the task reward of the structured prediction problem (Norouzi et al., 2016; Li et al., 2016; Yu et al., 2017). Compared to imitation learning methods (Daume et al., 2009; Ross et al., 2011) that interpolate a model distribution with an oracle, NSM needs to solve a challenging search problem of training from weak supervisions in a large search space. Our solution employs two techniques (a) a symbolic "computer" helps find good programs by pruning the search space (b) an iterative ML training process, where beam search is used to find pseudogold programs. Wiseman and Rush (Wiseman and Rush, 2016) proposed a max-margin approach to train a sequence-to-sequence scorer. However, their training procedure is more involved, and we did not implement it in this work. MIXER (Ranzato et al., 2015) also proposed to combine ML training and REINFORCE, but they only considered tasks with full supervisions. Berant and Liang (Berant and Liang, 2015) applied imitation learning to semantic parsing, but still requires hand crafted grammars and features.</p>
<p>NSM is similar to Neural Programmer (Neelakantan et al., 2015) and Dynamic Neural Module Network (Andreas et al., 2016) in that they all solve the problem of semantic parsing from structured data, and generate programs using similar semantics. The main difference between these approaches is how an intermediate result (the memory) is represented. Neural Programmer and Dynamic-NMN chose to represent results as vectors of weights (row selectors and attention vectors), which enables backpropagation and search through all possible programs in parallel. How-
ever, their strategy is not applicable to a large KB such as Freebase, which contains about 100M entities, and more than 20k properties. Instead, NSM chooses a more scalable approach, where the "computer" saves intermediate results, and the neural network only refers to them with variable names (e.g., " $R_{1}$ " for all cities in the US).</p>
<p>NSM is similar to the Path Ranking Algorithm (PRA) (Lao et al., 2011) in that semantics is encoded as a sequence of actions, and denotations are used to prune the search space during learning. NSM is more powerful than PRA by 1) allowing more complex semantics to be composed through the use of a key-variable memory; 2) controlling the search procedure with a trained neural network, while PRA only samples actions uniformly; 3) allowing input questions to express complex relations, and then dynamically generating action sequences. PRA can combine multiple semantic representations to produce the final prediction, which remains to be future work for NSM.</p>
<h2>5 Conclusion</h2>
<p>We propose the Manager-Programmer-Computer framework for neural program induction. It integrates neural networks with a symbolic nondifferentiable computer to support abstract, scalable and precise operations through a friendly neural computer interface. Within this framework, we introduce the Neural Symbolic Machine, which integrates a neural sequence-to-sequence "programmer" with key-variable memory, and a symbolic Lisp interpreter with code assistance. Because the interpreter is non-differentiable and to directly optimize the task reward, we apply REINFORCE and use pseudo-gold programs found by an iterative ML training process to bootstrap training. NSM achieves new state-of-the-art results on a challenging semantic parsing dataset with weak supervision, and significantly closes the gap between weak and full supervision. It is trained end-to-end, and does not require any feature engineering or domain-specific knowledge.</p>
<h2>Acknowledgements</h2>
<p>We thank for discussions and help from Arvind Neelakantan, Mohammad Norouzi, Tom Kwiatkowski, Eugene Brevdo, Lukasz Kaizer, Thomas Strohmann, Yonghui Wu, Zhifeng Chen, Alexandre Lacoste, and John Blitzer. The second author is partially supported by the Israel Science Foundation, grant 942/16.</p>
<h2>References</h2>
<p>Jacob Andreas, Marcus Rohrbach, Trevor Darrell, and Dan Klein. 2016. Learning to compose neural networks for question answering. CoRR abs/1601.01705.</p>
<p>Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2014. Neural machine translation by jointly learning to align and translate. CoRR abs/1409.0473. http://arxiv.org/abs/1409.0473.</p>
<p>Jonathan Berant, Andrew Chou, Roy Frostig, and Percy Liang. 2013. Semantic parsing on freebase from question-answer pairs. In EMNLP. volume 2, page 6 .</p>
<p>Jonathan Berant and Percy Liang. 2015. Imitation learning of agenda-based semantic parsers. TACL 3:545-558.
K. Bollacker, C. Evans, P. Paritosh, T. Sturge, and J. Taylor. 2008. Freebase: a collaboratively created graph database for structuring human knowledge. In International Conference on Management of Data (SIGMOD). pages 1247-1250.</p>
<p>Kyunghyun Cho, Bart van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning phrase representations using rnn encoder-decoder for statistical machine translation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP). Association for Computational Linguistics, Doha, Qatar, pages 1724-1734. http://www.aclweb.org/anthology/D141179.
H. Daume, J. Langford, and D. Marcu. 2009. Searchbased structured prediction. Machine Learning 75:297-325.</p>
<p>Li Dong and Mirella Lapata. 2016. Language to logical form with neural attention. In Association for Computational Linguistics (ACL).</p>
<p>Alex Graves, Greg Wayne, and Ivo Danihelka. 2014. Neural turing machines. arXiv preprint arXiv:1410.5401 .</p>
<p>Alex Graves, Greg Wayne, Malcolm Reynolds, Tim Harley, Ivo Danihelka, Agnieszka GrabskaBarwinska, Sergio G. Colmenarejo, Edward Grefenstette, Tiago Ramalho, John Agapiou, AdriÃ P. Badia, Karl M. Hermann, Yori Zwols, Georg Ostrovski, Adam Cain, Helen King, Christopher Summerfield, Phil Blunsom, Koray Kavukcuoglu, and Demis Hassabis. 2016a. Hybrid computing using a neural network with dynamic external memory. Nature advance online publication. https://doi.org/10.1038/nature20101.</p>
<p>Alex Graves, Greg Wayne, Malcolm Reynolds, Tim Harley, Ivo Danihelka, Agnieszka GrabskaBarwińska, Sergio Gómez Colmenarejo, Edward Grefenstette, Tiago Ramalho, John Agapiou, et al.</p>
<p>2016b. Hybrid computing using a neural network with dynamic external memory. Nature .</p>
<p>Geoffrey Hinton, Li Deng, Dong Yu, George E Dahl, Abdel-rahman Mohamed, Navdeep Jaitly, Andrew Senior, Vincent Vanhoucke, Patrick Nguyen, Tara N Sainath, et al. 2012. Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups. IEEE Signal Processing Magazine 29(6):82-97.</p>
<p>Robin Jia and Percy Liang. 2016. Data recombination for neural semantic parsing. In Association for Computational Linguistics (ACL).
J. Jiang, A. Teichert, J. Eisner, and H. Daume. 2012. Learned prioritization for trading off accuracy and speed. In Advances in Neural Information Processing Systems (NIPS).</p>
<p>Łukasz Kaiser and Ilya Sutskever. 2015. Neural gpus learn algorithms. arXiv preprint arXiv:1511.08228 .</p>
<p>Diederik P. Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. CoRR abs/1412.6980. http://arxiv.org/abs/1412.6980.</p>
<p>Ni Lao, Tom Mitchell, and William W Cohen. 2011. Random walk inference and learning in a large scale knowledge base. In Proceedings of the Conference on Empirical Methods in Natural Language Processing. Association for Computational Linguistics, pages 529-539.</p>
<p>Jiwei Li, Will Monroe, Alan Ritter, Michel Galley, Jianfeng Gao, and Dan Jurafsky. 2016. Deep reinforcement learning for dialogue generation. arXiv preprint arXiv:1606.01541 .
P. Liang, M. I. Jordan, and D. Klein. 2011. Learning dependency-based compositional semantics. In Association for Computational Linguistics (ACL). pages 590-599.</p>
<p>Arvind Neelakantan, Quoc V. Le, and Ilya Sutskever. 2015. Neural programmer: Inducing latent programs with gradient descent. CoRR abs/1511.04834.</p>
<p>Mohammad Norouzi, Samy Bengio, zhifeng Chen, Navdeep Jaitly, Mike Schuster, Yonghui Wu, and Dale Schuurmans. 2016. Reward augmented maximum likelihood for neural structured prediction. In Advances in Neural Information Processing Systems (NIPS).</p>
<p>Panupong Pasupat and Percy Liang. 2015. Compositional semantic parsing on semi-structured tables. In ACL.</p>
<p>Jeffrey Pennington, Richard Socher, and Christopher D. Manning. 2014. Glove: Global vectors for word representation. In EMNLP.</p>
<p>Marc'Aurelio Ranzato, Sumit Chopra, Michael Auli, and Wojciech Zaremba. 2015. Sequence level training with recurrent neural networks. arXiv preprint arXiv:1511.06732 .</p>
<p>Scott Reed and Nando de Freitas. 2016. Neural programmer-interpreters. In $I C L R$.
S. Ross, G. Gordon, and A. Bagnell. 2011. A reduction of imitation learning and structured prediction to noregret online learning. In Artificial Intelligence and Statistics (AISTATS).</p>
<p>Tom Schaul, John Quan, Ioannis Antonoglou, and David Silver. 2016. Prioritized experience replay. In International Conference on Learning Representations. Puerto Rico.</p>
<p>Jürgen Schmidhuber. 2004. Optimal ordered problem solver. Machine Learning 54(3):211-254.</p>
<p>David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. 2016. Mastering the game of go with deep neural networks and tree search. Nature 529(7587):484-489.</p>
<p>Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014. Sequence to sequence learning with neural networks. In Advances in neural information processing systems. pages 3104-3112.</p>
<p>Richard S. Sutton and Andrew G. Barto. 1998. Reinforcement Learning: An Introduction. MIT Press, Cambridge, MA.</p>
<p>Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly. 2015. Pointer networks. In Advances in Neural Information Processing Systems (NIPS).</p>
<p>Yushi Wang, Jonathan Berant, and Percy Liang. 2015. Building a semantic parser overnight. In Association for Computational Linguistics (ACL).</p>
<p>Jason Weston, Sumit Chopra, and Antoine Bordes. 2014. Memory networks. arXiv preprint arXiv:1410.3916 .</p>
<p>Ronald J. Williams. 1992. Simple statistical gradientfollowing algorithms for connectionist reinforcement learning. In Machine Learning. pages 229256.</p>
<p>Sam Wiseman and Alexander M. Rush. 2016. Sequence-to-sequence learning as beamsearch optimization. CoRR abs/1606.02960. http://arxiv.org/abs/1606.02960.</p>
<p>Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V. Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, Jeff Klingner, Apurva Shah, Melvin Johnson, Xiaobing Liu, Lukasz Kaiser, Stephan Gouws, Yoshikiyo Kato, Taku Kudo, Hideto Kazawa, Keith Stevens, George Kurian, Nishant</p>
<p>Patil, Wei Wang, Cliff Young, Jason Smith, Jason Riesa, Alex Rudnick, Oriol Vinyals, Greg Corrado, Macduff Hughes, and Jeffrey Dean. 2016. Google's neural machine translation system: Bridging the gap between human and machine translation. CoRR abs/1609.08144. http://arxiv.org/abs/1609.08144.</p>
<p>Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and Jianfeng Gao. 2015. Semantic parsing via staged query graph generation: Question answering with knowledge base. In Association for Computational Linguistics (ACL).</p>
<p>Wen-tau Yih, Matthew Richardson, Chris Meek, MingWei Chang, and Jina Suh. 2016. The value of semantic parse labeling for knowledge base question answering. In Association for Computational Linguistics (ACL).</p>
<p>Pengcheng Yin, Zhengdong Lu, Hang Li, and Ben Kao. 2015. Neural enquirer: Learning to query tables. arXiv preprint arXiv:1512.00965 .</p>
<p>Adam Yu, Hongrae Lee, and Quoc Le. 2017. Learning to skim text. In $A C L$.</p>
<p>Wojciech Zaremba and Ilya Sutskever. 2015. Reinforcement learning neural turing machines. arXiv preprint arXiv:1505.00521 .
M. Zelle and R. J. Mooney. 1996. Learning to parse database queries using inductive logic programming. In Association for the Advancement of Artificial Intelligence (AAAI). pages 1050-1055.
L. S. Zettlemoyer and M. Collins. 2005. Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars. In Uncertainty in Artificial Intelligence (UAI). pages 658666 .</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{2}$ We kept "/common/topic/notable_types".&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>