<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-6343 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-6343</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-6343</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-125.html">extraction-schema-125</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of large language model agents that use memory to solve text‑based games, including details about the memory type, representation, update mechanism, benchmark used, performance with and without memory, training method, and any reported challenges or ablations.</div>
                <p><strong>Paper ID:</strong> paper-92a8f7f09f3705cb5a6009a42220a6f01ea084e8</p>
                <p><strong>Paper Title:</strong> <a href="https://www.semanticscholar.org/paper/92a8f7f09f3705cb5a6009a42220a6f01ea084e8" target="_blank">Language Models as Zero-Shot Planners: Extracting Actionable Knowledge for Embodied Agents</a></p>
                <p><strong>Paper Venue:</strong> International Conference on Machine Learning</p>
                <p><strong>Paper TL;DR:</strong> This paper investigates the possibility of grounding high-level tasks, expressed in natural language, to a chosen set of actionable steps and proposes a procedure that conditions on existing demonstrations and semantically translates the plans to admissible actions.</p>
                <p><strong>Paper Abstract:</strong> Can world knowledge learned by large language models (LLMs) be used to act in interactive environments? In this paper, we investigate the possibility of grounding high-level tasks, expressed in natural language (e.g."make breakfast"), to a chosen set of actionable steps (e.g."open fridge"). While prior work focused on learning from explicit step-by-step examples of how to act, we surprisingly find that if pre-trained LMs are large enough and prompted appropriately, they can effectively decompose high-level tasks into mid-level plans without any further training. However, the plans produced naively by LLMs often cannot map precisely to admissible actions. We propose a procedure that conditions on existing demonstrations and semantically translates the plans to admissible actions. Our evaluation in the recent VirtualHome environment shows that the resulting method substantially improves executability over the LLM baseline. The conducted human evaluation reveals a trade-off between executability and correctness but shows a promising sign towards extracting actionable knowledge from language models. Website at https://huangwl18.github.io/language-planner</p>
                <p><strong>Cost:</strong> 0.005</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <p class="empty-note">No extracted data.</p>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <p class="empty-note">No potentially relevant new papers extracted.</p>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-6343",
    "paper_id": "paper-92a8f7f09f3705cb5a6009a42220a6f01ea084e8",
    "extraction_schema_id": "extraction-schema-125",
    "extracted_data": [],
    "potentially_relevant_new_papers": [],
    "cost": 0.00514175,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><h1>Language Models as Zero-Shot Planners: Extracting Actionable Knowledge for Embodied Agents</h1>
<p>Wenlong Huang<br>UC Berkeley</p>
<p>Pieter Abbeel<br>UC Berkeley</p>
<p>Deepak Pathak*<br>Carnegie Mellon University</p>
<p>Igor Mordatch*<br>Google</p>
<h4>Abstract</h4>
<p>Can world knowledge learned by large language models (LLMs) be used to act in interactive environments? In this paper, we investigate the possibility of grounding high-level tasks, expressed in natural language (e.g. "make breakfast"), to a chosen set of actionable steps (e.g. "open fridge"). While prior work focused on learning from explicit step-by-step examples of how to act, we surprisingly find that if pre-trained LMs are large enough and prompted appropriately, they can effectively decompose high-level tasks into mid-level plans without any further training. However, the plans produced naively by LLMs often cannot map precisely to admissible actions. We propose a procedure that conditions on existing demonstrations and semantically translates the plans to admissible actions. Our evaluation in the recent VirtualHome environment shows that the resulting method substantially improves executability over the LLM baseline. The conducted human evaluation reveals a trade-off between executability and correctness but shows a promising sign towards extracting actionable knowledge from language models.</p>
<p><img alt="img-0.jpeg" src="img-0.jpeg" /></p>
<p>Figure 1: Executability v.s. semantic correctness of generated plans (left), sample plans by different models (right), and example environment execution (bottom). Large models can produce action plans indistinguishable from those by humans, but frequently are not executable in the environment. Using our techniques, we can significantly improve executability, albeit at the cost of correctness. More samples can be found in Appendix A.5.</p>
<p><sup id="fnref:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<h1>Contents</h1>
<p>1 Introduction ..... 3
2 Evaluation Framework ..... 4
2.1 Evaluated Environment: VirtualHome ..... 4
2.2 Metrics ..... 5
3 Method ..... 6
3.1 Querying LLMs for Action Plans ..... 6
3.2 Admissible Action Parsing by Semantic Translation ..... 6
3.3 Autoregressive Trajectory Correction ..... 7
3.4 Dynamic Example Selection for Improved Knowledge Extraction ..... 7
4 Results ..... 8
4.1 Do LLMs contain actionable knowledge for high-level tasks? ..... 8
4.2 How executable are the LLM action plans? ..... 9
4.3 Can LLM action plans be made executable by proposed procedure? ..... 9
5 Analysis and Discussions ..... 10
5.1 Ablation of design decisions ..... 10
5.2 Are the generated action plans grounded in the environment? ..... 10
5.3 Effect of Different Translation LMs ..... 11
5.4 Can LLMs generate actionable programs by following step-by-step instructions? ..... 11
5.5 Analysis of program length ..... 12
6 Related Works ..... 12
7 Conclusion, Limitations \&amp; Future Work ..... 13
A Appendix ..... 18
A. 1 Hyperparameter Search ..... 18
A. 2 Details of Human Evaluations ..... 19
A. 3 All Evaluated Tasks ..... 20
A. 4 Natural Language Templates for All Atomic Actions ..... 21
A. 5 Random Samples of Action Plans ..... 22</p>
<h1>1 Introduction</h1>
<p>Large language models (LLMs) have made impressive advances in language generation and understanding in recent years [10, 39, 40, 5]. See [4] for a recent summary of their capabilities and impacts. Being trained on large corpora of human-produced language, these models are thought to contain a lot of information about the world [42, 23, 3] - albeit in linguistic form.</p>
<p>We ask whether we can use such knowledge contained in LLMs not just for linguistic tasks, but to make goal-driven decisions that can be enacted in interactive, embodied environments. But we are not simply interested in whether we can train models on a dataset of demonstrations collected for some specific environment - we are instead interested in whether LLMs already contain information necessary to accomplish goals without any additional training.</p>
<p>More specifically, we ask whether world knowledge about how to perform high-level tasks (such as "make breakfast") can be expanded to a series of groundable actions (such as "open fridge", "grab milk", "close fridge", etc) that can be executed in the environment. For our investigation, we use the recently proposed VirtualHome environment [38]. It can simulate a large variety of realistic human activities in a household environment and supports the ability to perform them via embodied actions defined with a verb-object syntax. However, due to the open-ended nature of the tasks, it is difficult to autonomously evaluate their success. We rely on human evaluation (conducted on Mechanical Turk) to decide whether sequences of actions meaningfully accomplish posed tasks.</p>
<p>We find that large GPT-3 [5] and Codex [7] models, when prompted with a single fixed example of a task description and its associated sequence of actions, can produce very plausible action plans for the task we're interested in. Such completions reflect the information already stored in the model - no model fine-tuning is involved. Additionally, we only observe this effect in the larger models. Unfortunately, despite their semantic correctness, the produced action plans are often not executable in the environment. Produced actions may not map precisely to admissible actions, or may contain various linguistic ambiguities.</p>
<p>We propose several tools to improve executability of the model's outputs. First, we enumerate all admissible actions and map the model's output phrases to the most semantically-similar admissible action (we use similarity measure between sentence embeddings produced by a RoBERTa model [27] in this work, but other choices are possible). Second, we use the model to autoregressively generate actions in a plan by conditioning past actions that have been made admissible via the technique above. Such on-the-fly correction can keep generation anchored to admissible actions. Third, we provide weak supervision to the model by prompting the model with a known task example similar to the query task. This is somewhat reminiscent of prompt tuning approaches but does not require access to gradients or internals of the model.</p>
<p>Using the above tools to bias model generation, we find that we improve executability of action plans from $18 \%$ to $79 \%$ (see Figure 1) without any invasive modifications to model parameters or any extra gradient or internal information beyond what is returned from the model's forward pass. This is advantageous because it does not require any modifications to the model training procedure and can fit within existing model serving pipelines. However, we do find there to be some drop in correctness of the action sequences generated with the above tools (as judged by humans), indicating a promising step, but requiring more research on the topic.</p>
<p>To summarize, our paper's contributions are as follows:</p>
<ul>
<li>We show that without any training, large language models can be prompted to generate plausible goal-driven action plans, but such plans are frequently not executable in interactive environments.</li>
<li>We propose several tools to improve executability of the model generation without invasive probing or modifications to the model.</li>
<li>We conduct a human evaluation of multiple techniques and models and report on the trade-offs between executability and semantic correctness.</li>
</ul>
<p><img alt="img-1.jpeg" src="img-1.jpeg" /></p>
<p>Figure 2: We investigate the possibility of extracting actionable knowledge from pre-trained large language models (LLMs). We first show surprising finding that pre-trained causal LLMs can decompose high-level tasks into sensible mid-level action plans (left). To make the plans executable, we propose to translate each step into admissible action via another pre-trained masked LLM (middle). The translated action is appended to the prompt used for generating the remaining steps (right). All models are kept frozen without additional training.</p>
<h1>2 Evaluation Framework</h1>
<p>Simulating open-ended tasks that resemble naturalistic human activities requires an environment to support a rich set of diverse interactions, rendering most existing embodied environments unsuitable for our investigation. One exception is VirtualHome [38], which we evaluate on as it models complex human activities, though only in a household setting. To measure correctness of the generated action plans, for which evaluating computationally is inherently difficult for these open-ended tasks, we conduct a human evaluation similar to Puig et al. [38]. We note that since no further training is involved throughout our investigations, the observations and findings presented in this paper should also translate to similar embodied environments, likely even beyond the household domain.</p>
<h3>2.1 Evaluated Environment: VirtualHome</h3>
<p>Preliminaries In VirtualHome, activities are expressed as programs. Each program consists of a sequence of textual action steps, where each step is written as: [action] 〈arg〉 (idx). Each action refers to one of the 42 atomic actions supported in VirtualHome, such as "walk" and "open". Full list of atomic actions can be found in Appendix A.4. Different actions take in different numbers of arg, such as "bedroom" and "fridge", that are necessary for specifying an interaction. Associated with each arg is a unique id specifying the corresponding node in the environment graph, in case of multiple instances of the same object class are present in the graph. For the sake of simplicity, we omit the id in the remaining discussions of this paper and allow automatic assignment by the environment. An example program is shown below for the task "Relax on sofa":</p>
<div class="codehilite"><pre><span></span><code>[WALK] 〈living_room〉(1)
[WALK] 〈television〉(1)
[FIND] 〈television〉(1)
[SWITCHON] 〈television〉(1)
[FIND] 〈sofa〉(1)
[SIT] 〈sofa〉(1)
[TURNTO] 〈television〉(1)
[WATCH] 〈television〉(1)
</code></pre></div>

<p>Evaluated Tasks We use the ActivityPrograms knowledge base collected by Puig et al. [38] for evaluation. It contains 2821 different entries annotated by Amazon Mechanical Turk (MTurk) workers. Each entry contains 1) a high-level task name (e.g. "Watch TV"), 2) detailed instructions expressed in natural language to complete the task (e.g. "Sit on my couch directly opposite my TV, switch on my TV with the remote control and watch"), and 3) an executable program containing all necessary steps for a robotic agent (example above). We omit the use of detailed instructions (2) as we desire direct extraction of executable programs (3) from only high-level task names (1). There are 292 distinct high-level tasks in the knowledge base, from which we randomly sample 88 held-out tasks for evaluation. The remaining 204 tasks are used as demonstration set from which we are allowed</p>
<div class="codehilite"><pre><span></span><code>Algorithm 1: Generating Action Plans from Pre-Trained Language Models
    Notation Summary:
    \(L M_{P}\) : text completion language model (also referred as Planning LM)
    \(L M_{T}\) : text embedding language model (also referred as Translation LM)
    \(\left\{\left(T_{i}, E_{i}\right)\right\}_{i=1}^{N}\) : demonstration set, where \(T\) is task name and \(E\) is example plan for \(T\)
    \(C\) : cosine similarity function
    \(P\) : mean token log probability under \(L M_{P}\)
    Input: query task name \(Q\), e.g. &quot;make breakfast&quot;
    Output: action plan consisting of admissible env actions, e.g. &quot;open fridge&quot;
    Extract most similar example \(\left(T^{*}, E^{*}\right)\) whose \(T^{*}\) maximizes \(C\left(L M_{T}(T), L M_{T}(Q)\right)\)
    Initialize prompt with \(\left(T^{*}+E^{*}+Q\right)\)
    while max step is not reached do
        Sample \(L M_{P}\) with current prompt to obtain \(k\) single-step action phrases
        for each sample \(\hat{a}\) and each admissible env action \(a_{e}\) do
            Calculate ranking score by \(C\left(L M_{T}(\hat{a}), L M_{T}\left(a_{e}\right)\right)+\beta \cdot P(\hat{a})\)
        end for
        Append highest-scoring env action \(a_{e}^{*}\) to prompt
        Append \(a_{e}^{*}\) to output
        if \(&gt;50 \%\) samples are 0 -length or highest score \(&lt;\epsilon\) then
            break
            end if
    end while
</code></pre></div>

<p>to select as example(s) for prompting language models, or in the case of supervised fine-tuning baselines, they are used to fine-tune pre-trained language models.</p>
<h1>2.2 Metrics</h1>
<p>A program that commands the agent to wander around in a household environment is highly executable but is mostly not correct. On the other hand, a program composed of natural language instructions annotated by humans is likely correct but cannot be executed, because its format is ambiguous and may lack necessary common-sense actions (e.g. fridge must be opened before an agent can grab things from it). We thus consider two axes for evaluation: executability and correctness.</p>
<p>Executability Executability measures whether an action plan can be correctly parsed and satisfies the common-sense constraints of the environment. To be correctly parsed, an action plan must be syntactically correct and contain only allowed actions and recognizable objects. To satisfy the common-sense constraints, each action step must not violate the set of its pre-conditions (e.g. the agent cannot grab milk from the fridge before opening it) and post-conditions (e.g. the state of the fridge changes from "closed" to "open" after the agent opens it). We report the average executability across all 88 tasks and all 7 VirtualHome scenes.</p>
<p>Correctness Unlike most embodied environments where the completion of a task can be easily judged, the ambiguous and multimodal nature of natural language task specification makes it impractical to obtain a gold-standard measurement of correctness ${ }^{1}$. Therefore, we conduct human evaluations for the main methods. For the remaining analysis, we rely on a match-based metric that measures how similar a generated program is to human annotations. Specifically, we follow Puig et al. [38] and calculate the longest common subsequence (LCS) between two programs, normalized by the maximum length of the two. In the presence of multiple human-written programs for a single task, we take the maximum LCS across them. However, we note that the majority of the tasks only have one human annotation, but there are often many plausible ways to complete a certain task, making</p>
<p><sup id="fnref2:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>this metric imperfect at evaluation program correctness ${ }^{2}$. Although correlation between the two is shown by Puig et al. [38], we consider it only as a proxy metric in replacement of unscalable human evaluation.</p>
<h1>3 Method</h1>
<p>In this section, we investigate the possibility of extracting actionable knowledge from pre-trained language models without further training. We first give an overview of the common approach to query large language models (LLMs) and how it may be used for embodied agents in Section 3.1. Then we describe an inference-time procedure that addresses several deficiencies of the LLM baseline and offers better executability in embodied environments. We break down the proposed procedure into three individual components, each discussed in Section 3.2, 3.3, 3.4. Pseudo-code is in Algorithm 1.</p>
<p>Since LMs excel at dealing with natural language text instead of the specific format required by VirtualHome as described in Section 2.1, we only expose natural language text to LMs. To do this, we define a bi-directional mapping for each atomic action that converts between the natural language format and the program format. For instance, "walk to living room" is mapped to [WALK] 〈living_room〉 (1). Full list of the mappings is in Appendix A.4.</p>
<h3>3.1 Querying LLMs for Action Plans</h3>
<p>Previous works have shown that large language models pre-trained on a colossal amount of data would internalize rich world knowledge that can be probed to perform various downstream tasks [39, 5]. Notably, autoregressive LLMs can even perform in-context learning, an ability to solve tasks using only contextual information without gradient updates [5]. Contextual information is given as part of the input prompt and LMs are asked to complete the remaining text. It often consists of natural language instructions and/or a number of examples containing the desired input/output pairs.
We adopt the same approach to query LLMs to generate action plans for high-level tasks. Specifically, we prepend one example high-level task and its annotated action plan from the demonstration set to the query task, as shown in Figure 2. To obtain text completion results, we sample from autoregressive LLM using temperature sampling and nucleus sampling [18]. We refer to this LM as Planning LM and the approach using this LM for plan generation as Vanilla $\langle\mathbf{L M}\rangle$, where $\langle\mathbf{L M}\rangle$ is replaced by specific language model such as GPT-3.
To improve the generation quality, we follow Chen et al. [7] to sample multiple outputs for each query. However, unlike Chen et al. [7] who investigate program synthesis and can choose the sample with highest unit test pass rate, we only consider the setting where one sample is allowed to be evaluated for each task. This is because repetitive trial-and-error is equivalent to probing the environment for privileged information, which should not be considered viable in our setting. For Vanilla $\langle$ LM $\rangle$, to choose the best action plan $X^{*}$ among $k$ samples $\left(X_{1}, X_{2}, \ldots, X_{k}\right)$, each consisting of $n_{i}$ tokens $X_{i}=\left(x_{i, 1}, x_{i, 2}, \ldots, x_{i, n_{i}}\right)$, we select the sample with highest mean log probability as follows:</p>
<p>$$
\underset{X_{i}}{\operatorname{argmax}}\left(P_{\theta}\left(X_{i}\right):=\frac{1}{n_{i}} \sum_{j=1}^{n_{i}} \log p_{\theta}\left(x_{i, j} \mid x_{i,&lt;j}\right)\right) \text { where } \theta \text { parameterizes the Planning LM. }
$$</p>
<h3>3.2 Admissible Action Parsing by Semantic Translation</h3>
<p>One issue arises when naively following the above approach to generate action plans: the plan expressed in free-form language often cannot be mapped to unambiguous actionable steps and thus is not executable by a robotic agent. Many reasons can cause such failures: 1) the output does not follow pre-defined mappings of any atomic action (e.g. "I first walk to the bedroom" is not of the format "walk to $\langle$ PLACE $\rangle$ "), 2) the output may refer to atomic action and objects using words unrecognizable by the environment (e.g. "microwave the chocolate milk" where "microwave" and "chocolate milk" cannot be mapped to precise action and object), or 3) the output contains lexically ambiguous words (e.g. "open TV" should instead be "switch on TV").</p>
<p><sup id="fnref3:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p>Instead of developing a set of rules to transform the free-form text into admissible action steps, we propose to again leverage world knowledge learned by language models to semantically translate the action. For each admissible environment action $a_{e}$, we calculate its semantic distance to the predicted action phrase $\hat{a}$ by cosine similarity:</p>
<p>$$
C\left(f(\hat{a}), f\left(a_{e}\right)\right):=\frac{f(\hat{a}) \cdot f\left(a_{e}\right)}{|f(\hat{a})|\left|f\left(a_{e}\right)\right|} \text { where } f \text { is an embedding function. }
$$</p>
<p>To embed the output action phrase and environment actions, we use a BERT-style LM [10, 27] pre-trained with Sentence-BERT [41] objective, to which we refer as Translation LM ${ }^{1}$. The action embedding is obtained by mean-pooling the last layer hidden states across all tokens in that action phrase. While the set of admissible actions in our environment is discrete and possible to exhaustively enumerate, sampling or projection can be employed in larger discrete or continuous action spaces.</p>
<h1>3.3 Autoregressive Trajectory Correction</h1>
<p>Translating each step of the program after the entire program has been synthesized lacks consideration of achievability of individual steps and subjects to compounding errors. In practice, LLMs might output compounded instructions for a single step, even though it cannot be completed using one admissible action in the environment. To this end, we can instead interleave plan generation and action translation to allow for automatic trajectory correction. At each step, we first query Planning LM to generate $k$ samples for a single action $\left(\vec{a}<em 2="2">{1}, \vec{a}</em>}, \ldots, \vec{a<em e="e">{k}\right)$. For each sample $\hat{a}$, we consider both its semantic soundness and its achievability in the environment. Specifically, we aim to find admissible environment action $a</em>$ by modifying the ranking scheme described in Equation 1 as follows:</p>
<p>$$
\underset{a_{e}}{\operatorname{argmax}}\left[\max <em e="e">{\hat{a}} C\left(f(\hat{a}), f\left(a</em>
$$}\right)\right)+\beta \cdot P_{\theta}(\hat{a})\right] \text { where } \beta \text { is a weighting coefficient. </p>
<p>Then we append the translated environment action $a_{e}$ to the unfinished text completion. This way all subsequent steps will be conditioned on admissible actions instead of free-form action phrases generated by Planning LM. Furthermore, we can use Translation LM to detect out-of-distribution actions, those outside the capabilities of a robot, and terminate a program early instead of mapping to a faulty action. This can be achieved by setting a threshold $\epsilon$ such that if $\max <em e="e">{\hat{a}, a</em>)&lt;\epsilon$ at step $t$, the program is terminated early. Since we now sample Planning LM for individual steps instead of an entire sequence, another termination condition we consider is when $&gt;50 \%$ of current-step samples are 0 -length (excluding leading or trailing non-English text tokens).}} C\left(f(\hat{a}), f\left(a_{e}\right)\right)+$ $\beta \cdot P_{\theta}(\hat{a</p>
<h3>3.4 Dynamic Example Selection for Improved Knowledge Extraction</h3>
<p>So far in the text, we always give the same example in the prompt for all query tasks. However, consider the task of "ordering pizza". Prompting LLMs with this task may give the assumption that the agent is initialized in front of a computer, and the LLMs may guide the agent to search for a pizza store and click "checkout my cart". Although these are reasonable and feasible in the real world, such assumption cannot always be made as these interactions may not be supported in simulated environments. In fact, the closest series of actions that human experts give in VirtualHome may be "walking to a computer", "switching on the computer", and "typing the keyboard". Without being fine-tuned on these data, LLMs would often fail at these tasks.
To provide weak supervision at inference time, we propose to select the most similar task $T$ and its example plan $E$ from the demonstration set to be used as the example in the prompt. Specifically, we re-use the same Translation LM introduced in Section 3.2 and select $\left(T^{<em>}, E^{</em>}\right)$ whose high-level task name $T^{*}$ maximizes $C(f(T), f(Q))$, where $Q$ is the query task. This approach bears resemblance to several recent works [37, 13, 26, 43]. An example is shown in Figure 2 where "Shave" is the most similar to the query task "Apply lotion".</p>
<p>Final Method Combining the various improvement discussed above, we refer to the final method as Translated $\langle\mathbf{L M}\rangle$, where $\langle\mathbf{L M}\rangle$ is replaced by specific language model used such as GPT-3.</p>
<p><sup id="fnref4:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<p><img alt="img-2.jpeg" src="img-2.jpeg" /></p>
<p>Figure 3: Visualization of VirtualHome programs generated by our approach. The top row shows the execution of the task "Complete Amazon Turk Surveys", and the bottom row shows the task "Get Glass of Milk". We show LLMs not only can generate sensible action plans given only high-level tasks but also contains the actionable knowledge that can be extracted for grounding in embodied environments.</p>
<h1>4 Results</h1>
<p>In this section, we first show that language models can generate sensible action plans for many high-level tasks, even without any additional training. Then we highlight its inadequacy when naively applied to embodied environments and demonstrate how this can be improved by again leveraging world knowledge learned by LLMs. Visualization of generated programs is shown in Figure 3.</p>
<p>Sampling from LMs Pre-trained LMs are sensitive to sampling parameters and the specific example given in the prompt. For all evaluated methods, we perform hyperparameter search over various sampling parameters, and for methods using a fixed prompt example, we report metrics averaged across three randomly chosen examples. To select the best run for each method, we rank the runs by the sum of LCS and executability, each normalized by human-expert scores. Further details are in Appendix A.1.</p>
<p>Model Choices For Planning LM, we evaluate a representative set of causal language models. For Translation LM, we mainly use Sentence-RoBERTa-355M and provide relevant ablations in Section 5.3. GPT-3 and Codex are accessed using OpenAI API, and the remaining models are accessed through open-source packages, Hugging Face Transformers [55] and SentenceTransformers [41], all without additional training (except for the fine-tuning baseline).</p>
<h3>4.1 Do LLMs contain actionable knowledge for high-level tasks?</h3>
<p>We first investigate whether LLMs can generate sensible action plans expressed in free-form language. We use the approach described in Section 3.1 to query pre-trained LLMs. To evaluate the correctness of generated action plans, we conduct human evaluations. For each model, we ask 10 human annotators to determine - by answering "Yes" or "No" - whether each task can be completed using provided action steps. To provide a reference of how humans might rate the action plans provided by other humans, we also ask annotators to rate the human-written action plans included in the VirtualHome dataset for the same set of tasks. In contrast to the free-form text output by LLMs, humans wrote the plans using a graphical programming interface that enforces strict syntax and a chosen set of atomic action vocabulary, which limit the expressivity and the completeness of their answers ${ }^{4}$. More details of our human evaluation procedure can be found in Appendix A.2.</p>
<p>We show the human evaluation results in Figure 1, where the y-axis shows correctness averaged across all tasks and all annotators. Surprisingly, when LLMs are large enough and without imposed syntactic constraints, they can generate highly realistic action plans whose correctness - as deemed by human annotators - even surpasses human-written action plans. We also observe some level of correctness for smaller models such as GPT-2. However, inspection of its produced output indicates</p>
<p><sup id="fnref5:0"><a class="footnote-ref" href="#fn:0">1</a></sup></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Language Model</th>
<th style="text-align: left;">Executability</th>
<th style="text-align: left;">LCS</th>
<th style="text-align: left;">Correctness</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Vanilla GPT-2 117M</td>
<td style="text-align: left;">$18.66 \%$</td>
<td style="text-align: left;">$3.19 \%$</td>
<td style="text-align: left;">$15.81 \%(4.90 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla GPT-2 1.5B</td>
<td style="text-align: left;">$39.40 \%$</td>
<td style="text-align: left;">$7.78 \%$</td>
<td style="text-align: left;">$29.25 \%(5.28 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla Codex 2.5B</td>
<td style="text-align: left;">$17.62 \%$</td>
<td style="text-align: left;">$15.57 \%$</td>
<td style="text-align: left;">$63.08 \%(7.12 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla GPT-Neo 2.7B</td>
<td style="text-align: left;">$29.92 \%$</td>
<td style="text-align: left;">$11.52 \%$</td>
<td style="text-align: left;">$65.29 \%(9.08 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla Codex 12B</td>
<td style="text-align: left;">$18.07 \%$</td>
<td style="text-align: left;">$16.97 \%$</td>
<td style="text-align: left;">$64.87 \%(5.41 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla GPT-3 13B</td>
<td style="text-align: left;">$25.87 \%$</td>
<td style="text-align: left;">$13.40 \%$</td>
<td style="text-align: left;">$49.44 \%(8.14 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla GPT-3 175B</td>
<td style="text-align: left;">$7.79 \%$</td>
<td style="text-align: left;">$17.82 \%$</td>
<td style="text-align: left;">$77.86 \%(6.42 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: left;">$100.00 \%$</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;">$70.05 \%(5.44 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Fine-tuned GPT-3 13B</td>
<td style="text-align: left;">$66.07 \%$</td>
<td style="text-align: left;">$34.08 \%$</td>
<td style="text-align: left;">$64.92 \%(5.96 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Our Final Methods</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Translated Codex 12B</td>
<td style="text-align: left;">$78.57 \%$</td>
<td style="text-align: left;">$24.72 \%$</td>
<td style="text-align: left;">$54.88 \%(5.90 \%)$</td>
</tr>
<tr>
<td style="text-align: left;">Translated GPT-3 175B</td>
<td style="text-align: left;">$73.05 \%$</td>
<td style="text-align: left;">$24.09 \%$</td>
<td style="text-align: left;">$66.13 \%(8.38 \%)$</td>
</tr>
</tbody>
</table>
<p>Table 1: Human-evaluated correctness and evaluation results in VirtualHome. Although action plans generated by large language models can match or even surpass human-written plans in correctness measure, they are rarely executable. By translating the naive action plans, we show an important step towards grounding LLMs in embodied environments, but we observe room to achieve this without trading executability for correctness. We also observe a failure mode among smaller models that lead to high executability. For correctness measure, standard error of the mean across 10 human annotators is reported in the parenthesis.
that it often generates shorter plans by ignoring common-sense actions or by simply rephrasing the given task (e.g. the task "Go to sleep" produces only a single step "Go to bed"). These failure modes sometimes mislead human annotators to mark them correct as the annotators may ignore common-sense actions in their judgment as well, resulting in a higher correctness rate than the quality of the output shows.</p>
<h1>4.2 How executable are the LLM action plans?</h1>
<p>We analyze the executability of LLM plans by evaluating them in all 7 household scenes in VirtualHome. As shown in Table 1, we find action plans generated naively by LLMs are generally not very executable. Although smaller models seem to have higher executability, we find that the majority of these executable plans are produced by ignoring the queried task and repeating the given example of a different task. This is validated by the fact that smaller models have lower LCS than larger models despite having high executability, showing that this failure mode is prevalent among smaller models. In contrast, larger models do not suffer severely from this failure mode. Yet as a result of being more expressive, their generated programs are substantially less executable.</p>
<h3>4.3 Can LLM action plans be made executable by proposed procedure?</h3>
<p>We evaluate the effectiveness of our proposed procedure of action translation. We first create a bank of all allowed 47522 action steps in the environment, including all possible combinations of atomic actions and allowed arguments/objects. Then we use an off-the-shelf Sentence-RoBERTa [27, 41] as Translation LM to create embeddings for actions and output text. For better computational efficiency, we pre-compute the embeddings for all allowed actions, leaving minor computation overhead for our procedure over the baseline methods at inference time. As shown in Table 1, executability of generated programs is significantly improved. Furthermore, we also observe improved LCS because the translated action steps precisely follow the program syntax and thus are more similar to the plans produced by human experts. Sample output is shown in Figure 1 and a larger random subset of generated samples can be found in Appendix A.5.
To validate their correctness, we again perform human evaluations using the same procedure from Section 4.1 Results are shown in Table 1. We find that despite being more similar to human-written plans as they follow strict syntax, the programs are deemed less correct by humans compared to their vanilla counterparts. By examining the output, we observe two main sources of errors. First, we find Translation LM is poor at mapping compounded instructions to a succinct admissible action, e.g. "brush teeth with toothbrush and toothpaste". Second, we find that the generated programs are sometimes terminated too early. This is partly due to the imperfect expressivity of the environment;</p>
<p>certain necessary actions or objects are not implemented to fully achieve some tasks, so Translation LM cannot map to a sufficiently similar action. This is also reflected by our human evaluation results of the programs written by other humans, as only $70 \%$ of the programs are considered complete.</p>
<h1>5 Analysis and Discussions</h1>
<h3>5.1 Ablation of design decisions</h3>
<p>We perform ablation studies for the three components of our proposed procedure, described in Section 3.2, 3.3, and 3.4 respectively. As shown in Table 2, leaving out any of the three components would all lead to decreased performance in both executability and LCS. An exception is Translated GPT-3 w/o Trajectory Correction, where we observe a slight improvement in LCS at the expense of a considerable drop in executability. Among the three proposed components, leaving out action translation leads to the most significant executability drop, showing the importance of action translation in extracting executable action plans from LLMs.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Methods</th>
<th style="text-align: left;">Executability</th>
<th style="text-align: left;">LCS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Translated Codex 12B</td>
<td style="text-align: left;">$\mathbf{7 8 . 5 7 \%}$</td>
<td style="text-align: left;">$\mathbf{2 4 . 7 2 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">- w/o Action Translation</td>
<td style="text-align: left;">$31.49 \%$</td>
<td style="text-align: left;">$22.53 \%$</td>
</tr>
<tr>
<td style="text-align: left;">- w/o Dynamic Example</td>
<td style="text-align: left;">$50.86 \%$</td>
<td style="text-align: left;">$22.84 \%$</td>
</tr>
<tr>
<td style="text-align: left;">- w/o Trajectory Correction</td>
<td style="text-align: left;">$55.19 \%$</td>
<td style="text-align: left;">$24.43 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Translated GPT-3 175B</td>
<td style="text-align: left;">$\mathbf{7 3 . 0 5 \%}$</td>
<td style="text-align: left;">$24.09 \%$</td>
</tr>
<tr>
<td style="text-align: left;">- w/o Action Translation</td>
<td style="text-align: left;">$36.04 \%$</td>
<td style="text-align: left;">$24.31 \%$</td>
</tr>
<tr>
<td style="text-align: left;">- w/o Dynamic Example</td>
<td style="text-align: left;">$60.82 \%$</td>
<td style="text-align: left;">$22.92 \%$</td>
</tr>
<tr>
<td style="text-align: left;">- w/o Trajectory Correction</td>
<td style="text-align: left;">$40.10 \%$</td>
<td style="text-align: left;">$\mathbf{2 4 . 9 8 \%}$</td>
</tr>
</tbody>
</table>
<p>Table 2: Ablation of three proposed techniques.</p>
<h3>5.2 Are the generated action plans grounded in the environment?</h3>
<p>Since successful execution of correct action plans directly measures grounding, we calculate the percentage of generated action plans that are both correct and executable. We deem an action plan to be correct if $70 \%$ or more human annotators decide it is correct. Human-written plans are $100 \%$ executable, of which $65.91 \%$ are deemed correct. Results for LMs are shown in Figure 4.</p>
<p>Although smaller LMs such as GPT-2 can generate highly executable action plans as shown in Table 1, these executable plans mostly are not correct, as they often repeat the given example or do not contain all necessary steps. Increasing model parameters can lead to some improvement in generating plans that are both executable and correct, yet it scales poorly with the parameter count. In the meantime, action translation offers a promising way towards grounding actionable knowledge by producing executable and correct plans, though a large gap remains to be closed to reach human-level performance $(65.91 \%)$.
<img alt="img-3.jpeg" src="img-3.jpeg" /></p>
<p>Figure 4: Percentage of both executable and correct action plans generated by LMs.</p>
<h1>5.3 Effect of Different Translation LMs</h1>
<p>In this section, we study the effect of using different Translation LM. We compare two size variants of Sentence BERT and Sentence RoBERTa [10, 27, 41] trained on the STS benchmark [6] and a baseline using averaged GloVe embeddings [35]. Results are shown in Table 3. Notably, we do not observe significant differences in executability and LCS across different variants of BERT and RoBERTa. We hypothesize that this is because any language models trained on reasonably large datasets should be capable of the single-step action phrase translation considered in this work. However, simply using average GloVe embeddings would lead to significantly reduced performance.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Translation LM</th>
<th style="text-align: left;">Parameter Count</th>
<th style="text-align: center;">Executability</th>
<th style="text-align: center;">LCS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">CODEX 12B as Planning LM</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Avg. GloVe embeddings</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">$46.92 \%$</td>
<td style="text-align: center;">$9.71 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence Bert (base)</td>
<td style="text-align: left;">110 M</td>
<td style="text-align: center;">$73.21 \%$</td>
<td style="text-align: center;">$24.10 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence Bert (large)</td>
<td style="text-align: left;">340 M</td>
<td style="text-align: center;">$75.16 \%$</td>
<td style="text-align: center;">$20.79 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence RoBERTa (base)</td>
<td style="text-align: left;">125 M</td>
<td style="text-align: center;">$74.35 \%$</td>
<td style="text-align: center;">$22.82 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence RoBERTa (large)</td>
<td style="text-align: left;">325 M</td>
<td style="text-align: center;">$\mathbf{7 8 . 5 7 \%}$</td>
<td style="text-align: center;">$\mathbf{2 4 . 7 2 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">GPT-3 175B as Planning LM</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">Avg. GloVe embeddings</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">$47.40 \%$</td>
<td style="text-align: center;">$12.16 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence Bert (base)</td>
<td style="text-align: left;">110 M</td>
<td style="text-align: center;">$\mathbf{7 7 . 6 0 \%}$</td>
<td style="text-align: center;">$\mathbf{2 4 . 4 9 \%}$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence Bert (large)</td>
<td style="text-align: left;">340 M</td>
<td style="text-align: center;">$67.86 \%$</td>
<td style="text-align: center;">$21.24 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence RoBERTa (base)</td>
<td style="text-align: left;">125 M</td>
<td style="text-align: center;">$72.73 \%$</td>
<td style="text-align: center;">$23.64 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Sentence RoBERTa (large)</td>
<td style="text-align: left;">325 M</td>
<td style="text-align: center;">$73.05 \%$</td>
<td style="text-align: center;">$24.09 \%$</td>
</tr>
</tbody>
</table>
<p>Table 3: Effect of different Translation LMs on executability and LCS.</p>
<h3>5.4 Can LLMs generate actionable programs by following step-by-step instructions?</h3>
<p>Prior works often focus on translating step-by-step instructions into executable programs. Specifically, instead of only providing a high-level task name, how-to instructions are also provided, as shown in Figure 5. Although this setting is easier as it does not require rich prior knowledge, how-to instructions can help resolve much ambiguity of exactly how to perform a high-level task when multiple solutions are possible. To investigate whether pre-trained LLMs are capable of doing this without additional training, we include these instructions in the prompt and evaluate LLMs with the proposed procedure. We compare to a supervised baseline from VirtualHome that trains an LSTM [17] from scratch on human-annotated data. Since the code to train the baseline is not publicly released and a different train/test split is likely used, we only show results reported in Puig et al. [38] as a crude reference. We also cannot compare executability as it is not reported. Results are shown in Table 4. Surprisingly, without being fine-tuned on any domain data, Translated Codex/GPT-3 can attain LCS close to supervised methods while generating highly executable programs.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Task: Read book</th>
<th style="text-align: left;">Step 8: Sit on chair</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Description: Walk to home office,</td>
<td style="text-align: left;">Step 9: Read novel</td>
</tr>
<tr>
<td style="text-align: left;">turn on light, grab a book, sit in</td>
<td style="text-align: left;">Task: Find dictionary</td>
</tr>
<tr>
<td style="text-align: left;">chair, start to read the book.</td>
<td style="text-align: left;">Description: Move towards the</td>
</tr>
<tr>
<td style="text-align: left;">Step 1: Walk to home office</td>
<td style="text-align: left;">bookshelf, scan the bookshelf for</td>
</tr>
<tr>
<td style="text-align: left;">Step 2: Walk to light</td>
<td style="text-align: left;">the dictionary, when the</td>
</tr>
<tr>
<td style="text-align: left;">Step 3: Find light</td>
<td style="text-align: left;">dictionary is found, pick up the</td>
</tr>
<tr>
<td style="text-align: left;">Step 4: Switch on light</td>
<td style="text-align: left;">dictionary.</td>
</tr>
<tr>
<td style="text-align: left;">Step 5: Find novel</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Step 6: Grab novel</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Step 7: Find chair</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Figure 5: An example prompt containing step-bystep instructions.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Methods</th>
<th style="text-align: left;">Executability</th>
<th style="text-align: center;">LCS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Translated Codex 12B</td>
<td style="text-align: left;">$78.57 \%$</td>
<td style="text-align: center;">$32.87 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Translated GPT-3 175B</td>
<td style="text-align: left;">$74.15 \%$</td>
<td style="text-align: center;">$31.05 \%$</td>
</tr>
<tr>
<td style="text-align: left;">Supervised LSTM</td>
<td style="text-align: left;">-</td>
<td style="text-align: center;">$34.00 \%$</td>
</tr>
</tbody>
</table>
<p>Table 4: Executability and LCS when conditioned on step-by-step instructions.</p>
<h1>5.5 Analysis of program length</h1>
<p>Shorter programs have a natural advantage of being more executable as they need to satisfy less pre/post-conditions, albeit being prone to incompleteness. To validate the proposed approach does not simply generate very short programs, we calculate the average program length across the 88 evaluated tasks. Results are shown in Table 5. Mirroring the observations made in Section 4.1 and Section 4.2, we find smaller LMs such as GPT-2 tend to generate shorter programs than larger models do while frequently repeating the given executable example. In contrast, larger models like Codex and GPT-3 can generate more expressive programs with high realism, yet consequently, they often suffer from executability. We show proposed procedure can find appropriate balance and is capable of generating programs that are highly executable while maintaining reasonable expressiveness as measured by program length.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Methods</th>
<th style="text-align: center;">Executability</th>
<th style="text-align: center;">Average Length</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Vanilla GPT-2 1.5B</td>
<td style="text-align: center;">$39.40 \%$</td>
<td style="text-align: center;">4.24</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla Codex 12B</td>
<td style="text-align: center;">$18.07 \%$</td>
<td style="text-align: center;">7.22</td>
</tr>
<tr>
<td style="text-align: left;">Vanilla GPT-3 175B</td>
<td style="text-align: center;">$7.79 \%$</td>
<td style="text-align: center;">9.716</td>
</tr>
<tr>
<td style="text-align: left;">Translated Codex 12B</td>
<td style="text-align: center;">$78.57 \%$</td>
<td style="text-align: center;">7.13</td>
</tr>
<tr>
<td style="text-align: left;">Translated GPT-3 175B</td>
<td style="text-align: center;">$73.05 \%$</td>
<td style="text-align: center;">7.36</td>
</tr>
<tr>
<td style="text-align: left;">Human</td>
<td style="text-align: center;">$100.00 \%$</td>
<td style="text-align: center;">9.66</td>
</tr>
</tbody>
</table>
<p>Table 5: Average executability \&amp; program length of different methods.</p>
<h2>6 Related Works</h2>
<p>Large-scale natural language modeling has witnessed rapid advances since the inception of the Transformer architecture [53]. It has been shown by recent works that large language models (LLMs) pre-trained on large unstructured text corpus not only can perform strongly on various down-stream NLP tasks [10, 39, 40, 5] but the learned representations can also be used to model relations of entities [23], retrieve matching visual features [19], synthesize code from docstrings [15, 7], solve math problems [8, 46], and even as valuable priors when applied to diverse tasks from different modalities [28, 52]. Notably, by pre-training on large-scale data, these models can also internalize an implicit knowledge base containing rich information about the world from which factual answers (e.g. "Dante was born in $\langle$ PLACE $\rangle$ ") can be extracted [36, 21, 9, 50, 42]. Compared to prior works in single-step knowledge extraction, we aim to extract sequential action plans to complete open-ended human activities while satisfying various constraints of an interactive environment.</p>
<p>Many prior works have looked into grounding natural language in embodied environments. A series of them parse language instructions into formal logic or rely mainly on lexical analysis to resolve various linguistic ambiguities for embodied agents [2, 33, 34, 51]. However, they often require many hand-designed rules or scale inadequately to more complex tasks and environments. Recently, many efforts have been put into creating more realistic environments with the goal to further advances in this area [38, 47, 48, 22, 44, 1]. At the same time, by leveraging the better representation power of neural architectures, a number of works have looked into creating instruction-following agents that can perform manipulation [29, 30], navigation [11, 54, 31], or both [49, 16, 12]. Recent works also use language as hierarchical abstractions to plan actions using imitation learning [45] and to guide exploration in reinforcement learning [32].
Notably, many prior works do not leverage full-blown pre-trained LLMs; most investigate smaller LMs that require considerable domain-specific data for fine-tuning to obtain reasonable performance. Perhaps more importantly, few works have evaluated LLMs in an embodiment setting that realizes the full potential of the actionable knowledge these models already contain by pre-training on large-scale unstructured text: the tasks evaluated are often generated from a handful of templates, which do not resemble the highly diverse activities that humans perform in daily lives [14, 20]. The development of VirtualHome environment [38] enables such possibility. However, relevant works [38, 25] rely on human-annotated data and perform supervised training from scratch. Due to the lack of rich world knowledge, these models can only generate action plans given detailed instructions of how to act or video demonstrations. Concurrent work by Li et al. [24] validates similar hypothesis that</p>
<p>LMs contain rich actionable knowledge. They fine-tune GPT-2 with demonstrations to incorporate environment context and to predict actions in VirtualHome, and evaluate on tasks that are generated from pre-defined predicates. In contrast, we investigate existing knowledge in LLMs without any additional training and evaluate on human activity tasks expressed in free-form language.</p>
<h1>7 Conclusion, Limitations \&amp; Future Work</h1>
<p>In this work, we investigate actionable knowledge already contained in pre-trained LLMs without any additional training. We present several techniques to extract this knowledge to perform common-sense grounding by planning actions for complex human activities.</p>
<p>Despite promising findings, there remain several limitations of this work which we discuss as follows:
Drop in Correctness Although our approach can significantly improve executability of the generated plans, we observe a considerable drop in correctness. In addition to the errors caused by the proposed action translation (discussed in Section 4.3), this is partially attributed to the limited expressivity of VirtualHome, as it may not support all necessary actions to fully complete all evaluated tasks (correctness is judged by humans). This is also reflected by that Vanilla LMs can even surpass human-written plans, which are restricted by environment expressivity.</p>
<p>Mid-Level Grounding Instead of grounding the LLM generation to low-level actions by using downstream data from a specific environment, we focus on high-level to mid-level grounding such that we evaluate raw knowledge of LLMs as closely and broadly as possible. Hence, we only consider the most prominent challenge in mid-level grounding that the generated plans must satisfy all common-sense constraints (characterized by executability metric). As a result, we assume there is a low-level controller that can execute these mid-level actions (such as "grab cup"), and we do not investigate the usefulness of LLMs for low-level sensorimotor behavior grounding. To perform sensorimotor grounding, such as navigation and interaction mask prediction, domain-specific data and fine-tuning are likely required.</p>
<p>Ignorant of Environment Context We do not incorporate observation context or feedback into our models. To some extent, we approach LLMs in the same way as how VirtualHome asks human annotators to write action plans for a given human activity by imagination, in which case humans similarly do not observe environment context. Similar to human-written plans, we assume the plans generated by LMs only refer to one instance of each object class. As a result, successful plan generation for tasks like "stack two plates on the right side of a cup" is not possible.</p>
<p>Evaluation Protocol We measure quality of plans by a combination of executability and correctness instead of one straightforward metric. To the best of our knowledge, there isn't a known way to computationally assess the semantic correctness of the plans due to the tasks' open-ended and multi-modal nature. Prior work also adopt similar combination of metrics [38]. We report two metrics individually to shine light on the deficiencies of existing LLMs which we hope could provide insights for future works. To provide a holistic view, we report results by combining two metrics in Section 5.2.</p>
<p>We believe addressing each of these shortcoming will lead to exciting future directions. We also hope these findings can inspire future investigations into using pre-trained LMs for goal-driven decision-making problems and grounding the learned knowledge in embodied environments.</p>
<h2>Acknowledgment</h2>
<p>We would like to thank OpenAI for providing academic access to the OpenAI API and Luke Metz for valuable feedback and discussions. This work was supported in part by Berkeley Deep Drive, NSF IIS-2024594, and GoodAI Research Award.</p>
<h1>References</h1>
<p>[1] Peter Anderson, Qi Wu, Damien Teney, Jake Bruce, Mark Johnson, Niko Sünderhauf, Ian Reid, Stephen Gould, and Anton Van Den Hengel. Vision-and-language navigation: Interpreting visually-grounded navigation instructions in real environments. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 3674-3683, 2018.
[2] Yoav Artzi and Luke Zettlemoyer. Weakly supervised learning of semantic parsers for mapping instructions to actions. Transactions of the Association for Computational Linguistics, 1:49-62, 2013.
[3] BIG-bench collaboration. Beyond the imitation game: Measuring and extrapolating the capabilities of language models. In preparation, 2021. URL https://github.com/google/ BIG-bench/.
[4] Rishi Bommasani, Drew A. Hudson, Ehsan Adeli, Russ Altman, Simran Arora, Sydney von Arx, Michael S. Bernstein, Jeannette Bohg, Antoine Bosselut, Emma Brunskill, Erik Brynjolfsson, Shyamal Buch, Dallas Card, Rodrigo Castellon, Niladri Chatterji, Annie Chen, Kathleen Creel, Jared Quincy Davis, Dora Demszky, Chris Donahue, Moussa Doumbouya, Esin Durmus, Stefano Ermon, John Etchemendy, Kawin Ethayarajh, Li Fei-Fei, Chelsea Finn, Trevor Gale, Lauren Gillespie, Karan Goel, Noah Goodman, Shelby Grossman, Neel Guha, Tatsunori Hashimoto, Peter Henderson, John Hewitt, Daniel E. Ho, Jenny Hong, Kyle Hsu, Jing Huang, Thomas Icard, Saahil Jain, Dan Jurafsky, Pratyusha Kalluri, Siddharth Karamcheti, Geoff Keeling, Fereshte Khani, Omar Khattab, Pang Wei Kohd, Mark Krass, Ranjay Krishna, Rohith Kuditipudi, Ananya Kumar, Faisal Ladhak, Mina Lee, Tony Lee, Jure Leskovec, Isabelle Levent, Xiang Lisa Li, Xuechen Li, Tengyu Ma, Ali Malik, Christopher D. Manning, Suvir Mirchandani, Eric Mitchell, Zanele Munyikwa, Suraj Nair, Avanika Narayan, Deepak Narayanan, Ben Newman, Allen Nie, Juan Carlos Niebles, Hamed Nilforoshan, Julian Nyarko, Giray Ogut, Laurel Orr, Isabel Papadimitriou, Joon Sung Park, Chris Piech, Eva Portelance, Christopher Potts, Aditi Raghunathan, Rob Reich, Hongyu Ren, Frieda Rong, Yusuf Roohani, Camilo Ruiz, Jack Ryan, Christopher Ré, Dorsa Sadigh, Shiori Sagawa, Keshav Santhanam, Andy Shih, Krishnan Srinivasan, Alex Tamkin, Rohan Taori, Armin W. Thomas, Florian Tramèr, Rose E. Wang, William Wang, Bohan Wu, Jiajun Wu, Yuhuai Wu, Sang Michael Xie, Michihiro Yasunaga, Jiaxuan You, Matei Zaharia, Michael Zhang, Tianyi Zhang, Xikun Zhang, Yuhui Zhang, Lucia Zheng, Kaitlyn Zhou, and Percy Liang. On the opportunities and risks of foundation models, 2021.
[5] Tom B Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. arXiv preprint arXiv:2005.14165, 2020.
[6] Daniel Cer, Mona Diab, Eneko Agirre, Inigo Lopez-Gazpio, and Lucia Specia. Semeval-2017 task 1: Semantic textual similarity-multilingual and cross-lingual focused evaluation. arXiv preprint arXiv:1708.00055, 2017.
[7] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde, Jared Kaplan, Harri Edwards, Yura Burda, Nicholas Joseph, Greg Brockman, et al. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374, 2021.
[8] Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168, 2021.
[9] Joe Davison, Joshua Feldman, and Alexander M Rush. Commonsense knowledge mining from pretrained models. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages 1173-1178, 2019.
[10] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.</p>
<p>[11] Daniel Fried, Ronghang Hu, Volkan Cirik, Anna Rohrbach, Jacob Andreas, Louis-Philippe Morency, Taylor Berg-Kirkpatrick, Kate Saenko, Dan Klein, and Trevor Darrell. Speakerfollower models for vision-and-language navigation. arXiv preprint arXiv:1806.02724, 2018.
[12] Justin Fu, Anoop Korattikara, Sergey Levine, and Sergio Guadarrama. From language to goals: Inverse reinforcement learning for vision-based instruction following. arXiv preprint arXiv:1902.07742, 2019.
[13] Tianyu Gao, Adam Fisch, and Danqi Chen. Making pre-trained language models better few-shot learners. arXiv preprint arXiv:2012.15723, 2020.
[14] Brent Harrison and Mark O Riedl. Learning from stories: using crowdsourced narratives to train virtual agents. In Twelfth Artificial Intelligence and Interactive Digital Entertainment Conference, 2016.
[15] Dan Hendrycks, Steven Basart, Saurav Kadavath, Mantas Mazeika, Akul Arora, Ethan Guo, Collin Burns, Samir Puranik, Horace He, Dawn Song, et al. Measuring coding challenge competence with apps. arXiv preprint arXiv:2105.09938, 2021.
[16] Felix Hill, Sona Mokra, Nathaniel Wong, and Tim Harley. Human instruction-following with deep reinforcement learning via transfer-learning from text. arXiv preprint arXiv:2005.09382, 2020.
[17] Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. Neural computation, 9(8): $1735-1780,1997$.
[18] Ari Holtzman, Jan Buys, Li Du, Maxwell Forbes, and Yejin Choi. The curious case of neural text degeneration. arXiv preprint arXiv:1904.09751, 2019.
[19] Gabriel Ilharco, Rowan Zellers, Ali Farhadi, and Hannaneh Hajishirzi. Probing text models for common ground with visual representations. arXiv e-prints, pages arXiv-2005, 2020.
[20] Peter A Jansen. Visually-grounded planning without vision: Language models infer detailed plans from high-level instructions. arXiv preprint arXiv:2009.14259, 2020.
[21] Zhengbao Jiang, Frank F Xu, Jun Araki, and Graham Neubig. How can we know what language models know? Transactions of the Association for Computational Linguistics, 8:423-438, 2020.
[22] Eric Kolve, Roozbeh Mottaghi, Winson Han, Eli VanderBilt, Luca Weihs, Alvaro Herrasti, Daniel Gordon, Yuke Zhu, Abhinav Gupta, and Ali Farhadi. Ai2-thor: An interactive 3d environment for visual ai. arXiv preprint arXiv:1712.05474, 2017.
[23] Belinda Z Li, Maxwell Nye, and Jacob Andreas. Implicit representations of meaning in neural language models. arXiv preprint arXiv:2106.00737, 2021.
[24] Shuang Li, Xavier Puig, Yilun Du, Clinton Wang, Ekin Akyurek, Antonio Torralba, Jacob Andreas, and Igor Mordatch. Pre-trained language models for interactive decision-making. arXiv preprint arXiv:2202.01771, 2022.
[25] Yuan-Hong Liao, Xavier Puig, Marko Boben, Antonio Torralba, and Sanja Fidler. Synthesizing environment-aware activities via activity sketches. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 6291-6299, 2019.
[26] Jiachang Liu, Dinghan Shen, Yizhe Zhang, Bill Dolan, Lawrence Carin, and Weizhu Chen. What makes good in-context examples for gpt-2? arXiv preprint arXiv:2101.06804, 2021.
[27] Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. Roberta: A robustly optimized bert pretraining approach. arXiv preprint arXiv:1907.11692, 2019.
[28] Kevin Lu, Aditya Grover, Pieter Abbeel, and Igor Mordatch. Pretrained transformers as universal computation engines. arXiv preprint arXiv:2103.05247, 2021.</p>
<p>[29] Corey Lynch and Pierre Sermanet. Grounding language in play. arXiv preprint arXiv:2005.07648, 2020.
[30] Corey Lynch and Pierre Sermanet. Language conditioned imitation learning over unstructured data. Proceedings of Robotics: Science and Systems. doi, 10, 2021.
[31] Arjun Majumdar, Ayush Shrivastava, Stefan Lee, Peter Anderson, Devi Parikh, and Dhruv Batra. Improving vision-and-language navigation with image-text pairs from the web. In European Conference on Computer Vision, pages 259-274. Springer, 2020.
[32] Suvir Mirchandani, Siddharth Karamcheti, and Dorsa Sadigh. Ella: Exploration through learned language abstraction. arXiv preprint arXiv:2103.05825, 2021.
[33] Dipendra Misra, Kejia Tao, Percy Liang, and Ashutosh Saxena. Environment-driven lexicon induction for high-level instructions. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pages 992-1002, 2015.
[34] Dipendra K Misra, Jaeyong Sung, Kevin Lee, and Ashutosh Saxena. Tell me dave: Contextsensitive grounding of natural language to manipulation instructions. The International Journal of Robotics Research, 35(1-3):281-300, 2016.
[35] Jeffrey Pennington, Richard Socher, and Christopher D Manning. Glove: Global vectors for word representation. In Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP), pages 1532-1543, 2014.
[36] Fabio Petroni, Tim Rocktäschel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, Alexander H Miller, and Sebastian Riedel. Language models as knowledge bases? arXiv preprint arXiv:1909.01066, 2019.
[37] Gabriel Poesia, Oleksandr Polozov, Vu Le, Ashish Tiwari, Gustavo Soares, Christopher Meek, and Sumit Gulwani. Synchromesh: Reliable code generation from pre-trained language models. arXiv preprint arXiv:2201.11227, 2022.
[38] Xavier Puig, Kevin Ra, Marko Boben, Jiaman Li, Tingwu Wang, Sanja Fidler, and Antonio Torralba. Virtualhome: Simulating household activities via programs. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 8494-8502, 2018.
[39] Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. OpenAI blog, 1(8):9, 2019.
[40] Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. Exploring the limits of transfer learning with a unified text-to-text transformer. arXiv preprint arXiv:1910.10683, 2019.
[41] Nils Reimers and Iryna Gurevych. Sentence-bert: Sentence embeddings using siamese bertnetworks. arXiv preprint arXiv:1908.10084, 2019.
[42] Adam Roberts, Colin Raffel, and Noam Shazeer. How much knowledge can you pack into the parameters of a language model? arXiv preprint arXiv:2002.08910, 2020.
[43] Ohad Rubin, Jonathan Herzig, and Jonathan Berant. Learning to retrieve prompts for in-context learning. arXiv preprint arXiv:2112.08633, 2021.
[44] Manolis Savva, Abhishek Kadian, Oleksandr Maksymets, Yili Zhao, Erik Wijmans, Bhavana Jain, Julian Straub, Jia Liu, Vladlen Koltun, Jitendra Malik, et al. Habitat: A platform for embodied ai research. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 9339-9347, 2019.
[45] Pratyusha Sharma, Antonio Torralba, and Jacob Andreas. Skill induction and planning with latent language. arXiv preprint arXiv:2110.01517, 2021.
[46] Jianhao Shen, Yichun Yin, Lin Li, Lifeng Shang, Xin Jiang, Ming Zhang, and Qun Liu. Generate \&amp; rank: A multi-task framework for math word problems. arXiv preprint arXiv:2109.03034, 2021.</p>
<p>[47] Mohit Shridhar, Jesse Thomason, Daniel Gordon, Yonatan Bisk, Winson Han, Roozbeh Mottaghi, Luke Zettlemoyer, and Dieter Fox. Alfred: A benchmark for interpreting grounded instructions for everyday tasks. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 10740-10749, 2020.
[48] Mohit Shridhar, Xingdi Yuan, Marc-Alexandre Côté, Yonatan Bisk, Adam Trischler, and Matthew Hausknecht. Alfworld: Aligning text and embodied environments for interactive learning. arXiv preprint arXiv:2010.03768, 2020.
[49] Alessandro Suglia, Qiaozi Gao, Jesse Thomason, Govind Thattai, and Gaurav Sukhatme. Embodied bert: A transformer model for embodied, language-guided visual task completion. arXiv preprint arXiv:2108.04927, 2021.
[50] Alon Talmor, Yanai Elazar, Yoav Goldberg, and Jonathan Berant. olmpics-on what language model pre-training captures. Transactions of the Association for Computational Linguistics, 8: $743-758,2020$.
[51] Moritz Tenorth, Daniel Nyga, and Michael Beetz. Understanding and executing instructions for everyday manipulation tasks from the world wide web. In 2010 ieee international conference on robotics and automation, pages 1486-1491. IEEE, 2010.
[52] Maria Tsimpoukelli, Jacob Menick, Serkan Cabi, SM Eslami, Oriol Vinyals, and Felix Hill. Multimodal few-shot learning with frozen language models. arXiv preprint arXiv:2106.13884, 2021.
[53] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural information processing systems, pages 5998-6008, 2017.
[54] Xin Wang, Qiuyuan Huang, Asli Celikyilmaz, Jianfeng Gao, Dinghan Shen, Yuan-Fang Wang, William Yang Wang, and Lei Zhang. Reinforced cross-modal matching and self-supervised imitation learning for vision-language navigation. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 6629-6638, 2019.
[55] Thomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi, Pierric Cistac, Tim Rault, Rémi Louf, Morgan Funtowicz, et al. Huggingface's transformers: State-of-the-art natural language processing. arXiv preprint arXiv:1910.03771, 2019.</p>
<h1>A Appendix</h1>
<h2>A. 1 Hyperparameter Search</h2>
<p>For each evaluated method, we perform grid search over the following hyperparameters:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Search Values</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">epsilon $(\epsilon)$</td>
<td style="text-align: center;">Out-of-distribution early termination threshold</td>
<td style="text-align: center;">${0,0.4,0.8}$</td>
</tr>
<tr>
<td style="text-align: center;">temperature</td>
<td style="text-align: center;">sampling parameter adjusting relative token probabilities</td>
<td style="text-align: center;">${0.1,0.3,0.6}$</td>
</tr>
<tr>
<td style="text-align: center;">k</td>
<td style="text-align: center;">number of samples generated by Planning LM</td>
<td style="text-align: center;">${1,10}$</td>
</tr>
<tr>
<td style="text-align: center;">beta $(\beta)$</td>
<td style="text-align: center;">weighting coefficient in action translation to trade off semantic and translation correctness</td>
<td style="text-align: center;">${0.3}$</td>
</tr>
<tr>
<td style="text-align: center;">frequence_penalty</td>
<td style="text-align: center;">OpenAI API only; penalize new tokens based on their existing frequency in the text so far</td>
<td style="text-align: center;">${0.1,0.3,0.6,0.9}$</td>
</tr>
<tr>
<td style="text-align: center;">presence_penalty</td>
<td style="text-align: center;">OpenAI API only; penalize new tokens based on whether they appear in the text so far</td>
<td style="text-align: center;">${0.3,0.5,0.8}$</td>
</tr>
<tr>
<td style="text-align: center;">repetition_penalty</td>
<td style="text-align: center;">Hugging Face Transformers only; penalize new tokens based on whether repeating existing text</td>
<td style="text-align: center;">${1.0,1.2,1.5,1.8}$</td>
</tr>
</tbody>
</table>
<p>For methods that use fixed example across evaluated tasks, we search over the following three randomly chosen examples:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Example 1</th>
<th style="text-align: center;">Example 2</th>
<th style="text-align: center;">Example 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Task: Use computer</td>
<td style="text-align: center;">Task: Relax on sofa</td>
<td style="text-align: center;">Task: Read book</td>
</tr>
<tr>
<td style="text-align: center;">Step 1: Walk to home office</td>
<td style="text-align: center;">Step 1: Walk to home office</td>
<td style="text-align: center;">Step 1: Walk to home office</td>
</tr>
<tr>
<td style="text-align: center;">Step 2: Walk to chair</td>
<td style="text-align: center;">Step 2: Walk to couch</td>
<td style="text-align: center;">Step 2: Walk to novel</td>
</tr>
<tr>
<td style="text-align: center;">Step 3: Find chair</td>
<td style="text-align: center;">Step 3: Find couch</td>
<td style="text-align: center;">Step 3: Find novel</td>
</tr>
<tr>
<td style="text-align: center;">Step 4: Sit on chair</td>
<td style="text-align: center;">Step 4: Sit on couch</td>
<td style="text-align: center;">Step 4: Grab novel</td>
</tr>
<tr>
<td style="text-align: center;">Step 5: Find computer</td>
<td style="text-align: center;">Step 5: Find pillow</td>
<td style="text-align: center;">Step 5: Find chair</td>
</tr>
<tr>
<td style="text-align: center;">Step 6: Switch on computer</td>
<td style="text-align: center;">Step 6: Lie on couch</td>
<td style="text-align: center;">Step 6: Sit on chair</td>
</tr>
<tr>
<td style="text-align: center;">Step 7: Turn to computer</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Step 7: Read novel</td>
</tr>
<tr>
<td style="text-align: center;">Step 8: Look at computer</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Step 9: Find keyboard</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Step 10: Type on keyboard</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1>A. 2 Details of Human Evaluations</h1>
<p>Human evaluations are conducted on Amazon Mechanical Turk. For each method, we generate action plans for all 88 high-level tasks. To account for the expressivity of the VirtualHome environment [38], we include action plans written by human experts from the VirtualHome dataset as references in our human evaluations. The evaluations are conducted in the form of questionnaires containing all action plans whose order is randomly shuffled and whose corresponding methods are unknown to the annotators. Human annotators are required to answer all the questions in the questionnaire. For each question, the annotators need to answer either "Yes" or "No" indicating if they believe the action plan completes the task. For each method, we report correctness percentage averaged across 10 participated human annotators and all 88 tasks. We further report the standard error of the mean across human annotators. Screenshot can be found in Figure 6.</p>
<h2>Task Completion Questions</h2>
<p>Sign in to Google to save your progress. Learn more</p>
<ul>
<li>Required</li>
</ul>
<h2>Questions</h2>
<p>For every question below, determine whether the task can be completed in any reasonable scenario using the provided steps. In other words, can the task be decomposed into these steps? Note that simply restating the task does not mean completing it.</p>
<h2>Additional Notes:</h2>
<ul>
<li>There is no correct answer to each question. Please just use your first intuition to determine the answers. - If you're not sure what standard to follow, you may scroll through the questions first. Once you've set your standards, please abide by them for all the questions for the purpose of fair comparisons.</li>
</ul>
<p>Thank you!</p>
<p>Task: Look at painting
Step 1: Walk to home office
Step 2: Walk to drawing
Step 3: Find drawing
Step 4: Turn to drawing
Step 5: Look at drawing *</p>
<p>Yes
No</p>
<p>Figure 6: Screenshot of human evaluation interface, conducted as a Google Forms questionnaire.</p>
<h1>A. 3 All Evaluated Tasks</h1>
<p>The evaluated tasks are part of the ActivityPrograms dataset collected by Puig et al. [38]. Some of the task names may contain misspelling(s).</p>
<ol>
<li>Apply lotion</li>
<li>Arrange folders</li>
<li>Breakfast</li>
<li>Browse internet</li>
<li>Brush teeth</li>
<li>Change clothes</li>
<li>Change sheets and pillow cases</li>
<li>Collect napkin rings</li>
<li>Complete surveys on amazon turk</li>
<li>Compute</li>
<li>Decorate it</li>
<li>Do homework</li>
<li>Do work</li>
<li>Draft home</li>
<li>Draw picture</li>
<li>Dry soap bottles</li>
<li>Dust</li>
<li>Eat cereal</li>
<li>Eat cheese</li>
<li>Eat snacks and drink tea</li>
<li>Empty dishwasher and fill dishwasher</li>
<li>Entertain</li>
<li>Feed me</li>
<li>Find dictionary</li>
<li>Fix snack</li>
<li>Get glass of milk</li>
<li>Give milk to cat</li>
<li>Go to sleep</li>
<li>Grab things</li>
<li>Hand washing</li>
<li>Hang keys</li>
<li>Hang pictures</li>
<li>Iron shirt</li>
<li>Keep cats inside while door is open</li>
<li>Keep cats out of room</li>
<li>Leave home</li>
<li>Listen to music</li>
<li>Look at mirror</li>
<li>Look at painting</li>
<li>Make bed</li>
<li>Make popcorn</li>
<li>Organize closet</li>
<li>Organize pantry</li>
<li>Paint ceiling</li>
<li>Pay bills</li>
<li>Pick up toys</li>
<li>Play musical chairs</li>
<li>Prepare pot of boiling water</li>
<li>Push all chairs in</li>
<li>Push in desk chair</li>
<li>Put alarm clock in bedroom</li>
<li>Put away groceries</li>
<li>Put away toys</li>
<li>Put clothes away</li>
<li>Put mail in mail organizer</li>
<li>Put on your shoes</li>
<li>Put out flowers</li>
<li>Put up decoration</li>
<li>Read</li>
<li>Read newspaper</li>
<li>Read on sofa</li>
<li>Read to child</li>
<li>Read yourself to sleep</li>
<li>Receive credit card</li>
<li>Restock</li>
<li>Scrubbing living room tile floor is once week activity for me</li>
<li>Style hair</li>
<li>Switch on lamp</li>
<li>Take jacket off</li>
<li>Take shoes off</li>
<li>Tale off shoes</li>
<li>Throw away paper</li>
<li>Try yourself off</li>
<li>Turn off TV</li>
<li>Turn on TV with remote</li>
<li>Turn on radio</li>
<li>Type up document</li>
<li>Unload various items from pockets and place them in bowl on table</li>
<li>Use laptop</li>
<li>Vacuum</li>
<li>Walk to room</li>
<li>Wash dirty dishes</li>
<li>Wash face</li>
<li>Wash monitor</li>
<li>Wash teeth</li>
<li>Watch horror movie</li>
<li>Wipe down sink</li>
<li>Write book</li>
</ol>
<h1>A. 4 Natural Language Templates for All Atomic Actions</h1>
<p>VirtualHome requires action steps specified in a specific format, yet language models are trained to deal with mostly natural language. We thus define a natural language template for each atomic action and only expose the converted natural language text in all operations involving language models, i.e. autoregressive generation and action translation. After we obtain an entire generated program expressed in natural language, such as those in Figure 1 and Figure 2, we then convert each action step to the VirtualHome syntax. Full list of the atomic actions and their natural language templates can be found below.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Atomic Action in VirtualHome Syntax</th>
<th style="text-align: center;">Natural Language Template</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">[CLOSE] 〈arg1〉(1)</td>
<td style="text-align: center;">close 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[CUT] 〈arg1〉(1)</td>
<td style="text-align: center;">cut 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[DRINK] 〈arg1〉(1)</td>
<td style="text-align: center;">drink 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[DROP] 〈arg1〉(1)</td>
<td style="text-align: center;">drop 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[EAT] 〈arg1〉(1)</td>
<td style="text-align: center;">eat 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[FIND] 〈arg1〉(1)</td>
<td style="text-align: center;">find 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[GRAB] 〈arg1〉(1)</td>
<td style="text-align: center;">grab 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[GREET] 〈arg1〉(1)</td>
<td style="text-align: center;">greet 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[LIE] 〈arg1〉(1)</td>
<td style="text-align: center;">lie on 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[LOOKAT] 〈arg1〉(1)</td>
<td style="text-align: center;">look at 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[MOVE] 〈arg1〉(1)</td>
<td style="text-align: center;">move 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[OPEN] 〈arg1〉(1)</td>
<td style="text-align: center;">open 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[PLUGIN] 〈arg1〉(1)</td>
<td style="text-align: center;">plug in 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[PLUGOUT] 〈arg1〉(1)</td>
<td style="text-align: center;">plug out 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[POINTAT] 〈arg1〉(1)</td>
<td style="text-align: center;">point at 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[POUR] 〈arg1〉(1) 〈arg2〉(1)</td>
<td style="text-align: center;">pour 〈arg1〉 into 〈arg2〉</td>
</tr>
<tr>
<td style="text-align: center;">[PULL] 〈arg1〉(1)</td>
<td style="text-align: center;">pull 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[PUSH] 〈arg1〉(1)</td>
<td style="text-align: center;">push 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[PUTBACK] 〈arg1〉(1) 〈arg2〉(1)</td>
<td style="text-align: center;">put 〈arg1〉 on 〈arg2〉</td>
</tr>
<tr>
<td style="text-align: center;">[PUTIN] 〈arg1〉(1) 〈arg2〉(1)</td>
<td style="text-align: center;">put 〈arg1〉 in 〈arg2〉</td>
</tr>
<tr>
<td style="text-align: center;">[PUTOBJBACK] 〈arg1〉(1)</td>
<td style="text-align: center;">put back 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[PUTOFF] 〈arg1〉(1)</td>
<td style="text-align: center;">take off 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[PUTON] 〈arg1〉(1)</td>
<td style="text-align: center;">put on 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[READ] 〈arg1〉(1)</td>
<td style="text-align: center;">read 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[RELEASE]</td>
<td style="text-align: center;">release</td>
</tr>
<tr>
<td style="text-align: center;">[RINSE] 〈arg1〉(1)</td>
<td style="text-align: center;">rinse 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[RUN] 〈arg1〉(1)</td>
<td style="text-align: center;">run to 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[SCRUB] 〈arg1〉(1)</td>
<td style="text-align: center;">scrub 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[SIT] 〈arg1〉(1)</td>
<td style="text-align: center;">sit on 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[SLEEP]</td>
<td style="text-align: center;">sleep</td>
</tr>
<tr>
<td style="text-align: center;">[SQUEEZE] 〈arg1〉(1)</td>
<td style="text-align: center;">squeeze 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[STANDUP]</td>
<td style="text-align: center;">stand up</td>
</tr>
<tr>
<td style="text-align: center;">[SWITCHOFF] 〈arg1〉(1)</td>
<td style="text-align: center;">switch off 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[SWITCHON] 〈arg1〉(1)</td>
<td style="text-align: center;">switch on 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[TOUCH] 〈arg1〉(1)</td>
<td style="text-align: center;">touch 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[TURNTO] 〈arg1〉(1)</td>
<td style="text-align: center;">turn to 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[TYPE] 〈arg1〉(1)</td>
<td style="text-align: center;">type on 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[WAKEUP]</td>
<td style="text-align: center;">wake up</td>
</tr>
<tr>
<td style="text-align: center;">[WALK] 〈arg1〉(1)</td>
<td style="text-align: center;">walk to 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[WASH] 〈arg1〉(1)</td>
<td style="text-align: center;">wash 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[WATCH] 〈arg1〉(1)</td>
<td style="text-align: center;">watch 〈arg1〉</td>
</tr>
<tr>
<td style="text-align: center;">[WIPE] 〈arg1〉(1)</td>
<td style="text-align: center;">wipe 〈arg1〉</td>
</tr>
</tbody>
</table>
<div class="footnote">
<hr />
<ol>
<li id="fn:0">
<p>${ }^{4}$ Puig et al. [38] also conduct a human evaluation on 100 randomly sampled human-written programs and show that $64 \%$ of them are complete (i.e. contain all necessary steps). Readers are encouraged to refer to Puig et al. [38] for a more comprehensive analysis of the dataset.&#160;<a class="footnote-backref" href="#fnref:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:0" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:0" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>            </div>
        </div>

    </div>
</body>
</html>