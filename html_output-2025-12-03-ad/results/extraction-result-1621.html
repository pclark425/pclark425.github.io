<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction extraction-result-1621 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extracted Data Details for extraction-result-1621</h1>

        <div class="section">
            <h2>Extracted Data (Header)</h2>
            <div class="info-section">
                <p><strong>Extraction ID:</strong> extraction-result-1621</p>
                <p><strong>Extraction Schema Used (ID):</strong> <a href="../schemas/extraction-schema-31.html">extraction-schema-31</a></p>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <p><strong>Paper ID:</strong> paper-18980883</p>
                <p><strong>Paper Title:</strong> <a href="https://arxiv.org/pdf/1402.6785v1.pdf" target="_blank">Synthesis of Parametric Programs using Genetic Programming and Model Checking</a></p>
                <p><strong>Paper Abstract:</strong> Formal methods apply algorithms based on mathematical principles to enhance the reliability of systems. It would only be natural to try to progress from verification, model checking or testing a system against its formal specification into constructing it automatically. Classical algorithmic synthesis theory provides interesting algorithms but also alarming high complexity and undecidability results. The use of genetic programming, in combination with model checking and testing, provides a powerful heuristic to synthesize programs. The method is not completely automatic, as it is fine tuned by a user that sets up the specification and parameters. It also does not guarantee to always succeed and converge towards a solution that satisfies all the required properties. However, we applied it successfully on quite nontrivial examples and managed to find solutions to hard programming challenges, as well as to improve and to correct code. We describe here several versions of our method for synthesizing sequential and concurrent systems.</p>
                <p><strong>Cost:</strong> 0.012</p>
            </div>
        </div>

        <div class="section">
            <h2>Extracted Data (Details)</h2>
            <div class="extraction-instance-container" id="e1621.0">
                <h3 class="extraction-instance">Extracted Data Instance 0 (e1621.0)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>MCGP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Model-Checking-based Genetic Programming (MCGP)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A genetic programming framework that generates and evolves program trees using mutation (no crossover in practice) and evaluates candidates via enhanced model checking or SMT solving to synthesize, improve, or correct code with respect to temporal or logical specifications.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Model-Checking-based Genetic Programming (MCGP)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Generative 'generate-and-check' GP system that represents programs as syntax trees, initializes a random population subject to user-provided architecture and building blocks, and evolves candidates using mutation (principal operator) guided by fitness values produced by an enhanced model checker or an SMT solver. The framework supports evolving program code, architectures (for co-evolution), and accumulates failing parameter instances/test-cases to focus search for parametric problems. It includes a selection loop (µ/λ style), parsimony pressure to penalize program length, and optional use of SMT verification for loop-free code domains.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / code (syntactic trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Extensive subtree-based mutations applied to program ASTs: (a) replace the subtree rooted at a randomly chosen node with a newly generated random subtree (terminal or larger subtree); (b) insert an immediate parent above a chosen node, creating additional offspring as required (e.g., wrap in a while or insert a block with additional instructions); (c) replace a chosen node by one of its existing offspring and delete the remaining offspring (prune); (d) delete the subtree rooted at the chosen node (remove). All mutations must respect syntactic/typing constraints so generated code is legal.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Enhanced model checking fitness levels (per LTL property): four-tier scale (1) none of executions satisfy property; (2) some executions satisfy property; (3) only executions that do not satisfy require infinitely many decisions avoiding a satisfying path; (4) all executions satisfy property. For SMT/loop-free programs a three-level satisfiability-based metric is used per postcondition: (1) F' unsat => program incorrect for all inputs; (2) both F and F' satisfiable => program correct for some inputs; (3) F unsat => program correct for all inputs. Also uses accumulated counterexample test-cases (runner) to compute empirical pass/fail counts used in fitness.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program synthesis and repair (concurrent mutual exclusion algorithms, leader election, sequential loop-free bit-vector programs), parametric program synthesis via accumulated instance testing</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Traditional genetic programming (crossover-heavy GP), exhaustive enumeration approaches (e.g., Taubenfeld enumeration), SMT-based program synthesis (e.g., Gulwani et al. loop-free synthesis), and classical model checking</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mutation-centric GP combined with enhanced model checking can synthesize nontrivial concurrent algorithms (variants of mutual exclusion including Dekker-like, Peterson-like, and Kessels-like solutions) and correct/repair complex protocols (α-core) via co-evolution. Crossover was considered but intentionally not used because of controversy and practical choice; enhanced multi-level model checking fitness provides gradient information that directs search more effectively than binary model checking; accumulating failing parameter instances (coevolution of counterexamples) enables tackling parametric problems though without guarantees; integrating SMT (Z3) provides provable correctness for loop-free bit-vector programs; parsimony penalty prevents bloat and favors shorter solutions.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Synthesis of Parametric Programs using Genetic Programming and Model Checking', 'publication_date_yy_mm': '2014-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1621.1">
                <h3 class="extraction-instance">Extracted Data Instance 1 (e1621.1)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Mutation (GP)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>AST Subtree Mutation Operations in GP (as implemented)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Detailed, type-aware mutation operators applied to program ASTs: subtree replacement, parent insertion, node replacement by offspring (prune), and subtree deletion, all guaranteeing syntactically legal code after mutation.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>AST Subtree Mutation</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Randomly selects a node in a program's AST and applies one of several mutation types: (a) replace that subtree with a newly generated subtree (can be terminal or larger), (b) insert a new parent node above it (possibly creating additional sibling offspring consistent with parent type), (c) replace the node by one of its offspring and delete the remaining offspring, (d) delete the subtree entirely. Mutation type is chosen randomly but constrained by syntax/types to ensure legal code. Used as the dominant genetic operator in the framework.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / code trees</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>See system_description (subtree replacement; parent insertion/wrapping; pruning to offspring; subtree deletion), with random node selection and type-aware generation of new nodes and children.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Indirectly via verifier (enhanced model checking or SMT) which measures levels of property satisfaction and produces counterexamples; mutation fitness computed based on verifier outputs and parsimony penalty.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Program synthesis and repair (concurrent and sequential programs)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Crossover-based GP variants (traditional GP), random enumeration</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Mutation-only or mutation-centric GP sufficed to find many correct/novel concurrent algorithms in the studied domains; mutation types that can both grow (parent insertion) and shrink (deletion/prune) programs allow exploration and parsimony control; mutation combined with enhanced verification provides effective directed search without reliance on crossover.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Synthesis of Parametric Programs using Genetic Programming and Model Checking', 'publication_date_yy_mm': '2014-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1621.2">
                <h3 class="extraction-instance">Extracted Data Instance 2 (e1621.2)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Crossover (subtree swap)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Subtree Crossover (standard GP crossover, mentioned)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>Standard GP crossover operation that exchanges subtrees between two parent program trees at nodes of the same type to create two offspring; mentioned as a common GP operator but not used in this work.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>mention</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Subtree Crossover (standard)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Crossover selects a node in parent A, picks a node of the same type in parent B, exchanges the subtrees rooted at those nodes, yielding two offspring programs. The paper notes this is a conventional GP operator but states it is controversial and explicitly not used in their experiments.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / code trees</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td>Select a random node in first program; select a node of the same type in second program; swap the subtrees rooted at those nodes to produce two new programs (type-aware subtree exchange).</td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>General GP (mentioned in relation to program synthesis)</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Used as baseline concept for traditional GP (not used in experiments)</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Although traditional GP relies heavily on crossover, the authors considered it controversial and did not implement it in their synthesis experiments; they therefore attribute their empirical successes to mutation-driven evolution guided by model checking/SMT rather than crossover.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Synthesis of Parametric Programs using Genetic Programming and Model Checking', 'publication_date_yy_mm': '2014-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1621.3">
                <h3 class="extraction-instance">Extracted Data Instance 3 (e1621.3)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>SMT-integrated GP</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>SMT-Supported GP for Loop-Free Program Synthesis (Z3 integration)</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A variant of the framework that synthesizes loop-free sequential programs and uses an SMT solver (Z3) to verify correctness over bit-vector and related decidable theories, enabling provable correctness for specified domains.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>SMT-integrated GP (Prover + Runner)</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>GP engine generates loop-free straight-line programs constrained to a decidable theory (e.g., bit-vectors). A Prover module translates a candidate program into a logical formula η_P and checks postconditions using Z3, producing satisfiable/unsatisfiable results and counterexamples. A Runner executes programs on accumulated test-cases (counterexamples) for faster empirical fitness evaluation. The Prover supplies counterexamples for failed postconditions which are added as test-cases to guide further search. Fitness is multi-level based on satisfiability (correct for all inputs / some inputs / none).</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>loop-free programs (bit-vector expressions and assignments)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Same AST subtree mutation operators as the GP framework, but restricted to generate loop-free straight-line code and terms from the decidable theory (bit-vector operators, constants, permitted terminals).</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>SMT/Prover-based satisfiability levels per postcondition: (1) F' unsat => provably incorrect for all inputs; (2) both F and F' satisfiable => correct for some inputs (counterexample exists); (3) F unsat => provably correct for all inputs. Additionally empirical runner on SMT-generated counterexamples provides pass/fail counts.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Sequential loop-free program synthesis (examples: Hacker's Delight problems like avg(X,Y) without overflow, check X==2^n-1), bit-vector domains</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>SMT-based synthesis approaches (e.g., Gulwani et al. synthesizing loop-free programs), traditional GP verified by test cases</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Integrating an SMT solver (Z3) permits producing programs that are provably correct for all inputs within the chosen decidable domain (bit-vector widths), while also using SMT counterexamples as test-cases to smooth fitness. This combination found known concise solutions (e.g., avg without overflow; X==2^n-1) quickly. It trades expressiveness (requires loop-free / decidable theory) for provable executability.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Synthesis of Parametric Programs using Genetic Programming and Model Checking', 'publication_date_yy_mm': '2014-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="extraction-instance-container" id="e1621.4">
                <h3 class="extraction-instance">Extracted Data Instance 4 (e1621.4)</h3>
                <div class="extraction-query"><strong>Extraction Query:</strong> Extract any mentions of genetic/evolutionary algorithms that use crossover and mutation operations on code, programs, or literature to generate new solutions, with particular attention to measures of novelty, diversity, executability, and functionality.</div>
                <table>
                    <thead>
                        <tr>
                            <th style="width: 30%;">Field</th>
                            <th style="width: 70%;">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>name_short</strong></td>
                            <td>Coevolution (programs & architectures)</td>
                        </tr>
                        <tr>
                            <td><strong>name_full</strong></td>
                            <td>Coevolution of Candidate Programs and Counterexample Architectures</td>
                        </tr>
                        <tr>
                            <td><strong>brief_description</strong></td>
                            <td>A co-evolution strategy where candidate programs and failing parameter instances or architectures are evolved in parallel: architectures that falsify candidates are collected as counterexamples and used to guide program synthesis and repair.</td>
                        </tr>
                        <tr>
                            <td><strong>citation_title</strong></td>
                            <td>here</td>
                        </tr>
                        <tr>
                            <td><strong>mention_or_use</strong></td>
                            <td>use</td>
                        </tr>
                        <tr>
                            <td><strong>system_name</strong></td>
                            <td>Coevolution of Programs and Architectures/Parameters</td>
                        </tr>
                        <tr>
                            <td><strong>system_description</strong></td>
                            <td>Parallel evolution of two populations: (1) program candidates (to be correct on specifications) and (2) test-case/architecture candidates (configurations, initial parameter assignments, or topologies) that attempt to falsify programs. Architectures are represented syntactically and mutated. High-fitness architectures are those that induce property violations in target programs; high-fitness programs are those that pass accumulated architectures. Accumulated failing instances are retained and used to more strictly evaluate future programs.</td>
                        </tr>
                        <tr>
                            <td><strong>input_type</strong></td>
                            <td>programs / architectures / parameter instances (code and configuration trees)</td>
                        </tr>
                        <tr>
                            <td><strong>crossover_operation</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>mutation_operation</strong></td>
                            <td>Mutation applied to both program ASTs and architecture/configuration ASTs using same AST mutation repertoire (subtree replacement, insertion, deletion, etc.), constrained to produce legal architectures or instances.</td>
                        </tr>
                        <tr>
                            <td><strong>uses_literature</strong></td>
                            <td>False</td>
                        </tr>
                        <tr>
                            <td><strong>uses_code</strong></td>
                            <td>True</td>
                        </tr>
                        <tr>
                            <td><strong>novelty_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>executability_metric</strong></td>
                            <td>Programs are evaluated by enhanced model checking or SMT against the set of accumulated architectures/instances; architectures are evaluated by their ability to cause property violations (i.e., falsify the program). Fitness values derive from model checking/MSMT outcomes and counterexample production.</td>
                        </tr>
                        <tr>
                            <td><strong>executability_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_metric</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>diversity_results</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>novelty_executability_tradeoff</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>frontier_characterization</strong></td>
                            <td><span class="empty-note">null</span></td>
                        </tr>
                        <tr>
                            <td><strong>benchmark_or_domain</strong></td>
                            <td>Correction/falsification of parametric concurrent protocols (example: finding an architecture that triggers the known bug in α-core protocol), parametric system verification</td>
                        </tr>
                        <tr>
                            <td><strong>comparison_baseline</strong></td>
                            <td>Standard single-population GP or exhaustive parameter enumeration; manual counterexample construction</td>
                        </tr>
                        <tr>
                            <td><strong>key_findings</strong></td>
                            <td>Coevolution of architectures and programs enabled automated discovery of counterexample architectures that expose real bugs (used to find and then correct an error in the α-core protocol). Accumulating failing instances as test-cases makes the search for robust parametric solutions feasible in practice, though it does not provide completeness guarantees due to undecidability of parametric model checking.</td>
                        </tr>
                        <tr>
                            <td><strong>source_info</strong></td>
                            <td>{'paper_title': 'Synthesis of Parametric Programs using Genetic Programming and Model Checking', 'publication_date_yy_mm': '2014-02'}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Potentially Relevant New Papers (mentioned by this paper)</h2>
            <ol>
                <li>Synthesis of loop-free programs <em>(Rating: 2)</em></li>
                <li>Genetic Programming -An Introduction; On the Automatic Evolution of Computer Programs and its Applications <em>(Rating: 2)</em></li>
                <li>MCGP: A Software Synthesis Tool Based on Model Checking and Genetic Programming <em>(Rating: 2)</em></li>
                <li>Genetic Programming and Model Checking: Synthesizing New Mutual Exclusion Algorithms <em>(Rating: 2)</em></li>
                <li>Z3: An Efficient SMT Solver <em>(Rating: 1)</em></li>
            </ol>
        </div>

        <div class="section">
            <h2>Extracted Data (Debug)</h2>
            <pre><code>{
    "id": "extraction-result-1621",
    "paper_id": "paper-18980883",
    "extraction_schema_id": "extraction-schema-31",
    "extracted_data": [
        {
            "name_short": "MCGP",
            "name_full": "Model-Checking-based Genetic Programming (MCGP)",
            "brief_description": "A genetic programming framework that generates and evolves program trees using mutation (no crossover in practice) and evaluates candidates via enhanced model checking or SMT solving to synthesize, improve, or correct code with respect to temporal or logical specifications.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Model-Checking-based Genetic Programming (MCGP)",
            "system_description": "Generative 'generate-and-check' GP system that represents programs as syntax trees, initializes a random population subject to user-provided architecture and building blocks, and evolves candidates using mutation (principal operator) guided by fitness values produced by an enhanced model checker or an SMT solver. The framework supports evolving program code, architectures (for co-evolution), and accumulates failing parameter instances/test-cases to focus search for parametric problems. It includes a selection loop (µ/λ style), parsimony pressure to penalize program length, and optional use of SMT verification for loop-free code domains.",
            "input_type": "programs / code (syntactic trees)",
            "crossover_operation": null,
            "mutation_operation": "Extensive subtree-based mutations applied to program ASTs: (a) replace the subtree rooted at a randomly chosen node with a newly generated random subtree (terminal or larger subtree); (b) insert an immediate parent above a chosen node, creating additional offspring as required (e.g., wrap in a while or insert a block with additional instructions); (c) replace a chosen node by one of its existing offspring and delete the remaining offspring (prune); (d) delete the subtree rooted at the chosen node (remove). All mutations must respect syntactic/typing constraints so generated code is legal.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Enhanced model checking fitness levels (per LTL property): four-tier scale (1) none of executions satisfy property; (2) some executions satisfy property; (3) only executions that do not satisfy require infinitely many decisions avoiding a satisfying path; (4) all executions satisfy property. For SMT/loop-free programs a three-level satisfiability-based metric is used per postcondition: (1) F' unsat =&gt; program incorrect for all inputs; (2) both F and F' satisfiable =&gt; program correct for some inputs; (3) F unsat =&gt; program correct for all inputs. Also uses accumulated counterexample test-cases (runner) to compute empirical pass/fail counts used in fitness.",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Program synthesis and repair (concurrent mutual exclusion algorithms, leader election, sequential loop-free bit-vector programs), parametric program synthesis via accumulated instance testing",
            "comparison_baseline": "Traditional genetic programming (crossover-heavy GP), exhaustive enumeration approaches (e.g., Taubenfeld enumeration), SMT-based program synthesis (e.g., Gulwani et al. loop-free synthesis), and classical model checking",
            "key_findings": "Mutation-centric GP combined with enhanced model checking can synthesize nontrivial concurrent algorithms (variants of mutual exclusion including Dekker-like, Peterson-like, and Kessels-like solutions) and correct/repair complex protocols (α-core) via co-evolution. Crossover was considered but intentionally not used because of controversy and practical choice; enhanced multi-level model checking fitness provides gradient information that directs search more effectively than binary model checking; accumulating failing parameter instances (coevolution of counterexamples) enables tackling parametric problems though without guarantees; integrating SMT (Z3) provides provable correctness for loop-free bit-vector programs; parsimony penalty prevents bloat and favors shorter solutions.",
            "uuid": "e1621.0",
            "source_info": {
                "paper_title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking",
                "publication_date_yy_mm": "2014-02"
            }
        },
        {
            "name_short": "Mutation (GP)",
            "name_full": "AST Subtree Mutation Operations in GP (as implemented)",
            "brief_description": "Detailed, type-aware mutation operators applied to program ASTs: subtree replacement, parent insertion, node replacement by offspring (prune), and subtree deletion, all guaranteeing syntactically legal code after mutation.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "AST Subtree Mutation",
            "system_description": "Randomly selects a node in a program's AST and applies one of several mutation types: (a) replace that subtree with a newly generated subtree (can be terminal or larger), (b) insert a new parent node above it (possibly creating additional sibling offspring consistent with parent type), (c) replace the node by one of its offspring and delete the remaining offspring, (d) delete the subtree entirely. Mutation type is chosen randomly but constrained by syntax/types to ensure legal code. Used as the dominant genetic operator in the framework.",
            "input_type": "programs / code trees",
            "crossover_operation": null,
            "mutation_operation": "See system_description (subtree replacement; parent insertion/wrapping; pruning to offspring; subtree deletion), with random node selection and type-aware generation of new nodes and children.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Indirectly via verifier (enhanced model checking or SMT) which measures levels of property satisfaction and produces counterexamples; mutation fitness computed based on verifier outputs and parsimony penalty.",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Program synthesis and repair (concurrent and sequential programs)",
            "comparison_baseline": "Crossover-based GP variants (traditional GP), random enumeration",
            "key_findings": "Mutation-only or mutation-centric GP sufficed to find many correct/novel concurrent algorithms in the studied domains; mutation types that can both grow (parent insertion) and shrink (deletion/prune) programs allow exploration and parsimony control; mutation combined with enhanced verification provides effective directed search without reliance on crossover.",
            "uuid": "e1621.1",
            "source_info": {
                "paper_title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking",
                "publication_date_yy_mm": "2014-02"
            }
        },
        {
            "name_short": "Crossover (subtree swap)",
            "name_full": "Subtree Crossover (standard GP crossover, mentioned)",
            "brief_description": "Standard GP crossover operation that exchanges subtrees between two parent program trees at nodes of the same type to create two offspring; mentioned as a common GP operator but not used in this work.",
            "citation_title": "",
            "mention_or_use": "mention",
            "system_name": "Subtree Crossover (standard)",
            "system_description": "Crossover selects a node in parent A, picks a node of the same type in parent B, exchanges the subtrees rooted at those nodes, yielding two offspring programs. The paper notes this is a conventional GP operator but states it is controversial and explicitly not used in their experiments.",
            "input_type": "programs / code trees",
            "crossover_operation": "Select a random node in first program; select a node of the same type in second program; swap the subtrees rooted at those nodes to produce two new programs (type-aware subtree exchange).",
            "mutation_operation": null,
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": null,
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "General GP (mentioned in relation to program synthesis)",
            "comparison_baseline": "Used as baseline concept for traditional GP (not used in experiments)",
            "key_findings": "Although traditional GP relies heavily on crossover, the authors considered it controversial and did not implement it in their synthesis experiments; they therefore attribute their empirical successes to mutation-driven evolution guided by model checking/SMT rather than crossover.",
            "uuid": "e1621.2",
            "source_info": {
                "paper_title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking",
                "publication_date_yy_mm": "2014-02"
            }
        },
        {
            "name_short": "SMT-integrated GP",
            "name_full": "SMT-Supported GP for Loop-Free Program Synthesis (Z3 integration)",
            "brief_description": "A variant of the framework that synthesizes loop-free sequential programs and uses an SMT solver (Z3) to verify correctness over bit-vector and related decidable theories, enabling provable correctness for specified domains.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "SMT-integrated GP (Prover + Runner)",
            "system_description": "GP engine generates loop-free straight-line programs constrained to a decidable theory (e.g., bit-vectors). A Prover module translates a candidate program into a logical formula η_P and checks postconditions using Z3, producing satisfiable/unsatisfiable results and counterexamples. A Runner executes programs on accumulated test-cases (counterexamples) for faster empirical fitness evaluation. The Prover supplies counterexamples for failed postconditions which are added as test-cases to guide further search. Fitness is multi-level based on satisfiability (correct for all inputs / some inputs / none).",
            "input_type": "loop-free programs (bit-vector expressions and assignments)",
            "crossover_operation": null,
            "mutation_operation": "Same AST subtree mutation operators as the GP framework, but restricted to generate loop-free straight-line code and terms from the decidable theory (bit-vector operators, constants, permitted terminals).",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "SMT/Prover-based satisfiability levels per postcondition: (1) F' unsat =&gt; provably incorrect for all inputs; (2) both F and F' satisfiable =&gt; correct for some inputs (counterexample exists); (3) F unsat =&gt; provably correct for all inputs. Additionally empirical runner on SMT-generated counterexamples provides pass/fail counts.",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Sequential loop-free program synthesis (examples: Hacker's Delight problems like avg(X,Y) without overflow, check X==2^n-1), bit-vector domains",
            "comparison_baseline": "SMT-based synthesis approaches (e.g., Gulwani et al. synthesizing loop-free programs), traditional GP verified by test cases",
            "key_findings": "Integrating an SMT solver (Z3) permits producing programs that are provably correct for all inputs within the chosen decidable domain (bit-vector widths), while also using SMT counterexamples as test-cases to smooth fitness. This combination found known concise solutions (e.g., avg without overflow; X==2^n-1) quickly. It trades expressiveness (requires loop-free / decidable theory) for provable executability.",
            "uuid": "e1621.3",
            "source_info": {
                "paper_title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking",
                "publication_date_yy_mm": "2014-02"
            }
        },
        {
            "name_short": "Coevolution (programs & architectures)",
            "name_full": "Coevolution of Candidate Programs and Counterexample Architectures",
            "brief_description": "A co-evolution strategy where candidate programs and failing parameter instances or architectures are evolved in parallel: architectures that falsify candidates are collected as counterexamples and used to guide program synthesis and repair.",
            "citation_title": "here",
            "mention_or_use": "use",
            "system_name": "Coevolution of Programs and Architectures/Parameters",
            "system_description": "Parallel evolution of two populations: (1) program candidates (to be correct on specifications) and (2) test-case/architecture candidates (configurations, initial parameter assignments, or topologies) that attempt to falsify programs. Architectures are represented syntactically and mutated. High-fitness architectures are those that induce property violations in target programs; high-fitness programs are those that pass accumulated architectures. Accumulated failing instances are retained and used to more strictly evaluate future programs.",
            "input_type": "programs / architectures / parameter instances (code and configuration trees)",
            "crossover_operation": null,
            "mutation_operation": "Mutation applied to both program ASTs and architecture/configuration ASTs using same AST mutation repertoire (subtree replacement, insertion, deletion, etc.), constrained to produce legal architectures or instances.",
            "uses_literature": false,
            "uses_code": true,
            "novelty_metric": null,
            "novelty_results": null,
            "executability_metric": "Programs are evaluated by enhanced model checking or SMT against the set of accumulated architectures/instances; architectures are evaluated by their ability to cause property violations (i.e., falsify the program). Fitness values derive from model checking/MSMT outcomes and counterexample production.",
            "executability_results": null,
            "diversity_metric": null,
            "diversity_results": null,
            "novelty_executability_tradeoff": null,
            "frontier_characterization": null,
            "benchmark_or_domain": "Correction/falsification of parametric concurrent protocols (example: finding an architecture that triggers the known bug in α-core protocol), parametric system verification",
            "comparison_baseline": "Standard single-population GP or exhaustive parameter enumeration; manual counterexample construction",
            "key_findings": "Coevolution of architectures and programs enabled automated discovery of counterexample architectures that expose real bugs (used to find and then correct an error in the α-core protocol). Accumulating failing instances as test-cases makes the search for robust parametric solutions feasible in practice, though it does not provide completeness guarantees due to undecidability of parametric model checking.",
            "uuid": "e1621.4",
            "source_info": {
                "paper_title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking",
                "publication_date_yy_mm": "2014-02"
            }
        }
    ],
    "potentially_relevant_new_papers": [
        {
            "paper_title": "Synthesis of loop-free programs",
            "rating": 2,
            "sanitized_title": "synthesis_of_loopfree_programs"
        },
        {
            "paper_title": "Genetic Programming -An Introduction; On the Automatic Evolution of Computer Programs and its Applications",
            "rating": 2,
            "sanitized_title": "genetic_programming_an_introduction_on_the_automatic_evolution_of_computer_programs_and_its_applications"
        },
        {
            "paper_title": "MCGP: A Software Synthesis Tool Based on Model Checking and Genetic Programming",
            "rating": 2,
            "sanitized_title": "mcgp_a_software_synthesis_tool_based_on_model_checking_and_genetic_programming"
        },
        {
            "paper_title": "Genetic Programming and Model Checking: Synthesizing New Mutual Exclusion Algorithms",
            "rating": 2,
            "sanitized_title": "genetic_programming_and_model_checking_synthesizing_new_mutual_exclusion_algorithms"
        },
        {
            "paper_title": "Z3: An Efficient SMT Solver",
            "rating": 1,
            "sanitized_title": "z3_an_efficient_smt_solver"
        }
    ],
    "cost": 0.01194,
    "model_str": "gpt-5-mini"
}</code></pre>
        </div>
        <div class="section">
            <h2>Paper</h2>
            <div class="paper-content"><p>Synthesis of Parametric Programs using Genetic Programming and Model Checking</p>
<p>Gal Katz 
Department of Computer Science
Bar Ilan University Ramat Gan
52900Israel</p>
<p>Doron Peled 
Department of Computer Science
Bar Ilan University Ramat Gan
52900Israel</p>
<p>Synthesis of Parametric Programs using Genetic Programming and Model Checking
64C71B9B5C673D02E837550D6938322110.4204/EPTCS.140.5
Formal methods apply algorithms based on mathematical principles to enhance the reliability of systems.It would only be natural to try to progress from verification, model checking or testing a system against its formal specification into constructing it automatically.Classical algorithmic synthesis theory provides interesting algorithms but also alarming high complexity and undecidability results.The use of genetic programming, in combination of model checking and testing, provides a powerful heuristic to synthesize programs.The method is not completely automatic, as it is fine tuned by a user that sets up the specification and parameters.It also does not guarantee to always succeed and converge towards a solution that satisfies all the required properties.However, we applied it successfully on quite nontrivial examples and managed to find solutions to hard programming challenges, as well as to improve and to correct code.We describe here several versions of our method for synthesizing sequential and concurrent systems.</p>
<p>Introduction</p>
<p>Formal methods [16] assist software and hardware developers in enhancing the reliability of systems.They provide methods and tools to search for design and programming errors.While these methods are effective in the software development process, they also suffer from severe limitations: testing is not exhaustive, formal verification is extremely tedious and model checking is limited to particular domains (usually, finite state systems) and suffers from high complexity, where memory and time requirements are sometimes prohibitively high.</p>
<p>A natural progress from formal methods are algorithms for automatically converting the formal specification into code or a description of hardware.Such algorithms would create correct-by-design code or piece of hardware.However, high complexity [19] and even undecidability [20] appear in some main classical automatic synthesis problems.</p>
<p>The approach presented here is quite different from algorithmic synthesis.We perform a generateand-check kind of synthesis and use model checking or SAT solving to evaluate the generated candidates.An extreme approach would be to enumerate the possible programs (say, up to a certain size) and use model checking to find the correct solution(s).This was applied in Taubenfeld [3] to find mutual exclusion algorithms.Our synthesis method is based on genetic programming.It allows us to generate multiple candidate solutions at random and to mutate them, as a stochastic process.We employ enhanced model checking (model checking that does not only produce an affirmation to the checked properties or a counterexample, but distinguishes also some finer level of correctness) to provide fitness levels that are used to direct the search towards solutions that satisfy the given specification.Our synthesis method can be seen as a heuristic search in the space of syntactically fitting programs.It is not completely automatic, in the sense that the user can refine the specification and change the way the fitness is evaluated when the formal properties are satisfied.Our method is not guaranteed to terminate with a correct solution; we might give up after some time and can restart the search from a new random seed or with a refinement of the way the method assigns fitness.</p>
<p>Although this marriage between genetic programming and model checking is quite promising, it suffers from some limitations of model checking.First, model checking is primarily designed for finite state systems.Although some extensions of it exist (e.g., to programs with a single stack), model checking does not work in general for parametric systems.Unfortunately, most systems that we would like to synthesize are parametric in nature: almost every abstract algorithm on data structures, be it queue, tree, graph, is parametric, where the size of the structure, is not fixed.It is easy to demonstrate model checking on a sorting program with a fixed vector of numbers and some fixed initial assignment of values.However, when the length of the vector is parametric, and we need to prove correctness with respect to arbitrary set of values, existing model checking techniques often fail.</p>
<p>For this reason, we use model checking in our approach for synthesizing parametric systems not as a comprehensive method for finding correctness, but as a generalized testing tool, which can make exhaustive checks for fixed parameters.Under this setting, we accept candidate programs when there is ample evidence that they are correct, specifically, when they passed enough checks, rather than when we establish comprehensive correctness.</p>
<p>Our genetic programming synthesis approach allows us not only to generate code that satisfies a given temporal specification but also to improve and correct code.We can start with an existing solution for a specification, and use the genetic process to improve it.We can also start with some flawed version of the code and use our method to correct it.</p>
<p>Genetic Programming Based on Model Checking</p>
<p>We present in [8,9,10,11,12] a framework combining genetic programming and model checking, which allows to automatically synthesize code for given problems.The framework we suggest is depicted in Figure 1.</p>
<p>• The formal specification of the problem, as well as the required architecture and constraints on the structure of the desired solutions is provided by the user.This may also include some initial versions of the desired code that either need correction or improvement.</p>
<p>• An enhanced GP engine that generates random programs and then evolves them using mutation operations that allow to change the code randomly.</p>
<p>• A verifier that analyzes the generated programs, and provides useful information about their correctness.This can be a model checker, often enhanced to provide more information than yes/no (and counterexample), or a SAT solver.</p>
<p>The synthesis process goes through the following steps:</p>
<p>1.The user feeds the GP engine with the desired architecture and a set of constraints regarding the programs that are allowed to be generated.This includes:</p>
<p>(a) a set of functions literals and instructions used as building blocks for the generated programs, (b) the number of concurrent processes, the methods of communication between processes (in case of concurrent programs), (c) limitations on the size and structure of the generated programs, and the maximal number of permitted iterations.(d) The user may also provide some initial versions of the code that may be either incorrect or suboptimal.The genetic process can exploit these versions to evolve into better (correct or optimized) code.The user provides a formal specification for the problem.This consists, in our case, of a set of linear temporal logic properties, as well as additional quantitative requirements on the program behavior.</p>
<ol>
<li>
<p>The GP engine randomly generates an initial population of candidate programs based on the provided building blocks and constraints.</p>
</li>
<li>
<p>The verifier analyzes the behavior of the generated candidates against the specification properties, and provides fitness measures based on the amount of satisfaction.</p>
</li>
<li>
<p>The GP engine creates new programs by applying the genetic operations of mutation, which performs small random changes to the code, and crossover, which glues together parts of different candidate solutions.Steps 4 and 5 are repeated until either a perfect program is found (fully satisfying the specification), or until the maximal number of iterations is reached.</p>
</li>
</ol>
<p>6.The results are sent back to the user.This includes programs that satisfy all the specification properties, if one exists, or the best partially correct programs that was found, along with its verification results.For steps 4 and 5 above, we use the following selection method: • Randomly select µ candidate programs.</p>
<p>• Create λ new candidates by applying mutation (and optionally crossover) operations (as explained below) to the above µ candidates.We now have µ + λ candidates.• Calculate the fitness function for each of the new candidates based on "enhanced model checking".</p>
<p>• Based on the calculated fitness, choose new µ candidates from the set of µ + λ candidates.Candidates with higher fitness values are selected with a higher probability than others.Replace the originally selected µ with the ones selected at this step.We represent programs as trees, where an instruction or an expression is represented by a single node, having its parameters as its offspring.Terminal nodes represent constants.Examples of the instructions we use are assignment, while , if and block.The latter construct is a sequential composition of a pair of instructions.</p>
<p>At the first step, an initial population of candidate programs is generated.Each program is generated recursively, starting from the root, adding nodes until the tree is completed.The root node is chosen randomly from the set of instruction nodes, and each child node is chosen randomly from the set of nodes allowed by its parent type, and its place in the parameter list.Figure 2(i) shows an example of a randomly created tree that represents the following program:
while (A[2] != 0) A[me] = 1
The main operation we use is mutation.It allows making small changes on existing trees.The mutation includes the following steps:</p>
<ol>
<li>
<p>Randomly choose a node s from the program tree.</p>
</li>
<li>
<p>Apply one of the following operations to the tree with respect to ihe chosen node: (a) Replace the subtree with root s with a new randomly generated subtree.(b) Add an immediate parent to s. Randomly create other offspring to the new parent, if needed.(c) Replace the node s by one of its offspring.Delete the remaining offspring of that node.(d) Delete the subtree with root s.The node ancestors should be updated recursively.Mutation of type (a) can replace either a single terminal or an entire subtree.For example, the terminal "1" in the tree of Figure 2(i), is replaced by the grayed subtree in 2(ii), changing the assignment instruction into A[me] = A[0].Mutations of type (b) can extend programs in several ways, depending on the new parent node type.In case a "block" type is chosen, a new instruction(s) will be inserted before or after the mutation node.For instance, the grayed part of Figure 3 represents a second assignment instruction inserted into the original program.Similarly, choosing a parent node of type "while" will have the effect of wrapping the mutation node with a while loop.The type of mutation applied to candidate programs is randomly selected.All mutations must of course produce legal code.This affects the possible mutation type for the chosen node, and the type of new generated nodes.</p>
</li>
</ol>
<p>Another operation that is frequently used in genetic programming is crossover.The crossover operation creates new candidates by merging building blocks of two existing programs.The crossover steps are: 2. Randomly choose a node from the second program that has the same type as the first node.</p>
<ol>
<li>Exchange between the subtrees rooted by the two nodes, and use the two new programs created by this method.</li>
</ol>
<p>While traditional GP is heavily based on crossover, it is quite a controversial operation (see [2], for example).Crossover is not used in our work.</p>
<p>Fitness is used by GP in order to choose which programs have a higher probability to survive and participate in the genetic operations.In addition, the success termination criterion of the GP algorithm is based on the fitness value of the most fitted candidate.Traditionally, the fitness function is calculated by running the program on some set of inputs (a training set), which represent the possible inputs.In contrast, our fitness function is not based on running the programs on sample data, but on an enhanced model checking procedure.While the classical model checking provides a yes/no answer to the satisfiablity of the specification (thus yielding a two-valued fitness function), our model checking algorithm generates a smoother function by providing several levels of correctness.Often, we have the following four levels of correctness, per each linear temporal logic property:</p>
<ol>
<li>
<p>None of the executions of the program satisfy the property.</p>
</li>
<li>
<p>Some, but not all the executions of the program satisfy the property.</p>
</li>
<li>
<p>The only executions that do not satisfy the property must have infinitely many decisions that avoid a path that does satisfy the property.</p>
</li>
<li>
<p>All the executions satisfy the property.</p>
</li>
</ol>
<p>We provided several methods for generating the various fitness levels:</p>
<p>• Using Streett Automata, and a strongly-connected component analysis of the program graph [9].</p>
<p>• Enhanced model checking logic and algorithm [8,15].</p>
<p>• Probabilistic model checking.</p>
<p>There are several other considerations in setting up the calculation of the fitness.First, priority between the properties is used to suppress assigning fitness value due to the satisfaction of a liveness property (e.g., "when a process wants to enter its critical section, it would eventually be able to do so") when the safety property does not hold (e.g., "the two processes cannot enter their critical sections simultaneously").Another consideration is to prevent needless growth of the program by useless code.To alleviate this, we use some negative fitness value related to the program's length.This entails that a solution that satisfies all the specification is accepted even if it does not have perfect fitness value (due to length).</p>
<p>Example: Mutual Exclusion Algorithms</p>
<p>As an example, we used our method in order to automatically generate solutions to several variants of the Mutual Exclusion Problem.In this problem, first described and solved by Dijkstra [5], two or more processes are repeatedly running critical and non-critical sections of a program.The goal is to avoid the simultaneous execution of the critical section by more than one process.We limit our search for solutions to the case of only two processes.The problem is modeled using the following program parts that are executed in an infinite loop:
Non Critical Section Pre Protocol Critical Section Post Protocol
These parts are fixed, and, together with the number of processes involved (two) and the number of variables allowed, consist of the architecture provided to our genetic programming tool, together with the temporal specification.</p>
<p>The Non Critical Section part represents the process part on which it does not require an access to the shared resource.A process can make a nondeterministic choice whether to stay in that part, or to move into the Pre Protocol part.From the Critical Section part, a process always has to move into the Post Protocol part.The Non Critical Section and Critical Section parts are fixed, while our goal is to automatically generate code for the Pre Protocol and Post Protocol parts, such that the entire program will fully satisfy the problem's specification.</p>
<p>We use a restricted high level language based on the C language.Each process has access to its id (0 or 1) by the me literal, and to the other process' id by the other literal.The processes can use an array of shared bits with a size depended on the exact variant of the problem we wish to solve.The two processes run the same code.The available node types are: assignment, if, while, empty-while, block, and, or and array.Terminals include the constants: 0, 1, 2, me and other.</p>
<p>Table 1 describes the properties that define the problem specification.The four program parts are denoted by NonCS, Pre, CS and Post respectively.Property 1 is the basic safety property requiring the mutual exclusion.Properties displayed in pairs are symmetrically defined for the two processes.Prop-erties 2 and 3 guarantee that the processes are not hung in the Post Protocol part.Similar properties for the Critical Section are not needed, since it is a fixed part without an evolved code.Properties 4 and 5 require that a process can enter the critical section, if it is the only process trying to enter it.Property 6 requires that if both processes are trying to enter the critical section, at least one of them will eventually succeed.This property can be replaced by the stronger requirements 7 and 8 that guarantee that no process will starve.</p>
<p>There are several known solutions to the Mutual Exclusion problem, depending on the number of shared bits in use, the type of conditions allowed (simple / complex) and whether starvation-freedom is required.The variants of the problem we wish to solve are showed in Table 2. Three different configurations where used, in order to search for solutions to the variants described in Table 2.Each run included the creation of 150 initial programs by the GP engine, and the iterative creation of new programs until a perfect solution was found, or until a maximum of 2000 iterations.At each iteration, 5 programs were randomly selected, bred, and replaced using mutation.The values µ = 5, λ = 150 where chosen.</p>
<p>In addition to the temporal specification of mutual exclusion, our configuration allows three shared bits.The famous Dekker's algorithm [5] uses two bits to announce that they want to enter the critical section, and the third bit is used to set turns between the two processes.Many runs initially converged into deadlock-free algorithms using only two bits.Those algorithms have executions in which one of the processes starve, hence only partially satisfying properties 7 or 8. Program (a) shows one of those algorithms, which later evolved into program (b).The evolution first included the addition of the second line to the post protocol section (which only slightly decreased its fitness level due to the parsimony measure).A replacement mutation then changed the inner while loop condition, leading to a perfect solution similar to Dekker's algorithm.</p>
<p>Non Critical Section</p>
<p>Non Critical Section A
[me] = 1 A[me] = 1 While (A[other] == 1) While (A[other] == 1) While (A[0] != other) While (A[2] == me) A[me] = 0 A[me] = 0 A[me] = 1 A[me] = 1 Critical Section Critical Section A[me] = 0 A[2] = me A[me] = 0 (a) [94.34] (b) [96.70]
Inspired by algorithms developed by Tsay [21] and by Kessels [13], our next goal was to start from an existing algorithm, and by adding more constraints and building blocks, try to evolve into more advanced algorithms.</p>
<p>First, we allowed a minor asymmetry between the two processes.This is done by the operators not0 and not1, which act only on one of the processes.Thus, for process 0, not0(x) = ¬x while for process 1, not0(x) = x.This is reversed for not1(x), which negates its bit operand x only in process 1, and do nothing on process 0.</p>
<p>As a result, the tool found two algorithms that may be considered simpler than Peterson's.The first one has only one condition in the wait statement (written here using the syntax of a while loop), although with a more complicated atomic comparison, between two bits.Note that the variable turn is in fact A [2] and is renamed here turn to accord with classical presentation of the extra global bit that does not belong to a specific process.</p>
<p>Pre CS A[me] = 1 turn = me While (A[other] != not1(turn)); Critical Section A[me] = 0</p>
<p>The second algorithm uses the idea of setting the turn bit one more time after leaving the critical section.This allows the while condition to be even simpler.Tsay [21] used a similar refinement, but his algorithm needs an additional if statement, which is not used in our algorithm.</p>
<p>Pre CS A[me] = 1 turn = not0(A[other]) While (A[2] != me); Critical Section A[me] = 0 turn = other</p>
<p>Next, we aimed at finding more advanced algorithms satisfying additional properties.The configuration was extended into four shared bits and two private bits (one for each process).The first requirement was that each process can change only its 2 local bits, but can read all of the 4 shared bits This yielded the following algorithm.</p>
<p>Pre CS A[me] = 1 B[me] = not1(B[other]) While (A[other] == 1 and B[0] == not1(B[1])); Critical Section A[me] = 0</p>
<p>The algorithm uses the idea of using two bits as the "turn", were each process changes only its bit to set its turn, but compares both of them in the while loop.Finally, we added the requirement for busy waiting only on local bits (i.e. using local spins).The following algorithm (similar to Kessels') was generated, satisfying all properties from the table above.</p>
<p>Non Critical Section A[other] = 1 B[other] = not1(B[0]) T[me] = not1(B[other]) While (A[me] == 1 and B[me] == T[me]); Critical Section A[other] = 0 4 Synthesizing Parametric Programs</p>
<p>Our experience with genetic program synthesis quickly hits a difficulty that stems from the limited power of model checking: there are few interesting fixed finite state programs that can also be completely specified using pure temporal logic.Most programming problems are, in fact, parametric.Model checking is undecidable for parametric families of programs (say, with n processes, each with the same code, initialized with different parameters) even for a fixed property [1].One may look at mutual exclusion for a parametric number of processes.Examples are, sorting, where the number of processes and the values to be sorted are the parameters, network algorithms, such as finding the leader in a set of processes, etc.In order to synthesize parametric concurrent programs, in particular those that have a parametric number of processes, and even a parametric architecture, we use a different genetic programming strategy.</p>
<p>First, we assume that a solution that is checked for a large number of instances/parameters is acceptable.This is not a guarantee of correctness, but under the prohibitive undecidability of model checking for parametric programs, at least we have a strong evidence that the solution may generalize to an arbitrary configuration.In fact, there are several works on particular cases where one can calculate the parameter size that guarantees that if all the smaller instances are correct, then any instance is correct [6].Unfortunately, this is not a rule that can be applied to any arbitrary parametric problem.We apply a coevolution based synthesis algorithm: we collect parameters from failed checked cases and keep them as counterexamples.When suggesting a new solution, we check it against the collected counterexamples.We can view this process as a genetic search for both correct programs and counterexamples.The fitness is different, of course, for both tasks: a program gets higher fitness by being close to satisfying the full set of properties, while a counterexample is obtaining a high fitness if it fails the program.</p>
<p>In this sense, the model checking of a particular set of instances can be considered as a generalized testing for these values: each set of instances of the parameters provides a single finite state system that is itself comprehensively tested using model checking.This idea can be also used, independently, for model checking parametric systems.For example, consider a concurrent sorting program consisting of a parametric array of processes, each containing some initial value.Adjacent processes may exchange values during the algorithm.For any particular size and set of values, the model checking provides automatic and exhaustive test for a particular set of values, but the check is not exhaustive for all the array sizes or array values, but rather samples them.</p>
<p>In the classical leader election in a ring problem, the processes initially have their own values that they can transfer around, with the goal of finding a process that has the highest value.Then, the parameters include the size of the ring, and the initial assignment of values to processes.While we can check solutions up to a certain size, and in addition, check all possible initial values, the time and state explosion is huge.Instead, we can then store each set of instances of the parameters that failed for some candidate solution, and, when checking a new candidate solution, check it against the failed instances.A solution for the leader election, albeit not the most optimal one, was obtained using our genetic programming methods [10].</p>
<p>Correcting Erroneous Program</p>
<p>Our method is not limited to finding new program that satisfy the given specification.In fact, we can start with the code of an existing program instead of a completely random population and try to improve or correct it.In order to improve code, our fitness measure may include some quantitative evaluation; then the initial program may be found inferior to some later generated candidates.If the program we start with is erroneous, then it would not get a very high fitness value by failing to satisfy some of the properties.</p>
<p>In [11] we approached the ambitious problem of correcting a known protocol for obtaining interprocess interaction called α-core [17].The algorithm allows multiparty synchronization of several processes.It needs to function in a system that allows nondeterministic choices, which makes it challenging, as processes that may consider one possible interaction may also decide to be engaged in another interaction.The algorithm uses asynchronous message passing in order to enforce selection of the interactions by the involved processes.This nontrivial algorithm, which is used in practice for distributed systems, contains an error.</p>
<p>The protocol is quite big, involving sending different messages between the controlled processes, and the controlling processes, one per each possible multiparty interaction.These messages include announcing the willingness to be engaged in an interaction, committing an interaction, canceling an interaction, request for commit from the interaction manager processes, as well as announcement that the interaction can start, or is canceled due to the departure of at least one participant.The state space of such a protocol is obviously high.In addition, the protocol can run on any number of processes, each process with arbitrary number of choices to be involves in interactions, and each interaction includes any number of processes.</p>
<p>Recall that model checking of parametric programs is undecidable in general [1].In fact, we use our genetic programming approach first to find the error, and then to correct it.We use two important ideas:</p>
<ol>
<li>
<p>Use the genetic engine not only to generate programs, but also to evolve different architectures on which programs can run.</p>
</li>
<li>
<p>Apply a co-evolution process, where candidate programs, and test cases (architectures) that may fail these programs, are evolved in parallel.Specifically, the architecture for the candidate programs is also represented as code (or, equivalently, a syntactic tree) for spanning processes and their interactions, which can be subjected to genetic mutations.The fitness function directs the search for a program that may falsify the specification for the given erroneous program.After finding a "bad" architecture for a program, one that causes the program to fail its specification, our next goal is to reverse the genetic programming direction, and try to automatically correct the program, where a "correct" program at this step, is one that has passed model checking against the architecture.Yet, correcting the program for the first found wrong architecture only, does not guarantee its correctness under different architectures, hence more architectures that fail candidate solutions are collected.Note that we use for the co-evolution two separate fitness functions: one for searching for "bad" architectures, and one for searching for a correct solution.</p>
</li>
</ol>
<p>In Figure 4 we show the architecture that was found to produce the error in the original α-core algorithm.A message sequence chart in Figure 5  OFFER (1) OFFER ( 2) OFFER (3) n=1 OFFER (4) n=2 LOCK ( 5) OK ( 6) LOCK ( 7) OK ( 8) LOCK ( 9) START ( 10) REFUSE (11) START ( 12) REFUSE ( 13) ACKREF ( 14) UNLOCK (15) n=0 OFFER ( 16) OFFER (17) n=1 n=0 ACKREF (18) msc Assertion violation</p>
<p>A Tool for Genetic Programming Based on Model Checking</p>
<p>We constructed a tool, MCGP [12], that implements our ideas about model checking based genetic programming.Depending on these settings, the tool can be used for several purposes:</p>
<p>• Setting all parts as static will cause the tool to just run the enhanced model checking algorithm on the user-defined program, and provide its detailed results.</p>
<p>• Setting the init process as static and all or some of the other processes as dynamic will order the tool to synthesize code according to the specified architecture.This can be used for synthesizing programs from scratch, synthesizing only some missing parts of a given partial program, or trying to correct or improve a complete given program.</p>
<p>• Setting the init process as dynamic and all other processes as static, is used when trying to falsify a given parametric program by searching for a configuration that violates its specification (see [11]).• Setting both the init and the program processes as dynamic is used for synthesizing parametric programs, where the tool alternatively evolves various programs and configurations under which the programs have to be satisfied.</p>
<p>Replacing Model Checking by SAT Solving</p>
<p>Our approach can use automated deductive techniques instead of model checking in order to prove the correctness of the synthesized algorithms.However, it requires the verification procedures to be both fully automatic, and quite fast, so it can be repeated a large number of times.Obviously, most theorem provers that require some user interaction during the proof process cannot be used along with our framework.Furthermore, verification in this case is in general undecidable, so fast and complete procedure is not achievable.</p>
<p>Recently, there is a growing use of SAT and SMT solvers for verification purposes.These tools can function as high performance, and light-weight theorem provers for a broad range of decidable theories over first order logic, such as those of equalities with uninterpreted functions, bit-vectors and arrays.If we restrict our domain and structure of the synthesized programs as shown later, we can successfully (and quite quickly) verify their correctness for all inputs in the related domains.For some theories, variables are theoretically unbounded, while for other theories, we must limit their width.</p>
<p>Our work is inspired by [7], in which a set of short but ingenious and nontrivial programs, selected from the book Hacker's Delight [22], were successfully synthesized.These programs are loop-free, and use expressions over the decidable theory of bit-vectors.Thus, they can be easily converted into first order formulas which can then be verified by an SMT solver.The theory of bit-vectors is decidable only when limiting the width of its related variables.From a practical point of view, this does not impose a real constraint, since we can easily check the correctness of programs even with 128-bit variables.Unlike [7], we do not use the SMT solver for the direct synthesis of programs.Instead, we generate and evolve programs using our GP engine, and integrate the SMT solver into our verification component.</p>
<p>We modify our original framework in order to adopt it to the synthesis of sequential programs.In this new framework, the configuration provided by the user to the GP engine includes a set of building blocks, such as variables and functions that are related to the theory in use.Only loop-free programs are generated.The specification provided by the user consists of first order logic formulas describing pre and post-conditions over the above variables.A new verification component is built for dealing with sequential programs, including two modules.A Prover module is able to get programs from the GP engine, and transfer them into logical formulas that are then checked for correctness by the SMT solver against the specification.The results received from the SMT solver are then used for calculating the fitness function, and for generating counterexamples.The core of this module is based on the Microsoft Z3 SMT Solver [14].A Runner module is able to run programs directly, and check their correctness for specific given test cases.</p>
<p>For sequential programs, we can use the Hoare notation {ϕ}P{ψ} to denote the requirement that if the execution of the program starts with a state satisfying the (first order formula) ϕ, upon termination, it satisfies ψ.The formula ϕ is over the input variables.Assume they do not change.Otherwise, we can use an additional copy of them; a fixed part of the code copies them to the changeable copy.The formula ψ represents the connection between the input and output variables upon termination.Termination is not an issue here, as our generated loop-free programs must always terminate by construction (they contain no loops).Let ϕ be the common precondition and ψ 1 ..ψ n be a set of post-conditions.We want to check for each ψ i whether {ϕ}P{ψ i } holds.Using standard construction, we obtain a formula η P that represents the relationship between the input and output variables.</p>
<p>For each postcondition ψ i we define
F i := ϕ ∧ η P ∧ ¬ψ i and F ′ i := ϕ ∧ η P ∧ ψ i
We can define the following three fitness levels in order of increasing value:</p>
<ol>
<li>F ′ i is not satisfiable.Then, the program P is incorrect (w.r.t.ψ i ) for all possible inputs.2. both F i and F ′ i are satisfiable.There exists an input for which P satisfies ψ i .3. F i is unsatisfiable.P is correct (for all inputs).</li>
</ol>
<p>As an example for using our basic method, we tried first to synthesize one of the simplest programs from [22], which is required to output 0 in the variable R if and only if its input X equals 2 n − 1 for some non-negative n.The GP engine was allowed to generate straight line programs, using only assignment instructions, bit-vectors related operators (such as and, or and xor) constants (0 and 1), and variables.Within a few seconds, the following correct program was generated.</p>
<p>T = X + 1 R = T and X</p>
<p>Solutions found by the method described above are guaranteed to be correct for every possible input (in the domain of the variables, such as bit-vectors with a specific width).This is a major advantage over solutions generated by traditional GP, which can usually guarantee correctness only for the set of test cases.However, using test cases can help in building a smoother fitness function that can direct the generated programs into gradual improvements.Hence, we used for calculating the fitness function, in addition to the above satisfiability based levels, a collection of test cases that failed on previous selected candidates.Each test case is obtained using the SAT solver when checking satisfiability of F i on a previous candidate program.It consists of initial values from which we can run new checked candidates.Note that running the code on test cases, using the runner module, is faster than applying SAT solving using prover module.</p>
<p>After adding the ability to use test cases, we tried to synthesize a more advanced program that is required to compute the floor of the average of its inputs X and Y without overflowing (which may be caused by simply summing the inputs before dividing by two). Figure 7 shows some of the programs generated during the synthesis process (the logical shift right operator is denoted by "&gt;&gt;").</p>
<p>Program (a) is the naive way for computing the average.However, the addition may cause an overflow, and indeed the program was refuted by the SMT solver, yielding a counterexample with big inputs.At the next iteration, program (b) was generated.While not overflowing, the program is still incorrect if both of its inputs are odd, which was reflected by a second counterexample.Finally, the more ingenious program (c) was generated, and verified to be a correct solution (identical to the one presented in [22]).</p>
<p>Conclusions</p>
<p>We suggested the use of a methodology and a tool that perform synthesis of programs based on genetic programming guided by model checking.Code mutation is at the kernel of genetic programming (crossover is also extensively used, but we did not implement it).Our method can be used for</p>
<p>• synthesizing correct-by-design programs,</p>
<p>• finding errors in protocols with complicated architectures,</p>
<p>• automatically correcting erroneous code with respect to a given specification, and</p>
<p>• improving code, e.g., to perform more efficiently.</p>
<p>We demonstrated our method on the classical mutual exclusion problem, and were able to find existing solutions, as well as new solutions.</p>
<p>In general, the verification of parametric systems is undecidable, and in the few methods that promise termination, quite severe restrictions are required.The same apply to code synthesis.Nevertheless, we provide a co-evolution method for synthesizing parametric systems based on accumulating cases to be checked.Parameters or architectures on which the synthesis failed before, or test cases based on previous counterexamples are accumulated to be checked later with new candidate solutions.As the model checking itself is undecidable, we finish if we obtain a strong enough evidence that the solution is correct on the accumulated cases.</p>
<p>We allowed constructing the architecture (processes and the channels between them) as part of the code that can be mutated.Then the genetic mutation operation can be used in finding architectures in which given algorithms fail.This can be used to model check code with varying architecture, and furthermore, to correct it.</p>
<p>We started recently to look at replacing model checking by SAT and SMT tools.This provides an efficient alternative for some synthesis problem.In particular, SMT solvers may succeed in some parametric cases where model checking fails.</p>
<p>Although our method does not guarantee termination, neither for finding the error, nor for finding a correct version of the algorithm, it is quite general and can be fine tuned through provided heuristics in a convenient human-assisted process of code correction.</p>
<p>Figure 1 :
1
Figure 1: The Suggested Framework</p>
<p>Figure 2 :
2
Figure 2: (i) Randomly created program tree, (ii) the result of a replacement mutation</p>
<p>1 Figure 3 :
13
Figure 3: Tree after insertion mutation</p>
<p>Figure 4 :
4
Figure 4: An architecture violating the assertion</p>
<p>Figure 5 :
5
Figure 5: A Message Sequence Chart showing the counterexample for the α-core protocol</p>
<p>Figure 6 :
6
Figure 6: MCGP screen shot during synthesis of a mutual exclusion algorithm</p>
<p>Figure 7 :
7
Figure 7: Synthesized Programs for Computing avg(X,Y)</p>
<p>Table 1 :
1
Mutual Exclusion Specification
No. TypeDefinitionDescriptionLevel1Safety✷¬(p 0 in CS ∧ p 1 in CS)Mutual Exclusion12,3 Liveness ✷(p me in Post → ✸(p me in NonCS))Progress24,5✷(p me in Pre ∧ ✷(p other in NonCS)) →No Contest3✸(p me in CS))6✷((p 0 in Pre ∧ p 1 in Pre) → ✸(p 0 inDeadlock Freedom 4CS ∨ p 1 in CS))7,8✷(p
me in Pre → ✸(p me in CS)) Starvation 4</p>
<p>Table 2 :
2
Mutual Exclusion Variants
VariantNumberConditions RequirementRelevantKnown algorithmNo.of bitsproperties12SimpleDeadlock Freedom1,2,3,4,5,6One bit protocol [4]23SimpleStarvation Freedom 1,2,3,4,5,7,8 Dekker [5]33ComplexStarvation Freedom 1,2,3,4,5,7,8 Peterson [18]</p>
<p>Limits for Automatic Verification of Finite-State Concurrent Systems. R Krzysztof, Apt, Dexter Kozen, 10.1016/0020-0190(86)90071-2Inf. Process. Lett. 2261986</p>
<p>Genetic Programming -An Introduction; On the Automatic Evolution of Computer Programs and its Applications. W Banzhaf, P Nordin, R E Keller, F D Francone, 2001Morgan Kaufmann3rd edition. dpunkt.verlag</p>
<p>Automatic discovery of mutual exclusion algorithms. Yoah Bar, - David, Gadi Taubenfeld, 10.1145/872035.8720802003PODC305</p>
<p>Bounds on Shared Memory for Mutual Exclusion. James E Burns, Nancy A Lynch, 10.1006/inco.1993.1065Information and Computation. 10721993</p>
<p>Solution of a problem in concurrent programming control. W Edsger, Dijkstra, 10.1145/365559.365617Commun. ACM. 895691965</p>
<p>Reasoning about Rings. E , Allen Emerson &amp; Kedar, S Namjoshi, 10.1145/199448.199468POPL. 1995</p>
<p>Synthesis of loop-free programs. Sumit Gulwani, Susmit Jha, Ashish Tiwari, Ramarathnam Venkatesan, 10.1145/1993498.19935062011PLDI</p>
<p>Genetic Programming and Model Checking: Synthesizing New Mutual Exclusion Algorithms. Gal Katz, Doron Peled, 10.1007/978-3-540-88387-6_5ATVA. 53112008</p>
<p>Model Checking-Based Genetic Programming with an Application to Mutual Exclusion. Gal Katz, Doron Peled, 10.1007/978-3-540-78800-3_11TACAS. 49632008</p>
<p>Synthesizing Solutions to the Leader Election Problem using Model Checking and Genetic Programming. Gal Katz, Doron Peled, 10.1007/978-3-642-19237-1_13LNCS. 64052009HVC</p>
<p>Code Mutation in Verification and Automatic Code Correction. 10.1007/978-3-642-12002-2_36TACAS, LNCS2010</p>
<p>MCGP: A Software Synthesis Tool Based on Model Checking and Genetic Programming. 10.1007/978-3-642-15643-4_28ATVA. Gal Katz &amp; Doron Peled2010</p>
<p>Arbitration Without Common Modifiable Variables. L W Joep, Kessels, 10.1007/BF00288966Acta Inf. 171982</p>
<p>Z3: An Efficient SMT Solver. 10.1007/978-3-540-78800-3_24TACAS. Leonardo Mendon¸ca de Moura &amp; Nikolaj Bjørner2008</p>
<p>10.1007/978-3-540-70545-1_48Discriminative Model Checking. In: CAV. Peter Niebert, Doron Peled, Amir Pnueli, Springer20085123</p>
<p>Doron Peled, 10.1007/978-1-4757-3540-6Software Reliability Methods. Springer2001</p>
<p>An order-based algorithm for implementing multiparty synchronization. Jose Antonio Perez, Rafael Corchuelo, Miguel Toro, 10.1002/cpe.903Concurrency -Practice and Experience. 16122004</p>
<p>Economical Solutions to the Critical Section Problem in a Distributed System. Fischer Peterson, 10.1145/800105.803398STOC: ACM Symposium on Theory of Computing (STOC). 1977</p>
<p>On the Synthesis of a Reactive Module. Amir Pnueli, Roni Rosner, 10.1145/75277.75293POPL. 1989</p>
<p>Distributed Reactive Systems Are Hard to Synthesize. Amir Pnueli, Roni Rosner, 10.1109/FSCS.1990.89597FOCS. 1990</p>
<p>Deriving a Scalable Algorithm for Mutual Exclusion. Yih-Kuen Tsay, 10.1007/BFb0056497DISC. 1998</p>
<p>Hacker's Delight. Henry S Warren, 2002Addison-Wesley Longman Publishing Co., IncBoston, MA, USA</p>            </div>
        </div>

    </div>
</body>
</html>