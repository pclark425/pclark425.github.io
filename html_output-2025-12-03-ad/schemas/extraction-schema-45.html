<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extraction Schema extraction-schema-45 - Theorizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="header">
        <a href="../index.html"><i class="fas fa-flask"></i> Theorizer</a>
    </div>

    <div class="content">
        <h1>Extraction Schema Details for extraction-schema-45</h1>

        <div class="section">
            <h2>Extraction Schema (General Information)</h2>
            <div class="info-section">
                <p><strong>Schema ID:</strong> extraction-schema-45</p>
                <p><strong>Extraction Query:</strong> Extract any mentions of adaptive, learned, or parameterized operators (mutation, crossover, variation operators) in evolutionary algorithms, genetic algorithms, or genetic programming, including performance comparisons, operator representations, and results on code or text domains.</p>
            </div>
        </div>

        <div class="section">
            <h2>Extraction Schema (Details)</h2>
            <table>
                <thead>
                    <tr>
                        <th style="width: 20%;">Field Name</th>
                        <th style="width: 15%;">Type</th>
                        <th style="width: 65%;">Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>operator_name</strong></td>
                        <td>str</td>
                        <td>The name or identifier of the operator being studied (e.g., 'adaptive mutation', 'learned crossover', 'bandit-based operator selection', etc.)</td>
                    </tr>
                    <tr>
                        <td><strong>operator_type</strong></td>
                        <td>str</td>
                        <td>The category of operator: 'mutation', 'crossover', 'variation', 'selection', 'hybrid', or 'other'. Specify if multiple types.</td>
                    </tr>
                    <tr>
                        <td><strong>operator_description</strong></td>
                        <td>str</td>
                        <td>A detailed description of how the operator works, including its mechanism and any key properties.</td>
                    </tr>
                    <tr>
                        <td><strong>is_learned_or_adaptive</strong></td>
                        <td>bool</td>
                        <td>Is this operator learned, adaptive, or parameterized (true), or is it a fixed hand-designed operator (false)?</td>
                    </tr>
                    <tr>
                        <td><strong>learning_mechanism</strong></td>
                        <td>str</td>
                        <td>If the operator is learned/adaptive, describe the learning mechanism (e.g., 'reinforcement learning', 'bandit algorithm', 'gradient descent', 'meta-learning', 'evolutionary optimization', etc.). Null if not applicable.</td>
                    </tr>
                    <tr>
                        <td><strong>operator_representation</strong></td>
                        <td>str</td>
                        <td>How is the operator represented? (e.g., 'parameterized function', 'neural network', 'probability distribution', 'rule set', 'program', etc.). Null if not specified.</td>
                    </tr>
                    <tr>
                        <td><strong>domain_type</strong></td>
                        <td>str</td>
                        <td>What domain is the operator applied to? (e.g., 'code/programs', 'natural language/text', 'numerical optimization', 'combinatorial', 'hybrid code-text', etc.)</td>
                    </tr>
                    <tr>
                        <td><strong>context_dependent</strong></td>
                        <td>bool</td>
                        <td>Does the operator adapt based on context, population state, or search progress (true), or does it operate uniformly (false)? Null if not specified.</td>
                    </tr>
                    <tr>
                        <td><strong>modality_specific</strong></td>
                        <td>bool</td>
                        <td>Are there different operators or operator parameters for different modalities (e.g., separate operators for code vs. text)? True if yes, false if universal operator, null if not applicable.</td>
                    </tr>
                    <tr>
                        <td><strong>compositional</strong></td>
                        <td>bool</td>
                        <td>Is the operator compositional (combining multiple primitive operations)? True if yes, false if atomic, null if not specified.</td>
                    </tr>
                    <tr>
                        <td><strong>performance_metric</strong></td>
                        <td>str</td>
                        <td>What metric(s) were used to evaluate the operator? (e.g., 'solution quality', 'convergence speed', 'diversity', 'novelty', 'executability rate', 'Pareto frontier coverage', etc.)</td>
                    </tr>
                    <tr>
                        <td><strong>performance_learned_operator</strong></td>
                        <td>str</td>
                        <td>Performance of the learned/adaptive operator on the task. Include numerical values with units. Null if not applicable or not reported.</td>
                    </tr>
                    <tr>
                        <td><strong>performance_fixed_operator</strong></td>
                        <td>str</td>
                        <td>Performance of fixed/hand-designed baseline operator(s) on the same task for comparison. Include numerical values with units. Null if not reported.</td>
                    </tr>
                    <tr>
                        <td><strong>performance_improvement</strong></td>
                        <td>str</td>
                        <td>Quantified improvement of learned/adaptive operator over baseline (e.g., '30% better', '2x faster convergence'). Null if not reported or not applicable.</td>
                    </tr>
                    <tr>
                        <td><strong>has_comparison</strong></td>
                        <td>bool</td>
                        <td>Does the paper directly compare learned/adaptive operators against fixed operators? True if yes, false if no.</td>
                    </tr>
                    <tr>
                        <td><strong>executability_preservation</strong></td>
                        <td>str</td>
                        <td>For code/program domains: what percentage or rate of generated variants remain executable? Include numerical values. Null if not applicable or not reported.</td>
                    </tr>
                    <tr>
                        <td><strong>novelty_diversity_metric</strong></td>
                        <td>str</td>
                        <td>How is novelty or diversity measured? Include specific metrics and values if reported (e.g., 'behavioral diversity score: 0.85', 'unique solutions: 150'). Null if not reported.</td>
                    </tr>
                    <tr>
                        <td><strong>transfer_learning</strong></td>
                        <td>bool</td>
                        <td>Does the paper study transfer of learned operators across different problems or domains? True if yes, false if no.</td>
                    </tr>
                    <tr>
                        <td><strong>transfer_results</strong></td>
                        <td>str</td>
                        <td>If transfer learning was studied, what were the results? (e.g., 'operators transferred with 80% of original performance', 'required 50% less training on new domain'). Null if not applicable.</td>
                    </tr>
                    <tr>
                        <td><strong>computational_cost</strong></td>
                        <td>str</td>
                        <td>What is the computational overhead of learning/adapting operators compared to using fixed operators? Include quantitative comparisons if available. Null if not reported.</td>
                    </tr>
                    <tr>
                        <td><strong>population_size</strong></td>
                        <td>str</td>
                        <td>What population size was used in experiments? (e.g., '100', '50-200', 'varies'). Null if not specified.</td>
                    </tr>
                    <tr>
                        <td><strong>cold_start_addressed</strong></td>
                        <td>bool</td>
                        <td>Does the paper address the cold-start problem (how operators perform with no prior data)? True if yes, false if no.</td>
                    </tr>
                    <tr>
                        <td><strong>operator_specialization</strong></td>
                        <td>str</td>
                        <td>Does the paper find evidence of operator specialization over time or for different problem types? Describe findings. Null if not studied.</td>
                    </tr>
                    <tr>
                        <td><strong>key_findings</strong></td>
                        <td>str</td>
                        <td>Summarize the key findings about operator learning/adaptation in 1-2 concise sentences, focusing on results most relevant to understanding when and why learned operators succeed or fail.</td>
                    </tr>
                    <tr>
                        <td><strong>limitations_or_failures</strong></td>
                        <td>str</td>
                        <td>What limitations, failure cases, or negative results are reported about learned/adaptive operators? (e.g., 'failed on small populations', 'no benefit for simple problems', 'high computational cost'). Null if none reported.</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>Extraction Schema (Debug)</h2>
            <pre><code>{
    "id": "extraction-schema-45",
    "schema": [
        {
            "name": "operator_name",
            "type": "str",
            "description": "The name or identifier of the operator being studied (e.g., 'adaptive mutation', 'learned crossover', 'bandit-based operator selection', etc.)"
        },
        {
            "name": "operator_type",
            "type": "str",
            "description": "The category of operator: 'mutation', 'crossover', 'variation', 'selection', 'hybrid', or 'other'. Specify if multiple types."
        },
        {
            "name": "operator_description",
            "type": "str",
            "description": "A detailed description of how the operator works, including its mechanism and any key properties."
        },
        {
            "name": "is_learned_or_adaptive",
            "type": "bool",
            "description": "Is this operator learned, adaptive, or parameterized (true), or is it a fixed hand-designed operator (false)?"
        },
        {
            "name": "learning_mechanism",
            "type": "str",
            "description": "If the operator is learned/adaptive, describe the learning mechanism (e.g., 'reinforcement learning', 'bandit algorithm', 'gradient descent', 'meta-learning', 'evolutionary optimization', etc.). Null if not applicable."
        },
        {
            "name": "operator_representation",
            "type": "str",
            "description": "How is the operator represented? (e.g., 'parameterized function', 'neural network', 'probability distribution', 'rule set', 'program', etc.). Null if not specified."
        },
        {
            "name": "domain_type",
            "type": "str",
            "description": "What domain is the operator applied to? (e.g., 'code/programs', 'natural language/text', 'numerical optimization', 'combinatorial', 'hybrid code-text', etc.)"
        },
        {
            "name": "context_dependent",
            "type": "bool",
            "description": "Does the operator adapt based on context, population state, or search progress (true), or does it operate uniformly (false)? Null if not specified."
        },
        {
            "name": "modality_specific",
            "type": "bool",
            "description": "Are there different operators or operator parameters for different modalities (e.g., separate operators for code vs. text)? True if yes, false if universal operator, null if not applicable."
        },
        {
            "name": "compositional",
            "type": "bool",
            "description": "Is the operator compositional (combining multiple primitive operations)? True if yes, false if atomic, null if not specified."
        },
        {
            "name": "performance_metric",
            "type": "str",
            "description": "What metric(s) were used to evaluate the operator? (e.g., 'solution quality', 'convergence speed', 'diversity', 'novelty', 'executability rate', 'Pareto frontier coverage', etc.)"
        },
        {
            "name": "performance_learned_operator",
            "type": "str",
            "description": "Performance of the learned/adaptive operator on the task. Include numerical values with units. Null if not applicable or not reported."
        },
        {
            "name": "performance_fixed_operator",
            "type": "str",
            "description": "Performance of fixed/hand-designed baseline operator(s) on the same task for comparison. Include numerical values with units. Null if not reported."
        },
        {
            "name": "performance_improvement",
            "type": "str",
            "description": "Quantified improvement of learned/adaptive operator over baseline (e.g., '30% better', '2x faster convergence'). Null if not reported or not applicable."
        },
        {
            "name": "has_comparison",
            "type": "bool",
            "description": "Does the paper directly compare learned/adaptive operators against fixed operators? True if yes, false if no."
        },
        {
            "name": "executability_preservation",
            "type": "str",
            "description": "For code/program domains: what percentage or rate of generated variants remain executable? Include numerical values. Null if not applicable or not reported."
        },
        {
            "name": "novelty_diversity_metric",
            "type": "str",
            "description": "How is novelty or diversity measured? Include specific metrics and values if reported (e.g., 'behavioral diversity score: 0.85', 'unique solutions: 150'). Null if not reported."
        },
        {
            "name": "transfer_learning",
            "type": "bool",
            "description": "Does the paper study transfer of learned operators across different problems or domains? True if yes, false if no."
        },
        {
            "name": "transfer_results",
            "type": "str",
            "description": "If transfer learning was studied, what were the results? (e.g., 'operators transferred with 80% of original performance', 'required 50% less training on new domain'). Null if not applicable."
        },
        {
            "name": "computational_cost",
            "type": "str",
            "description": "What is the computational overhead of learning/adapting operators compared to using fixed operators? Include quantitative comparisons if available. Null if not reported."
        },
        {
            "name": "population_size",
            "type": "str",
            "description": "What population size was used in experiments? (e.g., '100', '50-200', 'varies'). Null if not specified."
        },
        {
            "name": "cold_start_addressed",
            "type": "bool",
            "description": "Does the paper address the cold-start problem (how operators perform with no prior data)? True if yes, false if no."
        },
        {
            "name": "operator_specialization",
            "type": "str",
            "description": "Does the paper find evidence of operator specialization over time or for different problem types? Describe findings. Null if not studied."
        },
        {
            "name": "key_findings",
            "type": "str",
            "description": "Summarize the key findings about operator learning/adaptation in 1-2 concise sentences, focusing on results most relevant to understanding when and why learned operators succeed or fail."
        },
        {
            "name": "limitations_or_failures",
            "type": "str",
            "description": "What limitations, failure cases, or negative results are reported about learned/adaptive operators? (e.g., 'failed on small populations', 'no benefit for simple problems', 'high computational cost'). Null if none reported."
        }
    ],
    "extraction_query": "Extract any mentions of adaptive, learned, or parameterized operators (mutation, crossover, variation operators) in evolutionary algorithms, genetic algorithms, or genetic programming, including performance comparisons, operator representations, and results on code or text domains.",
    "supporting_theory_ids": [],
    "model_str": "claude-sonnet-4-5-20250929"
}</code></pre>
        </div>
    </div>
</body>
</html>